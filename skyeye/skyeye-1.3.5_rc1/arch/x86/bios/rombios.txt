00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void memsetb(seg,offset,value,count);
00040                                           !BCC_EOS
00041                                           ! 32   void memcpyb(dseg,doffset,sseg,soffset,count);
00042                                           !BCC_EOS
00043                                           ! 33   void memcpyd(dseg,doffset,sseg,soffset,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   memsetb(seg,offset,value,count)
00047                                           ! 36     Bit16u seg;
00048                                           export	_memsetb
00049                       00000000            _memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u value;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            _memsetb.count	set	8
00061                       00000002            _memsetb.seg	set	2
00062                       00000006            _memsetb.value	set	6
00063                       00000004            _memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           85C9                             test cx, cx
00072 000C           74           10                  je memsetb_end
00073 000E           8B46         04                  mov ax, 4[bp] ; segment
00074 0011           8EC0                             mov es, ax
00075 0013           8B46         06                  mov ax, 6[bp] ; offset
00076 0016           89C7                             mov di, ax
00077 0018           8A46         08                  mov al, 8[bp] ; value
00078 001B           FC                               cld
00079 001C           F3                               rep
00080 001D           AA                                stosb
00081                       0000001E              memsetb_end:
00082 001E           5F                               pop di
00083 001F           07                               pop es
00084 0020           59                               pop cx
00085 0021           58                               pop ax
00086 0022           5D                             pop bp
00087                                           ! 65 endasm
00088                                           !BCC_ENDASM
00089                                           ! 66   }
00090 0023           C3                         ret
00091                                           ! 67     void
00092                                           ! 68   memcpyb(dseg,doffset,sseg,soffset,count)
00093                                           ! 69     Bit16u dseg;
00094                                           export	_memcpyb
00095                       00000024            _memcpyb:
00096                                           !BCC_EOS
00097                                           ! 70     Bit16u doffset;
00098                                           !BCC_EOS
00099                                           ! 71     Bit16u sseg;
00100                                           !BCC_EOS
00101                                           ! 72     Bit16u soffset;
00102                                           !BCC_EOS
00103                                           ! 73     Bit16u count;
00104                                           !BCC_EOS
00105                                           ! 74   {
00106                                           ! 75 #asm
00107                                           !BCC_ASM
00108                       0000000A            _memcpyb.count	set	$A
00109                       00000006            _memcpyb.sseg	set	6
00110                       00000008            _memcpyb.soffset	set	8
00111                       00000002            _memcpyb.dseg	set	2
00112                       00000004            _memcpyb.doffset	set	4
00113 0024           55                             push bp
00114 0025           89E5                           mov bp, sp
00115 0027           50                               push ax
00116 0028           51                               push cx
00117 0029           06                               push es
00118 002A           57                               push di
00119 002B           1E                               push ds
00120 002C           56                               push si
00121 002D           8B4E         0C                  mov cx, 12[bp] ; count
00122 0030           85C9                             test cx, cx
00123 0032           74           17                  je memcpyb_end
00124 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00125 0037           8EC0                             mov es, ax
00126 0039           8B46         06                  mov ax, 6[bp] ; doffset
00127 003C           89C7                             mov di, ax
00128 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00129 0041           8ED8                             mov ds, ax
00130 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00131 0046           89C6                             mov si, ax
00132 0048           FC                               cld
00133 0049           F3                               rep
00134 004A           A4                                movsb
00135                       0000004B              memcpyb_end:
00136 004B           5E                               pop si
00137 004C           1F                               pop ds
00138 004D           5F                               pop di
00139 004E           07                               pop es
00140 004F           59                               pop cx
00141 0050           58                               pop ax
00142 0051           5D                             pop bp
00143                                           ! 106 endasm
00144                                           !BCC_ENDASM
00145                                           ! 107   }
00146 0052           C3                         ret
00147                                           ! 108     void
00148                                           ! 109  
00149                                           ! 109  memcpyd(dseg,doffset,sseg,soffset,count)
00150                                           ! 110     Bit16u dseg;
00151                                           export	_memcpyd
00152                       00000053            _memcpyd:
00153                                           !BCC_EOS
00154                                           ! 111     Bit16u doffset;
00155                                           !BCC_EOS
00156                                           ! 112     Bit16u sseg;
00157                                           !BCC_EOS
00158                                           ! 113     Bit16u soffset;
00159                                           !BCC_EOS
00160                                           ! 114     Bit16u count;
00161                                           !BCC_EOS
00162                                           ! 115   {
00163                                           ! 116 #asm
00164                                           !BCC_ASM
00165                       0000000A            _memcpyd.count	set	$A
00166                       00000006            _memcpyd.sseg	set	6
00167                       00000008            _memcpyd.soffset	set	8
00168                       00000002            _memcpyd.dseg	set	2
00169                       00000004            _memcpyd.doffset	set	4
00170 0053           55                             push bp
00171 0054           89E5                           mov bp, sp
00172 0056           50                               push ax
00173 0057           51                               push cx
00174 0058           06                               push es
00175 0059           57                               push di
00176 005A           1E                               push ds
00177 005B           56                               push si
00178 005C           8B4E         0C                  mov cx, 12[bp] ; count
00179 005F           85C9                             test cx, cx
00180 0061           74           18                  je memcpyd_end
00181 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00182 0066           8EC0                             mov es, ax
00183 0068           8B46         06                  mov ax, 6[bp] ; doffset
00184 006B           89C7                             mov di, ax
00185 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00186 0070           8ED8                             mov ds, ax
00187 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00188 0075           89C6                             mov si, ax
00189 0077           FC                               cld
00190 0078           F3                               rep
00191 0079     66    A5                                movsd
00192                       0000007B              memcpyd_end:
00193 007B           5E                               pop si
00194 007C           1F                               pop ds
00195 007D           5F                               pop di
00196 007E           07                               pop es
00197 007F           59                               pop cx
00198 0080           58                               pop ax
00199 0081           5D                             pop bp
00200                                           ! 147 endasm
00201                                           !BCC_ENDASM
00202                                           ! 148   }
00203 0082           C3                         ret
00204                                           ! 149   static Bit32u read_dword();
00205                                           !BCC_EOS
00206                                           ! 150   static void write_dword();
00207                                           !BCC_EOS
00208                                           ! 151     Bit32u
00209                                           ! 152   read_dword(seg, offset)
00210                                           ! 153     Bit16u seg;
00211                                           export	_read_dword
00212                       00000083            _read_dword:
00213                                           !BCC_EOS
00214                                           ! 154     Bit16u offset;
00215                                           !BCC_EOS
00216                                           ! 155   {
00217                                           ! 156 #asm
00218                                           !BCC_ASM
00219                       00000002            _read_dword.seg	set	2
00220                       00000004            _read_dword.offset	set	4
00221 0083           55                             push bp
00222 0084           89E5                           mov bp, sp
00223 0086           53                               push bx
00224 0087           1E                               push ds
00225 0088           8B46         04                  mov ax, 4[bp] ; segment
00226 008B           8ED8                             mov ds, ax
00227 008D           8B5E         06                  mov bx, 6[bp] ; offset
00228 0090           8B07                             mov ax, [bx]
00229 0092           83C3                   02        add bx, #2
00230 0095           8B17                             mov dx, [bx]
00231                                                 ;; ax = return value (word)
00232                                                 ;; dx = return value (word)
00233 0097           1F                               pop ds
00234 0098           5B                               pop bx
00235 0099           5D                             pop bp
00236                                           ! 172 endasm
00237                                           !BCC_ENDASM
00238                                           ! 173   }
00239 009A           C3                         ret
00240                                           ! 174     void
00241                                           ! 175   write_dword(seg, offset, data)
00242                                           ! 176     Bit16u seg;
00243                                           export	_write_dword
00244                       0000009B            _write_dword:
00245                                           !BCC_EOS
00246                                           ! 177     Bit16u offset;
00247                                           !BCC_EOS
00248                                           ! 178     Bit32u data;
00249                                           !BCC_EOS
00250                                           ! 179   {
00251                                           ! 180 #asm
00252                                           !BCC_ASM
00253                       00000002            _write_dword.seg	set	2
00254                       00000006            _write_dword.data	set	6
00255                       00000004            _write_dword.offset	set	4
00256 009B           55                             push bp
00257 009C           89E5                           mov bp, sp
00258 009E           50                               push ax
00259 009F           53                               push bx
00260 00A0           1E                               push ds
00261 00A1           8B46         04                  mov ax, 4[bp] ; segment
00262 00A4           8ED8                             mov ds, ax
00263 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00264 00A9           8B46         08                  mov ax, 8[bp] ; data word
00265 00AC           8907                             mov [bx], ax ; write data word
00266 00AE           83C3                   02        add bx, #2
00267 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00268 00B4           8907                             mov [bx], ax ; write data word
00269 00B6           1F                               pop ds
00270 00B7           5B                               pop bx
00271 00B8           58                               pop ax
00272 00B9           5D                             pop bp
00273                                           ! 198 endasm
00274                                           !BCC_ENDASM
00275                                           ! 199   }
00276 00BA           C3                         ret
00277                                           ! 200 #asm
00278                                           !BCC_ASM
00279                       00000002            _write_dword.seg	set	2
00280                       00000006            _write_dword.data	set	6
00281                       00000004            _write_dword.offset	set	4
00282                                             ;; and function
00283                       000000BB              landl:
00284                       000000BB              landul:
00285 00BB           36                             SEG SS
00286 00BC           2305                             and ax,[di]
00287 00BE           36                             SEG SS
00288 00BF           235D         02                  and bx,2[di]
00289 00C2           C3                             ret
00290                                             ;; add function
00291                       000000C3              laddl:
00292                       000000C3              laddul:
00293 00C3           36                             SEG SS
00294 00C4           0305                             add ax,[di]
00295 00C6           36                             SEG SS
00296 00C7           135D         02                  adc bx,2[di]
00297 00CA           C3                             ret
00298                                             ;; cmp function
00299                       000000CB              lcmpl:
00300                       000000CB              lcmpul:
00301 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00302 00D1     66    C1E3                   10      shl ebx, #16
00303 00D5     66    09D8                           or eax, ebx
00304 00D8     66    C1EB                   10      shr ebx, #16
00305 00DC           36                             SEG SS
00306 00DD     66    3B05                             cmp eax, dword ptr [di]
00307 00E0           C3                             ret
00308                                             ;; sub function
00309                       000000E1              lsubl:
00310                       000000E1              lsubul:
00311 00E1           36                             SEG SS
00312 00E2           2B05                           sub ax,[di]
00313 00E4           36                             SEG SS
00314 00E5           1B5D         02                sbb bx,2[di]
00315 00E8           C3                             ret
00316                                             ;; mul function
00317                       000000E9              lmull:
00318                       000000E9              lmulul:
00319 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00320 00EF     66    C1E3                   10      shl ebx, #16
00321 00F3     66    09D8                           or eax, ebx
00322 00F6           36                             SEG SS
00323 00F7     66    F725                           mul eax, dword ptr [di]
00324 00FA     66    89C3                           mov ebx, eax
00325 00FD     66    C1EB                   10      shr ebx, #16
00326 0101           C3                             ret
00327                                             ;; dec function
00328                       00000102              ldecl:
00329                       00000102              ldecul:
00330 0102           36                             SEG SS
00331 0103     66    FF0F                           dec dword ptr [bx]
00332 0106           C3                             ret
00333                                             ;; or function
00334                       00000107              lorl:
00335                       00000107              lorul:
00336 0107           36                             SEG SS
00337 0108           0B05                           or ax,[di]
00338 010A           36                             SEG SS
00339 010B           0B5D         02                or bx,2[di]
00340 010E           C3                             ret
00341                                             ;; inc function
00342                       0000010F              lincl:
00343                       0000010F              lincul:
00344 010F           36                             SEG SS
00345 0110     66    FF07                           inc dword ptr [bx]
00346 0113           C3                             ret
00347                                             ;; tst function
00348                       00000114              ltstl:
00349                       00000114              ltstul:
00350 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00351 011A     66    C1E3                   10      shl ebx, #16
00352 011E     66    09D8                           or eax, ebx
00353 0121     66    C1EB                   10      shr ebx, #16
00354 0125     66    85C0                           test eax, eax
00355 0128           C3                             ret
00356                                             ;; sr function
00357                       00000129              lsrul:
00358 0129           89F9                           mov cx,di
00359 012B           E3           19                jcxz lsr_exit
00360 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00361 0133     66    C1E3                   10      shl ebx, #16
00362 0137     66    09D8                           or eax, ebx
00363                       0000013A              lsr_loop:
00364 013A     66    D1E8                           shr eax, #1
00365 013D           E2           FB                loop lsr_loop
00366 013F     66    89C3                           mov ebx, eax
00367 0142     66    C1EB                   10      shr ebx, #16
00368                       00000146              lsr_exit:
00369 0146           C3                             ret
00370                                             ;; sl function
00371                       00000147              lsll:
00372                       00000147              lslul:
00373 0147           89F9                           mov cx,di
00374 0149           E3           19                jcxz lsl_exit
00375 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00376 0151     66    C1E3                   10      shl ebx, #16
00377 0155     66    09D8                           or eax, ebx
00378                       00000158              lsl_loop:
00379 0158     66    D1E0                           shl eax, #1
00380 015B           E2           FB                loop lsl_loop
00381 015D     66    89C3                           mov ebx, eax
00382 0160     66    C1EB                   10      shr ebx, #16
00383                       00000164              lsl_exit:
00384 0164           C3                             ret
00385                       00000165              idiv_:
00386 0165           99                             cwd
00387 0166           F7FB                           idiv bx
00388 0168           C3                             ret
00389                       00000169              idiv_u:
00390 0169           31D2                           xor dx,dx
00391 016B           F7F3                           div bx
00392 016D           C3                             ret
00393                       0000016E              ldivul:
00394 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00395 0174     66    C1E3                   10      shl ebx, #16
00396 0178     66    09D8                           or eax, ebx
00397 017B     66    31D2                           xor edx, edx
00398 017E           36                             SEG SS
00399 017F           8B5D         02                mov bx, 2[di]
00400 0182     66    C1E3                   10      shl ebx, #16
00401 0186           36                             SEG SS
00402 0187           8B1D                           mov bx, [di]
00403 0189     66    F7F3                           div ebx
00404 018C     66    89C3                           mov ebx, eax
00405 018F     66    C1EB                   10      shr ebx, #16
00406 0193           C3                             ret
00407                                           ! 326 endasm
00408                                           !BCC_ENDASM
00409                                           ! 327 typedef struct {
00410                                           ! 328   unsigned char filler1[0x400];
00411                                           !BCC_EOS
00412                                           ! 329   unsigned char filler2[0x6c];
00413                                           !BCC_EOS
00414                                           ! 330   Bit16u ticks_low;
00415                                           !BCC_EOS
00416                                           ! 331   Bit16u ticks_high;
00417                                           !BCC_EOS
00418                                           ! 332   Bit8u midnight_flag;
00419                                           !BCC_EOS
00420                                           ! 333 } bios_data_t;
00421                                           !BCC_EOS
00422                                           ! 334   typedef struct {
00423                                           ! 335     Bit16u heads;
00424                                           !BCC_EOS
00425                                           ! 336     Bit16u cylinders;
00426                                           !BCC_EOS
00427                                           ! 337     Bit16u spt;
00428                                           !BCC_EOS
00429                                           ! 338   } chs_t;
00430                                           !BCC_EOS
00431                                           ! 339   typedef struct {
00432                                           ! 340     Bit16u iobase1;
00433                                           !BCC_EOS
00434                                           ! 341     Bit16u iobase2;
00435                                           !BCC_EOS
00436                                           ! 342     Bit8u prefix;
00437                                           !BCC_EOS
00438                                           ! 343     Bit8u unused;
00439                                           !BCC_EOS
00440                                           ! 344     Bit8u irq;
00441                                           !BCC_EOS
00442                                           ! 345     Bit8u blkcount;
00443                                           !BCC_EOS
00444                                           ! 346     Bit8u dma;
00445                                           !BCC_EOS
00446                                           ! 347     Bit8u pio;
00447                                           !BCC_EOS
00448                                           ! 348     Bit16u options;
00449                                           !BCC_EOS
00450                                           ! 349     Bit16u reserved;
00451                                           !BCC_EOS
00452                                           ! 350     Bit8u revision;
00453                                           !BCC_EOS
00454                                           ! 351     Bit8u checksum;
00455                                           !BCC_EOS
00456                                           ! 352   } dpte_t;
00457                                           !BCC_EOS
00458                                           ! 353   typedef struct {
00459                                           ! 354     Bit8u iface;
00460                                           !BCC_EOS
00461                                           ! 355     Bit16u iobase1;
00462                                           !BCC_EOS
00463                                           ! 356     Bit16u iobase2;
00464                                           !BCC_EOS
00465                                           ! 357     Bit8u irq;
00466                                           !BCC_EOS
00467                                           ! 358   } ata_channel_t;
00468                                           !BCC_EOS
00469                                           ! 359   typedef struct {
00470                                           ! 360     Bit8u type;
00471                                           !BCC_EOS
00472                                           ! 361     Bit8u device;
00473                                           !BCC_EOS
00474                                           ! 362     Bit8u removable;
00475                                           !BCC_EOS
00476                                           ! 363     Bit8u lock;
00477                                           !BCC_EOS
00478                                           ! 364     Bit8u mode;
00479                                           !BCC_EOS
00480                                           ! 365     Bit16u blksize;
00481                                           !BCC_EOS
00482                                           ! 366     Bit8u
00483                                           ! 366  translation;
00484                                           !BCC_EOS
00485                                           ! 367     chs_t lchs;
00486                                           !BCC_EOS
00487                                           ! 368     chs_t pchs;
00488                                           !BCC_EOS
00489                                           ! 369     Bit32u sectors_low;
00490                                           !BCC_EOS
00491                                           ! 370     Bit32u sectors_high;
00492                                           !BCC_EOS
00493                                           ! 371   } ata_device_t;
00494                                           !BCC_EOS
00495                                           ! 372   typedef struct {
00496                                           ! 373     ata_channel_t channels[4];
00497                                           !BCC_EOS
00498                                           ! 374     ata_device_t devices[(4*2)];
00499                                           !BCC_EOS
00500                                           ! 375     Bit8u hdcount, hdidmap[(4*2)];
00501                                           !BCC_EOS
00502                                           ! 376     Bit8u cdcount, cdidmap[(4*2)];
00503                                           !BCC_EOS
00504                                           ! 377     dpte_t dpte;
00505                                           !BCC_EOS
00506                                           ! 378     Bit16u trsfsectors;
00507                                           !BCC_EOS
00508                                           ! 379     Bit32u trsfbytes;
00509                                           !BCC_EOS
00510                                           ! 380   } ata_t;
00511                                           !BCC_EOS
00512                                           ! 381   typedef struct {
00513                                           ! 382     Bit8u active;
00514                                           !BCC_EOS
00515                                           ! 383     Bit8u media;
00516                                           !BCC_EOS
00517                                           ! 384     Bit8u emulated_drive;
00518                                           !BCC_EOS
00519                                           ! 385     Bit8u controller_index;
00520                                           !BCC_EOS
00521                                           ! 386     Bit16u device_spec;
00522                                           !BCC_EOS
00523                                           ! 387     Bit32u ilba;
00524                                           !BCC_EOS
00525                                           ! 388     Bit16u buffer_segment;
00526                                           !BCC_EOS
00527                                           ! 389     Bit16u load_segment;
00528                                           !BCC_EOS
00529                                           ! 390     Bit16u sector_count;
00530                                           !BCC_EOS
00531                                           ! 391     chs_t vdevice;
00532                                           !BCC_EOS
00533                                           ! 392   } cdemu_t;
00534                                           !BCC_EOS
00535                                           ! 393   typedef struct {
00536                                           ! 394     unsigned char filler1[0x3D];
00537                                           !BCC_EOS
00538                                           ! 395     unsigned char fdpt0[0x10];
00539                                           !BCC_EOS
00540                                           ! 396     unsigned char fdpt1[0x10];
00541                                           !BCC_EOS
00542                                           ! 397     unsigned char filler2[0xC4];
00543                                           !BCC_EOS
00544                                           ! 398     ata_t ata;
00545                                           !BCC_EOS
00546                                           ! 399     cdemu_t cdemu;
00547                                           !BCC_EOS
00548                                           ! 400   } ebda_data_t;
00549                                           !BCC_EOS
00550                                           ! 401   typedef struct {
00551                                           ! 402     Bit8u size;
00552                                           !BCC_EOS
00553                                           ! 403     Bit8u reserved;
00554                                           !BCC_EOS
00555                                           ! 404     Bit16u count;
00556                                           !BCC_EOS
00557                                           ! 405     Bit16u offset;
00558                                           !BCC_EOS
00559                                           ! 406     Bit16u segment;
00560                                           !BCC_EOS
00561                                           ! 407     Bit32u lba1;
00562                                           !BCC_EOS
00563                                           ! 408     Bit32u lba2;
00564                                           !BCC_EOS
00565                                           ! 409   } int13ext_t;
00566                                           !BCC_EOS
00567                                           ! 410   typedef struct {
00568                                           ! 411     Bit16u size;
00569                                           !BCC_EOS
00570                                           ! 412     Bit16u infos;
00571                                           !BCC_EOS
00572                                           ! 413     Bit32u cylinders;
00573                                           !BCC_EOS
00574                                           ! 414     Bit32u heads;
00575                                           !BCC_EOS
00576                                           ! 415     Bit32u spt;
00577                                           !BCC_EOS
00578                                           ! 416     Bit32u sector_count1;
00579                                           !BCC_EOS
00580                                           ! 417     Bit32u sector_count2;
00581                                           !BCC_EOS
00582                                           ! 418     Bit16u blksize;
00583                                           !BCC_EOS
00584                                           ! 419     Bit16u dpte_offset;
00585                                           !BCC_EOS
00586                                           ! 420     Bit16u dpte_segment;
00587                                           !BCC_EOS
00588                                           ! 421     Bit16u key;
00589                                           !BCC_EOS
00590                                           ! 422     Bit8u dpi_length;
00591                                           !BCC_EOS
00592                                           ! 423     Bit8u reserved1;
00593                                           !BCC_EOS
00594                                           ! 424     Bit16u reserved2;
00595                                           !BCC_EOS
00596                                           ! 425     Bit8u host_bus[4];
00597                                           !BCC_EOS
00598                                           ! 426     Bit8u iface_type[8];
00599                                           !BCC_EOS
00600                                           ! 427     Bit8u iface_path[8];
00601                                           !BCC_EOS
00602                                           ! 428     Bit8u device_path[8];
00603                                           !BCC_EOS
00604                                           ! 429     Bit8u reserved3;
00605                                           !BCC_EOS
00606                                           ! 430     Bit8u checksum;
00607                                           !BCC_EOS
00608                                           ! 431   } dpt_t;
00609                                           !BCC_EOS
00610                                           ! 432 typedef struct {
00611                                           ! 433   union {
00612                                           ! 434     struct {
00613                                           ! 435       Bit16u di, si, bp, sp;
00614                                           !BCC_EOS
00615                                           ! 436       Bit16u bx, dx, cx, ax;
00616                                           !BCC_EOS
00617                                           ! 437     } r16;
00618                                           !BCC_EOS
00619                                           ! 438     struct {
00620                                           ! 439       Bit16u filler[4];
00621                                           !BCC_EOS
00622                                           ! 440       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00623                                           !BCC_EOS
00624                                           ! 441     } r8;
00625                                           !BCC_EOS
00626                                           ! 442   } u;
00627                                           !BCC_EOS
00628                                           ! 443 } pusha_regs_t;
00629                                           !BCC_EOS
00630                                           ! 444 typedef struct {
00631                                           ! 445  union {
00632                                           ! 446   struct {
00633                                           ! 447     Bit32u edi, esi, ebp, esp;
00634                                           !BCC_EOS
00635                                           ! 448     Bit32u ebx, edx, ecx, eax;
00636                                           !BCC_EOS
00637                                           ! 449   } r32;
00638                                           !BCC_EOS
00639                                           ! 450   struct {
00640                                           ! 451     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00641                                           !BCC_EOS
00642                                           ! 452     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00643                                           !BCC_EOS
00644                                           ! 453   } r16;
00645                                           !BCC_EOS
00646                                           ! 454   struct {
00647                                           ! 455     Bit32u filler[4];
00648                                           !BCC_EOS
00649                                           ! 456     Bit8u bl, bh;
00650                                           !BCC_EOS
00651                                           ! 457     Bit16u filler1;
00652                                           !BCC_EOS
00653                                           ! 458     Bit8u dl, dh;
00654                                           !BCC_EOS
00655                                           ! 459     Bit16u filler2;
00656                                           !BCC_EOS
00657                                           ! 460     Bit8u cl, ch;
00658                                           !BCC_EOS
00659                                           ! 461     Bit16u filler3;
00660                                           !BCC_EOS
00661                                           ! 462    
00662                                           ! 462  Bit8u al, ah;
00663                                           !BCC_EOS
00664                                           ! 463     Bit16u filler4;
00665                                           !BCC_EOS
00666                                           ! 464   } r8;
00667                                           !BCC_EOS
00668                                           ! 465  } u;
00669                                           !BCC_EOS
00670                                           ! 466 } pushad_regs_t;
00671                                           !BCC_EOS
00672                                           ! 467 typedef struct {
00673                                           ! 468   union {
00674                                           ! 469     struct {
00675                                           ! 470       Bit16u flags;
00676                                           !BCC_EOS
00677                                           ! 471     } r16;
00678                                           !BCC_EOS
00679                                           ! 472     struct {
00680                                           ! 473       Bit8u flagsl;
00681                                           !BCC_EOS
00682                                           ! 474       Bit8u flagsh;
00683                                           !BCC_EOS
00684                                           ! 475     } r8;
00685                                           !BCC_EOS
00686                                           ! 476   } u;
00687                                           !BCC_EOS
00688                                           ! 477 } flags_t;
00689                                           !BCC_EOS
00690                                           ! 478 typedef struct {
00691                                           ! 479   Bit16u ip;
00692                                           !BCC_EOS
00693                                           ! 480   Bit16u cs;
00694                                           !BCC_EOS
00695                                           ! 481   flags_t flags;
00696                                           !BCC_EOS
00697                                           ! 482 } iret_addr_t;
00698                                           !BCC_EOS
00699                                           ! 483 typedef struct {
00700                                           ! 484   Bit16u type;
00701                                           !BCC_EOS
00702                                           ! 485   Bit16u flags;
00703                                           !BCC_EOS
00704                                           ! 486   Bit32u vector;
00705                                           !BCC_EOS
00706                                           ! 487   Bit32u description;
00707                                           !BCC_EOS
00708                                           ! 488   Bit32u reserved;
00709                                           !BCC_EOS
00710                                           ! 489 } ipl_entry_t;
00711                                           !BCC_EOS
00712                                           ! 490 static Bit8u inb();
00713                                           !BCC_EOS
00714                                           ! 491 static Bit8u inb_cmos();
00715                                           !BCC_EOS
00716                                           ! 492 static void outb();
00717                                           !BCC_EOS
00718                                           ! 493 static void outb_cmos();
00719                                           !BCC_EOS
00720                                           ! 494 static Bit16u inw();
00721                                           !BCC_EOS
00722                                           ! 495 static void outw();
00723                                           !BCC_EOS
00724                                           ! 496 static void init_rtc();
00725                                           !BCC_EOS
00726                                           ! 497 static bx_bool rtc_updating();
00727                                           !BCC_EOS
00728                                           ! 498 static Bit8u read_byte();
00729                                           !BCC_EOS
00730                                           ! 499 static Bit16u read_word();
00731                                           !BCC_EOS
00732                                           ! 500 static void write_byte();
00733                                           !BCC_EOS
00734                                           ! 501 static void write_word();
00735                                           !BCC_EOS
00736                                           ! 502 static void bios_printf();
00737                                           !BCC_EOS
00738                                           ! 503 static Bit8u inhibit_mouse_int_and_events();
00739                                           !BCC_EOS
00740                                           ! 504 static void enable_mouse_int_and_events();
00741                                           !BCC_EOS
00742                                           ! 505 static Bit8u send_to_mouse_ctrl();
00743                                           !BCC_EOS
00744                                           ! 506 static Bit8u get_mouse_data();
00745                                           !BCC_EOS
00746                                           ! 507 static void set_kbd_command_byte();
00747                                           !BCC_EOS
00748                                           ! 508 static void int09_function();
00749                                           !BCC_EOS
00750                                           ! 509 static void int13_harddisk();
00751                                           !BCC_EOS
00752                                           ! 510 static void int13_cdrom();
00753                                           !BCC_EOS
00754                                           ! 511 static void int13_cdemu();
00755                                           !BCC_EOS
00756                                           ! 512 static void int13_eltorito();
00757                                           !BCC_EOS
00758                                           ! 513 static void int13_diskette_function();
00759                                           !BCC_EOS
00760                                           ! 514 static void int14_function();
00761                                           !BCC_EOS
00762                                           ! 515 static void int15_function();
00763                                           !BCC_EOS
00764                                           ! 516 static void int16_function();
00765                                           !BCC_EOS
00766                                           ! 517 static void int17_function();
00767                                           !BCC_EOS
00768                                           ! 518 static void int19_function();
00769                                           !BCC_EOS
00770                                           ! 519 static void int1a_function();
00771                                           !BCC_EOS
00772                                           ! 520 static void int70_function();
00773                                           !BCC_EOS
00774                                           ! 521 static void int74_function();
00775                                           !BCC_EOS
00776                                           ! 522 static Bit16u get_CS();
00777                                           !BCC_EOS
00778                                           ! 523 static Bit16u get_SS();
00779                                           !BCC_EOS
00780                                           ! 524 static unsigned int enqueue_key();
00781                                           !BCC_EOS
00782                                           ! 525 static unsigned int dequeue_key();
00783                                           !BCC_EOS
00784                                           ! 526 static void get_hd_geometry();
00785                                           !BCC_EOS
00786                                           ! 527 static void set_diskette_ret_status();
00787                                           !BCC_EOS
00788                                           ! 528 static void set_diskette_current_cyl();
00789                                           !BCC_EOS
00790                                           ! 529 static void determine_floppy_media();
00791                                           !BCC_EOS
00792                                           ! 530 static bx_bool floppy_drive_exists();
00793                                           !BCC_EOS
00794                                           ! 531 static bx_bool floppy_drive_recal();
00795                                           !BCC_EOS
00796                                           ! 532 static bx_bool floppy_media_known();
00797                                           !BCC_EOS
00798                                           ! 533 static bx_bool floppy_media_sense();
00799                                           !BCC_EOS
00800                                           ! 534 static bx_bool set_enable_a20();
00801                                           !BCC_EOS
00802                                           ! 535 static void debugger_on();
00803                                           !BCC_EOS
00804                                           ! 536 static void debugger_off();
00805                                           !BCC_EOS
00806                                           ! 537 static void keyboard_init();
00807                                           !BCC_EOS
00808                                           ! 538 static void keyboard_panic();
00809                                           !BCC_EOS
00810                                           ! 539 static void shutdown_status_panic();
00811                                           !BCC_EOS
00812                                           ! 540 static void nmi_handler_msg();
00813                                           !BCC_EOS
00814                                           ! 541 static void delay_ticks();
00815                                           !BCC_EOS
00816                                           ! 542 static void delay_ticks_and_check_for_keystrok
00817                                           ! 542 e();
00818                                           !BCC_EOS
00819                                           ! 543 static void interactive_bootkey();
00820                                           !BCC_EOS
00821                                           ! 544 static void print_bios_banner();
00822                                           !BCC_EOS
00823                                           ! 545 static void print_boot_device();
00824                                           !BCC_EOS
00825                                           ! 546 static void print_boot_failure();
00826                                           !BCC_EOS
00827                                           ! 547 static void print_cdromboot_failure();
00828                                           !BCC_EOS
00829                                           ! 548 void ata_init();
00830                                           !BCC_EOS
00831                                           ! 549 void ata_detect();
00832                                           !BCC_EOS
00833                                           ! 550 void ata_reset();
00834                                           !BCC_EOS
00835                                           ! 551 Bit16u ata_cmd_non_data();
00836                                           !BCC_EOS
00837                                           ! 552 Bit16u ata_cmd_data_in();
00838                                           !BCC_EOS
00839                                           ! 553 Bit16u ata_cmd_data_out();
00840                                           !BCC_EOS
00841                                           ! 554 Bit16u ata_cmd_packet();
00842                                           !BCC_EOS
00843                                           ! 555 Bit16u atapi_get_sense();
00844                                           !BCC_EOS
00845                                           ! 556 Bit16u atapi_is_ready();
00846                                           !BCC_EOS
00847                                           ! 557 Bit16u atapi_is_cdrom();
00848                                           !BCC_EOS
00849                                           ! 558 void cdemu_init();
00850                                           !BCC_EOS
00851                                           ! 559 Bit8u cdemu_isactive();
00852                                           !BCC_EOS
00853                                           ! 560 Bit8u cdemu_emulated_drive();
00854                                           !BCC_EOS
00855                                           ! 561 Bit16u cdrom_boot();
00856                                           !BCC_EOS
00857                                           ! 562 static char bios_cvs_version_string[] = "$Revision: 1.231.2.1 $ $Date: 2009/06/07 07:49:09 $";
00858                                           
00859                       00000194            _bios_cvs_version_string:
00860                       00000194            .1:
00861 0194                        24            .ascii	"$Revision: 1.231.2.1 $ $Date: 2009/06/07"
00862 01BC                        20            .ascii	" 07:49:09 $"
00863 01C7                        00            .byte	0
00864                                           !BCC_EOS
00865                                           ! 563 static struct {
00866                                           ! 564   Bit16u normal;
00867                                           !BCC_EOS
00868                                           ! 565   Bit16u shift;
00869                                           !BCC_EOS
00870                                           ! 566   Bit16u control;
00871                                           !BCC_EOS
00872                                           ! 567   Bit16u alt;
00873                                           !BCC_EOS
00874                                           ! 568   Bit8u lock_flags;
00875                                           !BCC_EOS
00876                                           ! 569   } scan_to_scanascii[0x58 + 1] = {
00877                       000001C8            _scan_to_scanascii:
00878                                           ! 570       { 0, 0, 0, 0, 0 },
00879 01C8                      0000            .word	0
00880 01CA                      0000            .word	0
00881 01CC                      0000            .word	0
00882 01CE                      0000            .word	0
00883 01D0                        00            .byte	0
00884 01D1                  00000001            .blkb	1
00885                                           ! 571       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00886 01D2                      011B            .word	$11B
00887 01D4                      011B            .word	$11B
00888 01D6                      011B            .word	$11B
00889 01D8                      0100            .word	$100
00890 01DA                        00            .byte	0
00891 01DB                  00000001            .blkb	1
00892                                           ! 572       { 0x0231, 0x0221, 0, 0x7800, 0 },
00893 01DC                      0231            .word	$231
00894 01DE                      0221            .word	$221
00895 01E0                      0000            .word	0
00896 01E2                      7800            .word	$7800
00897 01E4                        00            .byte	0
00898 01E5                  00000001            .blkb	1
00899                                           ! 573       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00900 01E6                      0332            .word	$332
00901 01E8                      0340            .word	$340
00902 01EA                      0300            .word	$300
00903 01EC                      7900            .word	$7900
00904 01EE                        00            .byte	0
00905 01EF                  00000001            .blkb	1
00906                                           ! 574       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00907 01F0                      0433            .word	$433
00908 01F2                      0423            .word	$423
00909 01F4                      0000            .word	0
00910 01F6                      7A00            .word	$7A00
00911 01F8                        00            .byte	0
00912 01F9                  00000001            .blkb	1
00913                                           ! 575       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00914 01FA                      0534            .word	$534
00915 01FC                      0524            .word	$524
00916 01FE                      0000            .word	0
00917 0200                      7B00            .word	$7B00
00918 0202                        00            .byte	0
00919 0203                  00000001            .blkb	1
00920                                           ! 576       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00921 0204                      0635            .word	$635
00922 0206                      0625            .word	$625
00923 0208                      0000            .word	0
00924 020A                      7C00            .word	$7C00
00925 020C                        00            .byte	0
00926 020D                  00000001            .blkb	1
00927                                           ! 577       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00928 020E                      0736            .word	$736
00929 0210                      075E            .word	$75E
00930 0212                      071E            .word	$71E
00931 0214                      7D00            .word	$7D00
00932 0216                        00            .byte	0
00933 0217                  00000001            .blkb	1
00934                                           ! 578       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00935 0218                      0837            .word	$837
00936 021A                      0826            .word	$826
00937 021C                      0000            .word	0
00938 021E                      7E00            .word	$7E00
00939 0220                        00            .byte	0
00940 0221                  00000001            .blkb	1
00941                                           ! 579       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00942 0222                      0938            .word	$938
00943 0224                      092A            .word	$92A
00944 0226                      0000            .word	0
00945 0228                      7F00            .word	$7F00
00946 022A                        00            .byte	0
00947 022B                  00000001            .blkb	1
00948                                           ! 580       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00949 022C                      0A39            .word	$A39
00950 022E                      0A28            .word	$A28
00951 0230                      0000            .word	0
00952 0232                      8000            .word	$8000
00953 0234                        00            .byte	0
00954 0235                  00000001            .blkb	1
00955                                           ! 581       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00956 0236                      0B30            .word	$B30
00957 0238                      0B29            .word	$B29
00958 023A                      0000            .word	0
00959 023C                      8100            .word	$8100
00960 023E                        00            .byte	0
00961 023F                  00000001            .blkb	1
00962                                           ! 582       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
00963 0240                      0C2D            .word	$C2D
00964 0242                      0C5F            .word	$C5F
00965 0244                      0C1F            .word	$C1F
00966 0246                      8200            .word	$8200
00967 0248                        00            .byte	0
00968 0249                  00000001            .blkb	1
00969                                           ! 583       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
00970 024A                      0D3D            .word	$D3D
00971 024C                      0D2B            .word	$D2B
00972 024E                      0000            .word	0
00973 0250                      8300            .word	$8300
00974 0252                        00            .byte	0
00975 0253                  00000001            .blkb	1
00976                                           ! 584       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
00977 0254                      0E08            .word	$E08
00978 0256                      0E08            .word	$E08
00979 0258                      0E7F            .word	$E7F
00980 025A                      0000            .word	0
00981 025C                        00            .byte	0
00982 025D                  00000001            .blkb	1
00983                                           ! 585       { 0x0f09, 0x0f00, 0, 0, 0 },
00984 025E                      0F09            .word	$F09
00985 0260                      0F00            .word	$F00
00986 0262                      0000            .word	0
00987 0264                      0000            .word	0
00988 0266                        00            .byte	0
00989 0267                  00000001            .blkb	1
00990                                           ! 586       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
00991 0268                      1071            .word	$1071
00992 026A                      1051            .word	$1051
00993 026C                      1011            .word	$1011
00994 026E                      1000            .word	$1000
00995 0270                        40            .byte	$40
00996 0271                  00000001            .blkb	1
00997                                           ! 587       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
00998 0272                      1177            .word	$1177
00999 0274                      1157            .word	$1157
01000 0276                      1117            .word	$1117
01001 0278                      1100            .word	$1100
01002 027A                        40            .byte	$40
01003 027B                  00000001            .blkb	1
01004                                           ! 588       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01005 027C                      1265            .word	$1265
01006 027E                      1245            .word	$1245
01007 0280                      1205            .word	$1205
01008 0282                      1200            .word	$1200
01009 0284                        40            .byte	$40
01010 0285                  00000001            .blkb	1
01011                                           ! 589       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01012 0286                      1372            .word	$1372
01013 0288                      1352            .word	$1352
01014 028A                      1312            .word	$1312
01015 028C                      1300            .word	$1300
01016 028E                        40            .byte	$40
01017 028F                  00000001            .blkb	1
01018                                           ! 590       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01019 0290                      1474            .word	$1474
01020 0292                      1454            .word	$1454
01021 0294                      1414            .word	$1414
01022 0296                      1400            .word	$1400
01023 0298                        40            .byte	$40
01024 0299                  00000001            .blkb	1
01025                                           ! 591       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01026 029A                      1579            .word	$1579
01027 029C                      1559            .word	$1559
01028 029E                      1519            .word	$1519
01029 02A0                      1500            .word	$1500
01030 02A2                        40            .byte	$40
01031 02A3                  00000001            .blkb	1
01032                                           ! 592       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01033 02A4                      1675            .word	$1675
01034 02A6                      1655            .word	$1655
01035 02A8                      1615            .word	$1615
01036 02AA                      1600            .word	$1600
01037 02AC                        40            .byte	$40
01038 02AD                  00000001            .blkb	1
01039                                           ! 593       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01040 02AE                      1769            .word	$1769
01041 02B0                      1749            .word	$1749
01042 02B2                      1709            .word	$1709
01043 02B4                      1700            .word	$1700
01044 02B6                        40            .byte	$40
01045 02B7                  00000001            .blkb	1
01046                                           ! 594       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01047 02B8                      186F            .word	$186F
01048 02BA                      184F            .word	$184F
01049 02BC                      180F            .word	$180F
01050 02BE                      1800            .word	$1800
01051 02C0                        40            .byte	$40
01052 02C1                  00000001            .blkb	1
01053                                           ! 595       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01054 02C2                      1970            .word	$1970
01055 02C4                      1950            .word	$1950
01056 02C6                      1910            .word	$1910
01057 02C8                      1900            .word	$1900
01058 02CA                        40            .byte	$40
01059 02CB                  00000001            .blkb	1
01060                                           ! 596       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01061 02CC                      1A5B            .word	$1A5B
01062 02CE                      1A7B            .word	$1A7B
01063 02D0                      1A1B            .word	$1A1B
01064 02D2                      0000            .word	0
01065 02D4                        00            .byte	0
01066 02D5                  00000001            .blkb	1
01067                                           ! 597       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01068 02D6                      1B5D            .word	$1B5D
01069 02D8                      1B7D            .word	$1B7D
01070 02DA                      1B1D            .word	$1B1D
01071 02DC                      0000            .word	0
01072 02DE                        00            .byte	0
01073 02DF                  00000001            .blkb	1
01074                                           ! 598       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01075 02E0                      1C0D            .word	$1C0D
01076 02E2                      1C0D            .word	$1C0D
01077 02E4                      1C0A            .word	$1C0A
01078 02E6                      0000            .word	0
01079 02E8                        00            .byte	0
01080 02E9                  00000001            .blkb	1
01081                                           ! 599       { 0, 0, 0, 0, 0 },
01082 02EA                      0000            .word	0
01083 02EC                      0000            .word	0
01084 02EE                      0000            .word	0
01085 02F0                      0000            .word	0
01086 02F2                        00            .byte	0
01087 02F3                  00000001            .blkb	1
01088                                           ! 600       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x4
01089 02F4                      1E61            .word	$1E61
01090 02F6                      1E41            .word	$1E41
01091 02F8                      1E01            .word	$1E01
01092 02FA                      1E00            .word	$1E00
01093                                           ! 600 0 },
01094 02FC                        40            .byte	$40
01095 02FD                  00000001            .blkb	1
01096                                           ! 601       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01097 02FE                      1F73            .word	$1F73
01098 0300                      1F53            .word	$1F53
01099 0302                      1F13            .word	$1F13
01100 0304                      1F00            .word	$1F00
01101 0306                        40            .byte	$40
01102 0307                  00000001            .blkb	1
01103                                           ! 602       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01104 0308                      2064            .word	$2064
01105 030A                      2044            .word	$2044
01106 030C                      2004            .word	$2004
01107 030E                      2000            .word	$2000
01108 0310                        40            .byte	$40
01109 0311                  00000001            .blkb	1
01110                                           ! 603       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01111 0312                      2166            .word	$2166
01112 0314                      2146            .word	$2146
01113 0316                      2106            .word	$2106
01114 0318                      2100            .word	$2100
01115 031A                        40            .byte	$40
01116 031B                  00000001            .blkb	1
01117                                           ! 604       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01118 031C                      2267            .word	$2267
01119 031E                      2247            .word	$2247
01120 0320                      2207            .word	$2207
01121 0322                      2200            .word	$2200
01122 0324                        40            .byte	$40
01123 0325                  00000001            .blkb	1
01124                                           ! 605       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01125 0326                      2368            .word	$2368
01126 0328                      2348            .word	$2348
01127 032A                      2308            .word	$2308
01128 032C                      2300            .word	$2300
01129 032E                        40            .byte	$40
01130 032F                  00000001            .blkb	1
01131                                           ! 606       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01132 0330                      246A            .word	$246A
01133 0332                      244A            .word	$244A
01134 0334                      240A            .word	$240A
01135 0336                      2400            .word	$2400
01136 0338                        40            .byte	$40
01137 0339                  00000001            .blkb	1
01138                                           ! 607       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01139 033A                      256B            .word	$256B
01140 033C                      254B            .word	$254B
01141 033E                      250B            .word	$250B
01142 0340                      2500            .word	$2500
01143 0342                        40            .byte	$40
01144 0343                  00000001            .blkb	1
01145                                           ! 608       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01146 0344                      266C            .word	$266C
01147 0346                      264C            .word	$264C
01148 0348                      260C            .word	$260C
01149 034A                      2600            .word	$2600
01150 034C                        40            .byte	$40
01151 034D                  00000001            .blkb	1
01152                                           ! 609       { 0x273b, 0x273a, 0, 0, 0 },
01153 034E                      273B            .word	$273B
01154 0350                      273A            .word	$273A
01155 0352                      0000            .word	0
01156 0354                      0000            .word	0
01157 0356                        00            .byte	0
01158 0357                  00000001            .blkb	1
01159                                           ! 610       { 0x2827, 0x2822, 0, 0, 0 },
01160 0358                      2827            .word	$2827
01161 035A                      2822            .word	$2822
01162 035C                      0000            .word	0
01163 035E                      0000            .word	0
01164 0360                        00            .byte	0
01165 0361                  00000001            .blkb	1
01166                                           ! 611       { 0x2960, 0x297e, 0, 0, 0 },
01167 0362                      2960            .word	$2960
01168 0364                      297E            .word	$297E
01169 0366                      0000            .word	0
01170 0368                      0000            .word	0
01171 036A                        00            .byte	0
01172 036B                  00000001            .blkb	1
01173                                           ! 612       { 0, 0, 0, 0, 0 },
01174 036C                      0000            .word	0
01175 036E                      0000            .word	0
01176 0370                      0000            .word	0
01177 0372                      0000            .word	0
01178 0374                        00            .byte	0
01179 0375                  00000001            .blkb	1
01180                                           ! 613       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01181 0376                      2B5C            .word	$2B5C
01182 0378                      2B7C            .word	$2B7C
01183 037A                      2B1C            .word	$2B1C
01184 037C                      0000            .word	0
01185 037E                        00            .byte	0
01186 037F                  00000001            .blkb	1
01187                                           ! 614       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01188 0380                      2C7A            .word	$2C7A
01189 0382                      2C5A            .word	$2C5A
01190 0384                      2C1A            .word	$2C1A
01191 0386                      2C00            .word	$2C00
01192 0388                        40            .byte	$40
01193 0389                  00000001            .blkb	1
01194                                           ! 615       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01195 038A                      2D78            .word	$2D78
01196 038C                      2D58            .word	$2D58
01197 038E                      2D18            .word	$2D18
01198 0390                      2D00            .word	$2D00
01199 0392                        40            .byte	$40
01200 0393                  00000001            .blkb	1
01201                                           ! 616       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01202 0394                      2E63            .word	$2E63
01203 0396                      2E43            .word	$2E43
01204 0398                      2E03            .word	$2E03
01205 039A                      2E00            .word	$2E00
01206 039C                        40            .byte	$40
01207 039D                  00000001            .blkb	1
01208                                           ! 617       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01209 039E                      2F76            .word	$2F76
01210 03A0                      2F56            .word	$2F56
01211 03A2                      2F16            .word	$2F16
01212 03A4                      2F00            .word	$2F00
01213 03A6                        40            .byte	$40
01214 03A7                  00000001            .blkb	1
01215                                           ! 618       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01216 03A8                      3062            .word	$3062
01217 03AA                      3042            .word	$3042
01218 03AC                      3002            .word	$3002
01219 03AE                      3000            .word	$3000
01220 03B0                        40            .byte	$40
01221 03B1                  00000001            .blkb	1
01222                                           ! 619       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01223 03B2                      316E            .word	$316E
01224 03B4                      314E            .word	$314E
01225 03B6                      310E            .word	$310E
01226 03B8                      3100            .word	$3100
01227 03BA                        40            .byte	$40
01228 03BB                  00000001            .blkb	1
01229                                           ! 620       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01230 03BC                      326D            .word	$326D
01231 03BE                      324D            .word	$324D
01232 03C0                      320D            .word	$320D
01233 03C2                      3200            .word	$3200
01234 03C4                        40            .byte	$40
01235 03C5                  00000001            .blkb	1
01236                                           ! 621       { 0x332c, 0x333c, 0, 0, 0 },
01237 03C6                      332C            .word	$332C
01238 03C8                      333C            .word	$333C
01239 03CA                      0000            .word	0
01240 03CC                      0000            .word	0
01241 03CE                        00            .byte	0
01242 03CF                  00000001            .blkb	1
01243                                           ! 622       { 0x342e, 0x343e, 0, 0, 0 },
01244 03D0                      342E            .word	$342E
01245 03D2                      343E            .word	$343E
01246 03D4                      0000            .word	0
01247 03D6                      0000            .word	0
01248 03D8                        00            .byte	0
01249 03D9                  00000001            .blkb	1
01250                                           ! 623       { 0x352f, 0x353f, 0, 0, 0 },
01251 03DA                      352F            .word	$352F
01252 03DC                      353F            .word	$353F
01253 03DE                      0000            .word	0
01254 03E0                      0000            .word	0
01255 03E2                        00            .byte	0
01256 03E3                  00000001            .blkb	1
01257                                           ! 624       { 0, 0, 0, 0, 0 },
01258 03E4                      0000            .word	0
01259 03E6                      0000            .word	0
01260 03E8                      0000            .word	0
01261 03EA                      0000            .word	0
01262 03EC                        00            .byte	0
01263 03ED                  00000001            .blkb	1
01264                                           ! 625       { 0x372a, 0x372a, 0, 0, 0 },
01265 03EE                      372A            .word	$372A
01266 03F0                      372A            .word	$372A
01267 03F2                      0000            .word	0
01268 03F4                      0000            .word	0
01269 03F6                        00            .byte	0
01270 03F7                  00000001            .blkb	1
01271                                           ! 626       { 0, 0, 0, 0, 0 },
01272 03F8                      0000            .word	0
01273 03FA                      0000            .word	0
01274 03FC                      0000            .word	0
01275 03FE                      0000            .word	0
01276 0400                        00            .byte	0
01277 0401                  00000001            .blkb	1
01278                                           ! 627       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01279 0402                      3920            .word	$3920
01280 0404                      3920            .word	$3920
01281 0406                      3920            .word	$3920
01282 0408                      3920            .word	$3920
01283 040A                        00            .byte	0
01284 040B                  00000001            .blkb	1
01285                                           ! 628       { 0, 0, 0, 0, 0 },
01286 040C                      0000            .word	0
01287 040E                      0000            .word	0
01288 0410                      0000            .word	0
01289 0412                      0000            .word	0
01290 0414                        00            .byte	0
01291 0415                  00000001            .blkb	1
01292                                           ! 629       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01293 0416                      3B00            .word	$3B00
01294 0418                      5400            .word	$5400
01295 041A                      5E00            .word	$5E00
01296 041C                      6800            .word	$6800
01297 041E                        00            .byte	0
01298 041F                  00000001            .blkb	1
01299                                           ! 630       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01300 0420                      3C00            .word	$3C00
01301 0422                      5500            .word	$5500
01302 0424                      5F00            .word	$5F00
01303 0426                      6900            .word	$6900
01304 0428                        00            .byte	0
01305 0429                  00000001            .blkb	1
01306                                           ! 631       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01307 042A                      3D00            .word	$3D00
01308 042C                      5600            .word	$5600
01309 042E                      6000            .word	$6000
01310 0430                      6A00            .word	$6A00
01311 0432                        00            .byte	0
01312 0433                  00000001            .blkb	1
01313                                           ! 632       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01314 0434                      3E00            .word	$3E00
01315 0436                      5700            .word	$5700
01316 0438                      6100            .word	$6100
01317 043A                      6B00            .word	$6B00
01318 043C                        00            .byte	0
01319 043D                  00000001            .blkb	1
01320                                           ! 633       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01321 043E                      3F00            .word	$3F00
01322 0440                      5800            .word	$5800
01323 0442                      6200            .word	$6200
01324 0444                      6C00            .word	$6C00
01325 0446                        00            .byte	0
01326 0447                  00000001            .blkb	1
01327                                           ! 634       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01328 0448                      4000            .word	$4000
01329 044A                      5900            .word	$5900
01330 044C                      6300            .word	$6300
01331 044E                      6D00            .word	$6D00
01332 0450                        00            .byte	0
01333 0451                  00000001            .blkb	1
01334                                           ! 635       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01335 0452                      4100            .word	$4100
01336 0454                      5A00            .word	$5A00
01337 0456                      6400            .word	$6400
01338 0458                      6E00            .word	$6E00
01339 045A                        00            .byte	0
01340 045B                  00000001            .blkb	1
01341                                           ! 636       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01342 045C                      4200            .word	$4200
01343 045E                      5B00            .word	$5B00
01344 0460                      6500            .word	$6500
01345 0462                      6F00            .word	$6F00
01346 0464                        00            .byte	0
01347 0465                  00000001            .blkb	1
01348                                           ! 637       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01349 0466                      4300            .word	$4300
01350 0468                      5C00            .word	$5C00
01351 046A                      6600            .word	$6600
01352 046C                      7000            .word	$7000
01353 046E                        00            .byte	0
01354 046F                  00000001            .blkb	1
01355                                           ! 638       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01356 0470                      4400            .word	$4400
01357 0472                      5D00            .word	$5D00
01358 0474                      6700            .word	$6700
01359 0476                      7100            .word	$7100
01360 0478                        00            .byte	0
01361 0479                  00000001            .blkb	1
01362                                           ! 639       { 0, 0, 0, 0, 0 },
01363 047A                      0000            .word	0
01364 047C                      0000            .word	0
01365 047E                      0000            .word	0
01366 0480                      0000            .word	0
01367 0482                        00            .byte	0
01368 0483                  00000001            .blkb	1
01369                                           ! 640       { 0, 0, 0, 0, 0 },
01370 0484                      0000            .word	0
01371 0486                      0000            .word	0
01372 0488                      0000            .word	0
01373 048A                      0000            .word	0
01374 048C                        00            .byte	0
01375 048D                  00000001            .blkb	1
01376                                           ! 641       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01377 048E                      4700            .word	$4700
01378 0490                      4737            .word	$4737
01379 0492                      7700            .word	$7700
01380 0494                      0000            .word	0
01381 0496                        20            .byte	$20
01382 0497                  00000001            .blkb	1
01383                                           ! 642       { 0x4800, 0x4838, 0, 0, 0x20 },
01384 0498                      4800            .word	$4800
01385 049A                      4838            .word	$4838
01386 049C                      0000            .word	0
01387 049E                      0000            .word	0
01388 04A0                        20            .byte	$20
01389 04A1                  00000001            .blkb	1
01390                                           ! 643       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01391 04A2                      4900            .word	$4900
01392 04A4                      4939            .word	$4939
01393 04A6                      8400            .word	$8400
01394 04A8                      0000            .word	0
01395 04AA                        20            .byte	$20
01396 04AB                  00000001            .blkb	1
01397                                           ! 644       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01398 04AC                      4A2D            .word	$4A2D
01399 04AE                      4A2D            .word	$4A2D
01400 04B0                      0000            .word	0
01401 04B2                      0000            .word	0
01402 04B4                        00            .byte	0
01403 04B5                  00000001            .blkb	1
01404                                           ! 645       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01405 04B6                      4B00            .word	$4B00
01406 04B8                      4B34            .word	$4B34
01407 04BA                      7300            .word	$7300
01408 04BC                      0000            .word	0
01409 04BE                        20            .byte	$20
01410 04BF                  00000001            .blkb	1
01411                                           ! 646       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01412 04C0                      4C00            .word	$4C00
01413 04C2                      4C35            .word	$4C35
01414 04C4                      0000            .word	0
01415 04C6                      0000            .word	0
01416 04C8                        20            .byte	$20
01417 04C9                  00000001            .blkb	1
01418                                           ! 647       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01419 04CA                      4D00            .word	$4D00
01420 04CC                      4D36            .word	$4D36
01421 04CE                      7400            .word	$7400
01422 04D0                      0000            .word	0
01423 04D2                        20            .byte	$20
01424 04D3                  00000001            .blkb	1
01425                                           ! 648       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01426 04D4                      4E2B            .word	$4E2B
01427 04D6                      4E2B            .word	$4E2B
01428 04D8                      0000            .word	0
01429 04DA                      0000            .word	0
01430 04DC                        00            .byte	0
01431 04DD                  00000001            .blkb	1
01432                                           ! 649       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01433 04DE                      4F00            .word	$4F00
01434 04E0                      4F31            .word	$4F31
01435 04E2                      7500            .word	$7500
01436 04E4                      0000            .word	0
01437 04E6                        20            .byte	$20
01438 04E7                  00000001            .blkb	1
01439                                           ! 650       { 0x5000, 0x5032, 0, 0, 0x
01440 04E8                      5000            .word	$5000
01441 04EA                      5032            .word	$5032
01442 04EC                      0000            .word	0
01443 04EE                      0000            .word	0
01444                                           ! 650 20 },
01445 04F0                        20            .byte	$20
01446 04F1                  00000001            .blkb	1
01447                                           ! 651       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01448 04F2                      5100            .word	$5100
01449 04F4                      5133            .word	$5133
01450 04F6                      7600            .word	$7600
01451 04F8                      0000            .word	0
01452 04FA                        20            .byte	$20
01453 04FB                  00000001            .blkb	1
01454                                           ! 652       { 0x5200, 0x5230, 0, 0, 0x20 },
01455 04FC                      5200            .word	$5200
01456 04FE                      5230            .word	$5230
01457 0500                      0000            .word	0
01458 0502                      0000            .word	0
01459 0504                        20            .byte	$20
01460 0505                  00000001            .blkb	1
01461                                           ! 653       { 0x5300, 0x532e, 0, 0, 0x20 },
01462 0506                      5300            .word	$5300
01463 0508                      532E            .word	$532E
01464 050A                      0000            .word	0
01465 050C                      0000            .word	0
01466 050E                        20            .byte	$20
01467 050F                  00000001            .blkb	1
01468                                           ! 654       { 0, 0, 0, 0, 0 },
01469 0510                      0000            .word	0
01470 0512                      0000            .word	0
01471 0514                      0000            .word	0
01472 0516                      0000            .word	0
01473 0518                        00            .byte	0
01474 0519                  00000001            .blkb	1
01475                                           ! 655       { 0, 0, 0, 0, 0 },
01476 051A                      0000            .word	0
01477 051C                      0000            .word	0
01478 051E                      0000            .word	0
01479 0520                      0000            .word	0
01480 0522                        00            .byte	0
01481 0523                  00000001            .blkb	1
01482                                           ! 656       { 0x565c, 0x567c, 0, 0, 0 },
01483 0524                      565C            .word	$565C
01484 0526                      567C            .word	$567C
01485 0528                      0000            .word	0
01486 052A                      0000            .word	0
01487 052C                        00            .byte	0
01488 052D                  00000001            .blkb	1
01489                                           ! 657       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01490 052E                      8500            .word	$8500
01491 0530                      8700            .word	$8700
01492 0532                      8900            .word	$8900
01493 0534                      8B00            .word	$8B00
01494 0536                        00            .byte	0
01495 0537                  00000001            .blkb	1
01496                                           ! 658       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01497 0538                      8600            .word	$8600
01498 053A                      8800            .word	$8800
01499 053C                      8A00            .word	$8A00
01500 053E                      8C00            .word	$8C00
01501 0540                        00            .byte	0
01502 0541                  00000001            .blkb	1
01503                                           ! 659       };
01504                                           !BCC_EOS
01505                                           ! 660   Bit8u
01506                                           ! 661 inb(port)
01507                                           ! 662   Bit16u port;
01508                                           
01509                                           export	_inb
01510                       00000542            _inb:
01511                                           !BCC_EOS
01512                                           ! 663 {
01513                                           ! 664 #asm
01514                                           !BCC_ASM
01515                       00000002            _inb.port	set	2
01516 0542           55                           push bp
01517 0543           89E5                         mov bp, sp
01518 0545           52                             push dx
01519 0546           8B56         04                mov dx, 4[bp]
01520 0549           EC                             in al, dx
01521 054A           5A                             pop dx
01522 054B           5D                           pop bp
01523                                           ! 672 endasm
01524                                           !BCC_ENDASM
01525                                           ! 673 }
01526 054C           C3                         ret
01527                                           ! 674   Bit16u
01528                                           ! 675 inw(port)
01529                                           ! 676   Bit16u port;
01530                                           export	_inw
01531                       0000054D            _inw:
01532                                           !BCC_EOS
01533                                           ! 677 {
01534                                           ! 678 #asm
01535                                           !BCC_ASM
01536                       00000002            _inw.port	set	2
01537 054D           55                           push bp
01538 054E           89E5                         mov bp, sp
01539 0550           52                             push dx
01540 0551           8B56         04                mov dx, 4[bp]
01541 0554           ED                             in ax, dx
01542 0555           5A                             pop dx
01543 0556           5D                           pop bp
01544                                           ! 686 endasm
01545                                           !BCC_ENDASM
01546                                           ! 687 }
01547 0557           C3                         ret
01548                                           ! 688   void
01549                                           ! 689 outb(port, val)
01550                                           ! 690   Bit16u port;
01551                                           export	_outb
01552                       00000558            _outb:
01553                                           !BCC_EOS
01554                                           ! 691   Bit8u val;
01555                                           !BCC_EOS
01556                                           ! 692 {
01557                                           ! 693 #asm
01558                                           !BCC_ASM
01559                       00000004            _outb.val	set	4
01560                       00000002            _outb.port	set	2
01561 0558           55                           push bp
01562 0559           89E5                         mov bp, sp
01563 055B           50                             push ax
01564 055C           52                             push dx
01565 055D           8B56         04                mov dx, 4[bp]
01566 0560           8A46         06                mov al, 6[bp]
01567 0563           EE                             out dx, al
01568 0564           5A                             pop dx
01569 0565           58                             pop ax
01570 0566           5D                           pop bp
01571                                           ! 704 endasm
01572                                           !BCC_ENDASM
01573                                           ! 705 }
01574 0567           C3                         ret
01575                                           ! 706   void
01576                                           ! 707 outw(port, val)
01577                                           ! 708   Bit16u port;
01578                                           export	_outw
01579                       00000568            _outw:
01580                                           !BCC_EOS
01581                                           ! 709   Bit16u val;
01582                                           !BCC_EOS
01583                                           ! 710 {
01584                                           ! 711 #asm
01585                                           !BCC_ASM
01586                       00000004            _outw.val	set	4
01587                       00000002            _outw.port	set	2
01588 0568           55                           push bp
01589 0569           89E5                         mov bp, sp
01590 056B           50                             push ax
01591 056C           52                             push dx
01592 056D           8B56         04                mov dx, 4[bp]
01593 0570           8B46         06                mov ax, 6[bp]
01594 0573           EF                             out dx, ax
01595 0574           5A                             pop dx
01596 0575           58                             pop ax
01597 0576           5D                           pop bp
01598                                           ! 722 endasm
01599                                           !BCC_ENDASM
01600                                           ! 723 }
01601 0577           C3                         ret
01602                                           ! 724   void
01603                                           ! 725 outb_cmos(cmos_reg, val)
01604                                           ! 726   Bit8u cmos_reg;
01605                                           export	_outb_cmos
01606                       00000578            _outb_cmos:
01607                                           !BCC_EOS
01608                                           ! 727   Bit8u val;
01609                                           !BCC_EOS
01610                                           ! 728 {
01611                                           ! 729 #asm
01612                                           !BCC_ASM
01613                       00000002            _outb_cmos.cmos_reg	set	2
01614                       00000004            _outb_cmos.val	set	4
01615 0578           55                           push bp
01616 0579           89E5                         mov bp, sp
01617 057B           8A46         04                mov al, 4[bp] ;; cmos_reg
01618 057E           E6                     70      out 0x70, al
01619 0580           8A46         06                mov al, 6[bp] ;; val
01620 0583           E6                     71      out 0x71, al
01621 0585           5D                           pop bp
01622                                           ! 737 endasm
01623                                           !BCC_ENDASM
01624                                           ! 738 }
01625 0586           C3                         ret
01626                                           ! 739   Bit8u
01627                                           ! 740 inb_cmos(cmos_reg)
01628                                           ! 741   Bit8u cmos_reg;
01629                                           export	_inb_cmos
01630                       00000587            _inb_cmos:
01631                                           !BCC_EOS
01632                                           ! 742 {
01633                                           ! 743 #asm
01634                                           !BCC_ASM
01635                       00000002            _inb_cmos.cmos_reg	set	2
01636 0587           55                           push bp
01637 0588           89E5                         mov bp, sp
01638 058A           8A46         04                mov al, 4[bp] ;; cmos_reg
01639 058D           E6                     70      out 0x70, al
01640 058F           E4                     71      in al, 0x71
01641 0591           5D                           pop bp
01642                                           ! 750 endasm
01643                                           !BCC_ENDASM
01644                                           ! 751 }
01645 0592           C3                         ret
01646                                           ! 752   void
01647                                           ! 753 init_rtc()
01648                                           ! 754 {
01649                                           export	_init_rtc
01650                       00000593            _init_rtc:
01651                                           ! 755   outb_cmos(0x0a, 0x26);
01652 0593           55                         push	bp
01653 0594           89E5                       mov	bp,sp
01654                                           ! Debug: list int = const $26 (used reg = )
01655 0596           B8                   0026  mov	ax,*$26
01656 0599           50                         push	ax
01657                                           ! Debug: list int = const $A (used reg = )
01658 059A           B8                   000A  mov	ax,*$A
01659 059D           50                         push	ax
01660                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01661 059E           E8         FFD7            call	_outb_cmos
01662 05A1           89EC                       mov	sp,bp
01663                                           !BCC_EOS
01664                                           ! 756   outb_cmos(0x0b, 0x02);
01665                                           ! Debug: list int = const 2 (used reg = )
01666 05A3           B8                   0002  mov	ax,*2
01667 05A6           50                         push	ax
01668                                           ! Debug: list int = const $B (used reg = )
01669 05A7           B8                   000B  mov	ax,*$B
01670 05AA           50                         push	ax
01671                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01672 05AB           E8         FFCA            call	_outb_cmos
01673 05AE           89EC                       mov	sp,bp
01674                                           !BCC_EOS
01675                                           ! 757   inb_cmos(0x0c);
01676                                           ! Debug: list int = const $C (used reg = )
01677 05B0           B8                   000C  mov	ax,*$C
01678 05B3           50                         push	ax
01679                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01680 05B4           E8         FFD0            call	_inb_cmos
01681 05B7           89EC                       mov	sp,bp
01682                                           !BCC_EOS
01683                                           ! 758   inb_cmos(0x0d);
01684                                           ! Debug: list int = const $D (used reg = )
01685 05B9           B8                   000D  mov	ax,*$D
01686 05BC           50                         push	ax
01687                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01688 05BD           E8         FFC7            call	_inb_cmos
01689 05C0           89EC                       mov	sp,bp
01690                                           !BCC_EOS
01691                                           ! 759 }
01692 05C2           5D                         pop	bp
01693 05C3           C3                         ret
01694                                           ! 760   bx_bool
01695                                           ! 761 rtc_updating()
01696                                           ! 762 {
01697                                           export	_rtc_updating
01698                       000005C4            _rtc_updating:
01699                                           ! 763   Bit16u count;
01700                                           !BCC_EOS
01701                                           ! 764   count = 25000;
01702 05C4           55                         push	bp
01703 05C5           89E5                       mov	bp,sp
01704 05C7           4C                         dec	sp
01705 05C8           4C                         dec	sp
01706                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01707 05C9           B8                   61A8  mov	ax,#$61A8
01708 05CC           8946         FE            mov	-2[bp],ax
01709                                           !BCC_EOS
01710                                           ! 765   while (--count != 0) {
01711 05CF           EB           15            jmp .3
01712                       000005D1            .4:
01713                                           ! 766     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01714                                           ! Debug: list int = const $A (used reg = )
01715 05D1           B8                   000A  mov	ax,*$A
01716 05D4           50                         push	ax
01717                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01718 05D5           E8         FFAF            call	_inb_cmos
01719 05D8           44                         inc	sp
01720 05D9           44                         inc	sp
01721                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01722 05DA           24                     80  and	al,#$80
01723                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01724 05DC           84C0                       test	al,al
01725 05DE           75           06            jne 	.5
01726                       000005E0            .6:
01727                                           ! 767       return(0);
01728 05E0           31C0                       xor	ax,ax
01729 05E2           89EC                       mov	sp,bp
01730 05E4           5D                         pop	bp
01731 05E5           C3                         ret
01732                                           !BCC_EOS
01733                                           ! 768     }
01734                       000005E6            .5:
01735                                           ! 769   return(1);
01736                       000005E6            .3:
01737                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01738 05E6           8B46         FE            mov	ax,-2[bp]
01739 05E9           48                         dec	ax
01740 05EA           8946         FE            mov	-2[bp],ax
01741                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01742 05ED           85C0                       test	ax,ax
01743 05EF           75           E0            jne	.4
01744                       000005F1            .7:
01745                       000005F1            .2:
01746 05F1           B8                   0001  mov	ax,*1
01747 05F4           89EC                       mov	sp,bp
01748 05F6           5D                         pop	bp
01749 05F7           C3                         ret
01750                                           !BCC_EOS
01751                                           ! 770 }
01752                                           ! 771   Bit8u
01753                                           ! 772 read_byte(seg, offset)
01754                                           ! 773   Bit16u seg;
01755                                           export	_read_byte
01756                       000005F8            _read_byte:
01757                                           !BCC_EOS
01758                                           ! 774   Bit16u offset;
01759                                           !BCC_EOS
01760                                           ! 775 {
01761                                           ! 776 #asm
01762                                           !BCC_ASM
01763                       00000002            _read_byte.seg	set	2
01764                       00000004            _read_byte.offset	set	4
01765 05F8           55                           push bp
01766 05F9           89E5                         mov bp, sp
01767 05FB           53                             push bx
01768 05FC           1E                             push ds
01769 05FD           8B46         04                mov ax, 4[bp] ; segment
01770 0600           8ED8                           mov ds, ax
01771 0602           8B5E         06                mov bx, 6[bp] ; offset
01772 0605           8A07                           mov al, [bx]
01773                                               ;; al = return value (byte)
01774 0607           1F                             pop ds
01775 0608           5B                             pop bx
01776 0609           5D                           pop bp
01777                                           ! 789 endasm
01778                                           !BCC_ENDASM
01779                                           ! 790 }
01780 060A           C3                         ret
01781                                           ! 791   Bit16u
01782                                           ! 792 read_word(seg, offset)
01783                                           ! 793   Bit16u seg;
01784                                           export	_read_word
01785                       0000060B            _read_word:
01786                                           !BCC_EOS
01787                                           ! 794   Bit16u offset;
01788                                           !BCC_EOS
01789                                           ! 795 {
01790                                           ! 796 #asm
01791                                           !BCC_ASM
01792                       00000002            _read_word.seg	set	2
01793                       00000004            _read_word.offset	set	4
01794 060B           55                           push bp
01795 060C           89E5                         mov bp, sp
01796 060E           53                             push bx
01797 060F           1E                             push ds
01798 0610           8B46         04                mov ax, 4[bp] ; segment
01799 0613           8ED8                           mov ds, ax
01800 0615           8B5E         06                mov bx, 6[bp] ; offset
01801 0618           8B07                           mov ax, [bx]
01802                                               ;; ax = return value (word)
01803 061A           1F                             pop ds
01804 061B           5B                             pop bx
01805 061C           5D                           pop bp
01806                                           ! 809 endasm
01807                                           !BCC_ENDASM
01808                                           ! 810 }
01809 061D           C3                         ret
01810                                           ! 811   void
01811                                           ! 812 write_byte(seg, offset, data)
01812                                           ! 813   Bit16u seg;
01813                                           export	_write_byte
01814                       0000061E            _write_byte:
01815                                           !BCC_EOS
01816                                           ! 814   Bit16u offset;
01817                                           !BCC_EOS
01818                                           ! 815   Bit8u data;
01819                                           !BCC_EOS
01820                                           ! 816 {
01821                                           ! 817 #asm
01822                                           !BCC_ASM
01823                       00000002            _write_byte.seg	set	2
01824                       00000006            _write_byte.data	set	6
01825                       00000004            _write_byte.offset	set	4
01826 061E           55                           push bp
01827 061F           89E5                         mov bp, sp
01828 0621           50                             push ax
01829 0622           53                             push bx
01830 0623           1E                             push ds
01831 0624           8B46         04                mov ax, 4[bp] ; segment
01832 0627           8ED8                           mov ds, ax
01833 0629           8B5E         06                mov bx, 6[bp] ; offset
01834 062C           8A46         08                mov al, 8[bp] ; data byte
01835 062F           8807                           mov [bx], al ; write data byte
01836 0631           1F                             pop ds
01837 0632           5B                             pop bx
01838 0633           58                             pop ax
01839 0634           5D                           pop bp
01840                                           ! 832 endasm
01841                                           !BCC_ENDASM
01842                                           ! 833 }
01843 0635           C3                         ret
01844                                           ! 834   void
01845                                           ! 835 write_word(seg, offset, data)
01846                                           ! 836   Bit16u seg;
01847                                           export	_write_word
01848                       00000636            _write_word:
01849                                           !BCC_EOS
01850                                           ! 837   Bit16u offset;
01851                                           !BCC_EOS
01852                                           ! 838   Bit16u data;
01853                                           !BCC_EOS
01854                                           ! 839 {
01855                                           ! 840 #asm
01856                                           !BCC_ASM
01857                       00000002            _write_word.seg	set	2
01858                       00000006            _write_word.data	set	6
01859                       00000004            _write_word.offset	set	4
01860 0636           55                           push bp
01861 0637           89E5                         mov bp, sp
01862 0639           50                             push ax
01863 063A           53                             push bx
01864 063B           1E                             push ds
01865 063C           8B46         04                mov ax, 4[bp] ; segment
01866 063F           8ED8                           mov ds, ax
01867 0641           8B5E         06                mov bx, 6[bp] ; offset
01868 0644           8B46         08                mov ax, 8[bp] ; data word
01869 0647           8907                           mov [bx], ax ; write data word
01870 0649           1F                             pop ds
01871 064A           5B                             pop bx
01872 064B           58                             pop ax
01873 064C           5D                           pop bp
01874                                           ! 855 endasm
01875                                           !BCC_ENDASM
01876                                           ! 856 }
01877 064D           C3                         ret
01878                                           ! 857   Bit16u
01879                                           ! 858 get_CS()
01880                                           ! 859 {
01881                                           export	_get_CS
01882                       0000064E            _get_CS:
01883                                           ! 860 #asm
01884                                           !BCC_ASM
01885 064E           8CC8                         mov ax, cs
01886                                           ! 862 endasm
01887                                           !BCC_ENDASM
01888                                           ! 863 }
01889 0650           C3                         ret
01890                                           ! 864   Bit16u
01891                                           ! 865 get_SS()
01892                                           ! 866 {
01893                                           export	_get_SS
01894                       00000651            _get_SS:
01895                                           ! 867 #asm
01896                                           !BCC_ASM
01897 0651           8CD0                         mov ax, ss
01898                                           ! 869 endasm
01899                                           !BCC_ENDASM
01900                                           ! 870 }
01901 0653           C3                         ret
01902                                           ! 871   void
01903                                           ! 872 wrch(c)
01904                                           ! 873   Bit8u c;
01905                                           export	_wrch
01906                       00000654            _wrch:
01907                                           !BCC_EOS
01908                                           ! 874 {
01909                                           ! 875 #asm
01910                                           !BCC_ASM
01911                       00000002            _wrch.c	set	2
01912 0654           55                           push bp
01913 0655           89E5                         mov bp, sp
01914 0657           53                           push bx
01915 0658           B4                     0E    mov ah, #0x0e
01916 065A           8A46         04              mov al, 4[bp]
01917 065D           31DB                         xor bx,bx
01918 065F           CD                     10    int #0x10
01919 0661           5B                           pop bx
01920 0662           5D                           pop bp
01921                                           ! 885 endasm
01922                                           !BCC_ENDASM
01923                                           ! 886 }
01924 0663           C3                         ret
01925                                           ! 887   void
01926                                           ! 888 send(action, c)
01927                                           ! 889   Bit16u action;
01928                                           export	_send
01929                       00000664            _send:
01930                                           !BCC_EOS
01931                                           ! 890   Bit8u c;
01932                                           !BCC_EOS
01933                                           ! 891 {
01934                                           ! 892   if (action & 8) outb(0x403, c);
01935 0664           55                         push	bp
01936 0665           89E5                       mov	bp,sp
01937                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
01938 0667           8A46         04            mov	al,4[bp]
01939 066A           24                     08  and	al,*8
01940 066C           84C0                       test	al,al
01941 066E           74           0F            je  	.8
01942                       00000670            .9:
01943                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01944 0670           8A46         06            mov	al,6[bp]
01945 0673           30E4                       xor	ah,ah
01946 0675           50                         push	ax
01947                                           ! Debug: list int = const $403 (used reg = )
01948 0676           B8                   0403  mov	ax,#$403
01949 0679           50                         push	ax
01950                                           ! Debug: func () void = outb+0 (used reg = )
01951 067A           E8         FEDB            call	_outb
01952 067D           89EC                       mov	sp,bp
01953                                           !BCC_EOS
01954                                           ! 893   if (action & 4) outb(0x402, c);
01955                       0000067F            .8:
01956                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
01957 067F           8A46         04            mov	al,4[bp]
01958 0682           24                     04  and	al,*4
01959 0684           84C0                       test	al,al
01960 0686           74           0F            je  	.A
01961                       00000688            .B:
01962                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01963 0688           8A46         06            mov	al,6[bp]
01964 068B           30E4                       xor	ah,ah
01965 068D           50                         push	ax
01966                                           ! Debug: list int = const $402 (used reg = )
01967 068E           B8                   0402  mov	ax,#$402
01968 0691           50                         push	ax
01969                                           ! Debug: func () void = outb+0 (used reg = )
01970 0692           E8         FEC3            call	_outb
01971 0695           89EC                       mov	sp,bp
01972                                           !BCC_EOS
01973                                           ! 894   if (action & 2) {
01974                       00000697            .A:
01975                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
01976 0697           8A46         04            mov	al,4[bp]
01977 069A           24                     02  and	al,*2
01978 069C           84C0                       test	al,al
01979 069E           74           1B            je  	.C
01980                       000006A0            .D:
01981                                           ! 895     if (c == '\n') wrch('\r');
01982                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
01983 06A0           8A46         06            mov	al,6[bp]
01984 06A3           3C                     0A  cmp	al,*$A
01985 06A5           75           09            jne 	.E
01986                       000006A7            .F:
01987                                           ! Debug: list int = const $D (used reg = )
01988 06A7           B8                   000D  mov	ax,*$D
01989 06AA           50                         push	ax
01990                                           ! Debug: func () void = wrch+0 (used reg = )
01991 06AB           E8         FFA6            call	_wrch
01992 06AE           89EC                       mov	sp,bp
01993                                           !BCC_EOS
01994                                           ! 896     wrch(c);
01995                       000006B0            .E:
01996                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01997 06B0           8A46         06            mov	al,6[bp]
01998 06B3           30E4                       xor	ah,ah
01999 06B5           50                         push	ax
02000                                           ! Debug: func () void = wrch+0 (used reg = )
02001 06B6           E8         FF9B            call	_wrch
02002 06B9           89EC                       mov	sp,bp
02003                                           !BCC_EOS
02004                                           ! 897   }
02005                                           ! 898 }
02006                       000006BB            .C:
02007 06BB           5D                         pop	bp
02008 06BC           C3                         ret
02009                                           ! 899   void
02010                                           ! 900 put_int(action, val, width, neg)
02011                                           ! 901   Bit16u action;
02012                                           export	_put_int
02013                       000006BD            _put_int:
02014                                           !BCC_EOS
02015                                           ! 902   short val, width;
02016                                           !BCC_EOS
02017                                           ! 903   bx_bool neg;
02018                                           !BCC_EOS
02019                                           ! 904 {
02020                                           ! 905   short nval = val / 10;
02021 06BD           55                         push	bp
02022 06BE           89E5                       mov	bp,sp
02023 06C0           4C                         dec	sp
02024 06C1           4C                         dec	sp
02025                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02026 06C2           8B46         06            mov	ax,6[bp]
02027 06C5           BB                   000A  mov	bx,*$A
02028 06C8           99                         cwd
02029 06C9           F7FB                       idiv	bx
02030                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02031 06CB           8946         FE            mov	-2[bp],ax
02032                                           !BCC_EOS
02033                                           ! 906   if (nval)
02034 06CE           8B46         FE            mov	ax,-2[bp]
02035 06D1           85C0                       test	ax,ax
02036 06D3           74           16            je  	.10
02037                       000006D5            .11:
02038                                           ! 907     put_int(action, nval, width - 1, neg);
02039                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02040 06D5           FF76         0A            push	$A[bp]
02041                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02042 06D8           8B46         08            mov	ax,8[bp]
02043                                           ! Debug: list int = ax-1 (used reg = )
02044 06DB           48                         dec	ax
02045 06DC           50                         push	ax
02046                                           ! Debug: list short nval = [S+8-4] (used reg = )
02047 06DD           FF76         FE            push	-2[bp]
02048                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02049 06E0           FF76         04            push	4[bp]
02050                                           ! Debug: func () void = put_int+0 (used reg = )
02051 06E3           E8         FFD7            call	_put_int
02052 06E6           83C4                   08  add	sp,*8
02053                                           !BCC_EOS
02054                                           ! 908   else {
02055 06E9           EB           2E            jmp .12
02056                       000006EB            .10:
02057                                           ! 909     while (--width > 0) send(action, ' ');
02058 06EB           EB           0D            jmp .14
02059                       000006ED            .15:
02060                                           ! Debug: list int = const $20 (used reg = )
02061 06ED           B8                   0020  mov	ax,*$20
02062 06F0           50                         push	ax
02063                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02064 06F1           FF76         04            push	4[bp]
02065                                           ! Debug: func () void = send+0 (used reg = )
02066 06F4           E8         FF6D            call	_send
02067 06F7           83C4                   04  add	sp,*4
02068                                           !BCC_EOS
02069                                           ! 910     if (neg) send(action, '-');
02070                       000006FA            .14:
02071                                           ! Debug: predec short width = [S+4+6] (used reg = )
02072 06FA           8B46         08            mov	ax,8[bp]
02073 06FD           48                         dec	ax
02074 06FE           8946         08            mov	8[bp],ax
02075                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02076 0701           85C0                       test	ax,ax
02077 0703           7F           E8            jg 	.15
02078                       00000705            .16:
02079                       00000705            .13:
02080 0705           8B46         0A            mov	ax,$A[bp]
02081 0708           85C0                       test	ax,ax
02082 070A           74           0D            je  	.17
02083                       0000070C            .18:
02084                                           ! Debug: list int = const $2D (used reg = )
02085 070C           B8                   002D  mov	ax,*$2D
02086 070F           50                         push	ax
02087                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02088 0710           FF76         04            push	4[bp]
02089                                           ! Debug: func () void = send+0 (used reg = )
02090 0713           E8         FF4E            call	_send
02091 0716           83C4                   04  add	sp,*4
02092                                           !BCC_EOS
02093                                           ! 911   }
02094                       00000719            .17:
02095                                           ! 912   send(action, val - (nval * 10) + '0');
02096                       00000719            .12:
02097                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02098 0719           8B46         FE            mov	ax,-2[bp]
02099 071C           89C2                       mov	dx,ax
02100 071E           D1E0                       shl	ax,*1
02101 0720           D1E0                       shl	ax,*1
02102 0722           01D0                       add	ax,dx
02103 0724           D1E0                       shl	ax,*1
02104                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02105 0726           50                         push	ax
02106 0727           8B46         06            mov	ax,6[bp]
02107 072A           2B46         FC            sub	ax,-4[bp]
02108 072D           44                         inc	sp
02109 072E           44                         inc	sp
02110                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02111                                           ! Debug: list int = ax+$30 (used reg = )
02112 072F           05                   0030  add	ax,*$30
02113 0732           50                         push	ax
02114                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02115 0733           FF76         04            push	4[bp]
02116                                           ! Debug: func () void = send+0 (used reg = )
02117 0736           E8         FF2B            call	_send
02118 0739           83C4                   04  add	sp,*4
02119                                           !BCC_EOS
02120                                           ! 913 }
02121 073C           89EC                       mov	sp,bp
02122 073E           5D                         pop	bp
02123 073F           C3                         ret
02124                                           ! 914   void
02125                                           ! Register BX used in function put_int
02126                                           ! 915 put_uint(action, val, width, neg)
02127                                           ! 916   Bit16u action;
02128                                           export	_put_uint
02129                       00000740            _put_uint:
02130                                           !BCC_EOS
02131                                           ! 917   unsigned short val;
02132                                           !BCC_EOS
02133                                           ! 918   short width;
02134                                           !BCC_EOS
02135                                           ! 919   bx_bool neg;
02136                                           !BCC_EOS
02137                                           ! 920 {
02138                                           ! 921   unsigned short nval = val / 10;
02139 0740           55                         push	bp
02140 0741           89E5                       mov	bp,sp
02141 0743           4C                         dec	sp
02142 0744           4C                         dec	sp
02143                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02144 0745           8B46         06            mov	ax,6[bp]
02145 0748           BB                   000A  mov	bx,*$A
02146 074B           E8         FA1B            call	idiv_u
02147                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02148 074E           8946         FE            mov	-2[bp],ax
02149                                           !BCC_EOS
02150                                           ! 922   if (nval)
02151 0751           8B46         FE            mov	ax,-2[bp]
02152 0754           85C0                       test	ax,ax
02153 0756           74           16            je  	.19
02154                       00000758            .1A:
02155                                           ! 923     put_uint(action, nval, width - 1, neg);
02156                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02157 0758           FF76         0A            push	$A[bp]
02158                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02159 075B           8B46         08            mov	ax,8[bp]
02160                                           ! Debug: list int = ax-1 (used reg = )
02161 075E           48                         dec	ax
02162 075F           50                         push	ax
02163                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02164 0760           FF76         FE            push	-2[bp]
02165                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02166 0763           FF76         04            push	4[bp]
02167                                           ! Debug: func () void = put_uint+0 (used reg = )
02168 0766           E8         FFD7            call	_put_uint
02169 0769           83C4                   08  add	sp,*8
02170                                           !BCC_EOS
02171                                           ! 924   else {
02172 076C           EB           2E            jmp .1B
02173                       0000076E            .19:
02174                                           ! 925     while (--width > 0) send(action, ' ');
02175 076E           EB           0D            jmp .1D
02176                       00000770            .1E:
02177                                           ! Debug: list int = const $20 (used reg = )
02178 0770           B8                   0020  mov	ax,*$20
02179 0773           50                         push	ax
02180                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02181 0774           FF76         04            push	4[bp]
02182                                           ! Debug: func () void = send+0 (used reg = )
02183 0777           E8         FEEA            call	_send
02184 077A           83C4                   04  add	sp,*4
02185                                           !BCC_EOS
02186                                           ! 926     if (neg) send(action, '-');
02187                       0000077D            .1D:
02188                                           ! Debug: predec short width = [S+4+6] (used reg = )
02189 077D           8B46         08            mov	ax,8[bp]
02190 0780           48                         dec	ax
02191 0781           8946         08            mov	8[bp],ax
02192                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02193 0784           85C0                       test	ax,ax
02194 0786           7F           E8            jg 	.1E
02195                       00000788            .1F:
02196                       00000788            .1C:
02197 0788           8B46         0A            mov	ax,$A[bp]
02198 078B           85C0                       test	ax,ax
02199 078D           74           0D            je  	.20
02200                       0000078F            .21:
02201                                           ! Debug: list int = const $2D (used reg = )
02202 078F           B8                   002D  mov	ax,*$2D
02203 0792           50                         push	ax
02204                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02205 0793           FF76         04            push	4[bp]
02206                                           ! Debug: func () void = send+0 (used reg = )
02207 0796           E8         FECB            call	_send
02208 0799           83C4                   04  add	sp,*4
02209                                           !BCC_EOS
02210                                           ! 927   }
02211                       0000079C            .20:
02212                                           ! 928   send(action, val - (nval * 10) + '0');
02213                       0000079C            .1B:
02214                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02215 079C           8B46         FE            mov	ax,-2[bp]
02216 079F           89C2                       mov	dx,ax
02217 07A1           D1E0                       shl	ax,*1
02218 07A3           D1E0                       shl	ax,*1
02219 07A5           01D0                       add	ax,dx
02220 07A7           D1E0                       shl	ax,*1
02221                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02222 07A9           50                         push	ax
02223 07AA           8B46         06            mov	ax,6[bp]
02224 07AD           2B46         FC            sub	ax,-4[bp]
02225 07B0           44                         inc	sp
02226 07B1           44                         inc	sp
02227                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02228                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02229 07B2           05                   0030  add	ax,*$30
02230 07B5           50                         push	ax
02231                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02232 07B6           FF76         04            push	4[bp]
02233                                           ! Debug: func () void = send+0 (used reg = )
02234 07B9           E8         FEA8            call	_send
02235 07BC           83C4                   04  add	sp,*4
02236                                           !BCC_EOS
02237                                           ! 929 }
02238 07BF           89EC                       mov	sp,bp
02239 07C1           5D                         pop	bp
02240 07C2           C3                         ret
02241                                           ! 930   void
02242                                           ! Register BX used in function put_uint
02243                                           ! 931 put_luint(action, val, width, neg)
02244                                           ! 932   Bit16u action;
02245                                           export	_put_luint
02246                       000007C3            _put_luint:
02247                                           !BCC_EOS
02248                                           ! 933   unsigned long val;
02249                                           !BCC_EOS
02250                                           ! 934   short width;
02251                                           !BCC_EOS
02252                                           ! 935   bx_bool neg;
02253                                           !BCC_EOS
02254                                           ! 936 {
02255                                           ! 937   unsigned long nval = val / 10;
02256 07C3           55                         push	bp
02257 07C4           89E5                       mov	bp,sp
02258 07C6           83C4                   FC  add	sp,*-4
02259                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02260 07C9           B8                   000A  mov	ax,*$A
02261 07CC           31DB                       xor	bx,bx
02262 07CE           53                         push	bx
02263 07CF           50                         push	ax
02264 07D0           8B46         06            mov	ax,6[bp]
02265 07D3           8B5E         08            mov	bx,8[bp]
02266 07D6           8D7E         F8            lea	di,-8[bp]
02267 07D9           E8         F992            call	ldivul
02268 07DC           83C4                   04  add	sp,*4
02269                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02270 07DF           8946         FC            mov	-4[bp],ax
02271 07E2           895E         FE            mov	-2[bp],bx
02272                                           !BCC_EOS
02273                                           ! 938   if (nval)
02274 07E5           8B46         FC            mov	ax,-4[bp]
02275 07E8           8B5E         FE            mov	bx,-2[bp]
02276 07EB           E8         F926            call	ltstl
02277 07EE           74           19            je  	.22
02278                       000007F0            .23:
02279                                           ! 939     put_luint(action, nval, widt
02280                                           ! 939 h - 1, neg);
02281                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02282 07F0           FF76         0C            push	$C[bp]
02283                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02284 07F3           8B46         0A            mov	ax,$A[bp]
02285                                           ! Debug: list int = ax-1 (used reg = )
02286 07F6           48                         dec	ax
02287 07F7           50                         push	ax
02288                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02289 07F8           FF76         FE            push	-2[bp]
02290 07FB           FF76         FC            push	-4[bp]
02291                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02292 07FE           FF76         04            push	4[bp]
02293                                           ! Debug: func () void = put_luint+0 (used reg = )
02294 0801           E8         FFBF            call	_put_luint
02295 0804           83C4                   0A  add	sp,*$A
02296                                           !BCC_EOS
02297                                           ! 940   else {
02298 0807           EB           2E            jmp .24
02299                       00000809            .22:
02300                                           ! 941     while (--width > 0) send(action, ' ');
02301 0809           EB           0D            jmp .26
02302                       0000080B            .27:
02303                                           ! Debug: list int = const $20 (used reg = )
02304 080B           B8                   0020  mov	ax,*$20
02305 080E           50                         push	ax
02306                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02307 080F           FF76         04            push	4[bp]
02308                                           ! Debug: func () void = send+0 (used reg = )
02309 0812           E8         FE4F            call	_send
02310 0815           83C4                   04  add	sp,*4
02311                                           !BCC_EOS
02312                                           ! 942     if (neg) send(action, '-');
02313                       00000818            .26:
02314                                           ! Debug: predec short width = [S+6+8] (used reg = )
02315 0818           8B46         0A            mov	ax,$A[bp]
02316 081B           48                         dec	ax
02317 081C           8946         0A            mov	$A[bp],ax
02318                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02319 081F           85C0                       test	ax,ax
02320 0821           7F           E8            jg 	.27
02321                       00000823            .28:
02322                       00000823            .25:
02323 0823           8B46         0C            mov	ax,$C[bp]
02324 0826           85C0                       test	ax,ax
02325 0828           74           0D            je  	.29
02326                       0000082A            .2A:
02327                                           ! Debug: list int = const $2D (used reg = )
02328 082A           B8                   002D  mov	ax,*$2D
02329 082D           50                         push	ax
02330                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02331 082E           FF76         04            push	4[bp]
02332                                           ! Debug: func () void = send+0 (used reg = )
02333 0831           E8         FE30            call	_send
02334 0834           83C4                   04  add	sp,*4
02335                                           !BCC_EOS
02336                                           ! 943   }
02337                       00000837            .29:
02338                                           ! 944   send(action, val - (nval * 10) + '0');
02339                       00000837            .24:
02340                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02341                                           ! Debug: expression subtree swapping
02342 0837           B8                   000A  mov	ax,*$A
02343 083A           31DB                       xor	bx,bx
02344 083C           8D7E         FC            lea	di,-4[bp]
02345 083F           E8         F8A7            call	lmulul
02346                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02347 0842           53                         push	bx
02348 0843           50                         push	ax
02349 0844           8B46         06            mov	ax,6[bp]
02350 0847           8B5E         08            mov	bx,8[bp]
02351 084A           8D7E         F8            lea	di,-8[bp]
02352 084D           E8         F891            call	lsubul
02353 0850           83C4                   04  add	sp,*4
02354                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02355 0853           53                         push	bx
02356 0854           50                         push	ax
02357 0855           B8                   0030  mov	ax,*$30
02358 0858           31DB                       xor	bx,bx
02359 085A           53                         push	bx
02360 085B           50                         push	ax
02361 085C           8B46         F8            mov	ax,-8[bp]
02362 085F           8B5E         FA            mov	bx,-6[bp]
02363 0862           8D7E         F4            lea	di,-$C[bp]
02364 0865           E8         F85B            call	laddul
02365 0868           83C4                   08  add	sp,*8
02366                                           ! Debug: list unsigned long = bx+0 (used reg = )
02367 086B           53                         push	bx
02368 086C           50                         push	ax
02369                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02370 086D           FF76         04            push	4[bp]
02371                                           ! Debug: func () void = send+0 (used reg = )
02372 0870           E8         FDF1            call	_send
02373 0873           83C4                   06  add	sp,*6
02374                                           !BCC_EOS
02375                                           ! 945 }
02376 0876           89EC                       mov	sp,bp
02377 0878           5D                         pop	bp
02378 0879           C3                         ret
02379                                           ! 946 void put_str(action, segment, offset)
02380                                           ! Register BX used in function put_luint
02381                                           ! 947   Bit16u action;
02382                                           export	_put_str
02383                       0000087A            _put_str:
02384                                           !BCC_EOS
02385                                           ! 948   Bit16u segment;
02386                                           !BCC_EOS
02387                                           ! 949   Bit16u offset;
02388                                           !BCC_EOS
02389                                           ! 950 {
02390                                           ! 951   Bit8u c;
02391                                           !BCC_EOS
02392                                           ! 952   while (c = read_byte(segment, offset)) {
02393 087A           55                         push	bp
02394 087B           89E5                       mov	bp,sp
02395 087D           4C                         dec	sp
02396 087E           4C                         dec	sp
02397 087F           EB           16            jmp .2C
02398                       00000881            .2D:
02399                                           ! 953     send(action, c);
02400                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02401 0881           8A46         FF            mov	al,-1[bp]
02402 0884           30E4                       xor	ah,ah
02403 0886           50                         push	ax
02404                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02405 0887           FF76         04            push	4[bp]
02406                                           ! Debug: func () void = send+0 (used reg = )
02407 088A           E8         FDD7            call	_send
02408 088D           83C4                   04  add	sp,*4
02409                                           !BCC_EOS
02410                                           ! 954     offset++;
02411                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02412 0890           8B46         08            mov	ax,8[bp]
02413 0893           40                         inc	ax
02414 0894           8946         08            mov	8[bp],ax
02415                                           !BCC_EOS
02416                                           ! 955   }
02417                                           ! 956 }
02418                       00000897            .2C:
02419                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02420 0897           FF76         08            push	8[bp]
02421                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02422 089A           FF76         06            push	6[bp]
02423                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02424 089D           E8         FD58            call	_read_byte
02425 08A0           83C4                   04  add	sp,*4
02426                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02427 08A3           8846         FF            mov	-1[bp],al
02428 08A6           84C0                       test	al,al
02429 08A8           75           D7            jne	.2D
02430                       000008AA            .2E:
02431                       000008AA            .2B:
02432 08AA           89EC                       mov	sp,bp
02433 08AC           5D                         pop	bp
02434 08AD           C3                         ret
02435                                           ! 957   void
02436                                           ! 958 delay_ticks(ticks)
02437                                           ! 959   Bit16u ticks;
02438                                           export	_delay_ticks
02439                       000008AE            _delay_ticks:
02440                                           !BCC_EOS
02441                                           ! 960 {
02442                                           ! 961   long ticks_to_wait, delta;
02443                                           !BCC_EOS
02444                                           ! 962   Bit32u prev_ticks, t;
02445                                           !BCC_EOS
02446                                           ! 963 #asm
02447 08AE           55                         push	bp
02448 08AF           89E5                       mov	bp,sp
02449 08B1           83C4                   F0  add	sp,*-$10
02450                                           !BCC_EOS
02451                                           !BCC_ASM
02452                       00000014            _delay_ticks.ticks	set	$14
02453                       00000004            .delay_ticks.ticks	set	4
02454                       00000000            _delay_ticks.t	set	0
02455                       FFFFFFF0            .delay_ticks.t	set	-$10
02456                       00000004            _delay_ticks.prev_ticks	set	4
02457                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02458                       00000008            _delay_ticks.delta	set	8
02459                       FFFFFFF8            .delay_ticks.delta	set	-8
02460                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02461                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02462 08B4           9C                           pushf
02463 08B5           FB                           sti
02464                                           ! 966 endasm
02465                                           !BCC_ENDASM
02466                                           !BCC_EOS
02467                                           ! 967   ticks_to_wait = ticks;
02468                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02469 08B6           8B46         04            mov	ax,4[bp]
02470 08B9           31DB                       xor	bx,bx
02471 08BB           8946         FC            mov	-4[bp],ax
02472 08BE           895E         FE            mov	-2[bp],bx
02473                                           !BCC_EOS
02474                                           ! 968   prev_ticks = read_dword(0x0, 0x46c);
02475                                           ! Debug: list int = const $46C (used reg = )
02476 08C1           B8                   046C  mov	ax,#$46C
02477 08C4           50                         push	ax
02478                                           ! Debug: list int = const 0 (used reg = )
02479 08C5           31C0                       xor	ax,ax
02480 08C7           50                         push	ax
02481                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02482 08C8           E8         F7B8            call	_read_dword
02483 08CB           89D3                       mov	bx,dx
02484 08CD           83C4                   04  add	sp,*4
02485                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02486 08D0           8946         F4            mov	-$C[bp],ax
02487 08D3           895E         F6            mov	-$A[bp],bx
02488                                           !BCC_EOS
02489                                           ! 969   do
02490                                           ! 970   {
02491                       000008D6            .31:
02492                                           ! 971 #asm
02493                                           !BCC_EOS
02494                                           !BCC_ASM
02495                       00000014            _delay_ticks.ticks	set	$14
02496                       00000004            .delay_ticks.ticks	set	4
02497                       00000000            _delay_ticks.t	set	0
02498                       FFFFFFF0            .delay_ticks.t	set	-$10
02499                       00000004            _delay_ticks.prev_ticks	set	4
02500                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02501                       00000008            _delay_ticks.delta	set	8
02502                       FFFFFFF8            .delay_ticks.delta	set	-8
02503                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02504                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02505 08D6           F4                             hlt
02506                                           ! 973 endasm
02507                                           !BCC_ENDASM
02508                                           !BCC_EOS
02509                                           ! 974     t = read_dword(0x0, 0x46c);
02510                                           ! Debug: list int = const $46C (used reg = )
02511 08D7           B8                   046C  mov	ax,#$46C
02512 08DA           50                         push	ax
02513                                           ! Debug: list int = const 0 (used reg = )
02514 08DB           31C0                       xor	ax,ax
02515 08DD           50                         push	ax
02516                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02517 08DE           E8         F7A2            call	_read_dword
02518 08E1           89D3                       mov	bx,dx
02519 08E3           83C4                   04  add	sp,*4
02520                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02521 08E6           8946         F0            mov	-$10[bp],ax
02522 08E9           895E         F2            mov	-$E[bp],bx
02523                                           !BCC_EOS
02524                                           ! 975     if (t > prev_ticks)
02525                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02526 08EC           8B46         F4            mov	ax,-$C[bp]
02527 08EF           8B5E         F6            mov	bx,-$A[bp]
02528 08F2           8D7E         F0            lea	di,-$10[bp]
02529 08F5           E8         F7D3            call	lcmpul
02530 08F8           73           26            jae 	.32
02531                       000008FA            .33:
02532                                           ! 976     {
02533                                           ! 977       delta = t - prev_ticks;
02534                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02535 08FA           8B46         F0            mov	ax,-$10[bp]
02536 08FD           8B5E         F2            mov	bx,-$E[bp]
02537 0900           8D7E         F4            lea	di,-$C[bp]
02538 0903           E8         F7DB            call	lsubul
02539                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02540 0906           8946         F8            mov	-8[bp],ax
02541 0909           895E         FA            mov	-6[bp],bx
02542                                           !BCC_EOS
02543                                           ! 978       ticks_to_wait -= delta;
02544                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02545 090C           8B46         FC            mov	ax,-4[bp]
02546 090F           8B5E         FE            mov	bx,-2[bp]
02547 0912           8D7E         F8            lea	di,-8[bp]
02548 0915           E8         F7C9            call	lsubl
02549 0918           8946         FC            mov	-4[bp],ax
02550 091B           895E         FE            mov	-2[bp],bx
02551                                           !BCC_EOS
02552                                           ! 979     }
02553                                           ! 980     else if (t < prev_ticks)
02554 091E           EB           20            jmp .34
02555                       00000920            .32:
02556                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02557 0920           8B46         F4            mov	ax,-$C[bp]
02558 0923           8B5E         F6            mov	bx,-$A[bp]
02559 0926           8D7E         F0            lea	di,-$10[bp]
02560 0929           E8         F79F            call	lcmpul
02561 092C           76           12            jbe 	.35
02562                       0000092E            .36:
02563                                           ! 981     {
02564                                           ! 982       ticks_to_wait -= t;
02565                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02566 092E           8B46         FC            mov	ax,-4[bp]
02567 0931           8B5E         FE            mov	bx,-2[bp]
02568 0934           8D7E         F0            lea	di,-$10[bp]
02569 0937           E8         F7A7            call	lsubul
02570 093A           8946         FC            mov	-4[bp],ax
02571 093D           895E         FE            mov	-2[bp],bx
02572                                           !BCC_EOS
02573                                           ! 983     }
02574                                           ! 984     prev_ticks = t;
02575                       00000940            .35:
02576                       00000940            .34:
02577                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02578 0940           8B46         F0            mov	ax,-$10[bp]
02579 0943           8B5E         F2            mov	bx,-$E[bp]
02580 0946           8946         F4            mov	-$C[bp],ax
02581 0949           895E         F6            mov	-$A[bp],bx
02582                                           !BCC_EOS
02583                                           ! 985   } while (ticks_to_wait > 0);
02584                       0000094C            .30:
02585                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02586 094C           31C0                       xor	ax,ax
02587 094E           31DB                       xor	bx,bx
02588 0950           8D7E         FC            lea	di,-4[bp]
02589 0953           E8         F775            call	lcmpl
02590 0956         0F8C         FF7C            blt 	.31
02591                       0000095A            .37:
02592                                           !BCC_EOS
02593                                           ! 986 #asm
02594                       0000095A            .2F:
02595                                           !BCC_EOS
02596                                           !BCC_ASM
02597                       00000014            _delay_ticks.ticks	set	$14
02598                       00000004            .delay_ticks.ticks	set	4
02599                       00000000            _delay_ticks.t	set	0
02600                       FFFFFFF0            .delay_ticks.t	set	-$10
02601                       00000004            _delay_ticks.prev_ticks	set	4
02602                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02603                       00000008            _delay_ticks.delta	set	8
02604                       FFFFFFF8            .delay_ticks.delta	set	-8
02605                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02606                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02607 095A           FA                           cli
02608 095B           9D                           popf
02609                                           ! 989 endasm
02610                                           !BCC_ENDASM
02611                                           !BCC_EOS
02612                                           ! 990 }
02613 095C           89EC                       mov	sp,bp
02614 095E           5D                         pop	bp
02615 095F           C3                         ret
02616                                           ! 991   Bit8u
02617                                           ! Register BX used in function delay_ticks
02618                                           ! 992 check_for_keystroke()
02619                                           ! 993 {
02620                                           export	_check_for_keystroke
02621                       00000960            _check_for_keystroke:
02622                                           ! 994 #asm
02623                                           !BCC_ASM
02624 0960           B8                   0100    mov ax, #0x100
02625 0963           CD                     16    int #0x16
02626 0965           74           04              jz no_key
02627 0967           B0                     01    mov al, #1
02628 0969           EB           02              jmp done
02629                       0000096B            no_key:
02630 096B           30C0                         xor al, al
02631                       0000096D            done:
02632                                           ! 1003 endasm
02633                                           !BCC_ENDASM
02634                                           ! 1004 }
02635 096D           C3                         ret
02636                                           ! 1005   Bit8u
02637                                           ! 1006 get_keystroke()
02638                                           ! 1007 {
02639                                           export	_get_keystroke
02640                       0000096E            _get_keystroke:
02641                                           ! 1008 #asm
02642                                           !BCC_ASM
02643 096E           B8                   0000    mov ax, #0x0
02644 0971           CD                     16    int #0x16
02645 0973           86C4                         xchg ah, al
02646                                           ! 1012 endasm
02647                                           !BCC_ENDASM
02648                                           ! 1013 }
02649 0975           C3                         ret
02650                                           ! 1014   void
02651                                           ! 1015 delay_ticks_and_check_for_keystroke(ticks, count)
02652                                           ! 1016   Bit16u ticks, count;
02653                                           export	_delay_ticks_and_check_for_keystroke
02654                       00000976            _delay_ticks_and_check_for_keystroke:
02655                                           !BCC_EOS
02656                                           ! 1017 {
02657                                           ! 1018   Bit16u i;
02658                                           !BCC_EOS
02659                                           ! 1019   for (i = 1; i <= count; i++) {
02660 0976           55                         push	bp
02661 0977           89E5                       mov	bp,sp
02662 0979           4C                         dec	sp
02663 097A           4C                         dec	sp
02664                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02665 097B           B8                   0001  mov	ax,*1
02666 097E           8946         FE            mov	-2[bp],ax
02667                                           !BCC_EOS
02668                                           !BCC_EOS
02669 0981           EB           18            jmp .3A
02670                       00000983            .3B:
02671                                           ! 1020     delay_ticks(ticks);
02672                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02673 0983           FF76         04            push	4[bp]
02674                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02675 0986           E8         FF25            call	_delay_ticks
02676 0989           44                         inc	sp
02677 098A           44                         inc	sp
02678                                           !BCC_EOS
02679                                           ! 1021     if (check_for_keystroke())
02680                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02681 098B           E8         FFD2            call	_check_for_keystroke
02682 098E           84C0                       test	al,al
02683 0990           74           02            je  	.3C
02684                       00000992            .3D:
02685                                           ! 1022       break;
02686 0992           EB           0F            jmp .38
02687                                           !BCC_EOS
02688                                           ! 1023   }
02689                       00000994            .3C:
02690                                           ! 1024 }
02691                       00000994            .39:
02692                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02693 0994           8B46         FE            mov	ax,-2[bp]
02694 0997           40                         inc	ax
02695 0998           8946         FE            mov	-2[bp],ax
02696                       0000099B            .3A:
02697                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02698 099B           8B46         FE            mov	ax,-2[bp]
02699 099E           3B46         06            cmp	ax,6[bp]
02700 09A1           76           E0            jbe	.3B
02701                       000009A3            .3E:
02702                       000009A3            .38:
02703 09A3           89EC                       mov	sp,bp
02704 09A5           5D                         pop	bp
02705 09A6           C3                         ret
02706                                           ! 1025   void
02707                                           ! 1026 bios_printf(action, s)
02708                                           ! 1027   Bit16u action;
02709                                           export	_bios_printf
02710                       000009A7            _bios_printf:
02711                                           !BCC_EOS
02712                                           ! 1028   Bit8u *s;
02713                                           !BCC_EOS
02714                                           ! 1029 {
02715                                           ! 1030   Bit8u c, format_char;
02716                                           !BCC_EOS
02717                                           ! 1031   bx_bool in_format;
02718                                           !BCC_EOS
02719                                           ! 1032   short i;
02720                                           !BCC_EOS
02721                                           ! 1033   Bit16u *arg_ptr;
02722                                           !BCC_EOS
02723                                           ! 1034   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02724                                           !BCC_EOS
02725                                           ! 1035   arg_ptr = &s;
02726 09A7           55                         push	bp
02727 09A8           89E5                       mov	bp,sp
02728 09AA           83C4                   EA  add	sp,*-$16
02729                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02730 09AD           8D5E         06            lea	bx,6[bp]
02731 09B0           895E         F8            mov	-8[bp],bx
02732                                           !BCC_EOS
02733                                           ! 1036   arg_seg = get_SS();
02734                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02735 09B3           E8         FC9B            call	_get_SS
02736                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02737 09B6           8946         F6            mov	-$A[bp],ax
02738                                           !BCC_EOS
02739                                           ! 1037   in_format = 0;
02740                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02741 09B9           31C0                       xor	ax,ax
02742 09BB           8946         FC            mov	-4[bp],ax
02743                                           !BCC_EOS
02744                                           ! 1038   format_width = 0;
02745                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02746 09BE           31C0                       xor	ax,ax
02747 09C0           8946         EC            mov	-$14[bp],ax
02748                                           !BCC_EOS
02749                                           ! 1039   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02750                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02751 09C3           8A46         04            mov	al,4[bp]
02752 09C6           24                     07  and	al,*7
02753                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02754 09C8           3C                     07  cmp	al,*7
02755 09CA           75           1B            jne 	.3F
02756                       000009CC            .40:
02757                                           ! 1040     outb(0x401, 0x00);
02758                                           ! Debug: list int = const 0 (used reg = )
02759 09CC           31C0                       xor	ax,ax
02760 09CE           50                         push	ax
02761                                           ! Debug: list int = const $401 (used reg = )
02762 09CF           B8                   0401  mov	ax,#$401
02763 09D2           50                         push	ax
02764                                           ! Debug: func () void = outb+0 (used reg = )
02765 09D3           E8         FB82            call	_outb
02766 09D6           83C4                   04  add	sp,*4
02767                                           !BCC_EOS
02768                                           ! 1041     bios_printf (2, "FATAL: ");
02769                                           ! Debug: list * char = .41+0 (used reg = )
02770 09D9           BB                   D9FF  mov	bx,#.41
02771 09DC           53                         push	bx
02772                                           ! Debug: list int = const 2 (used reg = )
02773 09DD           B8                   0002  mov	ax,*2
02774 09E0           50                         push	ax
02775                                           ! Debug: func () void = bios_printf+0 (used reg = )
02776 09E1           E8         FFC3            call	_bios_printf
02777 09E4           83C4                   04  add	sp,*4
02778                                           !BCC_EOS
02779                                           ! 1042   }
02780                                           ! 1043   while (c = read_byte(get_CS(), s)) {
02781                       000009E7            .3F:
02782 09E7           E9         0367            br 	.43
02783                       000009EA            .44:
02784                                           ! 1044     if ( c == '%' ) {
02785                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02786 09EA           8A46         FF            mov	al,-1[bp]
02787 09ED           3C                     25  cmp	al,*$25
02788 09EF           75           0E            jne 	.45
02789                       000009F1            .46:
02790                                           ! 1045       in_format = 1;
02791                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02792 09F1           B8                   0001  mov	ax,*1
02793 09F4           8946         FC            mov	-4[bp],ax
02794                                           !BCC_EOS
02795                                           ! 1046       format_width = 0;
02796                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02797 09F7           31C0                       xor	ax,ax
02798 09F9           8946         EC            mov	-$14[bp],ax
02799                                           !BCC_EOS
02800                                           ! 1047     }
02801                                           ! 1048     else if (in_format) {
02802 09FC           E9         034B            br 	.47
02803                       000009FF            .45:
02804 09FF           8B46         FC            mov	ax,-4[bp]
02805 0A02           85C0                       test	ax,ax
02806 0A04         0F84         0333            beq 	.48
02807                       00000A08            .49:
02808                                           ! 1049       if ( (c>='0') && (c<='9') ) {
02809                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02810 0A08           8A46         FF            mov	al,-1[bp]
02811 0A0B           3C                     30  cmp	al,*$30
02812 0A0D           72           28            jb  	.4A
02813                       00000A0F            .4C:
02814                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02815 0A0F           8A46         FF            mov	al,-1[bp]
02816 0A12           3C                     39  cmp	al,*$39
02817 0A14           77           21            ja  	.4A
02818                       00000A16            .4B:
02819                                           ! 1050         format_width = (format_width * 10) + (c - '0');
02820                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02821 0A16           8A46         FF            mov	al,-1[bp]
02822 0A19           30E4                       xor	ah,ah
02823 0A1B           05                   FFD0  add	ax,*-$30
02824 0A1E           50                         push	ax
02825                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02826 0A1F           8B46         EC            mov	ax,-$14[bp]
02827 0A22           89C2                       mov	dx,ax
02828 0A24           D1E0                       shl	ax,*1
02829 0A26           D1E0                       shl	ax,*1
02830 0A28           01D0                       add	ax,dx
02831 0A2A           D1E0                       shl	ax,*1
02832                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02833 0A2C           0346         E8            add	ax,-$18[bp]
02834 0A2F           44                         inc	sp
02835 0A30           44                         inc	sp
02836                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02837 0A31           8946         EC            mov	-$14[bp],ax
02838                                           !BCC_EOS
02839                                           ! 1051       }
02840                                           ! 1052       else {
02841 0A34           E9         0302            br 	.4D
02842                       00000A37            .4A:
02843                                           ! 1053         arg_ptr++;
02844                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02845 0A37           8B5E         F8            mov	bx,-8[bp]
02846 0A3A           43                         inc	bx
02847 0A3B           43                         inc	bx
02848 0A3C           895E         F8            mov	-8[bp],bx
02849                                           !BCC_EOS
02850                                           ! 1054         arg = read_word(arg_seg, arg_ptr);
02851                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02852 0A3F           FF76         F8            push	-8[bp]
02853                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
02854 0A42           FF76         F6            push	-$A[bp]
02855                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02856 0A45           E8         FBC3            call	_read_word
02857 0A48           83C4                   04  add	sp,*4
02858                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
02859 0A4B           8946         F4            mov	-$C[bp],ax
02860                                           !BCC_EOS
02861                                           ! 1055         if (c == 'x' || c == 'X') {
02862                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
02863 0A4E           8A46         FF            mov	al,-1[bp]
02864 0A51           3C                     78  cmp	al,*$78
02865 0A53           74           07            je  	.4F
02866                       00000A55            .50:
02867                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
02868 0A55           8A46         FF            mov	al,-1[bp]
02869 0A58           3C                     58  cmp	al,*$58
02870 0A5A           75           76            jne 	.4E
02871                       00000A5C            .4F:
02872                                           ! 1056           if (format_width == 0)
02873                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02874 0A5C           8B46         EC            mov	ax,-$14[bp]
02875 0A5F           85C0                       test	ax,ax
02876 0A61           75           06            jne 	.51
02877                       00000A63            .52:
02878                                           ! 1057             format_width = 4;
02879                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
02880 0A63           B8                   0004  mov	ax,*4
02881 0A66           8946         EC            mov	-$14[bp],ax
02882                                           !BCC_EOS
02883                                           ! 1058 
02884                                           ! 1058           if (c == 'x')
02885                       00000A69            .51:
02886                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
02887 0A69           8A46         FF            mov	al,-1[bp]
02888 0A6C           3C                     78  cmp	al,*$78
02889 0A6E           75           08            jne 	.53
02890                       00000A70            .54:
02891                                           ! 1059             hexadd = 'a';
02892                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
02893 0A70           B8                   0061  mov	ax,*$61
02894 0A73           8946         EA            mov	-$16[bp],ax
02895                                           !BCC_EOS
02896                                           ! 1060           else
02897                                           ! 1061             hexadd = 'A';
02898 0A76           EB           06            jmp .55
02899                       00000A78            .53:
02900                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
02901 0A78           B8                   0041  mov	ax,*$41
02902 0A7B           8946         EA            mov	-$16[bp],ax
02903                                           !BCC_EOS
02904                                           ! 1062           for (i=format_width-1; i>=0; i--) {
02905                       00000A7E            .55:
02906                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
02907 0A7E           8B46         EC            mov	ax,-$14[bp]
02908                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02909 0A81           48                         dec	ax
02910 0A82           8946         FA            mov	-6[bp],ax
02911                                           !BCC_EOS
02912                                           !BCC_EOS
02913 0A85           EB           41            jmp .58
02914                       00000A87            .59:
02915                                           ! 1063             nibble = (arg >> (4 * i)) & 0x000f;
02916                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02917                                           ! Debug: expression subtree swapping
02918 0A87           8B46         FA            mov	ax,-6[bp]
02919 0A8A           D1E0                       shl	ax,*1
02920 0A8C           D1E0                       shl	ax,*1
02921                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
02922 0A8E           89C3                       mov	bx,ax
02923 0A90           8B46         F4            mov	ax,-$C[bp]
02924 0A93           89D9                       mov	cx,bx
02925 0A95           D3E8                       shr	ax,cl
02926                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
02927 0A97           24                     0F  and	al,*$F
02928                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
02929 0A99           30E4                       xor	ah,ah
02930 0A9B           8946         F2            mov	-$E[bp],ax
02931                                           !BCC_EOS
02932                                           ! 1064             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
02933                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
02934 0A9E           8B46         F2            mov	ax,-$E[bp]
02935 0AA1           3D                   0009  cmp	ax,*9
02936 0AA4           77           08            ja  	.5A
02937                       00000AA6            .5B:
02938                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
02939 0AA6           8B46         F2            mov	ax,-$E[bp]
02940 0AA9           05                   0030  add	ax,*$30
02941 0AAC           EB           09            jmp .5C
02942                       00000AAE            .5A:
02943                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
02944 0AAE           8B46         F2            mov	ax,-$E[bp]
02945                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
02946 0AB1           05                   FFF6  add	ax,*-$A
02947 0AB4           0346         EA            add	ax,-$16[bp]
02948                       00000AB7            .5C:
02949                                           ! Debug: list unsigned int = ax+0 (used reg = )
02950 0AB7           50                         push	ax
02951                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02952 0AB8           FF76         04            push	4[bp]
02953                                           ! Debug: func () void = send+0 (used reg = )
02954 0ABB           E8         FBA6            call	_send
02955 0ABE           83C4                   04  add	sp,*4
02956                                           !BCC_EOS
02957                                           ! 1065           }
02958                                           ! 1066         }
02959                       00000AC1            .57:
02960                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
02961 0AC1           8B46         FA            mov	ax,-6[bp]
02962 0AC4           48                         dec	ax
02963 0AC5           8946         FA            mov	-6[bp],ax
02964                       00000AC8            .58:
02965                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
02966 0AC8           8B46         FA            mov	ax,-6[bp]
02967 0ACB           85C0                       test	ax,ax
02968 0ACD           7D           B8            jge	.59
02969                       00000ACF            .5D:
02970                       00000ACF            .56:
02971                                           ! 1067         else if (c == 'u') {
02972 0ACF           E9         0262            br 	.5E
02973                       00000AD2            .4E:
02974                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
02975 0AD2           8A46         FF            mov	al,-1[bp]
02976 0AD5           3C                     75  cmp	al,*$75
02977 0AD7           75           15            jne 	.5F
02978                       00000AD9            .60:
02979                                           ! 1068           put_uint(action, arg, format_width, 0);
02980                                           ! Debug: list int = const 0 (used reg = )
02981 0AD9           31C0                       xor	ax,ax
02982 0ADB           50                         push	ax
02983                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
02984 0ADC           FF76         EC            push	-$14[bp]
02985                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
02986 0ADF           FF76         F4            push	-$C[bp]
02987                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
02988 0AE2           FF76         04            push	4[bp]
02989                                           ! Debug: func () void = put_uint+0 (used reg = )
02990 0AE5           E8         FC58            call	_put_uint
02991 0AE8           83C4                   08  add	sp,*8
02992                                           !BCC_EOS
02993                                           ! 1069         }
02994                                           ! 1070         else if (c == 'l') {
02995 0AEB           E9         0246            br 	.61
02996                       00000AEE            .5F:
02997                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
02998 0AEE           8A46         FF            mov	al,-1[bp]
02999 0AF1           3C                     6C  cmp	al,*$6C
03000 0AF3         0F85         018D            bne 	.62
03001                       00000AF7            .63:
03002                                           ! 1071           s++;
03003                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03004 0AF7           8B5E         06            mov	bx,6[bp]
03005 0AFA           43                         inc	bx
03006 0AFB           895E         06            mov	6[bp],bx
03007                                           !BCC_EOS
03008                                           ! 1072           c = read_byte(get_CS(), s);
03009                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03010 0AFE           FF76         06            push	6[bp]
03011                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03012 0B01           E8         FB4A            call	_get_CS
03013                                           ! Debug: list unsigned short = ax+0 (used reg = )
03014 0B04           50                         push	ax
03015                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03016 0B05           E8         FAF0            call	_read_byte
03017 0B08           83C4                   04  add	sp,*4
03018                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03019 0B0B           8846         FF            mov	-1[bp],al
03020                                           !BCC_EOS
03021                                           ! 1073           arg_ptr++;
03022                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03023 0B0E           8B5E         F8            mov	bx,-8[bp]
03024 0B11           43                         inc	bx
03025 0B12           43                         inc	bx
03026 0B13           895E         F8            mov	-8[bp],bx
03027                                           !BCC_EOS
03028                                           ! 1074           hibyte = read_word(arg_seg, arg_ptr);
03029                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03030 0B16           FF76         F8            push	-8[bp]
03031                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03032 0B19           FF76         F6            push	-$A[bp]
03033                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03034 0B1C           E8         FAEC            call	_read_word
03035 0B1F           83C4                   04  add	sp,*4
03036                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03037 0B22           8946         F0            mov	-$10[bp],ax
03038                                           !BCC_EOS
03039                                           ! 1075           if (c == 'd') {
03040                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03041 0B25           8A46         FF            mov	al,-1[bp]
03042 0B28           3C                     64  cmp	al,*$64
03043 0B2A           75           73            jne 	.64
03044                       00000B2C            .65:
03045                                           ! 1076             if (hibyte & 0x8000)
03046                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03047 0B2C           8B46         F0            mov	ax,-$10[bp]
03048 0B2F           25                   8000  and	ax,#$8000
03049 0B32           85C0                       test	ax,ax
03050 0B34           74           3D            je  	.66
03051                       00000B36            .67:
03052                                           ! 1077               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03053                                           ! Debug: list int = const 1 (used reg = )
03054 0B36           B8                   0001  mov	ax,*1
03055 0B39           50                         push	ax
03056                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03057 0B3A           8B46         EC            mov	ax,-$14[bp]
03058                                           ! Debug: list unsigned int = ax-1 (used reg = )
03059 0B3D           48                         dec	ax
03060 0B3E           50                         push	ax
03061                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03062 0B3F           8B46         F4            mov	ax,-$C[bp]
03063 0B42           31DB                       xor	bx,bx
03064 0B44           53                         push	bx
03065 0B45           50                         push	ax
03066                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03067 0B46           8B46         F0            mov	ax,-$10[bp]
03068 0B49           31DB                       xor	bx,bx
03069                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03070 0B4B           93                         xchg	bx,ax
03071 0B4C           31C0                       xor	ax,ax
03072                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03073 0B4E           8D7E         E2            lea	di,-$1E[bp]
03074 0B51           E8         F5B3            call	lorul
03075 0B54           83C4                   04  add	sp,*4
03076                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03077 0B57           53                         push	bx
03078 0B58           50                         push	ax
03079 0B59           31C0                       xor	ax,ax
03080 0B5B           31DB                       xor	bx,bx
03081 0B5D           8D7E         E2            lea	di,-$1E[bp]
03082 0B60           E8         F57E            call	lsubul
03083 0B63           83C4                   04  add	sp,*4
03084                                           ! Debug: list unsigned long = bx+0 (used reg = )
03085 0B66           53                         push	bx
03086 0B67           50                         push	ax
03087                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03088 0B68           FF76         04            push	4[bp]
03089                                           ! Debug: func () void = put_luint+0 (used reg = )
03090 0B6B           E8         FC55            call	_put_luint
03091 0B6E           83C4                   0A  add	sp,*$A
03092                                           !BCC_EOS
03093                                           ! 1078             else
03094                                           ! 1079               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03095 0B71           EB           29            jmp .68
03096                       00000B73            .66:
03097                                           ! Debug: list int = const 0 (used reg = )
03098 0B73           31C0                       xor	ax,ax
03099 0B75           50                         push	ax
03100                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03101 0B76           FF76         EC            push	-$14[bp]
03102                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03103 0B79           8B46         F4            mov	ax,-$C[bp]
03104 0B7C           31DB                       xor	bx,bx
03105 0B7E           53                         push	bx
03106 0B7F           50                         push	ax
03107                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03108 0B80           8B46         F0            mov	ax,-$10[bp]
03109 0B83           31DB                       xor	bx,bx
03110                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03111 0B85           93                         xchg	bx,ax
03112 0B86           31C0                       xor	ax,ax
03113                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03114 0B88           8D7E         E2            lea	di,-$1E[bp]
03115 0B8B           E8         F579            call	lorul
03116 0B8E           83C4                   04  add	sp,*4
03117                                           ! Debug: list unsigned long = bx+0 (used reg = )
03118 0B91           53                         push	bx
03119 0B92           50                         push	ax
03120                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03121 0B93           FF76         04            push	4[bp]
03122                                           ! Debug: func () void = put_luint+0 (used reg = )
03123 0B96           E8         FC2A            call	_put_luint
03124 0B99           83C4                   0A  add	sp,*$A
03125                                           !BCC_EOS
03126                                           ! 1080           }
03127                       00000B9C            .68:
03128                                           ! 1081           else if (c == 'u') {
03129 0B9C           E9         00E2            br 	.69
03130                       00000B9F            .64:
03131                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03132 0B9F           8A46         FF            mov	al,-1[bp]
03133 0BA2           3C                     75  cmp	al,*$75
03134 0BA4           75           2C            jne 	.6A
03135                       00000BA6            .6B:
03136                                           ! 1082             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03137                                           ! Debug: list int = const 0 (used reg = )
03138 0BA6           31C0                       xor	ax,ax
03139 0BA8           50                         push	ax
03140                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03141 0BA9           FF76         EC            push	-$14[bp]
03142                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03143 0BAC           8B46         F4            mov	ax,-$C[bp]
03144 0BAF           31DB                       xor	bx,bx
03145 0BB1           53                         push	bx
03146 0BB2           50                         push	ax
03147                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03148 0BB3           8B46         F0            mov	ax,-$10[bp]
03149 0BB6           31DB                       xor	bx,bx
03150                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03151 0BB8           93                         xchg	bx,ax
03152 0BB9           31C0                       xor	ax,ax
03153                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03154 0BBB           8D7E         E2            lea	di,-$1E[bp]
03155 0BBE           E8         F546            call	lorul
03156 0BC1           83C4                   04  add	sp,*4
03157                                           ! Debug: list unsigned long = bx+0 (used reg = )
03158 0BC4           53                         push	bx
03159 0BC5           50                         push	ax
03160                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03161 0BC6           FF76         04            push	4[bp]
03162                                           ! Debug: func () void = put_luint+0 (used reg = )
03163 0BC9           E8         FBF7            call	_put_luint
03164 0BCC           83C4                   0A  add	sp,*$A
03165                                           !BCC_EOS
03166                                           ! 1083           }
03167                                           ! 1084           else if (c == 'x' || c == 'X')
03168 0BCF           E9         00AF            br 	.6C
03169                       00000BD2            .6A:
03170                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03171 0BD2           8A46         FF            mov	al,-1[bp]
03172 0BD5           3C                     78  cmp	al,*$78
03173 0BD7           74           09            je  	.6E
03174                       00000BD9            .6F:
03175                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03176 0BD9           8A46         FF            mov	al,-1[bp]
03177 0BDC           3C                     58  cmp	al,*$58
03178 0BDE         0F85         009F            bne 	.6D
03179                       00000BE2            .6E:
03180                                           ! 1085           {
03181                                           ! 1086             if (format_width == 0)
03182                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03183 0BE2           8B46         EC            mov	ax,-$14[bp]
03184 0BE5           85C0                       test	ax,ax
03185 0BE7           75           06            jne 	.70
03186                       00000BE9            .71:
03187                                           ! 1087               format_width = 8;
03188                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03189 0BE9           B8                   0008  mov	ax,*8
03190 0BEC           8946         EC            mov	-$14[bp],ax
03191                                           !BCC_EOS
03192                                           ! 1088             if (c == 'x')
03193                       00000BEF            .70:
03194                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03195 0BEF           8A46         FF            mov	al,-1[bp]
03196 0BF2           3C                     78  cmp	al,*$78
03197 0BF4           75           08            jne 	.72
03198                       00000BF6            .73:
03199                                           ! 1089               hexadd = 'a';
03200                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03201 0BF6           B8                   0061  mov	ax,*$61
03202 0BF9           8946         EA            mov	-$16[bp],ax
03203                                           !BCC_EOS
03204                                           ! 1090             else
03205                                           ! 1091               hexadd = 'A';
03206 0BFC           EB           06            jmp .74
03207                       00000BFE            .72:
03208                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03209 0BFE           B8                   0041  mov	ax,*$41
03210 0C01           8946         EA            mov	-$16[bp],ax
03211                                           !BCC_EOS
03212                                           ! 1092             for (i=format_width-1; i>=0; i--) {
03213                       00000C04            .74:
03214                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03215 0C04           8B46         EC            mov	ax,-$14[bp]
03216                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03217 0C07           48                         dec	ax
03218 0C08           8946         FA            mov	-6[bp],ax
03219                                           !BCC_EOS
03220                                           !BCC_EOS
03221 0C0B           EB           6D            jmp .77
03222                       00000C0D            .78:
03223                                           ! 1093               nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03224                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03225                                           ! Debug: expression subtree swapping
03226 0C0D           8B46         FA            mov	ax,-6[bp]
03227 0C10           D1E0                       shl	ax,*1
03228 0C12           D1E0                       shl	ax,*1
03229 0C14           50                         push	ax
03230                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03231 0C15           8B46         F4            mov	ax,-$C[bp]
03232 0C18           31DB                       xor	bx,bx
03233 0C1A           53                         push	bx
03234 0C1B           50                         push	ax
03235                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03236 0C1C           8B46         F0            mov	ax,-$10[bp]
03237 0C1F           31DB                       xor	bx,bx
03238                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03239 0C21           93                         xchg	bx,ax
03240 0C22           31C0                       xor	ax,ax
03241                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03242 0C24           8D7E         E4            lea	di,-$1C[bp]
03243 0C27           E8         F4DD            call	lorul
03244 0C2A           83C4                   04  add	sp,*4
03245                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03246 0C2D           8B7E         E8            mov	di,-$18[bp]
03247 0C30           E8         F4F6            call	lsrul
03248 0C33           44                         inc	sp
03249 0C34           44                         inc	sp
03250                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03251 0C35           53                         push	bx
03252 0C36           50                         push	ax
03253 0C37           B8                   000F  mov	ax,*$F
03254 0C3A           31DB                       xor	bx,bx
03255 0C3C           53                         push	bx
03256 0C3D           50                         push	ax
03257 0C3E           8B46         E6            mov	ax,-$1A[bp]
03258 0C41           8B5E         E8            mov	bx,-$18[bp]
03259 0C44           8D7E         E2            lea	di,-$1E[bp]
03260 0C47           E8         F471            call	landul
03261 0C4A           83C4                   08  add	sp,*8
03262                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03263 0C4D           8946         F2            mov	-$E[bp],ax
03264                                           !BCC_EOS
03265                                           ! 1094               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03266                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03267 0C50           8B46         F2            mov	ax,-$E[bp]
03268 0C53           3D                   0009  cmp	ax,*9
03269 0C56           77           08            ja  	.79
03270                       00000C58            .7A:
03271                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03272 0C58           8B46         F2            mov	ax,-$E[bp]
03273 0C5B           05                   0030  add	ax,*$30
03274 0C5E           EB           09            jmp .7B
03275                       00000C60            .79:
03276                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03277 0C60           8B46         F2            mov	ax,-$E[bp]
03278                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03279 0C63           05                   FFF6  add	ax,*-$A
03280 0C66           0346         EA            add	ax,-$16[bp]
03281                       00000C69            .7B:
03282                                           ! Debug: list unsigned int = ax+0 (used reg = )
03283 0C69           50                         push	ax
03284                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03285 0C6A           FF76         04            push	4[bp]
03286                                           ! Debug: func () void = send+0 (used reg = )
03287 0C6D           E8         F9F4            call	_send
03288 0C70           83C4                   04  add	sp,*4
03289                                           !BCC_EOS
03290                                           ! 1095             }
03291                                           ! 1096           }
03292                       00000C73            .76:
03293                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03294 0C73           8B46         FA            mov	ax,-6[bp]
03295 0C76           48                         dec	ax
03296 0C77           8946         FA            mov	-6[bp],ax
03297                       00000C7A            .77:
03298                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03299 0C7A           8B46         FA            mov	ax,-6[bp]
03300 0C7D           85C0                       test	ax,ax
03301 0C7F           7D           8C            jge	.78
03302                       00000C81            .7C:
03303                       00000C81            .75:
03304                                           ! 1097         }
03305                       00000C81            .6D:
03306                       00000C81            .6C:
03307                       00000C81            .69:
03308                                           ! 1098         else if (c == 'd') {
03309 0C81           E9         00B0            br 	.7D
03310                       00000C84            .62:
03311                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03312 0C84           8A46         FF            mov	al,-1[bp]
03313 0C87           3C                     64  cmp	al,*$64
03314 0C89           75           38            jne 	.7E
03315                       00000C8B            .7F:
03316                                           ! 1099           if (arg & 0x8000)
03317                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03318 0C8B           8B46         F4            mov	ax,-$C[bp]
03319 0C8E           25                   8000  and	ax,#$8000
03320 0C91           85C0                       test	ax,ax
03321 0C93           74           1A            je  	.80
03322                       00000C95            .81:
03323                                           ! 1100             put_int(action, -arg, format_width - 1, 1);
03324                                           ! Debug: list int = const 1 (used reg = )
03325 0C95           B8                   0001  mov	ax,*1
03326 0C98           50                         push	ax
03327                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03328 0C99           8B46         EC            mov	ax,-$14[bp]
03329                                           ! Debug: list unsigned int = ax-1 (used reg = )
03330 0C9C           48                         dec	ax
03331 0C9D           50                         push	ax
03332                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03333 0C9E           31C0                       xor	ax,ax
03334 0CA0           2B46         F4            sub	ax,-$C[bp]
03335                                           ! Debug: list unsigned int = ax+0 (used reg = )
03336 0CA3           50                         push	ax
03337                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03338 0CA4           FF76         04            push	4[bp]
03339                                           ! Debug: func () void = put_int+0 (used reg = )
03340 0CA7           E8         FA13            call	_put_int
03341 0CAA           83C4                   08  add	sp,*8
03342                                           !BCC_EOS
03343                                           ! 1101           else
03344                                           ! 1102             put_int(action, arg, format_width, 0);
03345 0CAD           EB           12            jmp .82
03346                       00000CAF            .80:
03347                                           ! Debug: list int = const 0 (used reg = )
03348 0CAF           31C0                       xor	ax,ax
03349 0CB1           50                         push	ax
03350                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03351 0CB2           FF76         EC            push	-$14[bp]
03352                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03353 0CB5           FF76         F4            push	-$C[bp]
03354                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03355 0CB8           FF76         04            push	4[bp]
03356                                           ! Debug: func () void = put_int+0 (used reg = )
03357 0CBB           E8         F9FF            call	_put_int
03358 0CBE           83C4                   08  add	sp,*8
03359                                           !BCC_EOS
03360                                           ! 1103         }
03361                       00000CC1            .82:
03362                                           ! 1104         else if (c == 's') {
03363 0CC1           EB           71            jmp .83
03364                       00000CC3            .7E:
03365                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03366 0CC3           8A46         FF            mov	al,-1[bp]
03367 0CC6           3C                     73  cmp	al,*$73
03368 0CC8           75           12            jne 	.84
03369                       00000CCA            .85:
03370                                           ! 1105           put_str(action, get_CS(), arg);
03371                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03372 0CCA           FF76         F4            push	-$C[bp]
03373                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03374 0CCD           E8         F97E            call	_get_CS
03375                                           ! Debug: list unsigned short = ax+0 (used reg = )
03376 0CD0           50                         push	ax
03377                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03378 0CD1           FF76         04            push	4[bp]
03379                                           ! Debug: func () void = put_str+0 (used reg = )
03380 0CD4           E8         FBA3            call	_put_str
03381 0CD7           83C4                   06  add	sp,*6
03382                                           !BCC_EOS
03383                                           ! 1106         }
03384                                           ! 1107         else if (c == 'S') {
03385 0CDA           EB           58            jmp .86
03386                       00000CDC            .84:
03387                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03388 0CDC           8A46         FF            mov	al,-1[bp]
03389 0CDF           3C                     53  cmp	al,*$53
03390 0CE1           75           2E            jne 	.87
03391                       00000CE3            .88:
03392                                           ! 1108           hibyte = arg;
03393                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03394 0CE3           8B46         F4            mov	ax,-$C[bp]
03395 0CE6           8946         F0            mov	-$10[bp],ax
03396                                           !BCC_EOS
03397                                           ! 1109           arg_ptr++;
03398                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03399 0CE9           8B5E         F8            mov	bx,-8[bp]
03400 0CEC           43                         inc	bx
03401 0CED           43                         inc	bx
03402 0CEE           895E         F8            mov	-8[bp],bx
03403                                           !BCC_EOS
03404                                           ! 1110           arg = read_word(arg_seg, arg_ptr);
03405                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03406 0CF1           FF76         F8            push	-8[bp]
03407                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03408 0CF4           FF76         F6            push	-$A[bp]
03409                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03410 0CF7           E8         F911            call	_read_word
03411 0CFA           83C4                   04  add	sp,*4
03412                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03413 0CFD           8946         F4            mov	-$C[bp],ax
03414                                           !BCC_EOS
03415                                           ! 1111           put_str(action, hibyte, arg);
03416                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03417 0D00           FF76         F4            push	-$C[bp]
03418                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03419 0D03           FF76         F0            push	-$10[bp]
03420                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03421 0D06           FF76         04            push	4[bp]
03422                                           ! Debug: func () void = put_str+0 (used reg = )
03423 0D09           E8         FB6E            call	_put_str
03424 0D0C           83C4                   06  add	sp,*6
03425                                           !BCC_EOS
03426                                           ! 1112         }
03427                                           ! 1113         else if (c == 'c') {
03428 0D0F           EB           23            jmp .89
03429                       00000D11            .87:
03430                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03431 0D11           8A46         FF            mov	al,-1[bp]
03432 0D14           3C                     63  cmp	al,*$63
03433 0D16           75           0E            jne 	.8A
03434                       00000D18            .8B:
03435                                           ! 1114           send(action, arg);
03436                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03437 0D18           FF76         F4            push	-$C[bp]
03438                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03439 0D1B           FF76         04            push	4[bp]
03440                                           ! Debug: func () void = send+0 (used reg = )
03441 0D1E           E8         F943            call	_send
03442 0D21           83C4                   04  add	sp,*4
03443                                           !BCC_EOS
03444                                           ! 1115         }
03445                                           ! 1116         else
03446                                           ! 1117           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03447 0D24           EB           0E            jmp .8C
03448                       00000D26            .8A:
03449                                           ! Debug: list * char = .8D+0 (used reg = )
03450 0D26           BB                   D9E2  mov	bx,#.8D
03451 0D29           53                         push	bx
03452                                           ! Debug: list int = const 7 (used reg = )
03453 0D2A           B8                   0007  mov	ax,*7
03454 0D2D           50                         push	ax
03455                                           ! Debug: func () void = bios_printf+0 (used reg = )
03456 0D2E           E8         FC76            call	_bios_printf
03457 0D31           83C4                   04  add	sp,*4
03458                                           !BCC_EOS
03459                                           ! 1118           in_format = 0;
03460                       00000D34            .8C:
03461                       00000D34            .89:
03462                       00000D34            .86:
03463                       00000D34            .83:
03464                       00000D34            .7D:
03465                       00000D34            .61:
03466                       00000D34            .5E:
03467                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03468 0D34           31C0                       xor	ax,ax
03469 0D36           8946         FC            mov	-4[bp],ax
03470                                           !BCC_EOS
03471                                           ! 1119       }
03472                                           ! 1120     }
03473                       00000D39            .4D:
03474                                           ! 1121     else {
03475 0D39           EB           0F            jmp .8E
03476                       00000D3B            .48:
03477                                           ! 1122       send(action, c);
03478                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03479 0D3B           8A46         FF            mov	al,-1[bp]
03480 0D3E           30E4                       xor	ah,ah
03481 0D40           50                         push	ax
03482                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03483 0D41           FF76         04            push	4[bp]
03484                                           ! Debug: func () void = send+0 (used reg = )
03485 0D44           E8         F91D            call	_send
03486 0D47           83C4                   04  add	sp,*4
03487                                           !BCC_EOS
03488                                           ! 1123     }
03489                                           ! 1124     s ++;
03490                       00000D4A            .8E:
03491                       00000D4A            .47:
03492                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03493 0D4A           8B5E         06            mov	bx,6[bp]
03494 0D4D           43                         inc	bx
03495 0D4E           895E         06            mov	6[bp],bx
03496                                           !BCC_EOS
03497                                           ! 1125   }
03498                                           ! 1126   if (ac
03499                       00000D51            .43:
03500                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03501 0D51           FF76         06            push	6[bp]
03502                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03503 0D54           E8         F8F7            call	_get_CS
03504                                           ! Debug: list unsigned short = ax+0 (used reg = )
03505 0D57           50                         push	ax
03506                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03507 0D58           E8         F89D            call	_read_byte
03508 0D5B           83C4                   04  add	sp,*4
03509                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03510 0D5E           8846         FF            mov	-1[bp],al
03511 0D61           84C0                       test	al,al
03512 0D63         0F85         FC83            bne 	.44
03513                       00000D67            .8F:
03514                       00000D67            .42:
03515                                           ! 1126 tion & 1) {
03516                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03517 0D67           8A46         04            mov	al,4[bp]
03518 0D6A           24                     01  and	al,*1
03519 0D6C           84C0                       test	al,al
03520 0D6E           74           04            je  	.90
03521                       00000D70            .91:
03522                                           ! 1127 #asm
03523                                           !BCC_EOS
03524                                           !BCC_ASM
03525                       00000002            _bios_printf.format_width	set	2
03526                       FFFFFFEC            .bios_printf.format_width	set	-$14
03527                       00000014            _bios_printf.format_char	set	$14
03528                       FFFFFFFE            .bios_printf.format_char	set	-2
03529                       00000006            _bios_printf.hibyte	set	6
03530                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03531                       0000000E            _bios_printf.arg_ptr	set	$E
03532                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03533                       0000001A            _bios_printf.action	set	$1A
03534                       00000004            .bios_printf.action	set	4
03535                       00000010            _bios_printf.i	set	$10
03536                       FFFFFFFA            .bios_printf.i	set	-6
03537                       0000000C            _bios_printf.arg_seg	set	$C
03538                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03539                       00000004            _bios_printf.shift_count	set	4
03540                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03541                       00000012            _bios_printf.in_format	set	$12
03542                       FFFFFFFC            .bios_printf.in_format	set	-4
03543                       0000001C            _bios_printf.s	set	$1C
03544                       00000006            .bios_printf.s	set	6
03545                       00000008            _bios_printf.nibble	set	8
03546                       FFFFFFF2            .bios_printf.nibble	set	-$E
03547                       00000015            _bios_printf.c	set	$15
03548                       FFFFFFFF            .bios_printf.c	set	-1
03549                       00000000            _bios_printf.hexadd	set	0
03550                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03551                       0000000A            _bios_printf.arg	set	$A
03552                       FFFFFFF4            .bios_printf.arg	set	-$C
03553 0D70           FA                             cli
03554                       00000D71             halt2_loop:
03555 0D71           F4                             hlt
03556 0D72           EB           FD                jmp halt2_loop
03557                                           ! 1132 endasm
03558                                           !BCC_ENDASM
03559                                           !BCC_EOS
03560                                           ! 1133   }
03561                                           ! 1134 }
03562                       00000D74            .90:
03563 0D74           89EC                       mov	sp,bp
03564 0D76           5D                         pop	bp
03565 0D77           C3                         ret
03566                                           ! 1135   void
03567                                           ! Register BX used in function bios_printf
03568                                           ! 1136 keyboard_init()
03569                                           ! 1137 {
03570                                           export	_keyboard_init
03571                       00000D78            _keyboard_init:
03572                                           ! 1138     Bit16u max;
03573                                           !BCC_EOS
03574                                           ! 1139     max=0xffff;
03575 0D78           55                         push	bp
03576 0D79           89E5                       mov	bp,sp
03577 0D7B           4C                         dec	sp
03578 0D7C           4C                         dec	sp
03579                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03580 0D7D           B8                   FFFF  mov	ax,#$FFFF
03581 0D80           8946         FE            mov	-2[bp],ax
03582                                           !BCC_EOS
03583                                           ! 1140     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03584 0D83           EB           0D            jmp .93
03585                       00000D85            .94:
03586                                           ! Debug: list int = const 0 (used reg = )
03587 0D85           31C0                       xor	ax,ax
03588 0D87           50                         push	ax
03589                                           ! Debug: list int = const $80 (used reg = )
03590 0D88           B8                   0080  mov	ax,#$80
03591 0D8B           50                         push	ax
03592                                           ! Debug: func () void = outb+0 (used reg = )
03593 0D8C           E8         F7C9            call	_outb
03594 0D8F           83C4                   04  add	sp,*4
03595                                           !BCC_EOS
03596                                           ! 1141     max=0x2000;
03597                       00000D92            .93:
03598                                           ! Debug: list int = const $64 (used reg = )
03599 0D92           B8                   0064  mov	ax,*$64
03600 0D95           50                         push	ax
03601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03602 0D96           E8         F7A9            call	_inb
03603 0D99           44                         inc	sp
03604 0D9A           44                         inc	sp
03605                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03606 0D9B           24                     02  and	al,*2
03607 0D9D           84C0                       test	al,al
03608 0D9F           74           0B            je  	.95
03609                       00000DA1            .96:
03610                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03611 0DA1           8B46         FE            mov	ax,-2[bp]
03612 0DA4           48                         dec	ax
03613 0DA5           8946         FE            mov	-2[bp],ax
03614                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03615 0DA8           85C0                       test	ax,ax
03616 0DAA           75           D9            jne	.94
03617                       00000DAC            .95:
03618                       00000DAC            .92:
03619                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03620 0DAC           B8                   2000  mov	ax,#$2000
03621 0DAF           8946         FE            mov	-2[bp],ax
03622                                           !BCC_EOS
03623                                           ! 1142     while (--max > 0) {
03624 0DB2           EB           2B            jmp .98
03625                       00000DB4            .99:
03626                                           ! 1143         outb(0x80, 0x00);
03627                                           ! Debug: list int = const 0 (used reg = )
03628 0DB4           31C0                       xor	ax,ax
03629 0DB6           50                         push	ax
03630                                           ! Debug: list int = const $80 (used reg = )
03631 0DB7           B8                   0080  mov	ax,#$80
03632 0DBA           50                         push	ax
03633                                           ! Debug: func () void = outb+0 (used reg = )
03634 0DBB           E8         F79A            call	_outb
03635 0DBE           83C4                   04  add	sp,*4
03636                                           !BCC_EOS
03637                                           ! 1144         if (inb(0x64) & 0x01) {
03638                                           ! Debug: list int = const $64 (used reg = )
03639 0DC1           B8                   0064  mov	ax,*$64
03640 0DC4           50                         push	ax
03641                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03642 0DC5           E8         F77A            call	_inb
03643 0DC8           44                         inc	sp
03644 0DC9           44                         inc	sp
03645                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03646 0DCA           24                     01  and	al,*1
03647 0DCC           84C0                       test	al,al
03648 0DCE           74           0F            je  	.9A
03649                       00000DD0            .9B:
03650                                           ! 1145             inb(0x60);
03651                                           ! Debug: list int = const $60 (used reg = )
03652 0DD0           B8                   0060  mov	ax,*$60
03653 0DD3           50                         push	ax
03654                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03655 0DD4           E8         F76B            call	_inb
03656 0DD7           44                         inc	sp
03657 0DD8           44                         inc	sp
03658                                           !BCC_EOS
03659                                           ! 1146             max = 0x2000;
03660                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03661 0DD9           B8                   2000  mov	ax,#$2000
03662 0DDC           8946         FE            mov	-2[bp],ax
03663                                           !BCC_EOS
03664                                           ! 1147         }
03665                                           ! 1148     }
03666                       00000DDF            .9A:
03667                                           ! 1149     outb(0x64, 0xaa);
03668                       00000DDF            .98:
03669                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03670 0DDF           8B46         FE            mov	ax,-2[bp]
03671 0DE2           48                         dec	ax
03672 0DE3           8946         FE            mov	-2[bp],ax
03673                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03674 0DE6           85C0                       test	ax,ax
03675 0DE8           75           CA            jne	.99
03676                       00000DEA            .9C:
03677                       00000DEA            .97:
03678                                           ! Debug: list int = const $AA (used reg = )
03679 0DEA           B8                   00AA  mov	ax,#$AA
03680 0DED           50                         push	ax
03681                                           ! Debug: list int = const $64 (used reg = )
03682 0DEE           B8                   0064  mov	ax,*$64
03683 0DF1           50                         push	ax
03684                                           ! Debug: func () void = outb+0 (used reg = )
03685 0DF2           E8         F763            call	_outb
03686 0DF5           83C4                   04  add	sp,*4
03687                                           !BCC_EOS
03688                                           ! 1150     max=0xffff;
03689                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03690 0DF8           B8                   FFFF  mov	ax,#$FFFF
03691 0DFB           8946         FE            mov	-2[bp],ax
03692                                           !BCC_EOS
03693                                           ! 1151     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03694 0DFE           EB           0D            jmp .9E
03695                       00000E00            .9F:
03696                                           ! Debug: list int = const 0 (used reg = )
03697 0E00           31C0                       xor	ax,ax
03698 0E02           50                         push	ax
03699                                           ! Debug: list int = const $80 (used reg = )
03700 0E03           B8                   0080  mov	ax,#$80
03701 0E06           50                         push	ax
03702                                           ! Debug: func () void = outb+0 (used reg = )
03703 0E07           E8         F74E            call	_outb
03704 0E0A           83C4                   04  add	sp,*4
03705                                           !BCC_EOS
03706                                           ! 1152     if (max==0x0) keyboard_panic(00);
03707                       00000E0D            .9E:
03708                                           ! Debug: list int = const $64 (used reg = )
03709 0E0D           B8                   0064  mov	ax,*$64
03710 0E10           50                         push	ax
03711                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03712 0E11           E8         F72E            call	_inb
03713 0E14           44                         inc	sp
03714 0E15           44                         inc	sp
03715                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03716 0E16           24                     02  and	al,*2
03717 0E18           84C0                       test	al,al
03718 0E1A           74           0B            je  	.A0
03719                       00000E1C            .A1:
03720                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03721 0E1C           8B46         FE            mov	ax,-2[bp]
03722 0E1F           48                         dec	ax
03723 0E20           8946         FE            mov	-2[bp],ax
03724                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03725 0E23           85C0                       test	ax,ax
03726 0E25           75           D9            jne	.9F
03727                       00000E27            .A0:
03728                       00000E27            .9D:
03729                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03730 0E27           8B46         FE            mov	ax,-2[bp]
03731 0E2A           85C0                       test	ax,ax
03732 0E2C           75           08            jne 	.A2
03733                       00000E2E            .A3:
03734                                           ! Debug: list int = const 0 (used reg = )
03735 0E2E           31C0                       xor	ax,ax
03736 0E30           50                         push	ax
03737                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03738 0E31           E8         0408            call	_keyboard_panic
03739 0E34           44                         inc	sp
03740 0E35           44                         inc	sp
03741                                           !BCC_EOS
03742                                           ! 1153     max=0xffff;
03743                       00000E36            .A2:
03744                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03745 0E36           B8                   FFFF  mov	ax,#$FFFF
03746 0E39           8946         FE            mov	-2[bp],ax
03747                                           !BCC_EOS
03748                                           ! 1154     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03749 0E3C           EB           0E            jmp .A5
03750                       00000E3E            .A6:
03751                                           ! Debug: list int = const 1 (used reg = )
03752 0E3E           B8                   0001  mov	ax,*1
03753 0E41           50                         push	ax
03754                                           ! Debug: list int = const $80 (used reg = )
03755 0E42           B8                   0080  mov	ax,#$80
03756 0E45           50                         push	ax
03757                                           ! Debug: func () void = outb+0 (used reg = )
03758 0E46           E8         F70F            call	_outb
03759 0E49           83C4                   04  add	sp,*4
03760                                           !BCC_EOS
03761                                           ! 1155     if (max==0x0) keyboard_panic(01);
03762                       00000E4C            .A5:
03763                                           ! Debug: list int = const $64 (used reg = )
03764 0E4C           B8                   0064  mov	ax,*$64
03765 0E4F           50                         push	ax
03766                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03767 0E50           E8         F6EF            call	_inb
03768 0E53           44                         inc	sp
03769 0E54           44                         inc	sp
03770                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03771 0E55           24                     01  and	al,*1
03772                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03773 0E57           84C0                       test	al,al
03774 0E59           75           0B            jne 	.A7
03775                       00000E5B            .A8:
03776                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03777 0E5B           8B46         FE            mov	ax,-2[bp]
03778 0E5E           48                         dec	ax
03779 0E5F           8946         FE            mov	-2[bp],ax
03780                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03781 0E62           85C0                       test	ax,ax
03782 0E64           75           D8            jne	.A6
03783                       00000E66            .A7:
03784                       00000E66            .A4:
03785                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03786 0E66           8B46         FE            mov	ax,-2[bp]
03787 0E69           85C0                       test	ax,ax
03788 0E6B           75           09            jne 	.A9
03789                       00000E6D            .AA:
03790                                           ! Debug: list int = const 1 (used reg = )
03791 0E6D           B8                   0001  mov	ax,*1
03792 0E70           50                         push	ax
03793                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03794 0E71           E8         03C8            call	_keyboard_panic
03795 0E74           44                         inc	sp
03796 0E75           44                         inc	sp
03797                                           !BCC_EOS
03798                                           ! 1156     if ((inb(0x60) != 0x55)){
03799                       00000E76            .A9:
03800                                           ! Debug: list int = const $60 (used reg = )
03801 0E76           B8                   0060  mov	ax,*$60
03802 0E79           50                         push	ax
03803                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03804 0E7A           E8         F6C5            call	_inb
03805 0E7D           44                         inc	sp
03806 0E7E           44                         inc	sp
03807                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03808 0E7F           3C                     55  cmp	al,*$55
03809 0E81           74           09            je  	.AB
03810                       00000E83            .AC:
03811                                           ! 1157         keyboard_panic(991);
03812                                           ! Debug: list int = const $3DF (used reg = )
03813 0E83           B8                   03DF  mov	ax,#$3DF
03814 0E86           50                         push	ax
03815                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03816 0E87           E8         03B2            call	_keyboard_panic
03817 0E8A           44                         inc	sp
03818 0E8B           44                         inc	sp
03819                                           !BCC_EOS
03820                                           ! 1158     }
03821                                           ! 1159     outb(0x64,0xab);
03822                       00000E8C            .AB:
03823                                           ! Debug: list int = const $AB (used reg = )
03824 0E8C           B8                   00AB  mov	ax,#$AB
03825 0E8F           50                         push	ax
03826                                           ! Debug: list int = const $64 (used reg = )
03827 0E90           B8                   0064  mov	ax,*$64
03828 0E93           50                         push	ax
03829                                           ! Debug: func () void = outb+0 (used reg = )
03830 0E94           E8         F6C1            call	_outb
03831 0E97           83C4                   04  add	sp,*4
03832                                           !BCC_EOS
03833                                           ! 1160     max=0xffff;
03834                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03835 0E9A           B8                   FFFF  mov	ax,#$FFFF
03836 0E9D           8946         FE            mov	-2[bp],ax
03837                                           !BCC_EOS
03838                                           ! 1161     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03839 0EA0           EB           0E            jmp .AE
03840                       00000EA2            .AF:
03841                                           ! Debug: list int = const $10 (used reg = )
03842 0EA2           B8                   0010  mov	ax,*$10
03843 0EA5           50                         push	ax
03844                                           ! Debug: list int = const $80 (used reg = )
03845 0EA6           B8                   0080  mov	ax,#$80
03846 0EA9           50                         push	ax
03847                                           ! Debug: func () void = outb+0 (used reg = )
03848 0EAA           E8         F6AB            call	_outb
03849 0EAD           83C4                   04  add	sp,*4
03850                                           !BCC_EOS
03851                                           ! 1162     if (max==0x0) keyboard_panic(10);
03852                       00000EB0            .AE:
03853                                           ! Debug: list int = const $64 (used reg = )
03854 0EB0           B8                   0064  mov	ax,*$64
03855 0EB3           50                         push	ax
03856                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03857 0EB4           E8         F68B            call	_inb
03858 0EB7           44                         inc	sp
03859 0EB8           44                         inc	sp
03860                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03861 0EB9           24                     02  and	al,*2
03862 0EBB           84C0                       test	al,al
03863 0EBD           74           0B            je  	.B0
03864                       00000EBF            .B1:
03865                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03866 0EBF           8B46         FE            mov	ax,-2[bp]
03867 0EC2           48                         dec	ax
03868 0EC3           8946         FE            mov	-2[bp],ax
03869                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03870 0EC6           85C0                       test	ax,ax
03871 0EC8           75           D8            jne	.AF
03872                       00000ECA            .B0:
03873                       00000ECA            .AD:
03874                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03875 0ECA           8B46         FE            mov	ax,-2[bp]
03876 0ECD           85C0                       test	ax,ax
03877 0ECF           75           09            jne 	.B2
03878                       00000ED1            .B3:
03879                                           ! Debug: list int = const $A (used reg = )
03880 0ED1           B8                   000A  mov	ax,*$A
03881 0ED4           50                         push	ax
03882                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03883 0ED5           E8         0364            call	_keyboard_panic
03884 0ED8           44                         inc	sp
03885 0ED9           44                         inc	sp
03886                                           !BCC_EOS
03887                                           ! 1163     max=0xffff;
03888                       00000EDA            .B2:
03889                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03890 0EDA           B8                   FFFF  mov	ax,#$FFFF
03891 0EDD           8946         FE            mov	-2[bp],ax
03892                                           !BCC_EOS
03893                                           ! 1164     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
03894 0EE0           EB           0E            jmp .B5
03895                       00000EE2            .B6:
03896                                           ! Debug: list int = const $11 (used reg = )
03897 0EE2           B8                   0011  mov	ax,*$11
03898 0EE5           50                         push	ax
03899                                           ! Debug: list int = const $80 (used reg = )
03900 0EE6           B8                   0080  mov	ax,#$80
03901 0EE9           50                         push	ax
03902                                           ! Debug: func () void = outb+0 (used reg = )
03903 0EEA           E8         F66B            call	_outb
03904 0EED           83C4                   04  add	sp,*4
03905                                           !BCC_EOS
03906                                           ! 1165     if (max==0x0) keyboard_panic(11);
03907                       00000EF0            .B5:
03908                                           ! Debug: list int = const $64 (used reg = )
03909 0EF0           B8                   0064  mov	ax,*$64
03910 0EF3           50                         push	ax
03911                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03912 0EF4           E8         F64B            call	_inb
03913 0EF7           44                         inc	sp
03914 0EF8           44                         inc	sp
03915                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03916 0EF9           24                     01  and	al,*1
03917                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03918 0EFB           84C0                       test	al,al
03919 0EFD           75           0B            jne 	.B7
03920                       00000EFF            .B8:
03921                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03922 0EFF           8B46         FE            mov	ax,-2[bp]
03923 0F02           48                         dec	ax
03924 0F03           8946         FE            mov	-2[bp],ax
03925                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03926 0F06           85C0                       test	ax,ax
03927 0F08           75           D8            jne	.B6
03928                       00000F0A            .B7:
03929                       00000F0A            .B4:
03930                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03931 0F0A           8B46         FE            mov	ax,-2[bp]
03932 0F0D           85C0                       test	ax,ax
03933 0F0F           75           09            jne 	.B9
03934                       00000F11            .BA:
03935                                           ! Debug: list int = const $B (used reg = )
03936 0F11           B8                   000B  mov	ax,*$B
03937 0F14           50                         push	ax
03938                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03939 0F15           E8         0324            call	_keyboard_panic
03940 0F18           44                         inc	sp
03941 0F19           44                         inc	sp
03942                                           !BCC_EOS
03943                                           ! 1166     if ((inb(0x60) != 0x00)) {
03944                       00000F1A            .B9:
03945                                           ! Debug: list int = const $60 (used reg = )
03946 0F1A           B8                   0060  mov	ax,*$60
03947 0F1D           50                         push	ax
03948                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03949 0F1E           E8         F621            call	_inb
03950 0F21           44                         inc	sp
03951 0F22           44                         inc	sp
03952                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03953 0F23           84C0                       test	al,al
03954 0F25           74           09            je  	.BB
03955                       00000F27            .BC:
03956                                           ! 1167         keyboard_panic(992);
03957                                           ! Debug: list int = const $3E0 (used reg = )
03958 0F27           B8                   03E0  mov	ax,#$3E0
03959 0F2A           50                         push	ax
03960                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03961 0F2B           E8         030E            call	_keyboard_panic
03962 0F2E           44                         inc	sp
03963 0F2F           44                         inc	sp
03964                                           !BCC_EOS
03965                                           ! 1168     }
03966                                           ! 1169     outb(0x64,0xae);
03967                       00000F30            .BB:
03968                                           ! Debug: list int = const $AE (used reg = )
03969 0F30           B8                   00AE  mov	ax,#$AE
03970 0F33           50                         push	ax
03971                                           ! Debug: list int = const $64 (used reg = )
03972 0F34           B8                   0064  mov	ax,*$64
03973 0F37           50                         push	ax
03974                                           ! Debug: func () void = outb+0 (used reg = )
03975 0F38           E8         F61D            call	_outb
03976 0F3B           83C4                   04  add	sp,*4
03977                                           !BCC_EOS
03978                                           ! 1170     outb(0x64,0xa8);
03979                                           ! Debug: list int = const $A8 (used reg = )
03980 0F3E           B8                   00A8  mov	ax,#$A8
03981 0F41           50                         push	ax
03982                                           ! Debug: list int = const $64 (used reg = )
03983 0F42           B8                   0064  mov	ax,*$64
03984 0F45           50                         push	ax
03985                                           ! Debug: func () void = outb+0 (used reg = )
03986 0F46           E8         F60F            call	_outb
03987 0F49           83C4                   04  add	sp,*4
03988                                           !BCC_EOS
03989                                           ! 1171     outb(0x60, 0xff);
03990                                           ! Debug: list int = const $FF (used reg = )
03991 0F4C           B8                   00FF  mov	ax,#$FF
03992 0F4F           50                         push	ax
03993                                           ! Debug: list int = const $60 (used reg = )
03994 0F50           B8                   0060  mov	ax,*$60
03995 0F53           50                         push	ax
03996                                           ! Debug: func () void = outb+0 (used reg = )
03997 0F54           E8         F601            call	_outb
03998 0F57           83C4                   04  add	sp,*4
03999                                           !BCC_EOS
04000                                           ! 1172     max=0xffff;
04001                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04002 0F5A           B8                   FFFF  mov	ax,#$FFFF
04003 0F5D           8946         FE            mov	-2[bp],ax
04004                                           !BCC_EOS
04005                                           ! 1173     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
04006 0F60           EB           0E            jmp .BE
04007                       00000F62            .BF:
04008                                           ! Debug: list int = const $20 (used reg = )
04009 0F62           B8                   0020  mov	ax,*$20
04010 0F65           50                         push	ax
04011                                           ! Debug: list int = const $80 (used reg = )
04012 0F66           B8                   0080  mov	ax,#$80
04013 0F69           50                         push	ax
04014                                           ! Debug: func () void = outb+0 (used reg = )
04015 0F6A           E8         F5EB            call	_outb
04016 0F6D           83C4                   04  add	sp,*4
04017                                           !BCC_EOS
04018                                           ! 1174     if (max==0x0) keyboard_panic(20);
04019                       00000F70            .BE:
04020                                           ! Debug: list int = const $64 (used reg = )
04021 0F70           B8                   0064  mov	ax,*$64
04022 0F73           50                         push	ax
04023                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04024 0F74           E8         F5CB            call	_inb
04025 0F77           44                         inc	sp
04026 0F78           44                         inc	sp
04027                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04028 0F79           24                     02  and	al,*2
04029 0F7B           84C0                       test	al,al
04030 0F7D           74           0B            je  	.C0
04031                       00000F7F            .C1:
04032                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04033 0F7F           8B46         FE            mov	ax,-2[bp]
04034 0F82           48                         dec	ax
04035 0F83           8946         FE            mov	-2[bp],ax
04036                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04037 0F86           85C0                       test	ax,ax
04038 0F88           75           D8            jne	.BF
04039                       00000F8A            .C0:
04040                       00000F8A            .BD:
04041                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04042 0F8A           8B46         FE            mov	ax,-2[bp]
04043 0F8D           85C0                       test	ax,ax
04044 0F8F           75           09            jne 	.C2
04045                       00000F91            .C3:
04046                                           ! Debug: list int = const $14 (used reg = )
04047 0F91           B8                   0014  mov	ax,*$14
04048 0F94           50                         push	ax
04049                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04050 0F95           E8         02A4            call	_keyboard_panic
04051 0F98           44                         inc	sp
04052 0F99           44                         inc	sp
04053                                           !BCC_EOS
04054                                           ! 1175     max=0xffff;
04055                       00000F9A            .C2:
04056                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04057 0F9A           B8                   FFFF  mov	ax,#$FFFF
04058 0F9D           8946         FE            mov	-2[bp],ax
04059                                           !BCC_EOS
04060                                           ! 1176     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04061 0FA0           EB           0E            jmp .C5
04062                       00000FA2            .C6:
04063                                           ! Debug: list int = const $21 (used reg = )
04064 0FA2           B8                   0021  mov	ax,*$21
04065 0FA5           50                         push	ax
04066                                           ! Debug: list int = const $80 (used reg = )
04067 0FA6           B8                   0080  mov	ax,#$80
04068 0FA9           50                         push	ax
04069                                           ! Debug: func () void = outb+0 (used reg = )
04070 0FAA           E8         F5AB            call	_outb
04071 0FAD           83C4                   04  add	sp,*4
04072                                           !BCC_EOS
04073                                           ! 1177     if (max==0x0) keyboard_panic(21);
04074                       00000FB0            .C5:
04075                                           ! Debug: list int = const $64 (used reg = )
04076 0FB0           B8                   0064  mov	ax,*$64
04077 0FB3           50                         push	ax
04078                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04079 0FB4           E8         F58B            call	_inb
04080 0FB7           44                         inc	sp
04081 0FB8           44                         inc	sp
04082                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04083 0FB9           24                     01  and	al,*1
04084                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04085 0FBB           84C0                       test	al,al
04086 0FBD           75           0B            jne 	.C7
04087                       00000FBF            .C8:
04088                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04089 0FBF           8B46         FE            mov	ax,-2[bp]
04090 0FC2           48                         dec	ax
04091 0FC3           8946         FE            mov	-2[bp],ax
04092                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04093 0FC6           85C0                       test	ax,ax
04094 0FC8           75           D8            jne	.C6
04095                       00000FCA            .C7:
04096                       00000FCA            .C4:
04097                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04098 0FCA           8B46         FE            mov	ax,-2[bp]
04099 0FCD           85C0                       test	ax,ax
04100 0FCF           75           09            jne 	.C9
04101                       00000FD1            .CA:
04102                                           ! Debug: list int = const $15 (used reg = )
04103 0FD1           B8                   0015  mov	ax,*$15
04104 0FD4           50                         push	ax
04105                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04106 0FD5           E8         0264            call	_keyboard_panic
04107 0FD8           44                         inc	sp
04108 0FD9           44                         inc	sp
04109                                           !BCC_EOS
04110                                           ! 1178     if ((inb(0x60) != 0xfa)) {
04111                       00000FDA            .C9:
04112                                           ! Debug: list int = const $60 (used reg = )
04113 0FDA           B8                   0060  mov	ax,*$60
04114 0FDD           50                         push	ax
04115                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04116 0FDE           E8         F561            call	_inb
04117 0FE1           44                         inc	sp
04118 0FE2           44                         inc	sp
04119                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04120 0FE3           3C                     FA  cmp	al,#$FA
04121 0FE5           74           09            je  	.CB
04122                       00000FE7            .CC:
04123                                           ! 1179         keyboard_panic(993);
04124                                           ! Debug: list int = const $3E1 (used reg = )
04125 0FE7           B8                   03E1  mov	ax,#$3E1
04126 0FEA           50                         push	ax
04127                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04128 0FEB           E8         024E            call	_keyboard_panic
04129 0FEE           44                         inc	sp
04130 0FEF           44                         inc	sp
04131                                           !BCC_EOS
04132                                           ! 1180     }
04133                                           ! 1181     max=0xffff;
04134                       00000FF0            .CB:
04135                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04136 0FF0           B8                   FFFF  mov	ax,#$FFFF
04137 0FF3           8946         FE            mov	-2[bp],ax
04138                                           !BCC_EOS
04139                                           ! 1182     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04140 0FF6           EB           0E            jmp .CE
04141                       00000FF8            .CF:
04142                                           ! Debug: list int = const $31 (used reg = )
04143 0FF8           B8                   0031  mov	ax,*$31
04144 0FFB           50                         push	ax
04145                                           ! Debug: list int = const $80 (used reg = )
04146 0FFC           B8                   0080  mov	ax,#$80
04147 0FFF           50                         push	ax
04148                                           ! Debug: func () void = outb+0 (used reg = )
04149 1000           E8         F555            call	_outb
04150 1003           83C4                   04  add	sp,*4
04151                                           !BCC_EOS
04152                                           ! 1183     if (max==0x0) keyboard_panic(31);
04153                       00001006            .CE:
04154                                           ! Debug: list int = const $64 (used reg = )
04155 1006           B8                   0064  mov	ax,*$64
04156 1009           50                         push	ax
04157                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04158 100A           E8         F535            call	_inb
04159 100D           44                         inc	sp
04160 100E           44                         inc	sp
04161                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04162 100F           24                     01  and	al,*1
04163                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04164 1011           84C0                       test	al,al
04165 1013           75           0B            jne 	.D0
04166                       00001015            .D1:
04167                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04168 1015           8B46         FE            mov	ax,-2[bp]
04169 1018           48                         dec	ax
04170 1019           8946         FE            mov	-2[bp],ax
04171                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04172 101C           85C0                       test	ax,ax
04173 101E           75           D8            jne	.CF
04174                       00001020            .D0:
04175                       00001020            .CD:
04176                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04177 1020           8B46         FE            mov	ax,-2[bp]
04178 1023           85C0                       test	ax,ax
04179 1025           75           09            jne 	.D2
04180                       00001027            .D3:
04181                                           ! Debug: list int = const $1F (used reg = )
04182 1027           B8                   001F  mov	ax,*$1F
04183 102A           50                         push	ax
04184                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04185 102B           E8         020E            call	_keyboard_panic
04186 102E           44                         inc	sp
04187 102F           44                         inc	sp
04188                                           !BCC_EOS
04189                                           ! 1184     if ((inb(0x60) != 0xaa)) {
04190                       00001030            .D2:
04191                                           ! Debug: list int = const $60 (used reg = )
04192 1030           B8                   0060  mov	ax,*$60
04193 1033           50                         push	ax
04194                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04195 1034           E8         F50B            call	_inb
04196 1037           44                         inc	sp
04197 1038           44                         inc	sp
04198                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04199 1039           3C                     AA  cmp	al,#$AA
04200 103B           74           09            je  	.D4
04201                       0000103D            .D5:
04202                                           ! 1185         keyboard_panic(994);
04203                                           ! Debug: list int = const $3E2 (used reg = )
04204 103D           B8                   03E2  mov	ax,#$3E2
04205 1040           50                         push	ax
04206                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04207 1041           E8         01F8            call	_keyboard_panic
04208 1044           44                         inc	sp
04209 1045           44                         inc	sp
04210                                           !BCC_EOS
04211                                           ! 1186     }
04212                                           ! 1187     outb(0x60, 0xf5);
04213                       00001046            .D4:
04214                                           ! Debug: list int = const $F5 (used reg = )
04215 1046           B8                   00F5  mov	ax,#$F5
04216 1049           50                         push	ax
04217                                           ! Debug: list int = const $60 (used reg = )
04218 104A           B8                   0060  mov	ax,*$60
04219 104D           50                         push	ax
04220                                           ! Debug: func () void = outb+0 (used reg = )
04221 104E           E8         F507            call	_outb
04222 1051           83C4                   04  add	sp,*4
04223                                           !BCC_EOS
04224                                           ! 1188     max=0xffff;
04225                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04226 1054           B8                   FFFF  mov	ax,#$FFFF
04227 1057           8946         FE            mov	-2[bp],ax
04228                                           !BCC_EOS
04229                                           ! 1189     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04230 105A           EB           0E            jmp .D7
04231                       0000105C            .D8:
04232                                           ! Debug: list int = const $40 (used reg = )
04233 105C           B8                   0040  mov	ax,*$40
04234 105F           50                         push	ax
04235                                           ! Debug: list int = const $80 (used reg = )
04236 1060           B8                   0080  mov	ax,#$80
04237 1063           50                         push	ax
04238                                           ! Debug: func () void = outb+0 (used reg = )
04239 1064           E8         F4F1            call	_outb
04240 1067           83C4                   04  add	sp,*4
04241                                           !BCC_EOS
04242                                           ! 1190     if (max==0x0) keyboard_panic(40);
04243                       0000106A            .D7:
04244                                           ! Debug: list int = const $64 (used reg = )
04245 106A           B8                   0064  mov	ax,*$64
04246 106D           50                         push	ax
04247                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04248 106E           E8         F4D1            call	_inb
04249 1071           44                         inc	sp
04250 1072           44                         inc	sp
04251                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04252 1073           24                     02  and	al,*2
04253 1075           84C0                       test	al,al
04254 1077           74           0B            je  	.D9
04255                       00001079            .DA:
04256                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04257 1079           8B46         FE            mov	ax,-2[bp]
04258 107C           48                         dec	ax
04259 107D           8946         FE            mov	-2[bp],ax
04260                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04261 1080           85C0                       test	ax,ax
04262 1082           75           D8            jne	.D8
04263                       00001084            .D9:
04264                       00001084            .D6:
04265                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04266 1084           8B46         FE            mov	ax,-2[bp]
04267 1087           85C0                       test	ax,ax
04268 1089           75           09            jne 	.DB
04269                       0000108B            .DC:
04270                                           ! Debug: list int = const $28 (used reg = )
04271 108B           B8                   0028  mov	ax,*$28
04272 108E           50                         push	ax
04273                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04274 108F           E8         01AA            call	_keyboard_panic
04275 1092           44                         inc	sp
04276 1093           44                         inc	sp
04277                                           !BCC_EOS
04278                                           ! 1191     max=0xffff;
04279                       00001094            .DB:
04280                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04281 1094           B8                   FFFF  mov	ax,#$FFFF
04282 1097           8946         FE            mov	-2[bp],ax
04283                                           !BCC_EOS
04284                                           ! 1192     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04285 109A           EB           0E            jmp .DE
04286                       0000109C            .DF:
04287                                           ! Debug: list int = const $41 (used reg = )
04288 109C           B8                   0041  mov	ax,*$41
04289 109F           50                         push	ax
04290                                           ! Debug: list int = const $80 (used reg = )
04291 10A0           B8                   0080  mov	ax,#$80
04292 10A3           50                         push	ax
04293                                           ! Debug: func () void = outb+0 (used reg = )
04294 10A4           E8         F4B1            call	_outb
04295 10A7           83C4                   04  add	sp,*4
04296                                           !BCC_EOS
04297                                           ! 1193     if (max==0x0) keyboard_panic(41);
04298                       000010AA            .DE:
04299                                           ! Debug: list int = const $64 (used reg = )
04300 10AA           B8                   0064  mov	ax,*$64
04301 10AD           50                         push	ax
04302                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04303 10AE           E8         F491            call	_inb
04304 10B1           44                         inc	sp
04305 10B2           44                         inc	sp
04306                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04307 10B3           24                     01  and	al,*1
04308                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04309 10B5           84C0                       test	al,al
04310 10B7           75           0B            jne 	.E0
04311                       000010B9            .E1:
04312                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04313 10B9           8B46         FE            mov	ax,-2[bp]
04314 10BC           48                         dec	ax
04315 10BD           8946         FE            mov	-2[bp],ax
04316                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04317 10C0           85C0                       test	ax,ax
04318 10C2           75           D8            jne	.DF
04319                       000010C4            .E0:
04320                       000010C4            .DD:
04321                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04322 10C4           8B46         FE            mov	ax,-2[bp]
04323 10C7           85C0                       test	ax,ax
04324 10C9           75           09            jne 	.E2
04325                       000010CB            .E3:
04326                                           ! Debug: list int = const $29 (used reg = )
04327 10CB           B8                   0029  mov	ax,*$29
04328 10CE           50                         push	ax
04329                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04330 10CF           E8         016A            call	_keyboard_panic
04331 10D2           44                         inc	sp
04332 10D3           44                         inc	sp
04333                                           !BCC_EOS
04334                                           ! 1194     if ((inb(0x60) != 0xfa)) {
04335                       000010D4            .E2:
04336                                           ! Debug: list int = const $60 (used reg = )
04337 10D4           B8                   0060  mov	ax,*$60
04338 10D7           50                         push	ax
04339                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04340 10D8           E8         F467            call	_inb
04341 10DB           44                         inc	sp
04342 10DC           44                         inc	sp
04343                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04344 10DD           3C                     FA  cmp	al,#$FA
04345 10DF           74           09            je  	.E4
04346                       000010E1            .E5:
04347                                           ! 1195         keyboard_panic(995);
04348                                           ! Debug: list int = const $3E3 (used reg = )
04349 10E1           B8                   03E3  mov	ax,#$3E3
04350 10E4           50                         push	ax
04351                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04352 10E5           E8         0154            call	_keyboard_panic
04353 10E8           44                         inc	sp
04354 10E9           44                         inc	sp
04355                                           !BCC_EOS
04356                                           ! 1196     }
04357                                           ! 1197     outb(0x64, 0x60);
04358                       000010EA            .E4:
04359                                           ! Debug: list int = const $60 (used reg = )
04360 10EA           B8                   0060  mov	ax,*$60
04361 10ED           50                         push	ax
04362                                           ! Debug: list int = const $64 (used reg = )
04363 10EE           B8                   0064  mov	ax,*$64
04364 10F1           50                         push	ax
04365                                           ! Debug: func () void = outb+0 (used reg = )
04366 10F2           E8         F463            call	_outb
04367 10F5           83C4                   04  add	sp,*4
04368                                           !BCC_EOS
04369                                           ! 1198     max=0xffff;
04370                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04371 10F8           B8                   FFFF  mov	ax,#$FFFF
04372 10FB           8946         FE            mov	-2[bp],ax
04373                                           !BCC_EOS
04374                                           ! 1199     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04375 10FE           EB           0E            jmp .E7
04376                       00001100            .E8:
04377                                           ! Debug: list int = const $50 (used reg = )
04378 1100           B8                   0050  mov	ax,*$50
04379 1103           50                         push	ax
04380                                           ! Debug: list int = const $80 (used reg = )
04381 1104           B8                   0080  mov	ax,#$80
04382 1107           50                         push	ax
04383                                           ! Debug: func () void = outb+0 (used reg = )
04384 1108           E8         F44D            call	_outb
04385 110B           83C4                   04  add	sp,*4
04386                                           !BCC_EOS
04387                                           ! 1200     if (max==0x0) keyboard_panic(50);
04388                       0000110E            .E7:
04389                                           ! Debug: list int = const $64 (used reg = )
04390 110E           B8                   0064  mov	ax,*$64
04391 1111           50                         push	ax
04392                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04393 1112           E8         F42D            call	_inb
04394 1115           44                         inc	sp
04395 1116           44                         inc	sp
04396                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04397 1117           24                     02  and	al,*2
04398 1119           84C0                       test	al,al
04399 111B           74           0B            je  	.E9
04400                       0000111D            .EA:
04401                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04402 111D           8B46         FE            mov	ax,-2[bp]
04403 1120           48                         dec	ax
04404 1121           8946         FE            mov	-2[bp],ax
04405                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04406 1124           85C0                       test	ax,ax
04407 1126           75           D8            jne	.E8
04408                       00001128            .E9:
04409                       00001128            .E6:
04410                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04411 1128           8B46         FE            mov	ax,-2[bp]
04412 112B           85C0                       test	ax,ax
04413 112D           75           09            jne 	.EB
04414                       0000112F            .EC:
04415                                           ! Debug: list int = const $32 (used reg = )
04416 112F           B8                   0032  mov	ax,*$32
04417 1132           50                         push	ax
04418                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04419 1133           E8         0106            call	_keyboard_panic
04420 1136           44                         inc	sp
04421 1137           44                         inc	sp
04422                                           !BCC_EOS
04423                                           ! 1201 
04424                                           ! 1201     outb(0x60, 0x61);
04425                       00001138            .EB:
04426                                           ! Debug: list int = const $61 (used reg = )
04427 1138           B8                   0061  mov	ax,*$61
04428 113B           50                         push	ax
04429                                           ! Debug: list int = const $60 (used reg = )
04430 113C           B8                   0060  mov	ax,*$60
04431 113F           50                         push	ax
04432                                           ! Debug: func () void = outb+0 (used reg = )
04433 1140           E8         F415            call	_outb
04434 1143           83C4                   04  add	sp,*4
04435                                           !BCC_EOS
04436                                           ! 1202     max=0xffff;
04437                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04438 1146           B8                   FFFF  mov	ax,#$FFFF
04439 1149           8946         FE            mov	-2[bp],ax
04440                                           !BCC_EOS
04441                                           ! 1203     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04442 114C           EB           0E            jmp .EE
04443                       0000114E            .EF:
04444                                           ! Debug: list int = const $60 (used reg = )
04445 114E           B8                   0060  mov	ax,*$60
04446 1151           50                         push	ax
04447                                           ! Debug: list int = const $80 (used reg = )
04448 1152           B8                   0080  mov	ax,#$80
04449 1155           50                         push	ax
04450                                           ! Debug: func () void = outb+0 (used reg = )
04451 1156           E8         F3FF            call	_outb
04452 1159           83C4                   04  add	sp,*4
04453                                           !BCC_EOS
04454                                           ! 1204     if (max==0x0) keyboard_panic(60);
04455                       0000115C            .EE:
04456                                           ! Debug: list int = const $64 (used reg = )
04457 115C           B8                   0064  mov	ax,*$64
04458 115F           50                         push	ax
04459                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04460 1160           E8         F3DF            call	_inb
04461 1163           44                         inc	sp
04462 1164           44                         inc	sp
04463                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04464 1165           24                     02  and	al,*2
04465 1167           84C0                       test	al,al
04466 1169           74           0B            je  	.F0
04467                       0000116B            .F1:
04468                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04469 116B           8B46         FE            mov	ax,-2[bp]
04470 116E           48                         dec	ax
04471 116F           8946         FE            mov	-2[bp],ax
04472                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04473 1172           85C0                       test	ax,ax
04474 1174           75           D8            jne	.EF
04475                       00001176            .F0:
04476                       00001176            .ED:
04477                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04478 1176           8B46         FE            mov	ax,-2[bp]
04479 1179           85C0                       test	ax,ax
04480 117B           75           09            jne 	.F2
04481                       0000117D            .F3:
04482                                           ! Debug: list int = const $3C (used reg = )
04483 117D           B8                   003C  mov	ax,*$3C
04484 1180           50                         push	ax
04485                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04486 1181           E8         00B8            call	_keyboard_panic
04487 1184           44                         inc	sp
04488 1185           44                         inc	sp
04489                                           !BCC_EOS
04490                                           ! 1205     outb(0x60, 0xf4);
04491                       00001186            .F2:
04492                                           ! Debug: list int = const $F4 (used reg = )
04493 1186           B8                   00F4  mov	ax,#$F4
04494 1189           50                         push	ax
04495                                           ! Debug: list int = const $60 (used reg = )
04496 118A           B8                   0060  mov	ax,*$60
04497 118D           50                         push	ax
04498                                           ! Debug: func () void = outb+0 (used reg = )
04499 118E           E8         F3C7            call	_outb
04500 1191           83C4                   04  add	sp,*4
04501                                           !BCC_EOS
04502                                           ! 1206     max=0xffff;
04503                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04504 1194           B8                   FFFF  mov	ax,#$FFFF
04505 1197           8946         FE            mov	-2[bp],ax
04506                                           !BCC_EOS
04507                                           ! 1207     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04508 119A           EB           0E            jmp .F5
04509                       0000119C            .F6:
04510                                           ! Debug: list int = const $70 (used reg = )
04511 119C           B8                   0070  mov	ax,*$70
04512 119F           50                         push	ax
04513                                           ! Debug: list int = const $80 (used reg = )
04514 11A0           B8                   0080  mov	ax,#$80
04515 11A3           50                         push	ax
04516                                           ! Debug: func () void = outb+0 (used reg = )
04517 11A4           E8         F3B1            call	_outb
04518 11A7           83C4                   04  add	sp,*4
04519                                           !BCC_EOS
04520                                           ! 1208     if (max==0x0) keyboard_panic(70);
04521                       000011AA            .F5:
04522                                           ! Debug: list int = const $64 (used reg = )
04523 11AA           B8                   0064  mov	ax,*$64
04524 11AD           50                         push	ax
04525                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04526 11AE           E8         F391            call	_inb
04527 11B1           44                         inc	sp
04528 11B2           44                         inc	sp
04529                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04530 11B3           24                     02  and	al,*2
04531 11B5           84C0                       test	al,al
04532 11B7           74           0B            je  	.F7
04533                       000011B9            .F8:
04534                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04535 11B9           8B46         FE            mov	ax,-2[bp]
04536 11BC           48                         dec	ax
04537 11BD           8946         FE            mov	-2[bp],ax
04538                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04539 11C0           85C0                       test	ax,ax
04540 11C2           75           D8            jne	.F6
04541                       000011C4            .F7:
04542                       000011C4            .F4:
04543                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04544 11C4           8B46         FE            mov	ax,-2[bp]
04545 11C7           85C0                       test	ax,ax
04546 11C9           75           09            jne 	.F9
04547                       000011CB            .FA:
04548                                           ! Debug: list int = const $46 (used reg = )
04549 11CB           B8                   0046  mov	ax,*$46
04550 11CE           50                         push	ax
04551                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04552 11CF           E8         006A            call	_keyboard_panic
04553 11D2           44                         inc	sp
04554 11D3           44                         inc	sp
04555                                           !BCC_EOS
04556                                           ! 1209     max=0xffff;
04557                       000011D4            .F9:
04558                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04559 11D4           B8                   FFFF  mov	ax,#$FFFF
04560 11D7           8946         FE            mov	-2[bp],ax
04561                                           !BCC_EOS
04562                                           ! 1210     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04563 11DA           EB           0E            jmp .FC
04564                       000011DC            .FD:
04565                                           ! Debug: list int = const $71 (used reg = )
04566 11DC           B8                   0071  mov	ax,*$71
04567 11DF           50                         push	ax
04568                                           ! Debug: list int = const $80 (used reg = )
04569 11E0           B8                   0080  mov	ax,#$80
04570 11E3           50                         push	ax
04571                                           ! Debug: func () void = outb+0 (used reg = )
04572 11E4           E8         F371            call	_outb
04573 11E7           83C4                   04  add	sp,*4
04574                                           !BCC_EOS
04575                                           ! 1211     if (max==0x0) keyboard_panic(70);
04576                       000011EA            .FC:
04577                                           ! Debug: list int = const $64 (used reg = )
04578 11EA           B8                   0064  mov	ax,*$64
04579 11ED           50                         push	ax
04580                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04581 11EE           E8         F351            call	_inb
04582 11F1           44                         inc	sp
04583 11F2           44                         inc	sp
04584                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04585 11F3           24                     01  and	al,*1
04586                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04587 11F5           84C0                       test	al,al
04588 11F7           75           0B            jne 	.FE
04589                       000011F9            .FF:
04590                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04591 11F9           8B46         FE            mov	ax,-2[bp]
04592 11FC           48                         dec	ax
04593 11FD           8946         FE            mov	-2[bp],ax
04594                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04595 1200           85C0                       test	ax,ax
04596 1202           75           D8            jne	.FD
04597                       00001204            .FE:
04598                       00001204            .FB:
04599                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04600 1204           8B46         FE            mov	ax,-2[bp]
04601 1207           85C0                       test	ax,ax
04602 1209           75           09            jne 	.100
04603                       0000120B            .101:
04604                                           ! Debug: list int = const $46 (used reg = )
04605 120B           B8                   0046  mov	ax,*$46
04606 120E           50                         push	ax
04607                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04608 120F           E8         002A            call	_keyboard_panic
04609 1212           44                         inc	sp
04610 1213           44                         inc	sp
04611                                           !BCC_EOS
04612                                           ! 1212     if ((inb(0x60) != 0xfa)) {
04613                       00001214            .100:
04614                                           ! Debug: list int = const $60 (used reg = )
04615 1214           B8                   0060  mov	ax,*$60
04616 1217           50                         push	ax
04617                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04618 1218           E8         F327            call	_inb
04619 121B           44                         inc	sp
04620 121C           44                         inc	sp
04621                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04622 121D           3C                     FA  cmp	al,#$FA
04623 121F           74           09            je  	.102
04624                       00001221            .103:
04625                                           ! 1213         keyboard_panic(996);
04626                                           ! Debug: list int = const $3E4 (used reg = )
04627 1221           B8                   03E4  mov	ax,#$3E4
04628 1224           50                         push	ax
04629                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04630 1225           E8         0014            call	_keyboard_panic
04631 1228           44                         inc	sp
04632 1229           44                         inc	sp
04633                                           !BCC_EOS
04634                                           ! 1214     }
04635                                           ! 1215     outb(0x80, 0x77);
04636                       0000122A            .102:
04637                                           ! Debug: list int = const $77 (used reg = )
04638 122A           B8                   0077  mov	ax,*$77
04639 122D           50                         push	ax
04640                                           ! Debug: list int = const $80 (used reg = )
04641 122E           B8                   0080  mov	ax,#$80
04642 1231           50                         push	ax
04643                                           ! Debug: func () void = outb+0 (used reg = )
04644 1232           E8         F323            call	_outb
04645 1235           83C4                   04  add	sp,*4
04646                                           !BCC_EOS
04647                                           ! 1216 }
04648 1238           89EC                       mov	sp,bp
04649 123A           5D                         pop	bp
04650 123B           C3                         ret
04651                                           ! 1217   void
04652                                           ! 1218 keyboard_panic(status)
04653                                           ! 1219   Bit16u status;
04654                                           export	_keyboard_panic
04655                       0000123C            _keyboard_panic:
04656                                           !BCC_EOS
04657                                           ! 1220 {
04658                                           ! 1221   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04659 123C           55                         push	bp
04660 123D           89E5                       mov	bp,sp
04661                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04662 123F           FF76         04            push	4[bp]
04663                                           ! Debug: list * char = .104+0 (used reg = )
04664 1242           BB                   D9CF  mov	bx,#.104
04665 1245           53                         push	bx
04666                                           ! Debug: list int = const 7 (used reg = )
04667 1246           B8                   0007  mov	ax,*7
04668 1249           50                         push	ax
04669                                           ! Debug: func () void = bios_printf+0 (used reg = )
04670 124A           E8         F75A            call	_bios_printf
04671 124D           89EC                       mov	sp,bp
04672                                           !BCC_EOS
04673                                           ! 1222 }
04674 124F           5D                         pop	bp
04675 1250           C3                         ret
04676                                           ! 1223   void
04677                                           ! Register BX used in function keyboard_panic
04678                                           ! 1224 shutdown_status_panic(status)
04679                                           ! 1225   Bit16u status;
04680                                           export	_shutdown_status_panic
04681                       00001251            _shutdown_status_panic:
04682                                           !BCC_EOS
04683                                           ! 1226 {
04684                                           ! 1227   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04685 1251           55                         push	bp
04686 1252           89E5                       mov	bp,sp
04687                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04688 1254           8A46         04            mov	al,4[bp]
04689 1257           30E4                       xor	ah,ah
04690 1259           50                         push	ax
04691                                           ! Debug: list * char = .105+0 (used reg = )
04692 125A           BB                   D9AA  mov	bx,#.105
04693 125D           53                         push	bx
04694                                           ! Debug: list int = const 7 (used reg = )
04695 125E           B8                   0007  mov	ax,*7
04696 1261           50                         push	ax
04697                                           ! Debug: func () void = bios_printf+0 (used reg = )
04698 1262           E8         F742            call	_bios_printf
04699 1265           89EC                       mov	sp,bp
04700                                           !BCC_EOS
04701                                           ! 1228 }
04702 1267           5D                         pop	bp
04703 1268           C3                         ret
04704                                           ! 1229 void s3_resume_panic()
04705                                           ! Register BX used in function shutdown_status_panic
04706                                           ! 1230 {
04707                                           export	_s3_resume_panic
04708                       00001269            _s3_resume_panic:
04709                                           ! 1231   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04710 1269           55                         push	bp
04711 126A           89E5                       mov	bp,sp
04712                                           ! Debug: list * char = .106+0 (used reg = )
04713 126C           BB                   D990  mov	bx,#.106
04714 126F           53                         push	bx
04715                                           ! Debug: list int = const 7 (used reg = )
04716 1270           B8                   0007  mov	ax,*7
04717 1273           50                         push	ax
04718                                           ! Debug: func () void = bios_printf+0 (used reg = )
04719 1274           E8         F730            call	_bios_printf
04720 1277           89EC                       mov	sp,bp
04721                                           !BCC_EOS
04722                                           ! 1232 }
04723 1279           5D                         pop	bp
04724 127A           C3                         ret
04725                                           ! 1233 void
04726                                           ! Register BX used in function s3_resume_panic
04727                                           ! 1234 print_bios_banner()
04728                                           ! 1235 {
04729                                           export	_print_bios_banner
04730                       0000127B            _print_bios_banner:
04731                                           ! 1236   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "10/11/09", bios_cvs_version_string);
04732 127B           55                         push	bp
04733 127C           89E5                       mov	bp,sp
04734                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04735 127E           BB                   0194  mov	bx,#_bios_cvs_version_string
04736 1281           53                         push	bx
04737                                           ! Debug: list * char = .108+0 (used reg = )
04738 1282           BB                   D963  mov	bx,#.108
04739 1285           53                         push	bx
04740                                           ! Debug: list * char = .107+0 (used reg = )
04741 1286           BB                   D96C  mov	bx,#.107
04742 1289           53                         push	bx
04743                                           ! Debug: list int = const 2 (used reg = )
04744 128A           B8                   0002  mov	ax,*2
04745 128D           50                         push	ax
04746                                           ! Debug: func () void = bios_printf+0 (used reg = )
04747 128E           E8         F716            call	_bios_printf
04748 1291           89EC                       mov	sp,bp
04749                                           !BCC_EOS
04750                                           ! 1237   bios_printf(2, "apmbios " "pcibios " "eltorito " "rombios32 " "\n\n");
04751                                           ! Debug: list * char = .109+0 (used reg = )
04752 1293           BB                   D93D  mov	bx,#.109
04753 1296           53                         push	bx
04754                                           ! Debug: list int = const 2 (used reg = )
04755 1297           B8                   0002  mov	ax,*2
04756 129A           50                         push	ax
04757                                           ! Debug: func () void = bios_printf+0 (used reg = )
04758 129B           E8         F709            call	_bios_printf
04759 129E           89EC                       mov	sp,bp
04760                                           !BCC_EOS
04761                                           ! 1238 }
04762 12A0           5D                         pop	bp
04763 12A1           C3                         ret
04764                                           ! 1239 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04765                                           ! Register BX used in function print_bios_banner
04766                                           
04767                       000012A2            _drivetypes:
04768                       000012A2            .10A:
04769 12A2                        00            .byte	0
04770 12A3                  00000009            .blkb	9
04771                       000012AC            .10B:
04772 12AC                        46            .ascii	"Floppy"
04773 12B2                        00            .byte	0
04774 12B3                  00000003            .blkb	3
04775                       000012B6            .10C:
04776 12B6                        48            .ascii	"Hard Disk"
04777 12BF                        00            .byte	0
04778                       000012C0            .10D:
04779 12C0                        43            .ascii	"CD-Rom"
04780 12C6                        00            .byte	0
04781 12C7                  00000003            .blkb	3
04782                       000012CA            .10E:
04783 12CA                        4E            .ascii	"Network"
04784 12D1                        00            .byte	0
04785 12D2                  00000002            .blkb	2
04786                                           !BCC_EOS
04787                                           ! 1240 static void
04788                                           ! 1241 init_boot_vectors()
04789                                           ! 1242 {
04790                                           
04791                       000012D4            _init_boot_vectors:
04792                                           ! 1243   ipl_entry_t e;
04793                                           !BCC_EOS
04794                                           ! 1244   Bit16u count = 0;
04795 12D4           55                         push	bp
04796 12D5           89E5                       mov	bp,sp
04797 12D7           83C4                   EE  add	sp,*-$12
04798                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04799 12DA           31C0                       xor	ax,ax
04800 12DC           8946         EE            mov	-$12[bp],ax
04801                                           !BCC_EOS
04802                                           ! 1245   Bit16u ss = get_SS();
04803 12DF           4C                         dec	sp
04804 12E0           4C                         dec	sp
04805                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04806 12E1           E8         F36D            call	_get_SS
04807                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04808 12E4           8946         EC            mov	-$14[bp],ax
04809                                           !BCC_EOS
04810                                           ! 1246   memsetb(0x9ff0, 0x0000, 0, 0xff);
04811                                           ! Debug: list int = const $FF (used reg = )
04812 12E7           B8                   00FF  mov	ax,#$FF
04813 12EA           50                         push	ax
04814                                           ! Debug: list int = const 0 (used reg = )
04815 12EB           31C0                       xor	ax,ax
04816 12ED           50                         push	ax
04817                                           ! Debug: list int = const 0 (used reg = )
04818 12EE           31C0                       xor	ax,ax
04819 12F0           50                         push	ax
04820                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04821 12F1           B8                   9FF0  mov	ax,#$9FF0
04822 12F4           50                         push	ax
04823                                           ! Debug: func () void = memsetb+0 (used reg = )
04824 12F5           E8         ED08            call	_memsetb
04825 12F8           83C4                   08  add	sp,*8
04826                                           !BCC_EOS
04827                                           ! 1247   write_word(0x9ff0, 0x0084, 0xFFFF);
04828                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04829 12FB           B8                   FFFF  mov	ax,#$FFFF
04830 12FE           50                         push	ax
04831                                           ! Debug: list int = const $84 (used reg = )
04832 12FF           B8                   0084  mov	ax,#$84
04833 1302           50                         push	ax
04834                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04835 1303           B8                   9FF0  mov	ax,#$9FF0
04836 1306           50                         push	ax
04837                                           ! Debug: func () void = write_word+0 (used reg = )
04838 1307           E8         F32C            call	_write_word
04839 130A           83C4                   06  add	sp,*6
04840                                           !BCC_EOS
04841                                           ! 1248   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04842                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04843 130D           B8                   0001  mov	ax,*1
04844 1310           8946         F0            mov	-$10[bp],ax
04845                                           !BCC_EOS
04846                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04847 1313           31C0                       xor	ax,ax
04848 1315           8946         F2            mov	-$E[bp],ax
04849                                           !BCC_EOS
04850                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04851 1318           31C0                       xor	ax,ax
04852 131A           31DB                       xor	bx,bx
04853 131C           8946         F4            mov	-$C[bp],ax
04854 131F           895E         F6            mov	-$A[bp],bx
04855                                           !BCC_EOS
04856                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04857 1322           31C0                       xor	ax,ax
04858 1324           31DB                       xor	bx,bx
04859 1326           8946         F8            mov	-8[bp],ax
04860 1329           895E         FA            mov	-6[bp],bx
04861                                           !BCC_EOS
04862                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04863 132C           31C0                       xor	ax,ax
04864 132E           31DB                       xor	bx,bx
04865 1330           8946         FC            mov	-4[bp],ax
04866 1333           895E         FE            mov	-2[bp],bx
04867                                           !BCC_EOS
04868                                           ! 1249   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04869                                           ! Debug: list int = const $10 (used reg = )
04870 1336           B8                   0010  mov	ax,*$10
04871 1339           50                         push	ax
04872                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04873 133A           8D5E         F0            lea	bx,-$10[bp]
04874 133D           53                         push	bx
04875                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04876 133E           FF76         EC            push	-$14[bp]
04877                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04878 1341           8B46         EE            mov	ax,-$12[bp]
04879 1344           B1                     04  mov	cl,*4
04880 1346           D3E0                       shl	ax,cl
04881                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04882                                           ! Debug: expression subtree swapping
04883                                           ! Debug: list unsigned int = ax+0 (used reg = )
04884 1348           50                         push	ax
04885                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04886 1349           B8                   9FF0  mov	ax,#$9FF0
04887 134C           50                         push	ax
04888                                           ! Debug: func () void = memcpyb+0 (used reg = )
04889 134D           E8         ECD4            call	_memcpyb
04890 1350           83C4                   0A  add	sp,*$A
04891                                           !BCC_EOS
04892                                           ! 1250   count++;
04893                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04894 1353           8B46         EE            mov	ax,-$12[bp]
04895 1356           40                         inc	ax
04896 1357           8946         EE            mov	-$12[bp],ax
04897                                           !BCC_EOS
04898                                           ! 1251   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04899                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
04900 135A           B8                   0002  mov	ax,*2
04901 135D           8946         F0            mov	-$10[bp],ax
04902                                           !BCC_EOS
04903                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04904 1360           31C0                       xor	ax,ax
04905 1362           8946         F2            mov	-$E[bp],ax
04906                                           !BCC_EOS
04907                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04908 1365           31C0                       xor	ax,ax
04909 1367           31DB                       xor	bx,bx
04910 1369           8946         F4            mov	-$C[bp],ax
04911 136C           895E         F6            mov	-$A[bp],bx
04912                                           !BCC_EOS
04913                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04914 136F           31C0                       xor	ax,ax
04915 1371           31DB                       xor	bx,bx
04916 1373           8946         F8            mov	-8[bp],ax
04917 1376           895E         FA            mov	-6[bp],bx
04918                                           !BCC_EOS
04919                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04920 1379           31C0                       xor	ax,ax
04921 137B           31DB                       xor	bx,bx
04922 137D           8946         FC            mov	-4[bp],ax
04923 1380           895E         FE            mov	-2[bp],bx
04924                                           !BCC_EOS
04925                                           ! 1252   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04926                                           ! Debug: list int = const $10 (used reg = )
04927 1383           B8                   0010  mov	ax,*$10
04928 1386           50                         push	ax
04929                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04930 1387           8D5E         F0            lea	bx,-$10[bp]
04931 138A           53                         push	bx
04932                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04933 138B           FF76         EC            push	-$14[bp]
04934                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04935 138E           8B46         EE            mov	ax,-$12[bp]
04936 1391           B1                     04  mov	cl,*4
04937 1393           D3E0                       shl	ax,cl
04938                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04939                                           ! Debug: expression subtree swapping
04940                                           ! Debug: list unsigned int = ax+0 (used reg = )
04941 1395           50                         push	ax
04942                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04943 1396           B8                   9FF0  mov	ax,#$9FF0
04944 1399           50                         push	ax
04945                                           ! Debug: func () void = memcpyb+0 (used reg = )
04946 139A           E8         EC87            call	_memcpyb
04947 139D           83C4                   0A  add	sp,*$A
04948                                           !BCC_EOS
04949                                           ! 1253   count++;
04950                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04951 13A0           8B46         EE            mov	ax,-$12[bp]
04952 13A3           40                         inc	ax
04953 13A4           8946         EE            mov	-$12[bp],ax
04954                                           !BCC_EOS
04955                                           ! 1254   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04956                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
04957 13A7           B8                   0003  mov	ax,*3
04958 13AA           8946         F0            mov	-$10[bp],ax
04959                                           !BCC_EOS
04960                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04961 13AD           31C0                       xor	ax,ax
04962 13AF           8946         F2            mov	-$E[bp],ax
04963                                           !BCC_EOS
04964                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04965 13B2           31C0                       xor	ax,ax
04966 13B4           31DB                       xor	bx,bx
04967 13B6           8946         F4            mov	-$C[bp],ax
04968 13B9           895E         F6            mov	-$A[bp],bx
04969                                           !BCC_EOS
04970                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04971 13BC           31C0                       xor	ax,ax
04972 13BE           31DB                       xor	bx,bx
04973 13C0           8946         F8            mov	-8[bp],ax
04974 13C3           895E         FA            mov	-6[bp],bx
04975                                           !BCC_EOS
04976                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04977 13C6           31C0                       xor	ax,ax
04978 13C8           31DB                       xor	bx,bx
04979 13CA           8946         FC            mov	-4[bp],ax
04980 13CD           895E         FE            mov	-2[bp],bx
04981                                           !BCC_EOS
04982                                           ! 1255   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04983                                           ! Debug: list int = const $10 (used reg = )
04984 13D0           B8                   0010  mov	ax,*$10
04985 13D3           50                         push	ax
04986                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04987 13D4           8D5E         F0            lea	bx,-$10[bp]
04988 13D7           53                         push	bx
04989                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04990 13D8           FF76         EC            push	-$14[bp]
04991                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04992 13DB           8B46         EE            mov	ax,-$12[bp]
04993 13DE           B1                     04  mov	cl,*4
04994 13E0           D3E0                       shl	ax,cl
04995                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04996                                           ! Debug: expression subtree swapping
04997                                           ! Debug: list unsigned int = ax+0 (used reg = )
04998 13E2           50                         push	ax
04999                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05000 13E3           B8                   9FF0  mov	ax,#$9FF0
05001 13E6           50                         push	ax
05002                                           ! Debug: func () void = memcpyb+0 (used reg = )
05003 13E7           E8         EC3A            call	_memcpyb
05004 13EA           83C4                   0A  add	sp,*$A
05005                                           !BCC_EOS
05006                                           ! 1256   count++;
05007                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05008 13ED           8B46         EE            mov	ax,-$12[bp]
05009 13F0           40                         inc	ax
05010 13F1           8946         EE            mov	-$12[bp],ax
05011                                           !BCC_EOS
05012                                           ! 1257   write_word(0x9ff0, 0x0080, count);
05013                                           ! Debug: list unsigned short count = [S+$16-$14] (used reg = )
05014 13F4           FF76         EE            push	-$12[bp]
05015                                           ! Debug: list int = const $80 (used reg = )
05016 13F7           B8                   0080  mov	ax,#$80
05017 13FA           50                         push	ax
05018                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05019 13FB           B8                   9FF0  mov	ax,#$9FF0
05020 13FE           50                         push	ax
05021                                           ! Debug: func () void = write_word+0 (used reg = )
05022 13FF           E8         F234            call	_write_word
05023 1402           83C4                   06  add	sp,*6
05024                                           !BCC_EOS
05025                                           ! 1258   write_word(0x9ff0, 0x0082, 0xffff);
05026                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05027 1405           B8                   FFFF  mov	ax,#$FFFF
05028 1408           50                         push	ax
05029                                           ! Debug: list int = const $82 (used reg = )
05030 1409           B8                   0082  mov	ax,#$82
05031 140C           50                         push	ax
05032                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05033 140D           B8                   9FF0  mov	ax,#$9FF0
05034 1410           50                         push	ax
05035                                           ! Debug: func () void = write_word+0 (used reg = )
05036 1411           E8         F222            call	_write_word
05037 1414           83C4                   06  add	sp,*6
05038                                           !BCC_EOS
05039                                           ! 1259 }
05040 1417           89EC                       mov	sp,bp
05041 1419           5D                         pop	bp
05042 141A           C3                         ret
05043                                           ! 1260 static Bit8u
05044                                           ! Register BX used in function init_boot_vectors
05045                                           ! 1261 get_boot_vector(i, e)
05046                                           ! 1262 Bit16u i; ipl_entry_t *e;
05047                       0000141B            _get_boot_vector:
05048                                           !BCC_EOS
05049                                           !BCC_EOS
05050                                           ! 1263 {
05051                                           ! 1264   Bit16u count;
05052                                           !BCC_EOS
05053                                           ! 1265   Bit16u ss = get_SS();
05054 141B           55                         push	bp
05055 141C           89E5                       mov	bp,sp
05056 141E           83C4                   FC  add	sp,*-4
05057                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05058 1421           E8         F22D            call	_get_SS
05059                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05060 1424           8946         FC            mov	-4[bp],ax
05061                                           !BCC_EOS
05062                                           ! 1266   count = read_word(0x9ff0, 0x0080);
05063                                           ! Debug: list int = const $80 (used reg = )
05064 1427           B8                   0080  mov	ax,#$80
05065 142A           50                         push	ax
05066                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05067 142B           B8                   9FF0  mov	ax,#$9FF0
05068 142E           50                         push	ax
05069                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05070 142F           E8         F1D9            call	_read_word
05071 1432           83C4                   04  add	sp,*4
05072                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05073 1435           8946         FE            mov	-2[bp],ax
05074                                           !BCC_EOS
05075                                           ! 1267   if (i >= count) return 0;
05076                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05077 1438           8B46         04            mov	ax,4[bp]
05078 143B           3B46         FE            cmp	ax,-2[bp]
05079 143E           72           06            jb  	.10F
05080                       00001440            .110:
05081 1440           30C0                       xor	al,al
05082 1442           89EC                       mov	sp,bp
05083 1444           5D                         pop	bp
05084 1445           C3                         ret
05085                                           !BCC_EOS
05086                                           ! 1268   memcpyb(ss, e, 0x9ff0, 0x0000 + i * sizeof (*e), sizeof
05087                       00001446            .10F:
05088                                           ! 1268  (*e));
05089                                           ! Debug: list int = const $10 (used reg = )
05090 1446           B8                   0010  mov	ax,*$10
05091 1449           50                         push	ax
05092                                           ! Debug: mul int = const $10 to unsigned short i = [S+8+2] (used reg = )
05093 144A           8B46         04            mov	ax,4[bp]
05094 144D           B1                     04  mov	cl,*4
05095 144F           D3E0                       shl	ax,cl
05096                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05097                                           ! Debug: expression subtree swapping
05098                                           ! Debug: list unsigned int = ax+0 (used reg = )
05099 1451           50                         push	ax
05100                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05101 1452           B8                   9FF0  mov	ax,#$9FF0
05102 1455           50                         push	ax
05103                                           ! Debug: list * struct  e = [S+$C+4] (used reg = )
05104 1456           FF76         06            push	6[bp]
05105                                           ! Debug: list unsigned short ss = [S+$E-6] (used reg = )
05106 1459           FF76         FC            push	-4[bp]
05107                                           ! Debug: func () void = memcpyb+0 (used reg = )
05108 145C           E8         EBC5            call	_memcpyb
05109 145F           83C4                   0A  add	sp,*$A
05110                                           !BCC_EOS
05111                                           ! 1269   return 1;
05112 1462           B0                     01  mov	al,*1
05113 1464           89EC                       mov	sp,bp
05114 1466           5D                         pop	bp
05115 1467           C3                         ret
05116                                           !BCC_EOS
05117                                           ! 1270 }
05118                                           ! 1271   void
05119                                           ! 1272 interactive_bootkey()
05120                                           ! 1273 {
05121                                           export	_interactive_bootkey
05122                       00001468            _interactive_bootkey:
05123                                           ! 1274   ipl_entry_t e;
05124                                           !BCC_EOS
05125                                           ! 1275   Bit16u count;
05126                                           !BCC_EOS
05127                                           ! 1276   char description[33];
05128                                           !BCC_EOS
05129                                           ! 1277   Bit8u scan_code;
05130                                           !BCC_EOS
05131                                           ! 1278   Bit8u i;
05132                                           !BCC_EOS
05133                                           ! 1279   Bit16u ss = get_SS();
05134 1468           55                         push	bp
05135 1469           89E5                       mov	bp,sp
05136 146B           83C4                   C8  add	sp,*-$38
05137                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05138 146E           E8         F1E0            call	_get_SS
05139                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05140 1471           8946         C8            mov	-$38[bp],ax
05141                                           !BCC_EOS
05142                                           ! 1280   Bit16u valid_choice = 0;
05143 1474           4C                         dec	sp
05144 1475           4C                         dec	sp
05145                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05146 1476           31C0                       xor	ax,ax
05147 1478           8946         C6            mov	-$3A[bp],ax
05148                                           !BCC_EOS
05149                                           ! 1281   while (check_for_keystroke())
05150                                           ! 1282     get_keystroke();
05151 147B           EB           03            jmp .112
05152                       0000147D            .113:
05153                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05154 147D           E8         F4EE            call	_get_keystroke
05155                                           !BCC_EOS
05156                                           ! 1283   bios_printf(2, "Press F12 for boot menu.\n\n");
05157                       00001480            .112:
05158                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05159 1480           E8         F4DD            call	_check_for_keystroke
05160 1483           84C0                       test	al,al
05161 1485           75           F6            jne	.113
05162                       00001487            .114:
05163                       00001487            .111:
05164                                           ! Debug: list * char = .115+0 (used reg = )
05165 1487           BB                   D922  mov	bx,#.115
05166 148A           53                         push	bx
05167                                           ! Debug: list int = const 2 (used reg = )
05168 148B           B8                   0002  mov	ax,*2
05169 148E           50                         push	ax
05170                                           ! Debug: func () void = bios_printf+0 (used reg = )
05171 148F           E8         F515            call	_bios_printf
05172 1492           83C4                   04  add	sp,*4
05173                                           !BCC_EOS
05174                                           ! 1284   delay_ticks_and_check_for_keystroke(11, 5);
05175                                           ! Debug: list int = const 5 (used reg = )
05176 1495           B8                   0005  mov	ax,*5
05177 1498           50                         push	ax
05178                                           ! Debug: list int = const $B (used reg = )
05179 1499           B8                   000B  mov	ax,*$B
05180 149C           50                         push	ax
05181                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05182 149D           E8         F4D6            call	_delay_ticks_and_check_for_keystroke
05183 14A0           83C4                   04  add	sp,*4
05184                                           !BCC_EOS
05185                                           ! 1285   if (check_for_keystroke())
05186                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05187 14A3           E8         F4BA            call	_check_for_keystroke
05188 14A6           84C0                       test	al,al
05189 14A8         0F84         01B1            beq 	.116
05190                       000014AC            .117:
05191                                           ! 1286   {
05192                                           ! 1287     scan_code = get_keystroke();
05193                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05194 14AC           E8         F4BF            call	_get_keystroke
05195                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05196 14AF           8846         CC            mov	-$34[bp],al
05197                                           !BCC_EOS
05198                                           ! 1288     if (scan_code == 0x86)
05199                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05200 14B2           8A46         CC            mov	al,-$34[bp]
05201 14B5           3C                     86  cmp	al,#$86
05202 14B7         0F85         01A2            bne 	.118
05203                       000014BB            .119:
05204                                           ! 1289     {
05205                                           ! 1290       while (check_for_keystroke())
05206                                           ! 1291         get_keystroke();
05207 14BB           EB           03            jmp .11B
05208                       000014BD            .11C:
05209                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05210 14BD           E8         F4AE            call	_get_keystroke
05211                                           !BCC_EOS
05212                                           ! 1292       bios_printf(2, "Select boot device:\n\n");
05213                       000014C0            .11B:
05214                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05215 14C0           E8         F49D            call	_check_for_keystroke
05216 14C3           84C0                       test	al,al
05217 14C5           75           F6            jne	.11C
05218                       000014C7            .11D:
05219                       000014C7            .11A:
05220                                           ! Debug: list * char = .11E+0 (used reg = )
05221 14C7           BB                   D90C  mov	bx,#.11E
05222 14CA           53                         push	bx
05223                                           ! Debug: list int = const 2 (used reg = )
05224 14CB           B8                   0002  mov	ax,*2
05225 14CE           50                         push	ax
05226                                           ! Debug: func () void = bios_printf+0 (used reg = )
05227 14CF           E8         F4D5            call	_bios_printf
05228 14D2           83C4                   04  add	sp,*4
05229                                           !BCC_EOS
05230                                           ! 1293       count = read_word(0x9ff0, 0x0080);
05231                                           ! Debug: list int = const $80 (used reg = )
05232 14D5           B8                   0080  mov	ax,#$80
05233 14D8           50                         push	ax
05234                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05235 14D9           B8                   9FF0  mov	ax,#$9FF0
05236 14DC           50                         push	ax
05237                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05238 14DD           E8         F12B            call	_read_word
05239 14E0           83C4                   04  add	sp,*4
05240                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05241 14E3           8946         EE            mov	-$12[bp],ax
05242                                           !BCC_EOS
05243                                           ! 1294       for (i = 0; i < count; i++)
05244                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05245 14E6           30C0                       xor	al,al
05246 14E8           8846         CB            mov	-$35[bp],al
05247                                           !BCC_EOS
05248                                           !BCC_EOS
05249                                           ! 1295       {
05250 14EB           E9         00FC            br 	.121
05251                       000014EE            .122:
05252                                           ! 1296         memcpyb(ss, &e, 0x9ff0, 0x0000 + i * sizeof (e), sizeof (e));
05253                                           ! Debug: list int = const $10 (used reg = )
05254 14EE           B8                   0010  mov	ax,*$10
05255 14F1           50                         push	ax
05256                                           ! Debug: mul int = const $10 to unsigned char i = [S+$3E-$37] (used reg = )
05257 14F2           8A46         CB            mov	al,-$35[bp]
05258 14F5           30E4                       xor	ah,ah
05259 14F7           B1                     04  mov	cl,*4
05260 14F9           D3E0                       shl	ax,cl
05261                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05262                                           ! Debug: expression subtree swapping
05263                                           ! Debug: list unsigned int = ax+0 (used reg = )
05264 14FB           50                         push	ax
05265                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05266 14FC           B8                   9FF0  mov	ax,#$9FF0
05267 14FF           50                         push	ax
05268                                           ! Debug: list * struct  e = S+$42-$12 (used reg = )
05269 1500           8D5E         F0            lea	bx,-$10[bp]
05270 1503           53                         push	bx
05271                                           ! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
05272 1504           FF76         C8            push	-$38[bp]
05273                                           ! Debug: func () void = memcpyb+0 (used reg = )
05274 1507           E8         EB1A            call	_memcpyb
05275 150A           83C4                   0A  add	sp,*$A
05276                                           !BCC_EOS
05277                                           ! 1297         bios_printf(2, "%d. ", i+1);
05278                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05279 150D           8A46         CB            mov	al,-$35[bp]
05280 1510           30E4                       xor	ah,ah
05281                                           ! Debug: list unsigned int = ax+1 (used reg = )
05282 1512           40                         inc	ax
05283 1513           50                         push	ax
05284                                           ! Debug: list * char = .123+0 (used reg = )
05285 1514           BB                   D907  mov	bx,#.123
05286 1517           53                         push	bx
05287                                           ! Debug: list int = const 2 (used reg = )
05288 1518           B8                   0002  mov	ax,*2
05289 151B           50                         push	ax
05290                                           ! Debug: func () void = bios_printf+0 (used reg = )
05291 151C           E8         F488            call	_bios_printf
05292 151F           83C4                   06  add	sp,*6
05293                                           !BCC_EOS
05294                                           ! 1298         switch(e.type)
05295 1522           8B46         F0            mov	ax,-$10[bp]
05296                                           ! 1299         {
05297 1525           E9         009F            br 	.126
05298                                           ! 1300           case 0x01:
05299                                           ! 1301           case 0x02:
05300                       00001528            .127:
05301                                           ! 1302           case 0x03:
05302                       00001528            .128:
05303                                           ! 1303             bios_printf(2, "%s\n", drivetypes[e.type]);
05304                       00001528            .129:
05305                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05306 1528           8B5E         F0            mov	bx,-$10[bp]
05307 152B           89DA                       mov	dx,bx
05308 152D           D1E3                       shl	bx,*1
05309 152F           D1E3                       shl	bx,*1
05310 1531           01D3                       add	bx,dx
05311 1533           D1E3                       shl	bx,*1
05312                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05313                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05314 1535           81C3                 12A2  add	bx,#_drivetypes
05315 1539           53                         push	bx
05316                                           ! Debug: list * char = .12A+0 (used reg = )
05317 153A           BB                   D903  mov	bx,#.12A
05318 153D           53                         push	bx
05319                                           ! Debug: list int = const 2 (used reg = )
05320 153E           B8                   0002  mov	ax,*2
05321 1541           50                         push	ax
05322                                           ! Debug: func () void = bios_printf+0 (used reg = )
05323 1542           E8         F462            call	_bios_printf
05324 1545           83C4                   06  add	sp,*6
05325                                           !BCC_EOS
05326                                           ! 1304             break;
05327 1548           E9         0098            br 	.124
05328                                           !BCC_EOS
05329                                           ! 1305           case 0x80:
05330                                           ! 1306             bios_printf(2, "%s", drivetypes[4]);
05331                       0000154B            .12B:
05332                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05333 154B           BB                   12CA  mov	bx,#_drivetypes+$28
05334 154E           53                         push	bx
05335                                           ! Debug: list * char = .12C+0 (used reg = )
05336 154F           BB                   D900  mov	bx,#.12C
05337 1552           53                         push	bx
05338                                           ! Debug: list int = const 2 (used reg = )
05339 1553           B8                   0002  mov	ax,*2
05340 1556           50                         push	ax
05341                                           ! Debug: func () void = bios_printf+0 (used reg = )
05342 1557           E8         F44D            call	_bios_printf
05343 155A           83C4                   06  add	sp,*6
05344                                           !BCC_EOS
05345                                           ! 1307             if (e.description != 0)
05346                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05347                                           ! Debug: expression subtree swapping
05348 155D           31C0                       xor	ax,ax
05349 155F           31DB                       xor	bx,bx
05350 1561           53                         push	bx
05351 1562           50                         push	ax
05352 1563           8B46         F8            mov	ax,-8[bp]
05353 1566           8B5E         FA            mov	bx,-6[bp]
05354 1569           8D7E         C2            lea	di,-2+..FFFF[bp]
05355 156C           E8         EB5C            call	lcmpul
05356 156F           8D66         C6            lea	sp,2+..FFFF[bp]
05357 1572           74           41            je  	.12D
05358                       00001574            .12E:
05359                                           ! 1308             {
05360                                           ! 1309               memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05361                                           ! Debug: list int = const $20 (used reg = )
05362 1574           B8                   0020  mov	ax,*$20
05363 1577           50                         push	ax
05364                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$3E-$A] (used reg = )
05365                                           ! Debug: expression subtree swapping
05366 1578           B8                   FFFF  mov	ax,#$FFFF
05367 157B           31DB                       xor	bx,bx
05368 157D           8D7E         F8            lea	di,-8[bp]
05369 1580           E8         EB38            call	landul
05370                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05371                                           ! Debug: list unsigned short = ax+0 (used reg = )
05372 1583           50                         push	ax
05373                                           ! Debug: sr int = const $10 to unsigned long e = [S+$40-$A] (used reg = )
05374 1584           8B46         F8            mov	ax,-8[bp]
05375 1587           8B5E         FA            mov	bx,-6[bp]
05376 158A           93                         xchg	bx,ax
05377 158B           31DB                       xor	bx,bx
05378                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05379                                           ! Debug: list unsigned short = ax+0 (used reg = )
05380 158D           50                         push	ax
05381                                           ! Debug: list * [$21] char description = S+$42-$35 (used reg = )
05382 158E           8D5E         CD            lea	bx,-$33[bp]
05383 1591           53                         push	bx
05384                                           ! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
05385 1592           FF76         C8            push	-$38[bp]
05386                                           ! Debug: func () void = memcpyb+0 (used reg = )
05387 1595           E8         EA8C            call	_memcpyb
05388 1598           83C4                   0A  add	sp,*$A
05389                                           !BCC_EOS
05390                                           ! 1310               description[32] = 0;
05391                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05392 159B           30C0                       xor	al,al
05393 159D           8846         ED            mov	-$13[bp],al
05394                                           !BCC_EOS
05395                                           ! 1311               bios_printf(2, " [%S]", ss, description);
05396                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05397 15A0           8D5E         CD            lea	bx,-$33[bp]
05398 15A3           53                         push	bx
05399                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05400 15A4           FF76         C8            push	-$38[bp]
05401                                           ! Debug: list * char = .12F+0 (used reg = )
05402 15A7           BB                   D8FA  mov	bx,#.12F
05403 15AA           53                         push	bx
05404                                           ! Debug: list int = const 2 (used reg = )
05405 15AB           B8                   0002  mov	ax,*2
05406 15AE           50                         push	ax
05407                                           ! Debug: func () void = bios_printf+0 (used reg = )
05408 15AF           E8         F3F5            call	_bios_printf
05409 15B2           83C4                   08  add	sp,*8
05410                                           !BCC_EOS
05411                                           ! 1312            }
05412                                           ! 1313            bios_printf(2, "\n");
05413                       000015B5            .12D:
05414                                           ! Debug: list * char = .130+0 (used reg = )
05415 15B5           BB                   D8F8  mov	bx,#.130
05416 15B8           53                         push	bx
05417                                           ! Debug: list int = const 2 (used reg = )
05418 15B9           B8                   0002  mov	ax,*2
05419 15BC           50                         push	ax
05420                                           ! Debug: func () void = bios_printf+0 (used reg = )
05421 15BD           E8         F3E7            call	_bios_printf
05422 15C0           83C4                   04  add	sp,*4
05423                                           !BCC_EOS
05424                                           ! 1314            break;
05425 15C3           EB           1E            jmp .124
05426                                           !BCC_EOS
05427                                           ! 1315         }
05428                                           ! 1316       }
05429 15C5           EB           1C            jmp .124
05430                       000015C7            .126:
05431 15C7           2D                   0001  sub	ax,*1
05432 15CA         0F84         FF5A            beq 	.127
05433 15CE           2D                   0001  sub	ax,*1
05434 15D1         0F84         FF53            beq 	.128
05435 15D5           2D                   0001  sub	ax,*1
05436 15D8         0F84         FF4C            beq 	.129
05437 15DC           2D                   007D  sub	ax,*$7D
05438 15DF         0F84         FF68            beq 	.12B
05439                       000015E3            .124:
05440                       FFFFFFC4            ..FFFF	=	-$3C
05441                                           ! 1317       count++;
05442                       000015E3            .120:
05443                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05444 15E3           8A46         CB            mov	al,-$35[bp]
05445 15E6           40                         inc	ax
05446 15E7           8846         CB            mov	-$35[bp],al
05447                       000015EA            .121:
05448                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05449 15EA           8A46         CB            mov	al,-$35[bp]
05450 15ED           30E4                       xor	ah,ah
05451 15EF           3B46         EE            cmp	ax,-$12[bp]
05452 15F2         0F82         FEF8            blo 	.122
05453                       000015F6            .131:
05454                       000015F6            .11F:
05455                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05456 15F6           8B46         EE            mov	ax,-$12[bp]
05457 15F9           40                         inc	ax
05458 15FA           8946         EE            mov	-$12[bp],ax
05459                                           !BCC_EOS
05460                                           ! 1318       while (!valid_choice) {
05461 15FD           EB           49            jmp .133
05462                       000015FF            .134:
05463                                           ! 1319         scan_code = get_keystroke();
05464                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05465 15FF           E8         F36C            call	_get_keystroke
05466                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05467 1602           8846         CC            mov	-$34[bp],al
05468                                           !BCC_EOS
05469                                           ! 1320         if (scan_code == 0x01 || scan_code == 0x58)
05470                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05471 1605           8A46         CC            mov	al,-$34[bp]
05472 1608           3C                     01  cmp	al,*1
05473 160A           74           07            je  	.136
05474                       0000160C            .137:
05475                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05476 160C           8A46         CC            mov	al,-$34[bp]
05477 160F           3C                     58  cmp	al,*$58
05478 1611           75           08            jne 	.135
05479                       00001613            .136:
05480                                           ! 1321         {
05481                                           ! 1322           valid_choice = 1;
05482                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05483 1613           B8                   0001  mov	ax,*1
05484 1616           8946         C6            mov	-$3A[bp],ax
05485                                           !BCC_EOS
05486                                           ! 1323         }
05487                                           ! 1324         else if (scan_code <= count)
05488 1619           EB           2D            jmp .138
05489                       0000161B            .135:
05490                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05491 161B           8A46         CC            mov	al,-$34[bp]
05492 161E           30E4                       xor	ah,ah
05493 1620           3B46         EE            cmp	ax,-$12[bp]
05494 1623           77           23            ja  	.139
05495                       00001625            .13A:
05496                                           ! 1325         {
05497                                           ! 1326           valid_choice = 1;
05498                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05499 1625           B8                   0001  mov	ax,*1
05500 1628           8946         C6            mov	-$3A[bp],ax
05501                                           !BCC_EOS
05502                                           ! 1327           scan_code -= 1;
05503                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05504 162B           8A46         CC            mov	al,-$34[bp]
05505 162E           30E4                       xor	ah,ah
05506 1630           48                         dec	ax
05507 1631           8846         CC            mov	-$34[bp],al
05508                                           !BCC_EOS
05509                                           ! 1328           write_word(0x9ff0, 0x0084, scan_code);
05510                                           ! Debug: list unsigned char scan_code = [S+$3C-$36] (used reg = )
05511 1634           8A46         CC            mov	al,-$34[bp]
05512 1637           30E4                       xor	ah,ah
05513 1639           50                         push	ax
05514                                           ! Debug: list int = const $84 (used reg = )
05515 163A           B8                   0084  mov	ax,#$84
05516 163D           50                         push	ax
05517                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05518 163E           B8                   9FF0  mov	ax,#$9FF0
05519 1641           50                         push	ax
05520                                           ! Debug: func () void = write_word+0 (used reg = )
05521 1642           E8         EFF1            call	_write_word
05522 1645           83C4                   06  add	sp,*6
05523                                           !BCC_EOS
05524                                           ! 1329         }
05525                                           ! 1330       }
05526                       00001648            .139:
05527                       00001648            .138:
05528                                           ! 1331       bios_printf(2, "\n");
05529                       00001648            .133:
05530 1648           8B46         C6            mov	ax,-$3A[bp]
05531 164B           85C0                       test	ax,ax
05532 164D           74           B0            je 	.134
05533                       0000164F            .13B:
05534                       0000164F            .132:
05535                                           ! Debug: list * char = .13C+0 (used reg = )
05536 164F           BB                   D8F6  mov	bx,#.13C
05537 1652           53                         push	bx
05538                                           ! Debug: list int = const 2 (used reg = )
05539 1653           B8                   0002  mov	ax,*2
05540 1656           50                         push	ax
05541                                           ! Debug: func () void = bios_printf+0 (used reg = )
05542 1657           E8         F34D            call	_bios_printf
05543 165A           83C4                   04  add	sp,*4
05544                                           !BCC_EOS
05545                                           ! 1332     }
05546                                           ! 1333   }
05547                       0000165D            .118:
05548                                           ! 1334 }
05549                       0000165D            .116:
05550 165D           89EC                       mov	sp,bp
05551 165F           5D                         pop	bp
05552 1660           C3                         ret
05553                                           ! 1335 void
05554                                           ! Register BX used in function interactive_bootkey
05555                                           ! 1336 print_boot_device(e)
05556                                           ! 1337   ipl_entry_t *e;
05557                                           export	_print_boot_device
05558                       00001661            _print_boot_device:
05559                                           !BCC_EOS
05560                                           ! 1338 {
05561                                           ! 1339   Bit16u type;
05562                                           !BCC_EOS
05563                                           ! 1340   char description[33];
05564                                           !BCC_EOS
05565                                           ! 1341   Bit16u ss = get_SS();
05566 1661           55                         push	bp
05567 1662           89E5                       mov	bp,sp
05568 1664           83C4                   DA  add	sp,*-$26
05569                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05570 1667           E8         EFE7            call	_get_SS
05571                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05572 166A           8946         DA            mov	-$26[bp],ax
05573                                           !BCC_EOS
05574                                           ! 1342   type = e->type;
05575 166D           8B5E         04            mov	bx,4[bp]
05576                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05577 1670           8B1F                       mov	bx,[bx]
05578 1672           895E         FE            mov	-2[bp],bx
05579                                           !BCC_EOS
05580                                           ! 1343   if (type == 0x80) type = 0x4;
05581                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05582 1675           8B46         FE            mov	ax,-2[bp]
05583 1678           3D                   0080  cmp	ax,#$80
05584 167B           75           06            jne 	.13D
05585                       0000167D            .13E:
05586                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05587 167D           B8                   0004  mov	ax,*4
05588 1680           8946         FE            mov	-2[bp],ax
05589                                           !BCC_EOS
05590                                           ! 1344   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05591                       00001683            .13D:
05592                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05593 1683           8B46         FE            mov	ax,-2[bp]
05594 1686           85C0                       test	ax,ax
05595 1688           74           08            je  	.140
05596                       0000168A            .141:
05597                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05598 168A           8B46         FE            mov	ax,-2[bp]
05599 168D           3D                   0004  cmp	ax,*4
05600 1690           76           0E            jbe 	.13F
05601                       00001692            .140:
05602                                           ! Debug: list * char = .142+0 (used reg = )
05603 1692           BB                   D8E6  mov	bx,#.142
05604 1695           53                         push	bx
05605                                           ! Debug: list int = const 7 (used reg = )
05606 1696           B8                   0007  mov	ax,*7
05607 1699           50                         push	ax
05608                                           ! Debug: func () void = bios_printf+0 (used reg = )
05609 169A           E8         F30A            call	_bios_printf
05610 169D           83C4                   04  add	sp,*4
05611                                           !BCC_EOS
05612                                           ! 1345   bios_printf(2, "Booting from %s", drivetypes[type]);
05613                       000016A0            .13F:
05614                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05615 16A0           8B5E         FE            mov	bx,-2[bp]
05616 16A3           89DA                       mov	dx,bx
05617 16A5           D1E3                       shl	bx,*1
05618 16A7           D1E3                       shl	bx,*1
05619 16A9           01D3                       add	bx,dx
05620 16AB           D1E3                       shl	bx,*1
05621                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05622                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05623 16AD           81C3                 12A2  add	bx,#_drivetypes
05624 16B1           53                         push	bx
05625                                           ! Debug: list * char = .143+0 (used reg = )
05626 16B2           BB                   D8D6  mov	bx,#.143
05627 16B5           53                         push	bx
05628                                           ! Debug: list int = const 2 (used reg = )
05629 16B6           B8                   0002  mov	ax,*2
05630 16B9           50                         push	ax
05631                                           ! Debug: func () void = bios_printf+0 (used reg = )
05632 16BA           E8         F2EA            call	_bios_printf
05633 16BD           83C4                   06  add	sp,*6
05634                                           !BCC_EOS
05635                                           ! 1346   if (type == 4 && e->description != 0) {
05636                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05637 16C0           8B46         FE            mov	ax,-2[bp]
05638 16C3           3D                   0004  cmp	ax,*4
05639 16C6           75           6A            jne 	.144
05640                       000016C8            .146:
05641 16C8           8B5E         04            mov	bx,4[bp]
05642                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05643                                           ! Debug: expression subtree swapping
05644 16CB           31C0                       xor	ax,ax
05645 16CD           31F6                       xor	si,si
05646 16CF           56                         push	si
05647 16D0           50                         push	ax
05648 16D1           8B47         08            mov	ax,8[bx]
05649 16D4           8B5F         0A            mov	bx,$A[bx]
05650 16D7           8D7E         D6            lea	di,-$2A[bp]
05651 16DA           E8         E9EE            call	lcmpul
05652 16DD           8D66         DA            lea	sp,-$26[bp]
05653 16E0           74           50            je  	.144
05654                       000016E2            .145:
05655                                           ! 1347     memcpyb(
05656                                           ! 1347 ss, &description, (Bit16u)(e->description >> 16), (Bit16u)(e->description & 0xffff), 32);
05657                                           ! Debug: list int = const $20 (used reg = )
05658 16E2           B8                   0020  mov	ax,*$20
05659 16E5           50                         push	ax
05660 16E6           8B5E         04            mov	bx,4[bp]
05661                                           ! Debug: and unsigned long = const $FFFF to unsigned long = [bx+8] (used reg = )
05662                                           ! Debug: expression subtree swapping
05663 16E9           FF77         0A            push	$A[bx]
05664 16EC           FF77         08            push	8[bx]
05665 16EF           B8                   FFFF  mov	ax,#$FFFF
05666 16F2           31DB                       xor	bx,bx
05667 16F4           8D7E         D4            lea	di,-$2C[bp]
05668 16F7           E8         E9C1            call	landul
05669 16FA           83C4                   04  add	sp,*4
05670                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05671                                           ! Debug: list unsigned short = ax+0 (used reg = )
05672 16FD           50                         push	ax
05673 16FE           8B5E         04            mov	bx,4[bp]
05674                                           ! Debug: sr int = const $10 to unsigned long = [bx+8] (used reg = )
05675 1701           8B47         08            mov	ax,8[bx]
05676 1704           8B5F         0A            mov	bx,$A[bx]
05677 1707           93                         xchg	bx,ax
05678 1708           31DB                       xor	bx,bx
05679                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05680                                           ! Debug: list unsigned short = ax+0 (used reg = )
05681 170A           50                         push	ax
05682                                           ! Debug: list * [$21] char description = S+$2E-$25 (used reg = )
05683 170B           8D5E         DD            lea	bx,-$23[bp]
05684 170E           53                         push	bx
05685                                           ! Debug: list unsigned short ss = [S+$30-$28] (used reg = )
05686 170F           FF76         DA            push	-$26[bp]
05687                                           ! Debug: func () void = memcpyb+0 (used reg = )
05688 1712           E8         E90F            call	_memcpyb
05689 1715           83C4                   0A  add	sp,*$A
05690                                           !BCC_EOS
05691                                           ! 1348     description[32] = 0;
05692                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05693 1718           30C0                       xor	al,al
05694 171A           8846         FD            mov	-3[bp],al
05695                                           !BCC_EOS
05696                                           ! 1349     bios_printf(2, " [%S]", ss, description);
05697                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05698 171D           8D5E         DD            lea	bx,-$23[bp]
05699 1720           53                         push	bx
05700                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05701 1721           FF76         DA            push	-$26[bp]
05702                                           ! Debug: list * char = .147+0 (used reg = )
05703 1724           BB                   D8D0  mov	bx,#.147
05704 1727           53                         push	bx
05705                                           ! Debug: list int = const 2 (used reg = )
05706 1728           B8                   0002  mov	ax,*2
05707 172B           50                         push	ax
05708                                           ! Debug: func () void = bios_printf+0 (used reg = )
05709 172C           E8         F278            call	_bios_printf
05710 172F           83C4                   08  add	sp,*8
05711                                           !BCC_EOS
05712                                           ! 1350   }
05713                                           ! 1351   bios_printf(2, "...\n");
05714                       00001732            .144:
05715                                           ! Debug: list * char = .148+0 (used reg = )
05716 1732           BB                   D8CB  mov	bx,#.148
05717 1735           53                         push	bx
05718                                           ! Debug: list int = const 2 (used reg = )
05719 1736           B8                   0002  mov	ax,*2
05720 1739           50                         push	ax
05721                                           ! Debug: func () void = bios_printf+0 (used reg = )
05722 173A           E8         F26A            call	_bios_printf
05723 173D           83C4                   04  add	sp,*4
05724                                           !BCC_EOS
05725                                           ! 1352 }
05726 1740           89EC                       mov	sp,bp
05727 1742           5D                         pop	bp
05728 1743           C3                         ret
05729                                           ! 1353   void
05730                                           ! Register BX used in function print_boot_device
05731                                           ! 1354 print_boot_failure(type, reason)
05732                                           ! 1355   Bit16u type; Bit8u reason;
05733                                           export	_print_boot_failure
05734                       00001744            _print_boot_failure:
05735                                           !BCC_EOS
05736                                           !BCC_EOS
05737                                           ! 1356 {
05738                                           ! 1357   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05739 1744           55                         push	bp
05740 1745           89E5                       mov	bp,sp
05741                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05742 1747           8B46         04            mov	ax,4[bp]
05743 174A           85C0                       test	ax,ax
05744 174C           74           08            je  	.14A
05745                       0000174E            .14B:
05746                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05747 174E           8B46         04            mov	ax,4[bp]
05748 1751           3D                   0003  cmp	ax,*3
05749 1754           76           0D            jbe 	.149
05750                       00001756            .14A:
05751                                           ! Debug: list * char = .14C+0 (used reg = )
05752 1756           BB                   D8BB  mov	bx,#.14C
05753 1759           53                         push	bx
05754                                           ! Debug: list int = const 7 (used reg = )
05755 175A           B8                   0007  mov	ax,*7
05756 175D           50                         push	ax
05757                                           ! Debug: func () void = bios_printf+0 (used reg = )
05758 175E           E8         F246            call	_bios_printf
05759 1761           89EC                       mov	sp,bp
05760                                           !BCC_EOS
05761                                           ! 1358   bios_printf(2, "Boot failed");
05762                       00001763            .149:
05763                                           ! Debug: list * char = .14D+0 (used reg = )
05764 1763           BB                   D8AF  mov	bx,#.14D
05765 1766           53                         push	bx
05766                                           ! Debug: list int = const 2 (used reg = )
05767 1767           B8                   0002  mov	ax,*2
05768 176A           50                         push	ax
05769                                           ! Debug: func () void = bios_printf+0 (used reg = )
05770 176B           E8         F239            call	_bios_printf
05771 176E           89EC                       mov	sp,bp
05772                                           !BCC_EOS
05773                                           ! 1359   if (type < 4) {
05774                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05775 1770           8B46         04            mov	ax,4[bp]
05776 1773           3D                   0004  cmp	ax,*4
05777 1776           73           23            jae 	.14E
05778                       00001778            .14F:
05779                                           ! 1360     if (reason==0)
05780                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05781 1778           8A46         06            mov	al,6[bp]
05782 177B           84C0                       test	al,al
05783 177D           75           0F            jne 	.150
05784                       0000177F            .151:
05785                                           ! 1361       bios_printf(2, ": not a bootable disk");
05786                                           ! Debug: list * char = .152+0 (used reg = )
05787 177F           BB                   D899  mov	bx,#.152
05788 1782           53                         push	bx
05789                                           ! Debug: list int = const 2 (used reg = )
05790 1783           B8                   0002  mov	ax,*2
05791 1786           50                         push	ax
05792                                           ! Debug: func () void = bios_printf+0 (used reg = )
05793 1787           E8         F21D            call	_bios_printf
05794 178A           89EC                       mov	sp,bp
05795                                           !BCC_EOS
05796                                           ! 1362     else
05797                                           ! 1363       bios_printf(2, ": could not read the boot disk");
05798 178C           EB           0D            jmp .153
05799                       0000178E            .150:
05800                                           ! Debug: list * char = .154+0 (used reg = )
05801 178E           BB                   D87A  mov	bx,#.154
05802 1791           53                         push	bx
05803                                           ! Debug: list int = const 2 (used reg = )
05804 1792           B8                   0002  mov	ax,*2
05805 1795           50                         push	ax
05806                                           ! Debug: func () void = bios_printf+0 (used reg = )
05807 1796           E8         F20E            call	_bios_printf
05808 1799           89EC                       mov	sp,bp
05809                                           !BCC_EOS
05810                                           ! 1364   }
05811                       0000179B            .153:
05812                                           ! 1365   bios_printf(2, "\n\n");
05813                       0000179B            .14E:
05814                                           ! Debug: list * char = .155+0 (used reg = )
05815 179B           BB                   D877  mov	bx,#.155
05816 179E           53                         push	bx
05817                                           ! Debug: list int = const 2 (used reg = )
05818 179F           B8                   0002  mov	ax,*2
05819 17A2           50                         push	ax
05820                                           ! Debug: func () void = bios_printf+0 (used reg = )
05821 17A3           E8         F201            call	_bios_printf
05822 17A6           89EC                       mov	sp,bp
05823                                           !BCC_EOS
05824                                           ! 1366 }
05825 17A8           5D                         pop	bp
05826 17A9           C3                         ret
05827                                           ! 1367   void
05828                                           ! Register BX used in function print_boot_failure
05829                                           ! 1368 print_cdromboot_failure( code )
05830                                           ! 1369   Bit16u code;
05831                                           export	_print_cdromboot_failure
05832                       000017AA            _print_cdromboot_failure:
05833                                           !BCC_EOS
05834                                           ! 1370 {
05835                                           ! 1371   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05836 17AA           55                         push	bp
05837 17AB           89E5                       mov	bp,sp
05838                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05839 17AD           FF76         04            push	4[bp]
05840                                           ! Debug: list * char = .156+0 (used reg = )
05841 17B0           BB                   D857  mov	bx,#.156
05842 17B3           53                         push	bx
05843                                           ! Debug: list int = const 6 (used reg = )
05844 17B4           B8                   0006  mov	ax,*6
05845 17B7           50                         push	ax
05846                                           ! Debug: func () void = bios_printf+0 (used reg = )
05847 17B8           E8         F1EC            call	_bios_printf
05848 17BB           89EC                       mov	sp,bp
05849                                           !BCC_EOS
05850                                           ! 1372   return;
05851 17BD           5D                         pop	bp
05852 17BE           C3                         ret
05853                                           !BCC_EOS
05854                                           ! 1373 }
05855                                           ! 1374 void
05856                                           ! Register BX used in function print_cdromboot_failure
05857                                           ! 1375 nmi_handler_msg()
05858                                           ! 1376 {
05859                                           export	_nmi_handler_msg
05860                       000017BF            _nmi_handler_msg:
05861                                           ! 1377   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05862 17BF           55                         push	bp
05863 17C0           89E5                       mov	bp,sp
05864                                           ! Debug: list * char = .157+0 (used reg = )
05865 17C2           BB                   D843  mov	bx,#.157
05866 17C5           53                         push	bx
05867                                           ! Debug: list int = const 7 (used reg = )
05868 17C6           B8                   0007  mov	ax,*7
05869 17C9           50                         push	ax
05870                                           ! Debug: func () void = bios_printf+0 (used reg = )
05871 17CA           E8         F1DA            call	_bios_printf
05872 17CD           89EC                       mov	sp,bp
05873                                           !BCC_EOS
05874                                           ! 1378 }
05875 17CF           5D                         pop	bp
05876 17D0           C3                         ret
05877                                           ! 1379 void
05878                                           ! Register BX used in function nmi_handler_msg
05879                                           ! 1380 int18_panic_msg()
05880                                           ! 1381 {
05881                                           export	_int18_panic_msg
05882                       000017D1            _int18_panic_msg:
05883                                           ! 1382   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05884 17D1           55                         push	bp
05885 17D2           89E5                       mov	bp,sp
05886                                           ! Debug: list * char = .158+0 (used reg = )
05887 17D4           BB                   D82E  mov	bx,#.158
05888 17D7           53                         push	bx
05889                                           ! Debug: list int = const 7 (used reg = )
05890 17D8           B8                   0007  mov	ax,*7
05891 17DB           50                         push	ax
05892                                           ! Debug: func () void = bios_printf+0 (used reg = )
05893 17DC           E8         F1C8            call	_bios_printf
05894 17DF           89EC                       mov	sp,bp
05895                                           !BCC_EOS
05896                                           ! 1383 }
05897 17E1           5D                         pop	bp
05898 17E2           C3                         ret
05899                                           ! 1384 void
05900                                           ! Register BX used in function int18_panic_msg
05901                                           ! 1385 log_bios_start()
05902                                           ! 1386 {
05903                                           export	_log_bios_start
05904                       000017E3            _log_bios_start:
05905                                           ! 1387   bios_printf(4, "%s\n", bios_cvs_version_string);
05906 17E3           55                         push	bp
05907 17E4           89E5                       mov	bp,sp
05908                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
05909 17E6           BB                   0194  mov	bx,#_bios_cvs_version_string
05910 17E9           53                         push	bx
05911                                           ! Debug: list * char = .159+0 (used reg = )
05912 17EA           BB                   D82A  mov	bx,#.159
05913 17ED           53                         push	bx
05914                                           ! Debug: list int = const 4 (used reg = )
05915 17EE           B8                   0004  mov	ax,*4
05916 17F1           50                         push	ax
05917                                           ! Debug: func () void = bios_printf+0 (used reg = )
05918 17F2           E8         F1B2            call	_bios_printf
05919 17F5           89EC                       mov	sp,bp
05920                                           !BCC_EOS
05921                                           ! 1388 }
05922 17F7           5D                         pop	bp
05923 17F8           C3                         ret
05924                                           ! 1389   bx_bool
05925                                           ! Register BX used in function log_bios_start
05926                                           ! 1390 set_enable_a20(val)
05927                                           ! 1391   bx_bool val;
05928                                           export	_set_enable_a20
05929                       000017F9            _set_enable_a20:
05930                                           !BCC_EOS
05931                                           ! 1392 {
05932                                           ! 1393   Bit8u oldval;
05933                                           !BCC_EOS
05934                                           ! 1394   oldval = inb(0x92);
05935 17F9           55                         push	bp
05936 17FA           89E5                       mov	bp,sp
05937 17FC           4C                         dec	sp
05938 17FD           4C                         dec	sp
05939                                           ! Debug: list int = const $92 (used reg = )
05940 17FE           B8                   0092  mov	ax,#$92
05941 1801           50                         push	ax
05942                                           ! Debug: func () unsigned char = inb+0 (used reg = )
05943 1802           E8         ED3D            call	_inb
05944 1805           44                         inc	sp
05945 1806           44                         inc	sp
05946                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
05947 1807           8846         FF            mov	-1[bp],al
05948                                           !BCC_EOS
05949                                           ! 1395   if (val)
05950 180A           8B46         04            mov	ax,4[bp]
05951 180D           85C0                       test	ax,ax
05952 180F           74           14            je  	.15A
05953                       00001811            .15B:
05954                                           ! 1396     outb(0x92, oldval | 0x02);
05955                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05956 1811           8A46         FF            mov	al,-1[bp]
05957 1814           0C                     02  or	al,*2
05958                                           ! Debug: list unsigned char = al+0 (used reg = )
05959 1816           30E4                       xor	ah,ah
05960 1818           50                         push	ax
05961                                           ! Debug: list int = const $92 (used reg = )
05962 1819           B8                   0092  mov	ax,#$92
05963 181C           50                         push	ax
05964                                           ! Debug: func () void = outb+0 (used reg = )
05965 181D           E8         ED38            call	_outb
05966 1820           83C4                   04  add	sp,*4
05967                                           !BCC_EOS
05968                                           ! 1397   else
05969                                           ! 1398     outb(0x92, oldval & 0xfd);
05970 1823           EB           12            jmp .15C
05971                       00001825            .15A:
05972                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
05973 1825           8A46         FF            mov	al,-1[bp]
05974 1828           24                     FD  and	al,#$FD
05975                                           ! Debug: list unsigned char = al+0 (used reg = )
05976 182A           30E4                       xor	ah,ah
05977 182C           50                         push	ax
05978                                           ! Debug: list int = const $92 (used reg = )
05979 182D           B8                   0092  mov	ax,#$92
05980 1830           50                         push	ax
05981                                           ! Debug: func () void = outb+0 (used reg = )
05982 1831           E8         ED24            call	_outb
05983 1834           83C4                   04  add	sp,*4
05984                                           !BCC_EOS
05985                                           ! 1399   return((oldval & 0x02) != 0);
05986                       00001837            .15C:
05987                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05988 1837           8A46         FF            mov	al,-1[bp]
05989 183A           24                     02  and	al,*2
05990                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
05991 183C           84C0                       test	al,al
05992 183E           74           04            je 	.15D
05993 1840           B0                     01  mov	al,*1
05994 1842           EB           02            jmp	.15E
05995                       00001844            .15D:
05996 1844           30C0                       xor	al,al
05997                       00001846            .15E:
05998                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
05999 1846           30E4                       xor	ah,ah
06000 1848           89EC                       mov	sp,bp
06001 184A           5D                         pop	bp
06002 184B           C3                         ret
06003                                           !BCC_EOS
06004                                           ! 1400 }
06005                                           ! 1401   void
06006                                           ! 1402 debugger_on()
06007                                           ! 1403 {
06008                                           export	_debugger_on
06009                       0000184C            _debugger_on:
06010                                           ! 1404   outb(0xfedc, 0x01);
06011 184C           55                         push	bp
06012 184D           89E5                       mov	bp,sp
06013                                           ! Debug: list int = const 1 (used reg = )
06014 184F           B8                   0001  mov	ax,*1
06015 1852           50                         push	ax
06016                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06017 1853           B8                   FEDC  mov	ax,#$FEDC
06018 1856           50                         push	ax
06019                                           ! Debug: func () void = outb+0 (used reg = )
06020 1857           E8         ECFE            call	_outb
06021 185A           89EC                       mov	sp,bp
06022                                           !BCC_EOS
06023                                           ! 1405 }
06024 185C           5D                         pop	bp
06025 185D           C3                         ret
06026                                           ! 1406   void
06027                                           ! 1407 debugger_off()
06028                                           ! 1408 {
06029                                           export	_debugger_off
06030                       0000185E            _debugger_off:
06031                                           ! 1409   outb(0xfedc, 0x00);
06032 185E           55                         push	bp
06033 185F           89E5                       mov	bp,sp
06034                                           ! Debug: list int = const 0 (used reg = )
06035 1861           31C0                       xor	ax,ax
06036 1863           50                         push	ax
06037                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06038 1864           B8                   FEDC  mov	ax,#$FEDC
06039 1867           50                         push	ax
06040                                           ! Debug: func () void = outb+0 (used reg = )
06041 1868           E8         ECED            call	_outb
06042 186B           89EC                       mov	sp,bp
06043                                           !BCC_EOS
06044                                           ! 1410 }
06045 186D           5D                         pop	bp
06046 186E           C3                         ret
06047                                           ! 1411 int
06048                                           ! 1412 s3_resume()
06049                                           ! 1413 {
06050                                           export	_s3_resume
06051                       0000186F            _s3_resume:
06052                                           ! 1414     Bit32u s3_wakeup_vector;
06053                                           !BCC_EOS
06054                                           ! 1415     Bit8u s3_resume_flag;
06055                                           !BCC_EOS
06056                                           ! 1416     s3_resume_flag = read_byte(0x40, 0xb0);
06057 186F           55                         push	bp
06058 1870           89E5                       mov	bp,sp
06059 1872           83C4                   FA  add	sp,*-6
06060                                           ! Debug: list int = const $B0 (used reg = )
06061 1875           B8                   00B0  mov	ax,#$B0
06062 1878           50                         push	ax
06063                                           ! Debug: list int = const $40 (used reg = )
06064 1879           B8                   0040  mov	ax,*$40
06065 187C           50                         push	ax
06066                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06067 187D           E8         ED78            call	_read_byte
06068 1880           83C4                   04  add	sp,*4
06069                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06070 1883           8846         FB            mov	-5[bp],al
06071                                           !BCC_EOS
06072                                           ! 1417     s3_wakeup_vector = read_dword(0x40, 0xb2);
06073                                           ! Debug: list int = const $B2 (used reg = )
06074 1886           B8                   00B2  mov	ax,#$B2
06075 1889           50                         push	ax
06076                                           ! Debug: list int = const $40 (used reg = )
06077 188A           B8                   0040  mov	ax,*$40
06078 188D           50                         push	ax
06079                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
06080 188E           E8         E7F2            call	_read_dword
06081 1891           89D3                       mov	bx,dx
06082 1893           83C4                   04  add	sp,*4
06083                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06084 1896           8946         FC            mov	-4[bp],ax
06085 1899           895E         FE            mov	-2[bp],bx
06086                                           !BCC_EOS
06087                                           ! 1418     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06088                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06089 189C           FF76         FE            push	-2[bp]
06090 189F           FF76         FC            push	-4[bp]
06091                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06092 18A2           8A46         FB            mov	al,-5[bp]
06093 18A5           30E4                       xor	ah,ah
06094 18A7           50                         push	ax
06095                                           ! Debug: list * char = .15F+0 (used reg = )
06096 18A8           BB                   D80F  mov	bx,#.15F
06097 18AB           53                         push	bx
06098                                           ! Debug: list int = const 4 (used reg = )
06099 18AC           B8                   0004  mov	ax,*4
06100 18AF           50                         push	ax
06101                                           ! Debug: func () void = bios_printf+0 (used reg = )
06102 18B0           E8         F0F4            call	_bios_printf
06103 18B3           83C4                   0A  add	sp,*$A
06104                                           !BCC_EOS
06105                                           ! 1419     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06106                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06107 18B6           8A46         FB            mov	al,-5[bp]
06108 18B9           3C                     FE  cmp	al,#$FE
06109 18BB           75           0B            jne 	.161
06110                       000018BD            .162:
06111 18BD           8B46         FC            mov	ax,-4[bp]
06112 18C0           8B5E         FE            mov	bx,-2[bp]
06113 18C3           E8         E84E            call	ltstl
06114 18C6           75           06            jne 	.160
06115                       000018C8            .161:
06116                                           ! 1420      return 0;
06117 18C8           31C0                       xor	ax,ax
06118 18CA           89EC                       mov	sp,bp
06119 18CC           5D                         pop	bp
06120 18CD           C3                         ret
06121                                           !BCC_EOS
06122                                           ! 1421     write_byte(0x40, 0xb0, 0);
06123                       000018CE            .160:
06124                                           ! Debug: list int = const 0 (used reg = )
06125 18CE           31C0                       xor	ax,ax
06126 18D0           50                         push	ax
06127                                           ! Debug: list int = const $B0 (used reg = )
06128 18D1           B8                   00B0  mov	ax,#$B0
06129 18D4           50                         push	ax
06130                                           ! Debug: list int = const $40 (used reg = )
06131 18D5           B8                   0040  mov	ax,*$40
06132 18D8           50                         push	ax
06133                                           ! Debug: func () void = write_byte+0 (used reg = )
06134 18D9           E8         ED42            call	_write_byte
06135 18DC           83C4                   06  add	sp,*6
06136                                           !BCC_EOS
06137                                           ! 1422     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06138                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06139                                           ! Debug: expression subtree swapping
06140 18DF           B8                   000F  mov	ax,*$F
06141 18E2           31DB                       xor	bx,bx
06142 18E4           8D7E         FC            lea	di,-4[bp]
06143 18E7           E8         E7D1            call	landul
06144                                           ! Debug: list unsigned long = bx+0 (used reg = )
06145 18EA           53                         push	bx
06146 18EB           50                         push	ax
06147                                           ! Debug: list int = const $B6 (used reg = )
06148 18EC           B8                   00B6  mov	ax,#$B6
06149 18EF           50                         push	ax
06150                                           ! Debug: list int = const $40 (used reg = )
06151 18F0           B8                   0040  mov	ax,*$40
06152 18F3           50                         push	ax
06153                                           ! Debug: func () void = write_word+0 (used reg = )
06154 18F4           E8         ED3F            call	_write_word
06155 18F7           83C4                   08  add	sp,*8
06156                                           !BCC_EOS
06157                                           ! 1423     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06158                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06159 18FA           8B46         FC            mov	ax,-4[bp]
06160 18FD           8B5E         FE            mov	bx,-2[bp]
06161 1900           BF                   0004  mov	di,*4
06162 1903           E8         E823            call	lsrul
06163                                           ! Debug: list unsigned long = bx+0 (used reg = )
06164 1906           53                         push	bx
06165 1907           50                         push	ax
06166                                           ! Debug: list int = const $B8 (used reg = )
06167 1908           B8                   00B8  mov	ax,#$B8
06168 190B           50                         push	ax
06169                                           ! Debug: list int = const $40 (used reg = )
06170 190C           B8                   0040  mov	ax,*$40
06171 190F           50                         push	ax
06172                                           ! Debug: func () void = write_word+0 (used reg = )
06173 1910           E8         ED23            call	_write_word
06174 1913           83C4                   08  add	sp,*8
06175                                           !BCC_EOS
06176                                           ! 1424     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06177                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06178                                           ! Debug: expression subtree swapping
06179 1916           B8                   000F  mov	ax,*$F
06180 1919           31DB                       xor	bx,bx
06181 191B           8D7E         FC            lea	di,-4[bp]
06182 191E           E8         E79A            call	landul
06183                                           ! Debug: list unsigned long = bx+0 (used reg = )
06184 1921           53                         push	bx
06185 1922           50                         push	ax
06186                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06187 1923           8B46         FC            mov	ax,-4[bp]
06188 1926           8B5E         FE            mov	bx,-2[bp]
06189 1929           BF                   0004  mov	di,*4
06190 192C           E8         E7FA            call	lsrul
06191                                           ! Debug: list unsigned long = bx+0 (used reg = )
06192 192F           53                         push	bx
06193 1930           50                         push	ax
06194                                           ! Debug: list * char = .163+0 (used reg = )
06195 1931           BB                   D7F6  mov	bx,#.163
06196 1934           53                         push	bx
06197                                           ! Debug: list int = const 4 (used reg = )
06198 1935           B8                   0004  mov	ax,*4
06199 1938           50                         push	ax
06200                                           ! Debug: func () void = bios_printf+0 (used reg = )
06201 1939           E8         F06B            call	_bios_printf
06202 193C           83C4                   0C  add	sp,*$C
06203                                           !BCC_EOS
06204                                           ! 1425 #asm
06205                                           !BCC_EOS
06206                                           !BCC_ASM
06207                       00000001            _s3_resume.s3_resume_flag	set	1
06208                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06209                       00000002            _s3_resume.s3_wakeup_vector	set	2
06210                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06211 193F           FF2E       04B6                jmpf [0x04b6]
06212                                           ! 1427 endasm
06213                                           !BCC_ENDASM
06214                                           !BCC_EOS
06215                                           ! 1428     return 1;
06216 1943           B8                   0001  mov	ax,*1
06217 1946           89EC                       mov	sp,bp
06218 1948           5D                         pop	bp
06219 1949           C3                         ret
06220                                           !BCC_EOS
06221                                           ! 1429 }
06222                                           ! 1430 void ata_init( )
06223                                           ! Register BX used in function s3_resume
06224                                           ! 1431 {
06225                                           export	_ata_init
06226                       0000194A            _ata_init:
06227                                           ! 1432   Bit16u ebda_seg=read_word(0x0040,0x000E);
06228 194A           55                         push	bp
06229 194B           89E5                       mov	bp,sp
06230 194D           4C                         dec	sp
06231 194E           4C                         dec	sp
06232                                           ! Debug: list int = const $E (used reg = )
06233 194F           B8                   000E  mov	ax,*$E
06234 1952           50                         push	ax
06235                                           ! Debug: list int = const $40 (used reg = )
06236 1953           B8                   0040  mov	ax,*$40
06237 1956           50                         push	ax
06238                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06239 1957           E8         ECB1            call	_read_word
06240 195A           83C4                   04  add	sp,*4
06241                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06242 195D           8946         FE            mov	-2[bp],ax
06243                                           !BCC_EOS
06244                                           ! 1433   Bit8u channel, device;
06245                                           !BCC_EOS
06246                                           ! 1434   for (channel=0; channel<4; channel++) {
06247 1960           4C                         dec	sp
06248 1961           4C                         dec	sp
06249                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06250 1962           30C0                       xor	al,al
06251 1964           8846         FD            mov	-3[bp],al
06252                                           !BCC_EOS
06253                                           !BCC_EOS
06254 1967           E9         0077            br 	.166
06255                       0000196A            .167:
06256                                           ! 1435     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06257                                           ! Debug: list int = const 0 (used reg = )
06258 196A           31C0                       xor	ax,ax
06259 196C           50                         push	ax
06260                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06261 196D           8A46         FD            mov	al,-3[bp]
06262 1970           30E4                       xor	ah,ah
06263 1972           B1                     03  mov	cl,*3
06264 1974           D3E0                       shl	ax,cl
06265 1976           89C3                       mov	bx,ax
06266                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06267                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06268 1978           81C3                 0122  add	bx,#$122
06269 197C           53                         push	bx
06270                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06271 197D           FF76         FE            push	-2[bp]
06272                                           ! Debug: func () void = write_byte+0 (used reg = )
06273 1980           E8         EC9B            call	_write_byte
06274 1983           83C4                   06  add	sp,*6
06275                                           !BCC_EOS
06276                                           ! 1436     write_word(ebd
06277                                           ! 1436 a_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06278                                           ! Debug: list int = const 0 (used reg = )
06279 1986           31C0                       xor	ax,ax
06280 1988           50                         push	ax
06281                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06282 1989           8A46         FD            mov	al,-3[bp]
06283 198C           30E4                       xor	ah,ah
06284 198E           B1                     03  mov	cl,*3
06285 1990           D3E0                       shl	ax,cl
06286 1992           89C3                       mov	bx,ax
06287                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06288                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06289 1994           81C3                 0124  add	bx,#$124
06290 1998           53                         push	bx
06291                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06292 1999           FF76         FE            push	-2[bp]
06293                                           ! Debug: func () void = write_word+0 (used reg = )
06294 199C           E8         EC97            call	_write_word
06295 199F           83C4                   06  add	sp,*6
06296                                           !BCC_EOS
06297                                           ! 1437     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06298                                           ! Debug: list int = const 0 (used reg = )
06299 19A2           31C0                       xor	ax,ax
06300 19A4           50                         push	ax
06301                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06302 19A5           8A46         FD            mov	al,-3[bp]
06303 19A8           30E4                       xor	ah,ah
06304 19AA           B1                     03  mov	cl,*3
06305 19AC           D3E0                       shl	ax,cl
06306 19AE           89C3                       mov	bx,ax
06307                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06308                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06309 19B0           81C3                 0126  add	bx,#$126
06310 19B4           53                         push	bx
06311                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06312 19B5           FF76         FE            push	-2[bp]
06313                                           ! Debug: func () void = write_word+0 (used reg = )
06314 19B8           E8         EC7B            call	_write_word
06315 19BB           83C4                   06  add	sp,*6
06316                                           !BCC_EOS
06317                                           ! 1438     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06318                                           ! Debug: list int = const 0 (used reg = )
06319 19BE           31C0                       xor	ax,ax
06320 19C0           50                         push	ax
06321                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06322 19C1           8A46         FD            mov	al,-3[bp]
06323 19C4           30E4                       xor	ah,ah
06324 19C6           B1                     03  mov	cl,*3
06325 19C8           D3E0                       shl	ax,cl
06326 19CA           89C3                       mov	bx,ax
06327                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06328                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06329 19CC           81C3                 0128  add	bx,#$128
06330 19D0           53                         push	bx
06331                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06332 19D1           FF76         FE            push	-2[bp]
06333                                           ! Debug: func () void = write_byte+0 (used reg = )
06334 19D4           E8         EC47            call	_write_byte
06335 19D7           83C4                   06  add	sp,*6
06336                                           !BCC_EOS
06337                                           ! 1439   }
06338                                           ! 1440   for (device=0; device<(4*2); device++) {
06339                       000019DA            .165:
06340                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06341 19DA           8A46         FD            mov	al,-3[bp]
06342 19DD           40                         inc	ax
06343 19DE           8846         FD            mov	-3[bp],al
06344                       000019E1            .166:
06345                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06346 19E1           8A46         FD            mov	al,-3[bp]
06347 19E4           3C                     04  cmp	al,*4
06348 19E6           72           82            jb 	.167
06349                       000019E8            .168:
06350                       000019E8            .164:
06351                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06352 19E8           30C0                       xor	al,al
06353 19EA           8846         FC            mov	-4[bp],al
06354                                           !BCC_EOS
06355                                           !BCC_EOS
06356 19ED           E9         01C0            br 	.16B
06357                       000019F0            .16C:
06358                                           ! 1441     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06359                                           ! Debug: list int = const 0 (used reg = )
06360 19F0           31C0                       xor	ax,ax
06361 19F2           50                         push	ax
06362                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06363 19F3           8A46         FC            mov	al,-4[bp]
06364 19F6           30E4                       xor	ah,ah
06365 19F8           B9                   001E  mov	cx,*$1E
06366 19FB           F7E9                       imul	cx
06367 19FD           89C3                       mov	bx,ax
06368                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06369                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06370 19FF           81C3                 0142  add	bx,#$142
06371 1A03           53                         push	bx
06372                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06373 1A04           FF76         FE            push	-2[bp]
06374                                           ! Debug: func () void = write_byte+0 (used reg = )
06375 1A07           E8         EC14            call	_write_byte
06376 1A0A           83C4                   06  add	sp,*6
06377                                           !BCC_EOS
06378                                           ! 1442     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06379                                           ! Debug: list int = const 0 (used reg = )
06380 1A0D           31C0                       xor	ax,ax
06381 1A0F           50                         push	ax
06382                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06383 1A10           8A46         FC            mov	al,-4[bp]
06384 1A13           30E4                       xor	ah,ah
06385 1A15           B9                   001E  mov	cx,*$1E
06386 1A18           F7E9                       imul	cx
06387 1A1A           89C3                       mov	bx,ax
06388                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06389                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06390 1A1C           81C3                 0143  add	bx,#$143
06391 1A20           53                         push	bx
06392                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06393 1A21           FF76         FE            push	-2[bp]
06394                                           ! Debug: func () void = write_byte+0 (used reg = )
06395 1A24           E8         EBF7            call	_write_byte
06396 1A27           83C4                   06  add	sp,*6
06397                                           !BCC_EOS
06398                                           ! 1443     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06399                                           ! Debug: list int = const 0 (used reg = )
06400 1A2A           31C0                       xor	ax,ax
06401 1A2C           50                         push	ax
06402                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06403 1A2D           8A46         FC            mov	al,-4[bp]
06404 1A30           30E4                       xor	ah,ah
06405 1A32           B9                   001E  mov	cx,*$1E
06406 1A35           F7E9                       imul	cx
06407 1A37           89C3                       mov	bx,ax
06408                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06409                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06410 1A39           81C3                 0144  add	bx,#$144
06411 1A3D           53                         push	bx
06412                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06413 1A3E           FF76         FE            push	-2[bp]
06414                                           ! Debug: func () void = write_byte+0 (used reg = )
06415 1A41           E8         EBDA            call	_write_byte
06416 1A44           83C4                   06  add	sp,*6
06417                                           !BCC_EOS
06418                                           ! 1444     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06419                                           ! Debug: list int = const 0 (used reg = )
06420 1A47           31C0                       xor	ax,ax
06421 1A49           50                         push	ax
06422                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06423 1A4A           8A46         FC            mov	al,-4[bp]
06424 1A4D           30E4                       xor	ah,ah
06425 1A4F           B9                   001E  mov	cx,*$1E
06426 1A52           F7E9                       imul	cx
06427 1A54           89C3                       mov	bx,ax
06428                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06429                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06430 1A56           81C3                 0145  add	bx,#$145
06431 1A5A           53                         push	bx
06432                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06433 1A5B           FF76         FE            push	-2[bp]
06434                                           ! Debug: func () void = write_byte+0 (used reg = )
06435 1A5E           E8         EBBD            call	_write_byte
06436 1A61           83C4                   06  add	sp,*6
06437                                           !BCC_EOS
06438                                           ! 1445     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06439                                           ! Debug: list int = const 0 (used reg = )
06440 1A64           31C0                       xor	ax,ax
06441 1A66           50                         push	ax
06442                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06443 1A67           8A46         FC            mov	al,-4[bp]
06444 1A6A           30E4                       xor	ah,ah
06445 1A6C           B9                   001E  mov	cx,*$1E
06446 1A6F           F7E9                       imul	cx
06447 1A71           89C3                       mov	bx,ax
06448                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06449                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06450 1A73           81C3                 0146  add	bx,#$146
06451 1A77           53                         push	bx
06452                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06453 1A78           FF76         FE            push	-2[bp]
06454                                           ! Debug: func () void = write_byte+0 (used reg = )
06455 1A7B           E8         EBA0            call	_write_byte
06456 1A7E           83C4                   06  add	sp,*6
06457                                           !BCC_EOS
06458                                           ! 1446     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06459                                           ! Debug: list int = const 0 (used reg = )
06460 1A81           31C0                       xor	ax,ax
06461 1A83           50                         push	ax
06462                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06463 1A84           8A46         FC            mov	al,-4[bp]
06464 1A87           30E4                       xor	ah,ah
06465 1A89           B9                   001E  mov	cx,*$1E
06466 1A8C           F7E9                       imul	cx
06467 1A8E           89C3                       mov	bx,ax
06468                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06469                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06470 1A90           81C3                 0148  add	bx,#$148
06471 1A94           53                         push	bx
06472                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06473 1A95           FF76         FE            push	-2[bp]
06474                                           ! Debug: func () void = write_word+0 (used reg = )
06475 1A98           E8         EB9B            call	_write_word
06476 1A9B           83C4                   06  add	sp,*6
06477                                           !BCC_EOS
06478                                           ! 1447     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06479                                           ! Debug: list int = const 0 (used reg = )
06480 1A9E           31C0                       xor	ax,ax
06481 1AA0           50                         push	ax
06482                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06483 1AA1           8A46         FC            mov	al,-4[bp]
06484 1AA4           30E4                       xor	ah,ah
06485 1AA6           B9                   001E  mov	cx,*$1E
06486 1AA9           F7E9                       imul	cx
06487 1AAB           89C3                       mov	bx,ax
06488                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06489                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06490 1AAD           81C3                 014A  add	bx,#$14A
06491 1AB1           53                         push	bx
06492                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06493 1AB2           FF76         FE            push	-2[bp]
06494                                           ! Debug: func () void = write_byte+0 (used reg = )
06495 1AB5           E8         EB66            call	_write_byte
06496 1AB8           83C4                   06  add	sp,*6
06497                                           !BCC_EOS
06498                                           ! 1448     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06499                                           ! Debug: list int = const 0 (used reg = )
06500 1ABB           31C0                       xor	ax,ax
06501 1ABD           50                         push	ax
06502                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06503 1ABE           8A46         FC            mov	al,-4[bp]
06504 1AC1           30E4                       xor	ah,ah
06505 1AC3           B9                   001E  mov	cx,*$1E
06506 1AC6           F7E9                       imul	cx
06507 1AC8           89C3                       mov	bx,ax
06508                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06509                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06510 1ACA           81C3                 014C  add	bx,#$14C
06511 1ACE           53                         push	bx
06512                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06513 1ACF           FF76         FE            push	-2[bp]
06514                                           ! Debug: func () void = write_word+0 (used reg = )
06515 1AD2           E8         EB61            call	_write_word
06516 1AD5           83C4                   06  add	sp,*6
06517                                           !BCC_EOS
06518                                           ! 1449     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
06519                                           ! Debug: list int = const 0 (used reg = )
06520 1AD8           31C0                       xor	ax,ax
06521 1ADA           50                         push	ax
06522                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06523 1ADB           8A46         FC            mov	al,-4[bp]
06524 1ADE           30E4                       xor	ah,ah
06525 1AE0           B9                   001E  mov	cx,*$1E
06526 1AE3           F7E9                       imul	cx
06527 1AE5           89C3                       mov	bx,ax
06528                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06529                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06530 1AE7           81C3                 014E  add	bx,#$14E
06531 1AEB           53                         push	bx
06532                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06533 1AEC           FF76         FE            push	-2[bp]
06534                                           ! Debug: func () void = write_word+0 (used reg = )
06535 1AEF           E8         EB44            call	_write_word
06536 1AF2           83C4                   06  add	sp,*6
06537                                           !BCC_EOS
06538                                           ! 1450     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06539                                           ! Debug: list int = const 0 (used reg = )
06540 1AF5           31C0                       xor	ax,ax
06541 1AF7           50                         push	ax
06542                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06543 1AF8           8A46         FC            mov	al,-4[bp]
06544 1AFB           30E4                       xor	ah,ah
06545 1AFD           B9                   001E  mov	cx,*$1E
06546 1B00           F7E9                       imul	cx
06547 1B02           89C3                       mov	bx,ax
06548                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06549                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06550 1B04           81C3                 0150  add	bx,#$150
06551 1B08           53                         push	bx
06552                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06553 1B09           FF76         FE            push	-2[bp]
06554                                           ! Debug: func () void = write_word+0 (used reg = )
06555 1B0C           E8         EB27            call	_write_word
06556 1B0F           83C4                   06  add	sp,*6
06557                                           !BCC_EOS
06558                                           ! 1451     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06559                                           ! Debug: list int = const 0 (used reg = )
06560 1B12           31C0                       xor	ax,ax
06561 1B14           50                         push	ax
06562                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06563 1B15           8A46         FC            mov	al,-4[bp]
06564 1B18           30E4                       xor	ah,ah
06565 1B1A           B9                   001E  mov	cx,*$1E
06566 1B1D           F7E9                       imul	cx
06567 1B1F           89C3                       mov	bx,ax
06568                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06569                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06570 1B21           81C3                 0152  add	bx,#$152
06571 1B25           53                         push	bx
06572                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06573 1B26           FF76         FE            push	-2[bp]
06574                                           ! Debug: func () void = write_word+0 (used reg = )
06575 1B29           E8         EB0A            call	_write_word
06576 1B2C           83C4                   06  add	sp,*6
06577                                           !BCC_EOS
06578                                           ! 1452     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06579                                           ! Debug: list int = const 0 (used reg = )
06580 1B2F           31C0                       xor	ax,ax
06581 1B31           50                         push	ax
06582                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06583 1B32           8A46         FC            mov	al,-4[bp]
06584 1B35           30E4                       xor	ah,ah
06585 1B37           B9                   001E  mov	cx,*$1E
06586 1B3A           F7E9                       imul	cx
06587 1B3C           89C3                       mov	bx,ax
06588                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06589                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06590 1B3E           81C3                 0154  add	bx,#$154
06591 1B42           53                         push	bx
06592                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06593 1B43           FF76         FE            push	-2[bp]
06594                                           ! Debug: func () void = write_word+0 (used reg = )
06595 1B46           E8         EAED            call	_write_word
06596 1B49           83C4                   06  add	sp,*6
06597                                           !BCC_EOS
06598                                           ! 1453     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06599                                           ! Debug: list int = const 0 (used reg = )
06600 1B4C           31C0                       xor	ax,ax
06601 1B4E           50                         push	ax
06602                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06603 1B4F           8A46         FC            mov	al,-4[bp]
06604 1B52           30E4                       xor	ah,ah
06605 1B54           B9                   001E  mov	cx,*$1E
06606 1B57           F7E9                       imul	cx
06607 1B59           89C3                       mov	bx,ax
06608                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06609                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06610 1B5B           81C3                 0156  add	bx,#$156
06611 1B5F           53                         push	bx
06612                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06613 1B60           FF76         FE            push	-2[bp]
06614                                           ! Debug: func () void = write_word+0 (used reg = )
06615 1B63           E8         EAD0            call	_write_word
06616 1B66           83C4                   06  add	sp,*6
06617                                           !BCC_EOS
06618                                           ! 1454     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06619                                           ! Debug: list long = const 0 (used reg = )
06620 1B69           31C0                       xor	ax,ax
06621 1B6B           31DB                       xor	bx,bx
06622 1B6D           53                         push	bx
06623 1B6E           50                         push	ax
06624                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06625 1B6F           8A46         FC            mov	al,-4[bp]
06626 1B72           30E4                       xor	ah,ah
06627 1B74           B9                   001E  mov	cx,*$1E
06628 1B77           F7E9                       imul	cx
06629 1B79           89C3                       mov	bx,ax
06630                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06631                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06632 1B7B           81C3                 0158  add	bx,#$158
06633 1B7F           53                         push	bx
06634                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06635 1B80           FF76         FE            push	-2[bp]
06636                                           ! Debug: func () void = write_dword+0 (used reg = )
06637 1B83           E8         E515            call	_write_dword
06638 1B86           83C4                   08  add	sp,*8
06639                                           !BCC_EOS
06640                                           ! 1455     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06641                                           ! Debug: list long = const 0 (used reg = )
06642 1B89           31C0                       xor	ax,ax
06643 1B8B           31DB                       xor	bx,bx
06644 1B8D           53                         push	bx
06645 1B8E           50                         push	ax
06646                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06647 1B8F           8A46         FC            mov	al,-4[bp]
06648 1B92           30E4                       xor	ah,ah
06649 1B94           B9                   001E  mov	cx,*$1E
06650 1B97           F7E9                       imul	cx
06651 1B99           89C3                       mov	bx,ax
06652                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06653                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06654 1B9B           81C3                 015C  add	bx,#$15C
06655 1B9F           53                         push	bx
06656                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06657 1BA0           FF76         FE            push	-2[bp]
06658                                           ! Debug: func () void = write_dword+0 (used reg = )
06659 1BA3           E8         E4F5            call	_write_dword
06660 1BA6           83C4                   08  add	sp,*8
06661                                           !BCC_EOS
06662                                           ! 1456   }
06663                                           ! 1457   for (device=0; device<(4*2); device++) {
06664                       00001BA9            .16A:
06665                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06666 1BA9           8A46         FC            mov	al,-4[bp]
06667 1BAC           40                         inc	ax
06668 1BAD           8846         FC            mov	-4[bp],al
06669                       00001BB0            .16B:
06670                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06671 1BB0           8A46         FC            mov	al,-4[bp]
06672 1BB3           3C                     08  cmp	al,*8
06673 1BB5         0F82         FE37            blo 	.16C
06674                       00001BB9            .16D:
06675                       00001BB9            .169:
06676                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06677 1BB9           30C0                       xor	al,al
06678 1BBB           8846         FC            mov	-4[bp],al
06679                                           !BCC_EOS
06680                                           !BCC_EOS
06681 1BBE           EB           39            jmp .170
06682                       00001BC0            .171:
06683                                           ! 1458     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06684                                           ! Debug: list int = const 8 (used reg = )
06685 1BC0           B8                   0008  mov	ax,*8
06686 1BC3           50                         push	ax
06687                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06688 1BC4           8A46         FC            mov	al,-4[bp]
06689 1BC7           30E4                       xor	ah,ah
06690 1BC9           89C3                       mov	bx,ax
06691                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06692                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06693 1BCB           81C3                 0233  add	bx,#$233
06694 1BCF           53                         push	bx
06695                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06696 1BD0           FF76         FE            push	-2[bp]
06697                                           ! Debug: func () void = write_byte+0 (used reg = )
06698 1BD3           E8         EA48            call	_write_byte
06699 1BD6           83C4                   06  add	sp,*6
06700                                           !BCC_EOS
06701                                           ! 1459     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06702                                           ! Debug: list int = const 8 (used reg = )
06703 1BD9           B8                   0008  mov	ax,*8
06704 1BDC           50                         push	ax
06705                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06706 1BDD           8A46         FC            mov	al,-4[bp]
06707 1BE0           30E4                       xor	ah,ah
06708 1BE2           89C3                       mov	bx,ax
06709                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06710                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06711 1BE4           81C3                 023C  add	bx,#$23C
06712 1BE8           53                         push	bx
06713                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06714 1BE9           FF76         FE            push	-2[bp]
06715                                           ! Debug: func () void = write_byte+0 (used reg = )
06716 1BEC           E8         EA2F            call	_write_byte
06717 1BEF           83C4                   06  add	sp,*6
06718                                           !BCC_EOS
06719                                           ! 1460   }
06720                                           ! 1461   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06721                       00001BF2            .16F:
06722                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06723 1BF2           8A46         FC            mov	al,-4[bp]
06724 1BF5           40                         inc	ax
06725 1BF6           8846         FC            mov	-4[bp],al
06726                       00001BF9            .170:
06727                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06728 1BF9           8A46         FC            mov	al,-4[bp]
06729 1BFC           3C                     08  cmp	al,*8
06730 1BFE           72           C0            jb 	.171
06731                       00001C00            .172:
06732                       00001C00            .16E:
06733                                           ! Debug: list int = const 0 (used reg = )
06734 1C00           31C0                       xor	ax,ax
06735 1C02           50                         push	ax
06736                                           ! Debug: list * unsigned char = const $232 (used reg = )
06737 1C03           B8                   0232  mov	ax,#$232
06738 1C06           50                         push	ax
06739                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06740 1C07           FF76         FE            push	-2[bp]
06741                                           ! Debug: func () void = write_byte+0 (used reg = )
06742 1C0A           E8         EA11            call	_write_byte
06743 1C0D           83C4                   06  add	sp,*6
06744                                           !BCC_EOS
06745                                           ! 1462   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06746                                           ! Debug: list int = const 0 (used reg = )
06747 1C10           31C0                       xor	ax,ax
06748 1C12           50                         push	ax
06749                                           ! Debug: list * unsigned char = const $23B (used reg = )
06750 1C13           B8                   023B  mov	ax,#$23B
06751 1C16           50                         push	ax
06752                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06753 1C17           FF76         FE            push	-2[bp]
06754                                           ! Debug: func () void = write_byte+0 (used reg = )
06755 1C1A           E8         EA01            call	_write_byte
06756 1C1D           83C4                   06  add	sp,*6
06757                                           !BCC_EOS
06758                                           ! 1463 }
06759 1C20           89EC                       mov	sp,bp
06760 1C22           5D                         pop	bp
06761 1C23           C3                         ret
06762                                           ! 1464 int await_ide();
06763                                           ! Register BX used in function ata_init
06764                                           !BCC_EOS
06765                                           ! 1465 static int await_ide(when_done,base,timeout)
06766                                           ! 1466   Bit8u when_done;
06767                       00001C24            _await_ide:
06768                                           !BCC_EOS
06769                                           ! 1467   Bit16u base;
06770                                           !BCC_EOS
06771                                           ! 1468   Bit16u timeout;
06772                                           !BCC_EOS
06773                                           ! 1469 {
06774                                           ! 1470   Bit32u time=0,last=0;
06775 1C24           55                         push	bp
06776 1C25           89E5                       mov	bp,sp
06777 1C27           83C4                   FC  add	sp,*-4
06778                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06779 1C2A           31C0                       xor	ax,ax
06780 1C2C           31DB                       xor	bx,bx
06781 1C2E           8946         FC            mov	-4[bp],ax
06782 1C31           895E         FE            mov	-2[bp],bx
06783 1C34           83C4                   FC  add	sp,*-4
06784                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
06785 1C37           31C0                       xor	ax,ax
06786 1C39           31DB                       xor	bx,bx
06787 1C3B           8946         F8            mov	-8[bp],ax
06788 1C3E           895E         FA            mov	-6[bp],bx
06789                                           !BCC_EOS
06790                                           ! 1471   Bit16u status;
06791                                           !BCC_EOS
06792                                           ! 1472   Bit8u result;
06793                                           !BCC_EOS
06794                                           ! 1473   status = inb(base + 7);
06795 1C41           83C4                   FC  add	sp,*-4
06796                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
06797 1C44           8B46         06            mov	ax,6[bp]
06798                                           ! Debug: list unsigned int = ax+7 (used reg = )
06799 1C47           05                   0007  add	ax,*7
06800 1C4A           50                         push	ax
06801                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06802 1C4B           E8         E8F4            call	_inb
06803 1C4E           44                         inc	sp
06804 1C4F           44                         inc	sp
06805                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
06806 1C50           30E4                       xor	ah,ah
06807 1C52           8946         F6            mov	-$A[bp],ax
06808                                           !BCC_EOS
06809                                           ! 1474   for(;;) {
06810                                           !BCC_EOS
06811                                           !BCC_EOS
06812                       00001C55            .175:
06813                                           ! 1475     status = inb(base+7);
06814                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
06815 1C55           8B46         06            mov	ax,6[bp]
06816                                           ! Debug: list unsigned int = ax+7 (used reg = )
06817 1C58           05                   0007  add	ax,*7
06818 1C5B           50                         push	ax
06819                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06820 1C5C           E8         E8E3            call	_inb
06821 1C5F           44                         inc	sp
06822 1C60           44                         inc	sp
06823                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
06824 1C61           30E4                       xor	ah,ah
06825 1C63           8946         F6            mov	-$A[bp],ax
06826                                           !BCC_EOS
06827                                           ! 1476     time++;
06828                                           ! 1476 
06829                                           ! Debug: postinc unsigned long time = [S+$E-6] (used reg = )
06830 1C66           8B46         FC            mov	ax,-4[bp]
06831 1C69           8B76         FE            mov	si,-2[bp]
06832 1C6C           8D5E         FC            lea	bx,-4[bp]
06833 1C6F           E8         E49D            call	lincl
06834                                           !BCC_EOS
06835                                           ! 1477     if (when_done == 1)
06836                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$E+2] (used reg = )
06837 1C72           8A46         04            mov	al,4[bp]
06838 1C75           3C                     01  cmp	al,*1
06839 1C77           75           0B            jne 	.176
06840                       00001C79            .177:
06841                                           ! 1478       result = status & 0x80;
06842                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06843 1C79           8A46         F6            mov	al,-$A[bp]
06844 1C7C           24                     80  and	al,#$80
06845                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06846 1C7E           8846         F5            mov	-$B[bp],al
06847                                           !BCC_EOS
06848                                           ! 1479     else if (when_done == 2)
06849 1C81           E9         0094            br 	.178
06850                       00001C84            .176:
06851                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$E+2] (used reg = )
06852 1C84           8A46         04            mov	al,4[bp]
06853 1C87           3C                     02  cmp	al,*2
06854 1C89           75           15            jne 	.179
06855                       00001C8B            .17A:
06856                                           ! 1480       result = !(status & 0x80);
06857                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06858 1C8B           8A46         F6            mov	al,-$A[bp]
06859 1C8E           24                     80  and	al,#$80
06860 1C90           84C0                       test	al,al
06861 1C92           75           04            jne 	.17B
06862                       00001C94            .17C:
06863 1C94           B0                     01  mov	al,*1
06864 1C96           EB           02            jmp	.17D
06865                       00001C98            .17B:
06866 1C98           30C0                       xor	al,al
06867                       00001C9A            .17D:
06868                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06869 1C9A           8846         F5            mov	-$B[bp],al
06870                                           !BCC_EOS
06871                                           ! 1481     else if (when_done == 3)
06872 1C9D           E9         0078            br 	.17E
06873                       00001CA0            .179:
06874                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$E+2] (used reg = )
06875 1CA0           8A46         04            mov	al,4[bp]
06876 1CA3           3C                     03  cmp	al,*3
06877 1CA5           75           1D            jne 	.17F
06878                       00001CA7            .180:
06879                                           ! 1482       result = !(status & 0x80) && (status & 0x08);
06880                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06881 1CA7           8A46         F6            mov	al,-$A[bp]
06882 1CAA           24                     80  and	al,#$80
06883 1CAC           84C0                       test	al,al
06884 1CAE           75           0D            jne 	.181
06885                       00001CB0            .183:
06886                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
06887 1CB0           8A46         F6            mov	al,-$A[bp]
06888 1CB3           24                     08  and	al,*8
06889 1CB5           84C0                       test	al,al
06890 1CB7           74           04            je  	.181
06891                       00001CB9            .182:
06892 1CB9           B0                     01  mov	al,*1
06893 1CBB           EB           02            jmp	.184
06894                       00001CBD            .181:
06895 1CBD           30C0                       xor	al,al
06896                       00001CBF            .184:
06897                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06898 1CBF           8846         F5            mov	-$B[bp],al
06899                                           !BCC_EOS
06900                                           ! 1483     else if (when_done == 4)
06901 1CC2           EB           54            jmp .185
06902                       00001CC4            .17F:
06903                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$E+2] (used reg = )
06904 1CC4           8A46         04            mov	al,4[bp]
06905 1CC7           3C                     04  cmp	al,*4
06906 1CC9           75           1D            jne 	.186
06907                       00001CCB            .187:
06908                                           ! 1484       result = !(status & 0x80) && !(status & 0x08);
06909                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06910 1CCB           8A46         F6            mov	al,-$A[bp]
06911 1CCE           24                     80  and	al,#$80
06912 1CD0           84C0                       test	al,al
06913 1CD2           75           0D            jne 	.188
06914                       00001CD4            .18A:
06915                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
06916 1CD4           8A46         F6            mov	al,-$A[bp]
06917 1CD7           24                     08  and	al,*8
06918 1CD9           84C0                       test	al,al
06919 1CDB           75           04            jne 	.188
06920                       00001CDD            .189:
06921 1CDD           B0                     01  mov	al,*1
06922 1CDF           EB           02            jmp	.18B
06923                       00001CE1            .188:
06924 1CE1           30C0                       xor	al,al
06925                       00001CE3            .18B:
06926                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06927 1CE3           8846         F5            mov	-$B[bp],al
06928                                           !BCC_EOS
06929                                           ! 1485     else if (when_done == 5)
06930 1CE6           EB           30            jmp .18C
06931                       00001CE8            .186:
06932                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$E+2] (used reg = )
06933 1CE8           8A46         04            mov	al,4[bp]
06934 1CEB           3C                     05  cmp	al,*5
06935 1CED           75           1D            jne 	.18D
06936                       00001CEF            .18E:
06937                                           ! 1486       result = !(status & 0x80) && (status & 0x40);
06938                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06939 1CEF           8A46         F6            mov	al,-$A[bp]
06940 1CF2           24                     80  and	al,#$80
06941 1CF4           84C0                       test	al,al
06942 1CF6           75           0D            jne 	.18F
06943                       00001CF8            .191:
06944                                           ! Debug: and int = const $40 to unsigned short status = [S+$E-$C] (used reg = )
06945 1CF8           8A46         F6            mov	al,-$A[bp]
06946 1CFB           24                     40  and	al,*$40
06947 1CFD           84C0                       test	al,al
06948 1CFF           74           04            je  	.18F
06949                       00001D01            .190:
06950 1D01           B0                     01  mov	al,*1
06951 1D03           EB           02            jmp	.192
06952                       00001D05            .18F:
06953 1D05           30C0                       xor	al,al
06954                       00001D07            .192:
06955                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06956 1D07           8846         F5            mov	-$B[bp],al
06957                                           !BCC_EOS
06958                                           ! 1487     else if (when_done == 0)
06959 1D0A           EB           0C            jmp .193
06960                       00001D0C            .18D:
06961                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$E+2] (used reg = )
06962 1D0C           8A46         04            mov	al,4[bp]
06963 1D0F           84C0                       test	al,al
06964 1D11           75           05            jne 	.194
06965                       00001D13            .195:
06966                                           ! 1488       result = 0;
06967                                           ! Debug: eq int = const 0 to unsigned char result = [S+$E-$D] (used reg = )
06968 1D13           30C0                       xor	al,al
06969 1D15           8846         F5            mov	-$B[bp],al
06970                                           !BCC_EOS
06971                                           ! 1489     if (result) return 0;
06972                       00001D18            .194:
06973                       00001D18            .193:
06974                       00001D18            .18C:
06975                       00001D18            .185:
06976                       00001D18            .17E:
06977                       00001D18            .178:
06978 1D18           8A46         F5            mov	al,-$B[bp]
06979 1D1B           84C0                       test	al,al
06980 1D1D           74           06            je  	.196
06981                       00001D1F            .197:
06982 1D1F           31C0                       xor	ax,ax
06983 1D21           89EC                       mov	sp,bp
06984 1D23           5D                         pop	bp
06985 1D24           C3                         ret
06986                                           !BCC_EOS
06987                                           ! 1490     if (time>>16 != last)
06988                       00001D25            .196:
06989                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
06990 1D25           8B46         FC            mov	ax,-4[bp]
06991 1D28           8B5E         FE            mov	bx,-2[bp]
06992 1D2B           93                         xchg	bx,ax
06993 1D2C           31DB                       xor	bx,bx
06994                                           ! Debug: ne unsigned long last = [S+$E-$A] to unsigned long = bx+0 (used reg = )
06995 1D2E           8D7E         F8            lea	di,-8[bp]
06996 1D31           E8         E397            call	lcmpul
06997 1D34           74           0F            je  	.198
06998                       00001D36            .199:
06999                                           ! 1491     {
07000                                           ! 1492       last = time >>16;
07001                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
07002 1D36           8B46         FC            mov	ax,-4[bp]
07003 1D39           8B5E         FE            mov	bx,-2[bp]
07004 1D3C           93                         xchg	bx,ax
07005 1D3D           31DB                       xor	bx,bx
07006                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$E-$A] (used reg = )
07007 1D3F           8946         F8            mov	-8[bp],ax
07008 1D42           895E         FA            mov	-6[bp],bx
07009                                           !BCC_EOS
07010                                           ! 1493       ;
07011                                           !BCC_EOS
07012                                           ! 1494     }
07013                                           ! 1495     if (status & 0x01)
07014                       00001D45            .198:
07015                                           ! Debug: and int = const 1 to unsigned short status = [S+$E-$C] (used reg = )
07016 1D45           8A46         F6            mov	al,-$A[bp]
07017 1D48           24                     01  and	al,*1
07018 1D4A           84C0                       test	al,al
07019 1D4C           74           07            je  	.19A
07020                       00001D4E            .19B:
07021                                           ! 1496     {
07022                                           ! 1497       ;
07023                                           !BCC_EOS
07024                                           ! 1498       return -1;
07025 1D4E           B8                   FFFF  mov	ax,*-1
07026 1D51           89EC                       mov	sp,bp
07027 1D53           5D                         pop	bp
07028 1D54           C3                         ret
07029                                           !BCC_EOS
07030                                           ! 1499     }
07031                                           ! 1500     if ((timeout == 0) || ((time>>11) > timeout)) break;
07032                       00001D55            .19A:
07033                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07034 1D55           8B46         08            mov	ax,8[bp]
07035 1D58           85C0                       test	ax,ax
07036 1D5A           74           26            je  	.19D
07037                       00001D5C            .19E:
07038                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07039 1D5C           8B46         08            mov	ax,8[bp]
07040 1D5F           31DB                       xor	bx,bx
07041 1D61           53                         push	bx
07042 1D62           50                         push	ax
07043                                           ! Debug: sr int = const $B to unsigned long time = [S+$12-6] (used reg = )
07044 1D63           8B46         FC            mov	ax,-4[bp]
07045 1D66           8B5E         FE            mov	bx,-2[bp]
07046 1D69           88E0                       mov	al,ah
07047 1D6B           88DC                       mov	ah,bl
07048 1D6D           88FB                       mov	bl,bh
07049 1D6F           28FF                       sub	bh,bh
07050 1D71           BF                   0003  mov	di,*3
07051 1D74           E8         E3B2            call	lsrul
07052                                           ! Debug: gt unsigned long (temp) = [S+$12-$12] to unsigned long = bx+0 (used reg = )
07053 1D77           8D7E         F0            lea	di,-$10[bp]
07054 1D7A           E8         E34E            call	lcmpul
07055 1D7D           8D66         F4            lea	sp,-$C[bp]
07056 1D80           76           02            jbe 	.19C
07057                       00001D82            .19D:
07058 1D82           EB           03            jmp .173
07059                                           !BCC_EOS
07060                                           ! 1501   }
07061                       00001D84            .19C:
07062                                           ! 1502   bios_printf(4, "IDE time out\n");
07063                       00001D84            .174:
07064 1D84           E9         FECE            br 	.175
07065                       00001D87            .173:
07066                                           ! Debug: list * char = .19F+0 (used reg = )
07067 1D87           BB                   D7E8  mov	bx,#.19F
07068 1D8A           53                         push	bx
07069                                           ! Debug: list int = const 4 (used reg = )
07070 1D8B           B8                   0004  mov	ax,*4
07071 1D8E           50                         push	ax
07072                                           ! Debug: func () void = bios_printf+0 (used reg = )
07073 1D8F           E8         EC15            call	_bios_printf
07074 1D92           83C4                   04  add	sp,*4
07075                                           !BCC_EOS
07076                                           ! 1503   return -1;
07077 1D95           B8                   FFFF  mov	ax,*-1
07078 1D98           89EC                       mov	sp,bp
07079 1D9A           5D                         pop	bp
07080 1D9B           C3                         ret
07081                                           !BCC_EOS
07082                                           ! 1504 }
07083                                           ! 1505 void ata_detect( )
07084                                           ! Register BX used in function await_ide
07085                                           ! 1506 {
07086                                           export	_ata_detect
07087                       00001D9C            _ata_detect:
07088                                           ! 1507   Bit16u ebda_seg=read_word(0x0040,0x000E);
07089 1D9C           55                         push	bp
07090 1D9D           89E5                       mov	bp,sp
07091 1D9F           4C                         dec	sp
07092 1DA0           4C                         dec	sp
07093                                           ! Debug: list int = const $E (used reg = )
07094 1DA1           B8                   000E  mov	ax,*$E
07095 1DA4           50                         push	ax
07096                                           ! Debug: list int = const $40 (used reg = )
07097 1DA5           B8                   0040  mov	ax,*$40
07098 1DA8           50                         push	ax
07099                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07100 1DA9           E8         E85F            call	_read_word
07101 1DAC           83C4                   04  add	sp,*4
07102                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07103 1DAF           8946         FE            mov	-2[bp],ax
07104                                           !BCC_EOS
07105                                           ! 1508   Bit8u hdcount, cdcount, device, type;
07106                                           !BCC_EOS
07107                                           ! 1509   Bit8u buffer[0x0200];
07108                                           !BCC_EOS
07109                                           ! 1510   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07110 1DB2           81C4                 FDFC  add	sp,#-$204
07111                                           ! Debug: list int = const 0 (used reg = )
07112 1DB6           31C0                       xor	ax,ax
07113 1DB8           50                         push	ax
07114                                           ! Debug: list * unsigned char = const $122 (used reg = )
07115 1DB9           B8                   0122  mov	ax,#$122
07116 1DBC           50                         push	ax
07117                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07118 1DBD           FF76         FE            push	-2[bp]
07119                                           ! Debug: func () void = write_byte+0 (used reg = )
07120 1DC0           E8         E85B            call	_write_byte
07121 1DC3           83C4                   06  add	sp,*6
07122                                           !BCC_EOS
07123                                           ! 1511   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07124                                           ! Debug: list int = const $1F0 (used reg = )
07125 1DC6           B8                   01F0  mov	ax,#$1F0
07126 1DC9           50                         push	ax
07127                                           ! Debug: list * unsigned short = const $124 (used reg = )
07128 1DCA           B8                   0124  mov	ax,#$124
07129 1DCD           50                         push	ax
07130                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07131 1DCE           FF76         FE            push	-2[bp]
07132                                           ! Debug: func () void = write_word+0 (used reg = )
07133 1DD1           E8         E862            call	_write_word
07134 1DD4           83C4                   06  add	sp,*6
07135                                           !BCC_EOS
07136                                           ! 1512   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
07137                                           ! Debug: list int = const $3F0 (used reg = )
07138 1DD7           B8                   03F0  mov	ax,#$3F0
07139 1DDA           50                         push	ax
07140                                           ! Debug: list * unsigned short = const $126 (used reg = )
07141 1DDB           B8                   0126  mov	ax,#$126
07142 1DDE           50                         push	ax
07143                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07144 1DDF           FF76         FE            push	-2[bp]
07145                                           ! Debug: func () void = write_word+0 (used reg = )
07146 1DE2           E8         E851            call	_write_word
07147 1DE5           83C4                   06  add	sp,*6
07148                                           !BCC_EOS
07149                                           ! 1513   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07150                                           ! Debug: list int = const $E (used reg = )
07151 1DE8           B8                   000E  mov	ax,*$E
07152 1DEB           50                         push	ax
07153                                           ! Debug: list * unsigned char = const $128 (used reg = )
07154 1DEC           B8                   0128  mov	ax,#$128
07155 1DEF           50                         push	ax
07156                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07157 1DF0           FF76         FE            push	-2[bp]
07158                                           ! Debug: func () void = write_byte+0 (used reg = )
07159 1DF3           E8         E828            call	_write_byte
07160 1DF6           83C4                   06  add	sp,*6
07161                                           !BCC_EOS
07162                                           ! 1514   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
07163                                           ! Debug: list int = const 0 (used reg = )
07164 1DF9           31C0                       xor	ax,ax
07165 1DFB           50                         push	ax
07166                                           ! Debug: list * unsigned char = const $12A (used reg = )
07167 1DFC           B8                   012A  mov	ax,#$12A
07168 1DFF           50                         push	ax
07169                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07170 1E00           FF76         FE            push	-2[bp]
07171                                           ! Debug: func () void = write_byte+0 (used reg = )
07172 1E03           E8         E818            call	_write_byte
07173 1E06           83C4                   06  add	sp,*6
07174                                           !BCC_EOS
07175                                           ! 1515   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07176                                           ! Debug: list int = const $170 (used reg = )
07177 1E09           B8                   0170  mov	ax,#$170
07178 1E0C           50                         push	ax
07179                                           ! Debug: list * unsigned short = const $12C (used reg = )
07180 1E0D           B8                   012C  mov	ax,#$12C
07181 1E10           50                         push	ax
07182                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07183 1E11           FF76         FE            push	-2[bp]
07184                                           ! Debug: func () void = write_word+0 (used reg = )
07185 1E14           E8         E81F            call	_write_word
07186 1E17           83C4                   06  add	sp,*6
07187                                           !BCC_EOS
07188                                           ! 1516   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07189                                           ! Debug: list int = const $370 (used reg = )
07190 1E1A           B8                   0370  mov	ax,#$370
07191 1E1D           50                         push	ax
07192                                           ! Debug: list * unsigned short = const $12E (used reg = )
07193 1E1E           B8                   012E  mov	ax,#$12E
07194 1E21           50                         push	ax
07195                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07196 1E22           FF76         FE            push	-2[bp]
07197                                           ! Debug: func () void = write_word+0 (used reg = )
07198 1E25           E8         E80E            call	_write_word
07199 1E28           83C4                   06  add	sp,*6
07200                                           !BCC_EOS
07201                                           ! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07202                                           ! Debug: list int = const $F (used reg = )
07203 1E2B           B8                   000F  mov	ax,*$F
07204 1E2E           50                         push	ax
07205                                           ! Debug: list * unsigned char = const $130 (used reg = )
07206 1E2F           B8                   0130  mov	ax,#$130
07207 1E32           50                         push	ax
07208                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07209 1E33           FF76         FE            push	-2[bp]
07210                                           ! Debug: func () void = write_byte+0 (used reg = )
07211 1E36           E8         E7E5            call	_write_byte
07212 1E39           83C4                   06  add	sp,*6
07213                                           !BCC_EOS
07214                                           ! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07215                                           ! Debug: list int = const 0 (used reg = )
07216 1E3C           31C0                       xor	ax,ax
07217 1E3E           50                         push	ax
07218                                           ! Debug: list * unsigned char = const $132 (used reg = )
07219 1E3F           B8                   0132  mov	ax,#$132
07220 1E42           50                         push	ax
07221                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07222 1E43           FF76         FE            push	-2[bp]
07223                                           ! Debug: func () void = write_byte+0 (used reg = )
07224 1E46           E8         E7D5            call	_write_byte
07225 1E49           83C4                   06  add	sp,*6
07226                                           !BCC_EOS
07227                                           ! 1519   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07228                                           ! Debug: list int = const $1E8 (used reg = )
07229 1E4C           B8                   01E8  mov	ax,#$1E8
07230 1E4F           50                         push	ax
07231                                           ! Debug: list * unsigned short = const $134 (used reg = )
07232 1E50           B8                   0134  mov	ax,#$134
07233 1E53           50                         push	ax
07234                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07235 1E54           FF76         FE            push	-2[bp]
07236                                           ! Debug: func () void = write_word+0 (used reg = )
07237 1E57           E8         E7DC            call	_write_word
07238 1E5A           83C4                   06  add	sp,*6
07239                                           !BCC_EOS
07240                                           ! 1520   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07241                                           ! Debug: list int = const $3E0 (used reg = )
07242 1E5D           B8                   03E0  mov	ax,#$3E0
07243 1E60           50                         push	ax
07244                                           ! Debug: list * unsigned short = const $136 (used reg = )
07245 1E61           B8                   0136  mov	ax,#$136
07246 1E64           50                         push	ax
07247                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07248 1E65           FF76         FE            push	-2[bp]
07249                                           ! Debug: func () void = write_word+0 (used reg = )
07250 1E68           E8         E7CB            call	_write_word
07251 1E6B           83C4                   06  add	sp,*6
07252                                           !BCC_EOS
07253                                           ! 1521   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07254                                           ! Debug: list int = const $C (used reg = )
07255 1E6E           B8                   000C  mov	ax,*$C
07256 1E71           50                         push	ax
07257                                           ! Debug: list * unsigned char = const $138 (used reg = )
07258 1E72           B8                   0138  mov	ax,#$138
07259 1E75           50                         push	ax
07260                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07261 1E76           FF76         FE            push	-2[bp]
07262                                           ! Debug: func () void = write_byte+0 (used reg = )
07263 1E79           E8         E7A2            call	_write_byte
07264 1E7C           83C4                   06  add	sp,*6
07265                                           !BCC_EOS
07266                                           ! 1522   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07267                                           ! Debug: list int = const 0 (used reg = )
07268 1E7F           31C0                       xor	ax,ax
07269 1E81           50                         push	ax
07270                                           ! Debug: list * unsigned char = const $13A (used reg = )
07271 1E82           B8                   013A  mov	ax,#$13A
07272 1E85           50                         push	ax
07273                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07274 1E86           FF76         FE            push	-2[bp]
07275                                           ! Debug: func () void = write_byte+0 (used reg = )
07276 1E89           E8         E792            call	_write_byte
07277 1E8C           83C4                   06  add	sp,*6
07278                                           !BCC_EOS
07279                                           ! 1523   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07280                                           ! Debug: list int = const $168 (used reg = )
07281 1E8F           B8                   0168  mov	ax,#$168
07282 1E92           50                         push	ax
07283                                           ! Debug: list * unsigned short = const $13C (used reg = )
07284 1E93           B8                   013C  mov	ax,#$13C
07285 1E96           50                         push	ax
07286                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07287 1E97           FF76         FE            push	-2[bp]
07288                                           ! Debug: func () void = write_word+0 (used reg = )
07289 1E9A           E8         E799            call	_write_word
07290 1E9D           83C4                   06  add	sp,*6
07291                                           !BCC_EOS
07292                                           ! 1524   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07293                                           ! Debug: list int = const $360 (used reg = )
07294 1EA0           B8                   0360  mov	ax,#$360
07295 1EA3           50                         push	ax
07296                                           ! Debug: list * unsigned short = const $13E (used reg = )
07297 1EA4           B8                   013E  mov	ax,#$13E
07298 1EA7           50                         push	ax
07299                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07300 1EA8           FF76         FE            push	-2[bp]
07301                                           ! Debug: func () void = write_word+0 (used reg = )
07302 1EAB           E8         E788            call	_write_word
07303 1EAE           83C4                   06  add	sp,*6
07304                                           !BCC_EOS
07305                                           ! 1525   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07306                                           ! Debug: list int = const $B (used reg = )
07307 1EB1           B8                   000B  mov	ax,*$B
07308 1EB4           50                         push	ax
07309                                           ! Debug: list * unsigned char = const $140 (used reg = )
07310 1EB5           B8                   0140  mov	ax,#$140
07311 1EB8           50                         push	ax
07312                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07313 1EB9           FF76         FE            push	-2[bp]
07314                                           ! Debug: func () void = write_byte+0 (used reg = )
07315 1EBC           E8         E75F            call	_write_byte
07316 1EBF           83C4                   06  add	sp,*6
07317                                           !BCC_EOS
07318                                           ! 1526   hdcount=cdcount=0;
07319                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07320 1EC2           30C0                       xor	al,al
07321 1EC4           8846         FC            mov	-4[bp],al
07322                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07323 1EC7           8846         FD            mov	-3[bp],al
07324                                           !BCC_EOS
07325                                           ! 1527   for(device=0; device<(4*2); device++) {
07326                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07327 1ECA           30C0                       xor	al,al
07328 1ECC           8846         FB            mov	-5[bp],al
07329                                           !BCC_EOS
07330                                           !BCC_EOS
07331 1ECF           E9         0DA5            br 	.1A2
07332                       00001ED2            .1A3:
07333                                           ! 1528     
07334                                           ! 1528 Bit16u iobase1, iobase2;
07335                                           !BCC_EOS
07336                                           ! 1529     Bit8u channel, slave, shift;
07337                                           !BCC_EOS
07338                                           ! 1530     Bit8u sc, sn, cl, ch, st;
07339                                           !BCC_EOS
07340                                           ! 1531     channel = device / 2;
07341 1ED2           83C4                   F4  add	sp,*-$C
07342                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07343 1ED5           8A46         FB            mov	al,-5[bp]
07344 1ED8           30E4                       xor	ah,ah
07345 1EDA           D1E8                       shr	ax,*1
07346                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07347 1EDC           8886       FDF5            mov	-$20B[bp],al
07348                                           !BCC_EOS
07349                                           ! 1532     slave = device % 2;
07350                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07351 1EE0           8A46         FB            mov	al,-5[bp]
07352 1EE3           30E4                       xor	ah,ah
07353 1EE5           24                     01  and	al,*1
07354                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07355 1EE7           8886       FDF4            mov	-$20C[bp],al
07356                                           !BCC_EOS
07357                                           ! 1533     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07358                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07359 1EEB           8A86       FDF5            mov	al,-$20B[bp]
07360 1EEF           30E4                       xor	ah,ah
07361 1EF1           B1                     03  mov	cl,*3
07362 1EF3           D3E0                       shl	ax,cl
07363 1EF5           89C3                       mov	bx,ax
07364                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07365                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07366 1EF7           81C3                 0124  add	bx,#$124
07367 1EFB           53                         push	bx
07368                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07369 1EFC           FF76         FE            push	-2[bp]
07370                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07371 1EFF           E8         E709            call	_read_word
07372 1F02           83C4                   04  add	sp,*4
07373                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07374 1F05           8986       FDF8            mov	-$208[bp],ax
07375                                           !BCC_EOS
07376                                           ! 1534     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07377                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07378 1F09           8A86       FDF5            mov	al,-$20B[bp]
07379 1F0D           30E4                       xor	ah,ah
07380 1F0F           B1                     03  mov	cl,*3
07381 1F11           D3E0                       shl	ax,cl
07382 1F13           89C3                       mov	bx,ax
07383                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07384                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07385 1F15           81C3                 0126  add	bx,#$126
07386 1F19           53                         push	bx
07387                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07388 1F1A           FF76         FE            push	-2[bp]
07389                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07390 1F1D           E8         E6EB            call	_read_word
07391 1F20           83C4                   04  add	sp,*4
07392                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07393 1F23           8986       FDF6            mov	-$20A[bp],ax
07394                                           !BCC_EOS
07395                                           ! 1535     outb(iobase2+6, 0x08 | 0x02);
07396                                           ! Debug: list int = const $A (used reg = )
07397 1F27           B8                   000A  mov	ax,*$A
07398 1F2A           50                         push	ax
07399                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07400 1F2B           8B86       FDF6            mov	ax,-$20A[bp]
07401                                           ! Debug: list unsigned int = ax+6 (used reg = )
07402 1F2F           05                   0006  add	ax,*6
07403 1F32           50                         push	ax
07404                                           ! Debug: func () void = outb+0 (used reg = )
07405 1F33           E8         E622            call	_outb
07406 1F36           83C4                   04  add	sp,*4
07407                                           !BCC_EOS
07408                                           ! 1536     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07409 1F39           8A86       FDF4            mov	al,-$20C[bp]
07410 1F3D           84C0                       test	al,al
07411 1F3F           74           04            je  	.1A4
07412                       00001F41            .1A5:
07413 1F41           B0                     B0  mov	al,#$B0
07414 1F43           EB           02            jmp .1A6
07415                       00001F45            .1A4:
07416 1F45           B0                     A0  mov	al,#$A0
07417                       00001F47            .1A6:
07418                                           ! Debug: list char = al+0 (used reg = )
07419 1F47           30E4                       xor	ah,ah
07420 1F49           50                         push	ax
07421                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07422 1F4A           8B86       FDF8            mov	ax,-$208[bp]
07423                                           ! Debug: list unsigned int = ax+6 (used reg = )
07424 1F4E           05                   0006  add	ax,*6
07425 1F51           50                         push	ax
07426                                           ! Debug: func () void = outb+0 (used reg = )
07427 1F52           E8         E603            call	_outb
07428 1F55           83C4                   04  add	sp,*4
07429                                           !BCC_EOS
07430                                           ! 1537     outb(iobase1+2, 0x55);
07431                                           ! Debug: list int = const $55 (used reg = )
07432 1F58           B8                   0055  mov	ax,*$55
07433 1F5B           50                         push	ax
07434                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07435 1F5C           8B86       FDF8            mov	ax,-$208[bp]
07436                                           ! Debug: list unsigned int = ax+2 (used reg = )
07437 1F60           40                         inc	ax
07438 1F61           40                         inc	ax
07439 1F62           50                         push	ax
07440                                           ! Debug: func () void = outb+0 (used reg = )
07441 1F63           E8         E5F2            call	_outb
07442 1F66           83C4                   04  add	sp,*4
07443                                           !BCC_EOS
07444                                           ! 1538     outb(iobase1+3, 0xaa);
07445                                           ! Debug: list int = const $AA (used reg = )
07446 1F69           B8                   00AA  mov	ax,#$AA
07447 1F6C           50                         push	ax
07448                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07449 1F6D           8B86       FDF8            mov	ax,-$208[bp]
07450                                           ! Debug: list unsigned int = ax+3 (used reg = )
07451 1F71           05                   0003  add	ax,*3
07452 1F74           50                         push	ax
07453                                           ! Debug: func () void = outb+0 (used reg = )
07454 1F75           E8         E5E0            call	_outb
07455 1F78           83C4                   04  add	sp,*4
07456                                           !BCC_EOS
07457                                           ! 1539     outb(iobase1+2, 0xaa);
07458                                           ! Debug: list int = const $AA (used reg = )
07459 1F7B           B8                   00AA  mov	ax,#$AA
07460 1F7E           50                         push	ax
07461                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07462 1F7F           8B86       FDF8            mov	ax,-$208[bp]
07463                                           ! Debug: list unsigned int = ax+2 (used reg = )
07464 1F83           40                         inc	ax
07465 1F84           40                         inc	ax
07466 1F85           50                         push	ax
07467                                           ! Debug: func () void = outb+0 (used reg = )
07468 1F86           E8         E5CF            call	_outb
07469 1F89           83C4                   04  add	sp,*4
07470                                           !BCC_EOS
07471                                           ! 1540     outb(iobase1+3, 0x55);
07472                                           ! Debug: list int = const $55 (used reg = )
07473 1F8C           B8                   0055  mov	ax,*$55
07474 1F8F           50                         push	ax
07475                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07476 1F90           8B86       FDF8            mov	ax,-$208[bp]
07477                                           ! Debug: list unsigned int = ax+3 (used reg = )
07478 1F94           05                   0003  add	ax,*3
07479 1F97           50                         push	ax
07480                                           ! Debug: func () void = outb+0 (used reg = )
07481 1F98           E8         E5BD            call	_outb
07482 1F9B           83C4                   04  add	sp,*4
07483                                           !BCC_EOS
07484                                           ! 1541     outb(iobase1+2, 0x55);
07485                                           ! Debug: list int = const $55 (used reg = )
07486 1F9E           B8                   0055  mov	ax,*$55
07487 1FA1           50                         push	ax
07488                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07489 1FA2           8B86       FDF8            mov	ax,-$208[bp]
07490                                           ! Debug: list unsigned int = ax+2 (used reg = )
07491 1FA6           40                         inc	ax
07492 1FA7           40                         inc	ax
07493 1FA8           50                         push	ax
07494                                           ! Debug: func () void = outb+0 (used reg = )
07495 1FA9           E8         E5AC            call	_outb
07496 1FAC           83C4                   04  add	sp,*4
07497                                           !BCC_EOS
07498                                           ! 1542     outb(iobase1+3, 0xaa);
07499                                           ! Debug: list int = const $AA (used reg = )
07500 1FAF           B8                   00AA  mov	ax,#$AA
07501 1FB2           50                         push	ax
07502                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07503 1FB3           8B86       FDF8            mov	ax,-$208[bp]
07504                                           ! Debug: list unsigned int = ax+3 (used reg = )
07505 1FB7           05                   0003  add	ax,*3
07506 1FBA           50                         push	ax
07507                                           ! Debug: func () void = outb+0 (used reg = )
07508 1FBB           E8         E59A            call	_outb
07509 1FBE           83C4                   04  add	sp,*4
07510                                           !BCC_EOS
07511                                           ! 1543     sc = inb(iobase1+2);
07512                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07513 1FC1           8B86       FDF8            mov	ax,-$208[bp]
07514                                           ! Debug: list unsigned int = ax+2 (used reg = )
07515 1FC5           40                         inc	ax
07516 1FC6           40                         inc	ax
07517 1FC7           50                         push	ax
07518                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07519 1FC8           E8         E577            call	_inb
07520 1FCB           44                         inc	sp
07521 1FCC           44                         inc	sp
07522                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07523 1FCD           8886       FDF2            mov	-$20E[bp],al
07524                                           !BCC_EOS
07525                                           ! 1544     sn = inb(iobase1+3);
07526                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07527 1FD1           8B86       FDF8            mov	ax,-$208[bp]
07528                                           ! Debug: list unsigned int = ax+3 (used reg = )
07529 1FD5           05                   0003  add	ax,*3
07530 1FD8           50                         push	ax
07531                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07532 1FD9           E8         E566            call	_inb
07533 1FDC           44                         inc	sp
07534 1FDD           44                         inc	sp
07535                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07536 1FDE           8886       FDF1            mov	-$20F[bp],al
07537                                           !BCC_EOS
07538                                           ! 1545     if ( (sc == 0x55) && (sn == 0xaa) ) {
07539                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07540 1FE2           8A86       FDF2            mov	al,-$20E[bp]
07541 1FE6           3C                     55  cmp	al,*$55
07542 1FE8         0F85         014F            bne 	.1A7
07543                       00001FEC            .1A9:
07544                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07545 1FEC           8A86       FDF1            mov	al,-$20F[bp]
07546 1FF0           3C                     AA  cmp	al,#$AA
07547 1FF2         0F85         0145            bne 	.1A7
07548                       00001FF6            .1A8:
07549                                           ! 1546       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07550                                           ! Debug: list int = const 1 (used reg = )
07551 1FF6           B8                   0001  mov	ax,*1
07552 1FF9           50                         push	ax
07553                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07554 1FFA           8A46         FB            mov	al,-5[bp]
07555 1FFD           30E4                       xor	ah,ah
07556 1FFF           B9                   001E  mov	cx,*$1E
07557 2002           F7E9                       imul	cx
07558 2004           89C3                       mov	bx,ax
07559                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07560                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07561 2006           81C3                 0142  add	bx,#$142
07562 200A           53                         push	bx
07563                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07564 200B           FF76         FE            push	-2[bp]
07565                                           ! Debug: func () void = write_byte+0 (used reg = )
07566 200E           E8         E60D            call	_write_byte
07567 2011           83C4                   06  add	sp,*6
07568                                           !BCC_EOS
07569                                           ! 1547       ata_reset(device);
07570                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07571 2014           8A46         FB            mov	al,-5[bp]
07572 2017           30E4                       xor	ah,ah
07573 2019           50                         push	ax
07574                                           ! Debug: func () void = ata_reset+0 (used reg = )
07575 201A           E8         0CAF            call	_ata_reset
07576 201D           44                         inc	sp
07577 201E           44                         inc	sp
07578                                           !BCC_EOS
07579                                           ! 1548       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07580 201F           8A86       FDF4            mov	al,-$20C[bp]
07581 2023           84C0                       test	al,al
07582 2025           74           04            je  	.1AA
07583                       00002027            .1AB:
07584 2027           B0                     B0  mov	al,#$B0
07585 2029           EB           02            jmp .1AC
07586                       0000202B            .1AA:
07587 202B           B0                     A0  mov	al,#$A0
07588                       0000202D            .1AC:
07589                                           ! Debug: list char = al+0 (used reg = )
07590 202D           30E4                       xor	ah,ah
07591 202F           50                         push	ax
07592                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07593 2030           8B86       FDF8            mov	ax,-$208[bp]
07594                                           ! Debug: list unsigned int = ax+6 (used reg = )
07595 2034           05                   0006  add	ax,*6
07596 2037           50                         push	ax
07597                                           ! Debug: func () void = outb+0 (used reg = )
07598 2038           E8         E51D            call	_outb
07599 203B           83C4                   04  add	sp,*4
07600                                           !BCC_EOS
07601                                           ! 1549       sc = inb(iobase1+2);
07602                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07603 203E           8B86       FDF8            mov	ax,-$208[bp]
07604                                           ! Debug: list unsigned int = ax+2 (used reg = )
07605 2042           40                         inc	ax
07606 2043           40                         inc	ax
07607 2044           50                         push	ax
07608                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07609 2045           E8         E4FA            call	_inb
07610 2048           44                         inc	sp
07611 2049           44                         inc	sp
07612                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07613 204A           8886       FDF2            mov	-$20E[bp],al
07614                                           !BCC_EOS
07615                                           ! 1550       sn = inb(iobase1+3);
07616                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07617 204E           8B86       FDF8            mov	ax,-$208[bp]
07618                                           ! Debug: list unsigned int = ax+3 (used reg = )
07619 2052           05                   0003  add	ax,*3
07620 2055           50                         push	ax
07621                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07622 2056           E8         E4E9            call	_inb
07623 2059           44                         inc	sp
07624 205A           44                         inc	sp
07625                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07626 205B           8886       FDF1            mov	-$20F[bp],al
07627                                           !BCC_EOS
07628                                           ! 1551       if ((sc==0x01) && (sn==0x01)) {
07629                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07630 205F           8A86       FDF2            mov	al,-$20E[bp]
07631 2063           3C                     01  cmp	al,*1
07632 2065         0F85         00D2            bne 	.1AD
07633                       00002069            .1AF:
07634                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07635 2069           8A86       FDF1            mov	al,-$20F[bp]
07636 206D           3C                     01  cmp	al,*1
07637 206F         0F85         00C8            bne 	.1AD
07638                       00002073            .1AE:
07639                                           ! 1552         cl = inb(iobase1+4);
07640                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07641 2073           8B86       FDF8            mov	ax,-$208[bp]
07642                                           ! Debug: list unsigned int = ax+4 (used reg = )
07643 2077           05                   0004  add	ax,*4
07644 207A           50                         push	ax
07645                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07646 207B           E8         E4C4            call	_inb
07647 207E           44                         inc	sp
07648 207F           44                         inc	sp
07649                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07650 2080           8886       FDF0            mov	-$210[bp],al
07651                                           !BCC_EOS
07652                                           ! 1553         ch = inb(iobase1+5);
07653                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07654 2084           8B86       FDF8            mov	ax,-$208[bp]
07655                                           ! Debug: list unsigned int = ax+5 (used reg = )
07656 2088           05                   0005  add	ax,*5
07657 208B           50                         push	ax
07658                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07659 208C           E8         E4B3            call	_inb
07660 208F           44                         inc	sp
07661 2090           44                         inc	sp
07662                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07663 2091           8886       FDEF            mov	-$211[bp],al
07664                                           !BCC_EOS
07665                                           ! 1554         st = inb(iobase1+7);
07666                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07667 2095           8B86       FDF8            mov	ax,-$208[bp]
07668                                           ! Debug: list unsigned int = ax+7 (used reg = )
07669 2099           05                   0007  add	ax,*7
07670 209C           50                         push	ax
07671                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07672 209D           E8         E4A2            call	_inb
07673 20A0           44                         inc	sp
07674 20A1           44                         inc	sp
07675                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07676 20A2           8886       FDEE            mov	-$212[bp],al
07677                                           !BCC_EOS
07678                                           ! 1555         if ((cl==0x14) && (ch==0xeb)) {
07679                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07680 20A6           8A86       FDF0            mov	al,-$210[bp]
07681 20AA           3C                     14  cmp	al,*$14
07682 20AC           75           28            jne 	.1B0
07683                       000020AE            .1B2:
07684                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07685 20AE           8A86       FDEF            mov	al,-$211[bp]
07686 20B2           3C                     EB  cmp	al,#$EB
07687 20B4           75           20            jne 	.1B0
07688                       000020B6            .1B1:
07689                                           ! 1556           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07690                                           ! Debug: list int = const 3 (used reg = )
07691 20B6           B8                   0003  mov	ax,*3
07692 20B9           50                         push	ax
07693                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07694 20BA           8A46         FB            mov	al,-5[bp]
07695 20BD           30E4                       xor	ah,ah
07696 20BF           B9                   001E  mov	cx,*$1E
07697 20C2           F7E9                       imul	cx
07698 20C4           89C3                       mov	bx,ax
07699                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07700                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07701 20C6           81C3                 0142  add	bx,#$142
07702 20CA           53                         push	bx
07703                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07704 20CB           FF76         FE            push	-2[bp]
07705                                           ! Debug: func () void = write_byte+0 (used reg = )
07706 20CE           E8         E54D            call	_write_byte
07707 20D1           83C4                   06  add	sp,*6
07708                                           !BCC_EOS
07709                                           ! 1557         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07710 20D4           EB           65            jmp .1B3
07711                       000020D6            .1B0:
07712                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07713 20D6           8A86       FDF0            mov	al,-$210[bp]
07714 20DA           84C0                       test	al,al
07715 20DC           75           30            jne 	.1B4
07716                       000020DE            .1B7:
07717                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07718 20DE           8A86       FDEF            mov	al,-$211[bp]
07719 20E2           84C0                       test	al,al
07720 20E4           75           28            jne 	.1B4
07721                       000020E6            .1B6:
07722                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07723 20E6           8A86       FDEE            mov	al,-$212[bp]
07724 20EA           84C0                       test	al,al
07725 20EC           74           20            je  	.1B4
07726                       000020EE            .1B5:
07727                                           ! 1558           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07728                                           ! Debug: list int = const 2 (used reg = )
07729 20EE           B8                   0002  mov	ax,*2
07730 20F1           50                         push	ax
07731                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07732 20F2           8A46         FB            mov	al,-5[bp]
07733 20F5           30E4                       xor	ah,ah
07734 20F7           B9                   001E  mov	cx,*$1E
07735 20FA           F7E9                       imul	cx
07736 20FC           89C3                       mov	bx,ax
07737                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07738                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07739 20FE           81C3                 0142  add	bx,#$142
07740 2102           53                         push	bx
07741                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07742 2103           FF76         FE            push	-2[bp]
07743                                           ! Debug: func () void = write_byte+0 (used reg = )
07744 2106           E8         E515            call	_write_byte
07745 2109           83C4                   06  add	sp,*6
07746                                           !BCC_EOS
07747                                           ! 1559         } else if ((cl==0xff) && (ch==0xff)) {
07748 210C           EB           2D            jmp .1B8
07749                       0000210E            .1B4:
07750                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
07751 210E           8A86       FDF0            mov	al,-$210[bp]
07752 2112           3C                     FF  cmp	al,#$FF
07753 2114           75           25            jne 	.1B9
07754                       00002116            .1BB:
07755                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
07756 2116           8A86       FDEF            mov	al,-$211[bp]
07757 211A           3C                     FF  cmp	al,#$FF
07758 211C           75           1D            jne 	.1B9
07759                       0000211E            .1BA:
07760                                           ! 1560           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
07761                                           ! Debug: list int = const 0 (used reg = )
07762 211E           31C0                       xor	ax,ax
07763 2120           50                         push	ax
07764                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07765 2121           8A46         FB            mov	al,-5[bp]
07766 2124           30E4                       xor	ah,ah
07767 2126           B9                   001E  mov	cx,*$1E
07768 2129           F7E9                       imul	cx
07769 212B           89C3                       mov	bx,ax
07770                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07771                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07772 212D           81C3                 0142  add	bx,#$142
07773 2131           53                         push	bx
07774                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07775 2132           FF76         FE            push	-2[bp]
07776                                           ! Debug: func () void = write_byte+0 (used reg = )
07777 2135           E8         E4E6            call	_write_byte
07778 2138           83C4                   06  add	sp,*6
07779                                           !BCC_EOS
07780                                           ! 1561         }
07781                                           ! 1562       }
07782                       0000213B            .1B9:
07783                       0000213B            .1B8:
07784                       0000213B            .1B3:
07785                                           ! 1563     }
07786                       0000213B            .1AD:
07787                                           ! 1564     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07788                       0000213B            .1A7:
07789                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07790 213B           8A46         FB            mov	al,-5[bp]
07791 213E           30E4                       xor	ah,ah
07792 2140           B9                   001E  mov	cx,*$1E
07793 2143           F7E9                       imul	cx
07794 2145           89C3                       mov	bx,ax
07795                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07796                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07797 2147           81C3                 0142  add	bx,#$142
07798 214B           53                         push	bx
07799                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07800 214C           FF76         FE            push	-2[bp]
07801                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07802 214F           E8         E4A6            call	_read_byte
07803 2152           83C4                   04  add	sp,*4
07804                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07805 2155           8846         FA            mov	-6[bp],al
07806                                           !BCC_EOS
07807                                           ! 1565     if(type == 0x02) {
07808                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07809 2158           8A46         FA            mov	al,-6[bp]
07810 215B           3C                     02  cmp	al,*2
07811 215D         0F85         05A8            bne 	.1BC
07812                       00002161            .1BD:
07813                                           ! 1566       Bit32u sectors_low, sectors_high;
07814                                           !BCC_EOS
07815                                           ! 1567       Bit16u cylinders, heads, spt, blksize;
07816                                           !BCC_EOS
07817                                           ! 1568       Bit8u translation, removable, mode;
07818                                           !BCC_EOS
07819                                           ! 1569       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07820 2161           83C4                   EC  add	sp,*-$14
07821                                           ! Debug: list int = const $FF (used reg = )
07822 2164           B8                   00FF  mov	ax,#$FF
07823 2167           50                         push	ax
07824                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07825 2168           8A46         FB            mov	al,-5[bp]
07826 216B           30E4                       xor	ah,ah
07827 216D           B9                   001E  mov	cx,*$1E
07828 2170           F7E9                       imul	cx
07829 2172           89C3                       mov	bx,ax
07830                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07831                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07832 2174           81C3                 0143  add	bx,#$143
07833 2178           53                         push	bx
07834                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
07835 2179           FF76         FE            push	-2[bp]
07836                                           ! Debug: func () void = write_byte+0 (used reg = )
07837 217C           E8         E49F            call	_write_byte
07838 217F           83C4                   06  add	sp,*6
07839                                           !BCC_EOS
07840                                           ! 1570       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
07841                                           ! Debug: list int = const 0 (used reg = )
07842 2182           31C0                       xor	ax,ax
07843 2184           50                         push	ax
07844                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07845 2185           8A46         FB            mov	al,-5[bp]
07846 2188           30E4                       xor	ah,ah
07847 218A           B9                   001E  mov	cx,*$1E
07848 218D           F7E9                       imul	cx
07849 218F           89C3                       mov	bx,ax
07850                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07851                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
07852 2191           81C3                 0146  add	bx,#$146
07853 2195           53                         push	bx
07854                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
07855 2196           FF76         FE            push	-2[bp]
07856                                           ! Debug: func () void = write_byte+0 (used reg = )
07857 2199           E8         E482            call	_write_byte
07858 219C           83C4                   06  add	sp,*6
07859                                           !BCC_EOS
07860                                           ! 1571       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07861                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
07862 219F           8D9E       FDFA            lea	bx,-$206[bp]
07863 21A3           53                         push	bx
07864                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07865 21A4           E8         E4AA            call	_get_SS
07866                                           ! Debug: list unsigned short = ax+0 (used reg = )
07867 21A7           50                         push	ax
07868                                           ! Debug: list long = const 0 (used reg = )
07869 21A8           31C0                       xor	ax,ax
07870 21AA           31DB                       xor	bx,bx
07871 21AC           53                         push	bx
07872 21AD           50                         push	ax
07873                                           ! Debug: list long = const 0 (used reg = )
07874 21AE           31C0                       xor	ax,ax
07875 21B0           31DB                       xor	bx,bx
07876 21B2           53                         push	bx
07877 21B3           50                         push	ax
07878                                           ! Debug: list int = const 0 (used reg = )
07879 21B4           31C0                       xor	ax,ax
07880 21B6           50                         push	ax
07881                                           ! Debug: list int = const 0 (used reg = )
07882 21B7           31C0                       xor	ax,ax
07883 21B9           50                         push	ax
07884                                           ! Debug: list int = const 0 (used reg = )
07885 21BA           31C0                       xor	ax,ax
07886 21BC           50                         push	ax
07887                                           ! Debug: list int = const 1 (used reg = )
07888 21BD           B8                   0001  mov	ax,*1
07889 21C0           50                         push	ax
07890                                           ! Debug: list int = const $EC (used reg = )
07891 21C1           B8                   00EC  mov	ax,#$EC
07892 21C4           50                         push	ax
07893                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
07894 21C5           8A46         FB            mov	al,-5[bp]
07895 21C8           30E4                       xor	ah,ah
07896 21CA           50                         push	ax
07897                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
07898 21CB           E8         0C56            call	_ata_cmd_data_in
07899 21CE           83C4                   18  add	sp,*$18
07900                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07901 21D1           85C0                       test	ax,ax
07902 21D3           74           0E            je  	.1BE
07903                       000021D5            .1BF:
07904                                           ! 1572         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07905                                           ! Debug: list * char = .1C0+0 (used reg = )
07906 21D5           BB                   D7BF  mov	bx,#.1C0
07907 21D8           53                         push	bx
07908                                           ! Debug: list int = const 7 (used reg = )
07909 21D9           B8                   0007  mov	ax,*7
07910 21DC           50                         push	ax
07911                                           ! Debug: func () void = bios_printf+0 (used reg = )
07912 21DD           E8         E7C7            call	_bios_printf
07913 21E0           83C4                   04  add	sp,*4
07914                                           !BCC_EOS
07915                                           ! 1573       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
07916                       000021E3            .1BE:
07917                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
07918 21E3           8D9E       FDFA            lea	bx,-$206[bp]
07919 21E7           53                         push	bx
07920                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07921 21E8           E8         E466            call	_get_SS
07922                                           ! Debug: list unsigned short = ax+0 (used reg = )
07923 21EB           50                         push	ax
07924                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07925 21EC           E8         E409            call	_read_byte
07926 21EF           83C4                   04  add	sp,*4
07927                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07928 21F2           24                     80  and	al,#$80
07929 21F4           84C0                       test	al,al
07930 21F6           74           04            je  	.1C1
07931                       000021F8            .1C2:
07932 21F8           B0                     01  mov	al,*1
07933 21FA           EB           02            jmp .1C3
07934                       000021FC            .1C1:
07935 21FC           30C0                       xor	al,al
07936                       000021FE            .1C3:
07937                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
07938 21FE           8886       FDDC            mov	-$224[bp],al
07939                                           !BCC_EOS
07940                                           ! 1574       mode = read_byte(get_SS(),buffer+9
07941                                           ! 1574 6) ? 0x01 : 0x00;
07942                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
07943 2202           8D9E       FE5A            lea	bx,-$1A6[bp]
07944 2206           53                         push	bx
07945                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07946 2207           E8         E447            call	_get_SS
07947                                           ! Debug: list unsigned short = ax+0 (used reg = )
07948 220A           50                         push	ax
07949                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07950 220B           E8         E3EA            call	_read_byte
07951 220E           83C4                   04  add	sp,*4
07952 2211           84C0                       test	al,al
07953 2213           74           04            je  	.1C4
07954                       00002215            .1C5:
07955 2215           B0                     01  mov	al,*1
07956 2217           EB           02            jmp .1C6
07957                       00002219            .1C4:
07958 2219           30C0                       xor	al,al
07959                       0000221B            .1C6:
07960                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07961 221B           8886       FDDB            mov	-$225[bp],al
07962                                           !BCC_EOS
07963                                           ! 1575       blksize = read_word(get_SS(),buffer+10);
07964                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
07965 221F           8D9E       FE04            lea	bx,-$1FC[bp]
07966 2223           53                         push	bx
07967                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07968 2224           E8         E42A            call	_get_SS
07969                                           ! Debug: list unsigned short = ax+0 (used reg = )
07970 2227           50                         push	ax
07971                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07972 2228           E8         E3E0            call	_read_word
07973 222B           83C4                   04  add	sp,*4
07974                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
07975 222E           8986       FDDE            mov	-$222[bp],ax
07976                                           !BCC_EOS
07977                                           ! 1576       cylinders = read_word(get_SS(),buffer+(1*2));
07978                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07979 2232           8D9E       FDFC            lea	bx,-$204[bp]
07980 2236           53                         push	bx
07981                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07982 2237           E8         E417            call	_get_SS
07983                                           ! Debug: list unsigned short = ax+0 (used reg = )
07984 223A           50                         push	ax
07985                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07986 223B           E8         E3CD            call	_read_word
07987 223E           83C4                   04  add	sp,*4
07988                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
07989 2241           8986       FDE4            mov	-$21C[bp],ax
07990                                           !BCC_EOS
07991                                           ! 1577       heads = read_word(get_SS(),buffer+(3*2));
07992                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
07993 2245           8D9E       FE00            lea	bx,-$200[bp]
07994 2249           53                         push	bx
07995                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07996 224A           E8         E404            call	_get_SS
07997                                           ! Debug: list unsigned short = ax+0 (used reg = )
07998 224D           50                         push	ax
07999                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08000 224E           E8         E3BA            call	_read_word
08001 2251           83C4                   04  add	sp,*4
08002                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08003 2254           8986       FDE2            mov	-$21E[bp],ax
08004                                           !BCC_EOS
08005                                           ! 1578       spt = read_word(get_SS(),buffer+(6*2));
08006                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08007 2258           8D9E       FE06            lea	bx,-$1FA[bp]
08008 225C           53                         push	bx
08009                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08010 225D           E8         E3F1            call	_get_SS
08011                                           ! Debug: list unsigned short = ax+0 (used reg = )
08012 2260           50                         push	ax
08013                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08014 2261           E8         E3A7            call	_read_word
08015 2264           83C4                   04  add	sp,*4
08016                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08017 2267           8986       FDE0            mov	-$220[bp],ax
08018                                           !BCC_EOS
08019                                           ! 1579       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08020                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08021 226B           8D9E       FEA0            lea	bx,-$160[bp]
08022 226F           53                         push	bx
08023                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08024 2270           E8         E3DE            call	_get_SS
08025                                           ! Debug: list unsigned short = ax+0 (used reg = )
08026 2273           50                         push	ax
08027                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08028 2274           E8         E394            call	_read_word
08029 2277           83C4                   04  add	sp,*4
08030                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08031 227A           25                   0400  and	ax,#$400
08032 227D           85C0                       test	ax,ax
08033 227F           74           34            je  	.1C7
08034                       00002281            .1C8:
08035                                           ! 1580         sectors_low = read_dword(get_SS(),buffer+(100*2));
08036                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08037 2281           8D9E       FEC2            lea	bx,-$13E[bp]
08038 2285           53                         push	bx
08039                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08040 2286           E8         E3C8            call	_get_SS
08041                                           ! Debug: list unsigned short = ax+0 (used reg = )
08042 2289           50                         push	ax
08043                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08044 228A           E8         DDF6            call	_read_dword
08045 228D           89D3                       mov	bx,dx
08046 228F           83C4                   04  add	sp,*4
08047                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08048 2292           8986       FDEA            mov	-$216[bp],ax
08049 2296           899E       FDEC            mov	-$214[bp],bx
08050                                           !BCC_EOS
08051                                           ! 1581         sectors_high = read_dword(get_SS(),buffer+(102*2));
08052                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08053 229A           8D9E       FEC6            lea	bx,-$13A[bp]
08054 229E           53                         push	bx
08055                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08056 229F           E8         E3AF            call	_get_SS
08057                                           ! Debug: list unsigned short = ax+0 (used reg = )
08058 22A2           50                         push	ax
08059                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08060 22A3           E8         DDDD            call	_read_dword
08061 22A6           89D3                       mov	bx,dx
08062 22A8           83C4                   04  add	sp,*4
08063                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08064 22AB           8986       FDE6            mov	-$21A[bp],ax
08065 22AF           899E       FDE8            mov	-$218[bp],bx
08066                                           !BCC_EOS
08067                                           ! 1582       } else {
08068 22B3           EB           25            jmp .1C9
08069                       000022B5            .1C7:
08070                                           ! 1583         sectors_low = read_dword(get_SS(),buffer+(60*2));
08071                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08072 22B5           8D9E       FE72            lea	bx,-$18E[bp]
08073 22B9           53                         push	bx
08074                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08075 22BA           E8         E394            call	_get_SS
08076                                           ! Debug: list unsigned short = ax+0 (used reg = )
08077 22BD           50                         push	ax
08078                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08079 22BE           E8         DDC2            call	_read_dword
08080 22C1           89D3                       mov	bx,dx
08081 22C3           83C4                   04  add	sp,*4
08082                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08083 22C6           8986       FDEA            mov	-$216[bp],ax
08084 22CA           899E       FDEC            mov	-$214[bp],bx
08085                                           !BCC_EOS
08086                                           ! 1584         sectors_high = 0;
08087                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08088 22CE           31C0                       xor	ax,ax
08089 22D0           31DB                       xor	bx,bx
08090 22D2           8986       FDE6            mov	-$21A[bp],ax
08091 22D6           899E       FDE8            mov	-$218[bp],bx
08092                                           !BCC_EOS
08093                                           ! 1585       }
08094                                           ! 1586       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08095                       000022DA            .1C9:
08096                                           ! Debug: list int = const $FF (used reg = )
08097 22DA           B8                   00FF  mov	ax,#$FF
08098 22DD           50                         push	ax
08099                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08100 22DE           8A46         FB            mov	al,-5[bp]
08101 22E1           30E4                       xor	ah,ah
08102 22E3           B9                   001E  mov	cx,*$1E
08103 22E6           F7E9                       imul	cx
08104 22E8           89C3                       mov	bx,ax
08105                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08106                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08107 22EA           81C3                 0143  add	bx,#$143
08108 22EE           53                         push	bx
08109                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08110 22EF           FF76         FE            push	-2[bp]
08111                                           ! Debug: func () void = write_byte+0 (used reg = )
08112 22F2           E8         E329            call	_write_byte
08113 22F5           83C4                   06  add	sp,*6
08114                                           !BCC_EOS
08115                                           ! 1587       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08116                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08117 22F8           8A86       FDDC            mov	al,-$224[bp]
08118 22FC           30E4                       xor	ah,ah
08119 22FE           50                         push	ax
08120                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08121 22FF           8A46         FB            mov	al,-5[bp]
08122 2302           30E4                       xor	ah,ah
08123 2304           B9                   001E  mov	cx,*$1E
08124 2307           F7E9                       imul	cx
08125 2309           89C3                       mov	bx,ax
08126                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08127                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08128 230B           81C3                 0144  add	bx,#$144
08129 230F           53                         push	bx
08130                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08131 2310           FF76         FE            push	-2[bp]
08132                                           ! Debug: func () void = write_byte+0 (used reg = )
08133 2313           E8         E308            call	_write_byte
08134 2316           83C4                   06  add	sp,*6
08135                                           !BCC_EOS
08136                                           ! 1588       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08137                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08138 2319           8A86       FDDB            mov	al,-$225[bp]
08139 231D           30E4                       xor	ah,ah
08140 231F           50                         push	ax
08141                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08142 2320           8A46         FB            mov	al,-5[bp]
08143 2323           30E4                       xor	ah,ah
08144 2325           B9                   001E  mov	cx,*$1E
08145 2328           F7E9                       imul	cx
08146 232A           89C3                       mov	bx,ax
08147                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08148                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08149 232C           81C3                 0146  add	bx,#$146
08150 2330           53                         push	bx
08151                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08152 2331           FF76         FE            push	-2[bp]
08153                                           ! Debug: func () void = write_byte+0 (used reg = )
08154 2334           E8         E2E7            call	_write_byte
08155 2337           83C4                   06  add	sp,*6
08156                                           !BCC_EOS
08157                                           ! 1589       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08158                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08159 233A           FFB6       FDDE            push	-$222[bp]
08160                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08161 233E           8A46         FB            mov	al,-5[bp]
08162 2341           30E4                       xor	ah,ah
08163 2343           B9                   001E  mov	cx,*$1E
08164 2346           F7E9                       imul	cx
08165 2348           89C3                       mov	bx,ax
08166                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08167                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08168 234A           81C3                 0148  add	bx,#$148
08169 234E           53                         push	bx
08170                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08171 234F           FF76         FE            push	-2[bp]
08172                                           ! Debug: func () void = write_word+0 (used reg = )
08173 2352           E8         E2E1            call	_write_word
08174 2355           83C4                   06  add	sp,*6
08175                                           !BCC_EOS
08176                                           ! 1590       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08177                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08178 2358           FFB6       FDE2            push	-$21E[bp]
08179                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08180 235C           8A46         FB            mov	al,-5[bp]
08181 235F           30E4                       xor	ah,ah
08182 2361           B9                   001E  mov	cx,*$1E
08183 2364           F7E9                       imul	cx
08184 2366           89C3                       mov	bx,ax
08185                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08186                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08187 2368           81C3                 0152  add	bx,#$152
08188 236C           53                         push	bx
08189                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08190 236D           FF76         FE            push	-2[bp]
08191                                           ! Debug: func () void = write_word+0 (used reg = )
08192 2370           E8         E2C3            call	_write_word
08193 2373           83C4                   06  add	sp,*6
08194                                           !BCC_EOS
08195                                           ! 1591       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
08196                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08197 2376           FFB6       FDE4            push	-$21C[bp]
08198                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08199 237A           8A46         FB            mov	al,-5[bp]
08200 237D           30E4                       xor	ah,ah
08201 237F           B9                   001E  mov	cx,*$1E
08202 2382           F7E9                       imul	cx
08203 2384           89C3                       mov	bx,ax
08204                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08205                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08206 2386           81C3                 0154  add	bx,#$154
08207 238A           53                         push	bx
08208                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08209 238B           FF76         FE            push	-2[bp]
08210                                           ! Debug: func () void = write_word+0 (used reg = )
08211 238E           E8         E2A5            call	_write_word
08212 2391           83C4                   06  add	sp,*6
08213                                           !BCC_EOS
08214                                           ! 1592       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08215                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08216 2394           FFB6       FDE0            push	-$220[bp]
08217                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08218 2398           8A46         FB            mov	al,-5[bp]
08219 239B           30E4                       xor	ah,ah
08220 239D           B9                   001E  mov	cx,*$1E
08221 23A0           F7E9                       imul	cx
08222 23A2           89C3                       mov	bx,ax
08223                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08224                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08225 23A4           81C3                 0156  add	bx,#$156
08226 23A8           53                         push	bx
08227                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08228 23A9           FF76         FE            push	-2[bp]
08229                                           ! Debug: func () void = write_word+0 (used reg = )
08230 23AC           E8         E287            call	_write_word
08231 23AF           83C4                   06  add	sp,*6
08232                                           !BCC_EOS
08233                                           ! 1593       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08234                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08235 23B2           FFB6       FDEC            push	-$214[bp]
08236 23B6           FFB6       FDEA            push	-$216[bp]
08237                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08238 23BA           8A46         FB            mov	al,-5[bp]
08239 23BD           30E4                       xor	ah,ah
08240 23BF           B9                   001E  mov	cx,*$1E
08241 23C2           F7E9                       imul	cx
08242 23C4           89C3                       mov	bx,ax
08243                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08244                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08245 23C6           81C3                 0158  add	bx,#$158
08246 23CA           53                         push	bx
08247                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08248 23CB           FF76         FE            push	-2[bp]
08249                                           ! Debug: func () void = write_dword+0 (used reg = )
08250 23CE           E8         DCCA            call	_write_dword
08251 23D1           83C4                   08  add	sp,*8
08252                                           !BCC_EOS
08253                                           ! 1594       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08254                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08255 23D4           FFB6       FDE8            push	-$218[bp]
08256 23D8           FFB6       FDE6            push	-$21A[bp]
08257                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08258 23DC           8A46         FB            mov	al,-5[bp]
08259 23DF           30E4                       xor	ah,ah
08260 23E1           B9                   001E  mov	cx,*$1E
08261 23E4           F7E9                       imul	cx
08262 23E6           89C3                       mov	bx,ax
08263                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08264                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08265 23E8           81C3                 015C  add	bx,#$15C
08266 23EC           53                         push	bx
08267                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08268 23ED           FF76         FE            push	-2[bp]
08269                                           ! Debug: func () void = write_dword+0 (used reg = )
08270 23F0           E8         DCA8            call	_write_dword
08271 23F3           83C4                   08  add	sp,*8
08272                                           !BCC_EOS
08273                                           ! 1595       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
08274                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08275 23F6           FFB6       FDE0            push	-$220[bp]
08276                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08277 23FA           FFB6       FDE2            push	-$21E[bp]
08278                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08279 23FE           FFB6       FDE4            push	-$21C[bp]
08280                                           ! Debug: list unsigned char slave = [S+$22E-$20E] (used reg = )
08281 2402           8A86       FDF4            mov	al,-$20C[bp]
08282 2406           30E4                       xor	ah,ah
08283 2408           50                         push	ax
08284                                           ! Debug: list unsigned char channel = [S+$230-$20D] (used reg = )
08285 2409           8A86       FDF5            mov	al,-$20B[bp]
08286 240D           30E4                       xor	ah,ah
08287 240F           50                         push	ax
08288                                           ! Debug: list * char = .1CA+0 (used reg = )
08289 2410           BB                   D79A  mov	bx,#.1CA
08290 2413           53                         push	bx
08291                                           ! Debug: list int = const 4 (used reg = )
08292 2414           B8                   0004  mov	ax,*4
08293 2417           50                         push	ax
08294                                           ! Debug: func () void = bios_printf+0 (used reg = )
08295 2418           E8         E58C            call	_bios_printf
08296 241B           83C4                   0E  add	sp,*$E
08297                                           !BCC_EOS
08298                                           ! 1596       translation = inb_cmos(0x39 + channel/2);
08299                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08300 241E           8A86       FDF5            mov	al,-$20B[bp]
08301 2422           30E4                       xor	ah,ah
08302 2424           D1E8                       shr	ax,*1
08303                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08304                                           ! Debug: expression subtree swapping
08305                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08306 2426           05                   0039  add	ax,*$39
08307 2429           50                         push	ax
08308                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08309 242A           E8         E15A            call	_inb_cmos
08310 242D           44                         inc	sp
08311 242E           44                         inc	sp
08312                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08313 242F           8886       FDDD            mov	-$223[bp],al
08314                                           !BCC_EOS
08315                                           ! 1597       for (shift=device%4; shift>0; shift--) translation >>= 2;
08316                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08317 2433           8A46         FB            mov	al,-5[bp]
08318 2436           30E4                       xor	ah,ah
08319 2438           24                     03  and	al,*3
08320                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08321 243A           8886       FDF3            mov	-$20D[bp],al
08322                                           !BCC_EOS
08323                                           !BCC_EOS
08324 243E           EB           17            jmp .1CD
08325                       00002440            .1CE:
08326                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08327 2440           8A86       FDDD            mov	al,-$223[bp]
08328 2444           30E4                       xor	ah,ah
08329 2446           D1E8                       shr	ax,*1
08330 2448           D1E8                       shr	ax,*1
08331 244A           8886       FDDD            mov	-$223[bp],al
08332                                           !BCC_EOS
08333                                           ! 1598       translation &= 0x03;
08334                       0000244E            .1CC:
08335                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08336 244E           8A86       FDF3            mov	al,-$20D[bp]
08337 2452           48                         dec	ax
08338 2453           8886       FDF3            mov	-$20D[bp],al
08339                       00002457            .1CD:
08340                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08341 2457           8A86       FDF3            mov	al,-$20D[bp]
08342 245B           84C0                       test	al,al
08343 245D           75           E1            jne	.1CE
08344                       0000245F            .1CF:
08345                       0000245F            .1CB:
08346                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08347 245F           8A86       FDDD            mov	al,-$223[bp]
08348 2463           24                     03  and	al,*3
08349 2465           8886       FDDD            mov	-$223[bp],al
08350                                           !BCC_EOS
08351                                           ! 1599       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08352                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08353 2469           8A86       FDDD            mov	al,-$223[bp]
08354 246D           30E4                       xor	ah,ah
08355 246F           50                         push	ax
08356                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08357 2470           8A46         FB            mov	al,-5[bp]
08358 2473           30E4                       xor	ah,ah
08359 2475           B9                   001E  mov	cx,*$1E
08360 2478           F7E9                       imul	cx
08361 247A           89C3                       mov	bx,ax
08362                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08363                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08364 247C           81C3                 014A  add	bx,#$14A
08365 2480           53                         push	bx
08366                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08367 2481           FF76         FE            push	-2[bp]
08368                                           ! Debug: func () void = write_byte+0 (used reg = )
08369 2484           E8         E197            call	_write_byte
08370 2487           83C4                   06  add	sp,*6
08371                                           !BCC_EOS
08372                                           ! 1600       switch (translation) {
08373 248A           8A86       FDDD            mov	al,-$223[bp]
08374 248E           EB           42            jmp .1D2
08375                                           ! 1601         case 0:
08376                                           ! 1602           bios_printf(4, "none");
08377                       00002490            .1D3:
08378                                           ! Debug: list * char = .1D4+0 (used reg = )
08379 2490           BB                   D795  mov	bx,#.1D4
08380 2493           53                         push	bx
08381                                           ! Debug: list int = const 4 (used reg = )
08382 2494           B8                   0004  mov	ax,*4
08383 2497           50                         push	ax
08384                                           ! Debug: func () void = bios_printf+0 (used reg = )
08385 2498           E8         E50C            call	_bios_printf
08386 249B           83C4                   04  add	sp,*4
08387                                           !BCC_EOS
08388                                           ! 1603           break;
08389 249E           EB           42            jmp .1D0
08390                                           !BCC_EOS
08391                                           ! 1604         case 1:
08392                                           ! 1605           bios_printf(4, "lba");
08393                       000024A0            .1D5:
08394                                           ! Debug: list * char = .1D6+0 (used reg = )
08395 24A0           BB                   D791  mov	bx,#.1D6
08396 24A3           53                         push	bx
08397                                           ! Debug: list int = const 4 (used reg = )
08398 24A4           B8                   0004  mov	ax,*4
08399 24A7           50                         push	ax
08400                                           ! Debug: func () void = bios_printf+0 (used reg = )
08401 24A8           E8         E4FC            call	_bios_printf
08402 24AB           83C4                   04  add	sp,*4
08403                                           !BCC_EOS
08404                                           ! 1606           break;
08405 24AE           EB           32            jmp .1D0
08406                                           !BCC_EOS
08407                                           ! 1607         case 2:
08408                                           ! 1608           bios_printf(4, "large");
08409                       000024B0            .1D7:
08410                                           ! Debug: list * char = .1D8+0 (used reg = )
08411 24B0           BB                   D78B  mov	bx,#.1D8
08412 24B3           53                         push	bx
08413                                           ! Debug: list int = const 4 (used reg = )
08414 24B4           B8                   0004  mov	ax,*4
08415 24B7           50                         push	ax
08416                                           ! Debug: func () void = bios_printf+0 (used reg = )
08417 24B8           E8         E4EC            call	_bios_printf
08418 24BB           83C4                   04  add	sp,*4
08419                                           !BCC_EOS
08420                                           ! 1609           break;
08421 24BE           EB           22            jmp .1D0
08422                                           !BCC_EOS
08423                                           ! 1610         case 3:
08424                                           ! 1611           bios_printf(4, "r-echs");
08425                       000024C0            .1D9:
08426                                           ! Debug: list * char = .1DA+0 (used reg = )
08427 24C0           BB                   D784  mov	bx,#.1DA
08428 24C3           53                         push	bx
08429                                           ! Debug: list int = const 4 (used reg = )
08430 24C4           B8                   0004  mov	ax,*4
08431 24C7           50                         push	ax
08432                                           ! Debug: func () void = bios_printf+0 (used reg = )
08433 24C8           E8         E4DC            call	_bios_printf
08434 24CB           83C4                   04  add	sp,*4
08435                                           !BCC_EOS
08436                                           ! 1612           break;
08437 24CE           EB           12            jmp .1D0
08438                                           !BCC_EOS
08439                                           ! 1613       }
08440                                           ! 1614       switch (translation) {
08441 24D0           EB           10            jmp .1D0
08442                       000024D2            .1D2:
08443 24D2           2C                     00  sub	al,*0
08444 24D4           74           BA            je 	.1D3
08445 24D6           2C                     01  sub	al,*1
08446 24D8           74           C6            je 	.1D5
08447 24DA           2C                     01  sub	al,*1
08448 24DC           74           D2            je 	.1D7
08449 24DE           2C                     01  sub	al,*1
08450 24E0           74           DE            je 	.1D9
08451                       000024E2            .1D0:
08452                       FFFFFDD8            ..FFFE	=	-$228
08453 24E2           8A86       FDDD            mov	al,-$223[bp]
08454 24E6           E9         0161            br 	.1DD
08455                                           ! 1615         case 0:
08456                                           ! 1616           break;
08457                       000024E9            .1DE:
08458 24E9           E9         0174            br 	.1DB
08459                                           !BCC_EOS
08460                                           ! 1617         case 1:
08461                                           ! 1618           spt = 63;
08462                       000024EC            .1DF:
08463                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08464 24EC           B8                   003F  mov	ax,*$3F
08465 24EF           8986       FDE0            mov	-$220[bp],ax
08466                                           !BCC_EOS
08467                                           ! 1619           
08468                                           ! 1619 sectors_low /= 63;
08469                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08470 24F3           B8                   003F  mov	ax,*$3F
08471 24F6           31DB                       xor	bx,bx
08472 24F8           53                         push	bx
08473 24F9           50                         push	ax
08474 24FA           8B86       FDEA            mov	ax,-$216[bp]
08475 24FE           8B9E       FDEC            mov	bx,-$214[bp]
08476 2502           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08477 2506           E8         DC65            call	ldivul
08478 2509           8986       FDEA            mov	-$216[bp],ax
08479 250D           899E       FDEC            mov	-$214[bp],bx
08480 2511           83C4                   04  add	sp,*4
08481                                           !BCC_EOS
08482                                           ! 1620           heads = sectors_low / 1024;
08483                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08484 2514           B8                   0400  mov	ax,#$400
08485 2517           31DB                       xor	bx,bx
08486 2519           53                         push	bx
08487 251A           50                         push	ax
08488 251B           8B86       FDEA            mov	ax,-$216[bp]
08489 251F           8B9E       FDEC            mov	bx,-$214[bp]
08490 2523           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08491 2527           E8         DC44            call	ldivul
08492 252A           83C4                   04  add	sp,*4
08493                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08494 252D           8986       FDE2            mov	-$21E[bp],ax
08495                                           !BCC_EOS
08496                                           ! 1621           if (heads>128) heads = 255;
08497                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08498 2531           8B86       FDE2            mov	ax,-$21E[bp]
08499 2535           3D                   0080  cmp	ax,#$80
08500 2538           76           09            jbe 	.1E0
08501                       0000253A            .1E1:
08502                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08503 253A           B8                   00FF  mov	ax,#$FF
08504 253D           8986       FDE2            mov	-$21E[bp],ax
08505                                           !BCC_EOS
08506                                           ! 1622           else if (heads>64) heads = 128;
08507 2541           EB           3D            jmp .1E2
08508                       00002543            .1E0:
08509                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08510 2543           8B86       FDE2            mov	ax,-$21E[bp]
08511 2547           3D                   0040  cmp	ax,*$40
08512 254A           76           09            jbe 	.1E3
08513                       0000254C            .1E4:
08514                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08515 254C           B8                   0080  mov	ax,#$80
08516 254F           8986       FDE2            mov	-$21E[bp],ax
08517                                           !BCC_EOS
08518                                           ! 1623           else if (heads>32) heads = 64;
08519 2553           EB           2B            jmp .1E5
08520                       00002555            .1E3:
08521                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08522 2555           8B86       FDE2            mov	ax,-$21E[bp]
08523 2559           3D                   0020  cmp	ax,*$20
08524 255C           76           09            jbe 	.1E6
08525                       0000255E            .1E7:
08526                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08527 255E           B8                   0040  mov	ax,*$40
08528 2561           8986       FDE2            mov	-$21E[bp],ax
08529                                           !BCC_EOS
08530                                           ! 1624           else if (heads>16) heads = 32;
08531 2565           EB           19            jmp .1E8
08532                       00002567            .1E6:
08533                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08534 2567           8B86       FDE2            mov	ax,-$21E[bp]
08535 256B           3D                   0010  cmp	ax,*$10
08536 256E           76           09            jbe 	.1E9
08537                       00002570            .1EA:
08538                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08539 2570           B8                   0020  mov	ax,*$20
08540 2573           8986       FDE2            mov	-$21E[bp],ax
08541                                           !BCC_EOS
08542                                           ! 1625           else heads=16;
08543 2577           EB           07            jmp .1EB
08544                       00002579            .1E9:
08545                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08546 2579           B8                   0010  mov	ax,*$10
08547 257C           8986       FDE2            mov	-$21E[bp],ax
08548                                           !BCC_EOS
08549                                           ! 1626           cylinders = sectors_low / heads;
08550                       00002580            .1EB:
08551                       00002580            .1E8:
08552                       00002580            .1E5:
08553                       00002580            .1E2:
08554                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08555 2580           8B86       FDE2            mov	ax,-$21E[bp]
08556 2584           31DB                       xor	bx,bx
08557                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08558 2586           53                         push	bx
08559 2587           50                         push	ax
08560 2588           8B86       FDEA            mov	ax,-$216[bp]
08561 258C           8B9E       FDEC            mov	bx,-$214[bp]
08562 2590           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08563 2594           E8         DBD7            call	ldivul
08564 2597           83C4                   04  add	sp,*4
08565                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08566 259A           8986       FDE4            mov	-$21C[bp],ax
08567                                           !BCC_EOS
08568                                           ! 1627           break;
08569 259E           E9         00BF            br 	.1DB
08570                                           !BCC_EOS
08571                                           ! 1628         case 3:
08572                                           ! 1629           if (heads==16) {
08573                       000025A1            .1EC:
08574                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08575 25A1           8B86       FDE2            mov	ax,-$21E[bp]
08576 25A5           3D                   0010  cmp	ax,*$10
08577 25A8           75           72            jne 	.1ED
08578                       000025AA            .1EE:
08579                                           ! 1630             if(cylinders>61439) cylinders=61439;
08580                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08581 25AA           8B86       FDE4            mov	ax,-$21C[bp]
08582 25AE           31DB                       xor	bx,bx
08583                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08584 25B0           53                         push	bx
08585 25B1           50                         push	ax
08586 25B2           B8                   EFFF  mov	ax,#$EFFF
08587 25B5           31DB                       xor	bx,bx
08588 25B7           53                         push	bx
08589 25B8           50                         push	ax
08590 25B9           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08591 25BD           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08592 25C1           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08593 25C5           E8         DB03            call	lcmpul
08594 25C8           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08595 25CC           76           07            jbe 	.1EF
08596                       000025CE            .1F0:
08597                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08598 25CE           B8                   EFFF  mov	ax,#$EFFF
08599 25D1           8986       FDE4            mov	-$21C[bp],ax
08600                                           !BCC_EOS
08601                                           ! 1631             heads=15;
08602                       000025D5            .1EF:
08603                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08604 25D5           B8                   000F  mov	ax,*$F
08605 25D8           8986       FDE2            mov	-$21E[bp],ax
08606                                           !BCC_EOS
08607                                           ! 1632             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08608                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08609 25DC           8B86       FDE4            mov	ax,-$21C[bp]
08610 25E0           31DB                       xor	bx,bx
08611                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08612 25E2           53                         push	bx
08613 25E3           50                         push	ax
08614 25E4           B8                   0010  mov	ax,*$10
08615 25E7           31DB                       xor	bx,bx
08616 25E9           53                         push	bx
08617 25EA           50                         push	ax
08618 25EB           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08619 25EF           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08620 25F3           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08621 25F7           E8         DAEF            call	lmulul
08622 25FA           83C4                   08  add	sp,*8
08623                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08624 25FD           53                         push	bx
08625 25FE           50                         push	ax
08626 25FF           B8                   000F  mov	ax,*$F
08627 2602           31DB                       xor	bx,bx
08628 2604           53                         push	bx
08629 2605           50                         push	ax
08630 2606           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08631 260A           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08632 260E           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08633 2612           E8         DB59            call	ldivul
08634 2615           83C4                   08  add	sp,*8
08635                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08636                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08637 2618           8986       FDE4            mov	-$21C[bp],ax
08638                                           !BCC_EOS
08639                                           ! 1633           }
08640                                           ! 1634         case 2:
08641                       0000261C            .1ED:
08642                                           ! 1635           while(cylinders > 1024) {
08643                       0000261C            .1F1:
08644 261C           EB           1F            jmp .1F3
08645                       0000261E            .1F4:
08646                                           ! 1636             cylinders >>= 1;
08647                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08648 261E           8B86       FDE4            mov	ax,-$21C[bp]
08649 2622           D1E8                       shr	ax,*1
08650 2624           8986       FDE4            mov	-$21C[bp],ax
08651                                           !BCC_EOS
08652                                           ! 1637             heads <<= 1;
08653                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08654 2628           8B86       FDE2            mov	ax,-$21E[bp]
08655 262C           D1E0                       shl	ax,*1
08656 262E           8986       FDE2            mov	-$21E[bp],ax
08657                                           !BCC_EOS
08658                                           ! 1638             if (heads > 127) break;
08659                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08660 2632           8B86       FDE2            mov	ax,-$21E[bp]
08661 2636           3D                   007F  cmp	ax,*$7F
08662 2639           76           02            jbe 	.1F5
08663                       0000263B            .1F6:
08664 263B           EB           09            jmp .1F2
08665                                           !BCC_EOS
08666                                           ! 1639           }
08667                       0000263D            .1F5:
08668                                           ! 1640           break;
08669                       0000263D            .1F3:
08670                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08671 263D           8B86       FDE4            mov	ax,-$21C[bp]
08672 2641           3D                   0400  cmp	ax,#$400
08673 2644           77           D8            ja 	.1F4
08674                       00002646            .1F7:
08675                       00002646            .1F2:
08676 2646           EB           18            jmp .1DB
08677                                           !BCC_EOS
08678                                           ! 1641       }
08679                                           ! 1642       if (cylinders > 1024) cylinders=1024;
08680 2648           EB           16            jmp .1DB
08681                       0000264A            .1DD:
08682 264A           2C                     00  sub	al,*0
08683 264C         0F84         FE99            beq 	.1DE
08684 2650           2C                     01  sub	al,*1
08685 2652         0F84         FE96            beq 	.1DF
08686 2656           2C                     01  sub	al,*1
08687 2658           74           C2            je 	.1F1
08688 265A           2C                     01  sub	al,*1
08689 265C         0F84         FF41            beq 	.1EC
08690                       00002660            .1DB:
08691                       FFFFFDD8            ..FFFD	=	-$228
08692                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08693 2660           8B86       FDE4            mov	ax,-$21C[bp]
08694 2664           3D                   0400  cmp	ax,#$400
08695 2667           76           07            jbe 	.1F8
08696                       00002669            .1F9:
08697                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08698 2669           B8                   0400  mov	ax,#$400
08699 266C           8986       FDE4            mov	-$21C[bp],ax
08700                                           !BCC_EOS
08701                                           ! 1643       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08702                       00002670            .1F8:
08703                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08704 2670           FFB6       FDE0            push	-$220[bp]
08705                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08706 2674           FFB6       FDE2            push	-$21E[bp]
08707                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08708 2678           FFB6       FDE4            push	-$21C[bp]
08709                                           ! Debug: list * char = .1FA+0 (used reg = )
08710 267C           BB                   D774  mov	bx,#.1FA
08711 267F           53                         push	bx
08712                                           ! Debug: list int = const 4 (used reg = )
08713 2680           B8                   0004  mov	ax,*4
08714 2683           50                         push	ax
08715                                           ! Debug: func () void = bios_printf+0 (used reg = )
08716 2684           E8         E320            call	_bios_printf
08717 2687           83C4                   0A  add	sp,*$A
08718                                           !BCC_EOS
08719                                           ! 1644       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08720                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08721 268A           FFB6       FDE2            push	-$21E[bp]
08722                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08723 268E           8A46         FB            mov	al,-5[bp]
08724 2691           30E4                       xor	ah,ah
08725 2693           B9                   001E  mov	cx,*$1E
08726 2696           F7E9                       imul	cx
08727 2698           89C3                       mov	bx,ax
08728                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08729                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08730 269A           81C3                 014C  add	bx,#$14C
08731 269E           53                         push	bx
08732                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08733 269F           FF76         FE            push	-2[bp]
08734                                           ! Debug: func () void = write_word+0 (used reg = )
08735 26A2           E8         DF91            call	_write_word
08736 26A5           83C4                   06  add	sp,*6
08737                                           !BCC_EOS
08738                                           ! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
08739                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08740 26A8           FFB6       FDE4            push	-$21C[bp]
08741                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08742 26AC           8A46         FB            mov	al,-5[bp]
08743 26AF           30E4                       xor	ah,ah
08744 26B1           B9                   001E  mov	cx,*$1E
08745 26B4           F7E9                       imul	cx
08746 26B6           89C3                       mov	bx,ax
08747                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08748                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
08749 26B8           81C3                 014E  add	bx,#$14E
08750 26BC           53                         push	bx
08751                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08752 26BD           FF76         FE            push	-2[bp]
08753                                           ! Debug: func () void = write_word+0 (used reg = )
08754 26C0           E8         DF73            call	_write_word
08755 26C3           83C4                   06  add	sp,*6
08756                                           !BCC_EOS
08757                                           ! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
08758                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08759 26C6           FFB6       FDE0            push	-$220[bp]
08760                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08761 26CA           8A46         FB            mov	al,-5[bp]
08762 26CD           30E4                       xor	ah,ah
08763 26CF           B9                   001E  mov	cx,*$1E
08764 26D2           F7E9                       imul	cx
08765 26D4           89C3                       mov	bx,ax
08766                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08767                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
08768 26D6           81C3                 0150  add	bx,#$150
08769 26DA           53                         push	bx
08770                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08771 26DB           FF76         FE            push	-2[bp]
08772                                           ! Debug: func () void = write_word+0 (used reg = )
08773 26DE           E8         DF55            call	_write_word
08774 26E1           83C4                   06  add	sp,*6
08775                                           !BCC_EOS
08776                                           ! 1647       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
08777                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
08778 26E4           8A46         FB            mov	al,-5[bp]
08779 26E7           30E4                       xor	ah,ah
08780 26E9           50                         push	ax
08781                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
08782 26EA           8A46         FD            mov	al,-3[bp]
08783 26ED           30E4                       xor	ah,ah
08784 26EF           89C3                       mov	bx,ax
08785                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08786                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
08787 26F1           81C3                 0233  add	bx,#$233
08788 26F5           53                         push	bx
08789                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08790 26F6           FF76         FE            push	-2[bp]
08791                                           ! Debug: func () void = write_byte+0 (used reg = )
08792 26F9           E8         DF22            call	_write_byte
08793 26FC           83C4                   06  add	sp,*6
08794                                           !BCC_EOS
08795                                           ! 1648       hdcount++;
08796                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
08797 26FF           8A46         FD            mov	al,-3[bp]
08798 2702           40                         inc	ax
08799 2703           8846         FD            mov	-3[bp],al
08800                                           !BCC_EOS
08801                                           ! 1649     }
08802 2706           83C4                   14  add	sp,*$14
08803                                           ! 1650     if(type == 0x03) {
08804                       00002709            .1BC:
08805                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
08806 2709           8A46         FA            mov	al,-6[bp]
08807 270C           3C                     03  cmp	al,*3
08808 270E         0F85         0180            bne 	.1FB
08809                       00002712            .1FC:
08810                                           ! 1651       Bit8u type, removable, mode;
08811                                           !BCC_EOS
08812                                           ! 1652       Bit16u blksize;
08813                                           !BCC_EOS
08814                                           ! 1653       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
08815 2712           83C4                   FA  add	sp,*-6
08816                                           ! Debug: list int = const 5 (used reg = )
08817 2715           B8                   0005  mov	ax,*5
08818 2718           50                         push	ax
08819                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08820 2719           8A46         FB            mov	al,-5[bp]
08821 271C           30E4                       xor	ah,ah
08822 271E           B9                   001E  mov	cx,*$1E
08823 2721           F7E9                       imul	cx
08824 2723           89C3                       mov	bx,ax
08825                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08826                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08827 2725           81C3                 0143  add	bx,#$143
08828 2729           53                         push	bx
08829                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08830 272A           FF76         FE            push	-2[bp]
08831                                           ! Debug: func () void = write_byte+0 (used reg = )
08832 272D           E8         DEEE            call	_write_byte
08833 2730           83C4                   06  add	sp,*6
08834                                           !BCC_EOS
08835                                           ! 1654       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08836                                           ! Debug: list int = const 0 (used reg = )
08837 2733           31C0                       xor	ax,ax
08838 2735           50                         push	ax
08839                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08840 2736           8A46         FB            mov	al,-5[bp]
08841 2739           30E4                       xor	ah,ah
08842 273B           B9                   001E  mov	cx,*$1E
08843 273E           F7E9                       imul	cx
08844 2740           89C3                       mov	bx,ax
08845                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08846                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08847 2742           81C3                 0146  add	bx,#$146
08848 2746           53                         push	bx
08849                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08850 2747           FF76         FE            push	-2[bp]
08851                                           ! Debug: func () void = write_byte+0 (used reg = )
08852 274A           E8         DED1            call	_write_byte
08853 274D           83C4                   06  add	sp,*6
08854                                           !BCC_EOS
08855                                           ! 1655       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08856                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08857 2750           8D9E       FDFA            lea	bx,-$206[bp]
08858 2754           53                         push	bx
08859                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08860 2755           E8         DEF9            call	_get_SS
08861                                           ! Debug: list unsigned short = ax+0 (used reg = )
08862 2758           50                         push	ax
08863                                           ! Debug: list long = const 0 (used reg = )
08864 2759           31C0                       xor	ax,ax
08865 275B           31DB                       xor	bx,bx
08866 275D           53                         push	bx
08867 275E           50                         push	ax
08868                                           ! Debug: list long = const 0 (used reg = )
08869 275F           31C0                       xor	ax,ax
08870 2761           31DB                       xor	bx,bx
08871 2763           53                         push	bx
08872 2764           50                         push	ax
08873                                           ! Debug: list int = const 0 (used reg = )
08874 2765           31C0                       xor	ax,ax
08875 2767           50                         push	ax
08876                                           ! Debug: list int = const 0 (used reg = )
08877 2768           31C0                       xor	ax,ax
08878 276A           50                         push	ax
08879                                           ! Debug: list int = const 0 (used reg = )
08880 276B           31C0                       xor	ax,ax
08881 276D           50                         push	ax
08882                                           ! Debug: list int = const 1 (used reg = )
08883 276E           B8                   0001  mov	ax,*1
08884 2771           50                         push	ax
08885                                           ! Debug: list int = const $A1 (used reg = )
08886 2772           B8                   00A1  mov	ax,#$A1
08887 2775           50                         push	ax
08888                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
08889 2776           8A46         FB            mov	al,-5[bp]
08890 2779           30E4                       xor	ah,ah
08891 277B           50                         push	ax
08892                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08893 277C           E8         06A5            call	_ata_cmd_data_in
08894 277F           83C4                   18  add	sp,*$18
08895                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08896 2782           85C0                       test	ax,ax
08897 2784           74           0E            je  	.1FD
08898                       00002786            .1FE:
08899                                           ! 1656         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08900                                           ! Debug: list * char = .1FF+0 (used reg = )
08901 2786           BB                   D749  mov	bx,#.1FF
08902 2789           53                         push	bx
08903                                           ! Debug: list int = const 7 (used reg = )
08904 278A           B8                   0007  mov	ax,*7
08905 278D           50                         push	ax
08906                                           ! Debug: func () void = bios_printf+0 (used reg = )
08907 278E           E8         E216            call	_bios_printf
08908 2791           83C4                   04  add	sp,*4
08909                                           !BCC_EOS
08910                                           ! 1657       type = read_byte(get_SS(),buffer+1) & 0x1f;
08911                       00002794            .1FD:
08912                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
08913 2794           8D9E       FDFB            lea	bx,-$205[bp]
08914 2798           53                         push	bx
08915                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08916 2799           E8         DEB5            call	_get_SS
08917                                           ! Debug: list unsigned short = ax+0 (used reg = )
08918 279C           50                         push	ax
08919                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08920 279D           E8         DE58            call	_read_byte
08921 27A0           83C4                   04  add	sp,*4
08922                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08923 27A3           24                     1F  and	al,*$1F
08924                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
08925 27A5           8886       FDED            mov	-$213[bp],al
08926                                           !BCC_EOS
08927                                           ! 1658       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08928                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08929 27A9           8D9E       FDFA            lea	bx,-$206[bp]
08930 27AD           53                         push	bx
08931                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08932 27AE           E8         DEA0            call	_get_SS
08933                                           ! Debug: list unsigned short = ax+0 (used reg = )
08934 27B1           50                         push	ax
08935                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08936 27B2           E8         DE43            call	_read_byte
08937 27B5           83C4                   04  add	sp,*4
08938                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08939 27B8           24                     80  and	al,#$80
08940 27BA           84C0                       test	al,al
08941 27BC           74           04            je  	.200
08942                       000027BE            .201:
08943 27BE           B0                     01  mov	al,*1
08944 27C0           EB           02            jmp .202
08945                       000027C2            .200:
08946 27C2           30C0                       xor	al,al
08947                       000027C4            .202:
08948                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
08949 27C4           8886       FDEC            mov	-$214[bp],al
08950                                           !BCC_EOS
08951                                           ! 1659       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08952                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
08953 27C8           8D9E       FE5A            lea	bx,-$1A6[bp]
08954 27CC           53                         push	bx
08955                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08956 27CD           E8         DE81            call	_get_SS
08957                                           ! Debug: list unsigned short = ax+0 (used reg = )
08958 27D0           50                         push	ax
08959                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08960 27D1           E8         DE24            call	_read_byte
08961 27D4           83C4                   04  add	sp,*4
08962 27D7           84C0                       test	al,al
08963 27D9           74           04            je  	.203
08964                       000027DB            .204:
08965 27DB           B0                     01  mov	al,*1
08966 27DD           EB           02            jmp .205
08967                       000027DF            .203:
08968 27DF           30C0                       xor	al,al
08969                       000027E1            .205:
08970                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
08971 27E1           8886       FDEB            mov	-$215[bp],al
08972                                           !BCC_EOS
08973                                           ! 1660       blksize = 2048;
08974                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
08975 27E5           B8                   0800  mov	ax,#$800
08976 27E8           8986       FDE8            mov	-$218[bp],ax
08977                                           !BCC_EOS
08978                                           ! 1661       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
08979                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
08980 27EC           8A86       FDED            mov	al,-$213[bp]
08981 27F0           30E4                       xor	ah,ah
08982 27F2           50                         push	ax
08983                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08984 27F3           8A46         FB            mov	al,-5[bp]
08985 27F6           30E4                       xor	ah,ah
08986 27F8           B9                   001E  mov	cx,*$1E
08987 27FB           F7E9                       imul	cx
08988 27FD           89C3                       mov	bx,ax
08989                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08990                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08991 27FF           81C3                 0143  add	bx,#$143
08992 2803           53                         push	bx
08993                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08994 2804           FF76         FE            push	-2[bp]
08995                                           ! Debug: func () void = write_byte+0 (used reg = )
08996 2807           E8         DE14            call	_write_byte
08997 280A           83C4                   06  add	sp,*6
08998                                           !BCC_EOS
08999                                           ! 1662       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09000                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09001 280D           8A86       FDEC            mov	al,-$214[bp]
09002 2811           30E4                       xor	ah,ah
09003 2813           50                         push	ax
09004                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09005 2814           8A46         FB            mov	al,-5[bp]
09006 2817           30E4                       xor	ah,ah
09007 2819           B9                   001E  mov	cx,*$1E
09008 281C           F7E9                       imul	cx
09009 281E           89C3                       mov	bx,ax
09010                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09011                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09012 2820           81C3                 0144  add	bx,#$144
09013 2824           53                         push	bx
09014                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09015 2825           FF76         FE            push	-2[bp]
09016                                           ! Debug: func () void = write_byte+0 (used reg = )
09017 2828           E8         DDF3            call	_write_byte
09018 282B           83C4                   06  add	sp,*6
09019                                           !BCC_EOS
09020                                           ! 1663       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09021                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09022 282E           8A86       FDEB            mov	al,-$215[bp]
09023 2832           30E4                       xor	ah,ah
09024 2834           50                         push	ax
09025                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09026 2835           8A46         FB            mov	al,-5[bp]
09027 2838           30E4                       xor	ah,ah
09028 283A           B9                   001E  mov	cx,*$1E
09029 283D           F7E9                       imul	cx
09030 283F           89C3                       mov	bx,ax
09031                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09032                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09033 2841           81C3                 0146  add	bx,#$146
09034 2845           53                         push	bx
09035                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09036 2846           FF76         FE            push	-2[bp]
09037                                           ! Debug: func () void = write_byte+0 (used reg = )
09038 2849           E8         DDD2            call	_write_byte
09039 284C           83C4                   06  add	sp,*6
09040                                           !BCC_EOS
09041                                           ! 1664       write_word(ebda_seg,&((ebda_data_t *)
09042                                           ! 1664  0)->ata.devices[device].blksize, blksize);
09043                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09044 284F           FFB6       FDE8            push	-$218[bp]
09045                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09046 2853           8A46         FB            mov	al,-5[bp]
09047 2856           30E4                       xor	ah,ah
09048 2858           B9                   001E  mov	cx,*$1E
09049 285B           F7E9                       imul	cx
09050 285D           89C3                       mov	bx,ax
09051                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09052                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09053 285F           81C3                 0148  add	bx,#$148
09054 2863           53                         push	bx
09055                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09056 2864           FF76         FE            push	-2[bp]
09057                                           ! Debug: func () void = write_word+0 (used reg = )
09058 2867           E8         DDCC            call	_write_word
09059 286A           83C4                   06  add	sp,*6
09060                                           !BCC_EOS
09061                                           ! 1665       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09062                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09063 286D           8A46         FB            mov	al,-5[bp]
09064 2870           30E4                       xor	ah,ah
09065 2872           50                         push	ax
09066                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09067 2873           8A46         FC            mov	al,-4[bp]
09068 2876           30E4                       xor	ah,ah
09069 2878           89C3                       mov	bx,ax
09070                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09071                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09072 287A           81C3                 023C  add	bx,#$23C
09073 287E           53                         push	bx
09074                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09075 287F           FF76         FE            push	-2[bp]
09076                                           ! Debug: func () void = write_byte+0 (used reg = )
09077 2882           E8         DD99            call	_write_byte
09078 2885           83C4                   06  add	sp,*6
09079                                           !BCC_EOS
09080                                           ! 1666       cdcount++;
09081                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09082 2888           8A46         FC            mov	al,-4[bp]
09083 288B           40                         inc	ax
09084 288C           8846         FC            mov	-4[bp],al
09085                                           !BCC_EOS
09086                                           ! 1667     }
09087 288F           83C4                   06  add	sp,*6
09088                                           ! 1668     {
09089                       00002892            .1FB:
09090                                           ! 1669       Bit32u sizeinmb;
09091                                           !BCC_EOS
09092                                           ! 1670       Bit16u ataversion;
09093                                           !BCC_EOS
09094                                           ! 1671       Bit8u c, i, version, model[41];
09095                                           !BCC_EOS
09096                                           ! 1672       switch (type) {
09097 2892           83C4                   CE  add	sp,*-$32
09098 2895           8A46         FA            mov	al,-6[bp]
09099 2898           E9         020B            br 	.208
09100                                           ! 1673         case 0x02:
09101                                           ! 1674           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
09102                       0000289B            .209:
09103                                           ! 1675             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09104                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09105 289B           8A46         FB            mov	al,-5[bp]
09106 289E           30E4                       xor	ah,ah
09107 28A0           B9                   001E  mov	cx,*$1E
09108 28A3           F7E9                       imul	cx
09109 28A5           89C3                       mov	bx,ax
09110                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09111                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09112 28A7           81C3                 0158  add	bx,#$158
09113 28AB           53                         push	bx
09114                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09115 28AC           FF76         FE            push	-2[bp]
09116                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09117 28AF           E8         D7D1            call	_read_dword
09118 28B2           89D3                       mov	bx,dx
09119 28B4           83C4                   04  add	sp,*4
09120                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09121 28B7           88E0                       mov	al,ah
09122 28B9           88DC                       mov	ah,bl
09123 28BB           88FB                       mov	bl,bh
09124 28BD           28FF                       sub	bh,bh
09125 28BF           BF                   0003  mov	di,*3
09126 28C2           E8         D864            call	lsrul
09127 28C5           53                         push	bx
09128 28C6           50                         push	ax
09129                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09130 28C7           8A46         FB            mov	al,-5[bp]
09131 28CA           30E4                       xor	ah,ah
09132 28CC           B9                   001E  mov	cx,*$1E
09133 28CF           F7E9                       imul	cx
09134 28D1           89C3                       mov	bx,ax
09135                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09136                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09137 28D3           81C3                 015C  add	bx,#$15C
09138 28D7           53                         push	bx
09139                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09140 28D8           FF76         FE            push	-2[bp]
09141                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09142 28DB           E8         D7A5            call	_read_dword
09143 28DE           89D3                       mov	bx,dx
09144 28E0           83C4                   04  add	sp,*4
09145                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09146 28E3           B1                     05  mov	cl,*5
09147 28E5           D3E0                       shl	ax,cl
09148 28E7           93                         xchg	bx,ax
09149 28E8           31C0                       xor	ax,ax
09150                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09151 28EA           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09152 28EE           E8         D816            call	lorul
09153 28F1           83C4                   04  add	sp,*4
09154                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09155 28F4           8986       FDEA            mov	-$216[bp],ax
09156 28F8           899E       FDEC            mov	-$214[bp],bx
09157                                           !BCC_EOS
09158                                           ! 1676         case 0x03:
09159                                           ! 1677           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09160                       000028FC            .20A:
09161                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09162 28FC           8D9E       FE9A            lea	bx,-$166[bp]
09163 2900           53                         push	bx
09164                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09165 2901           E8         DD4D            call	_get_SS
09166                                           ! Debug: list unsigned short = ax+0 (used reg = )
09167 2904           50                         push	ax
09168                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09169 2905           E8         DCF0            call	_read_byte
09170 2908           83C4                   04  add	sp,*4
09171 290B           50                         push	ax
09172                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09173 290C           8D9E       FE9B            lea	bx,-$165[bp]
09174 2910           53                         push	bx
09175                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09176 2911           E8         DD3D            call	_get_SS
09177                                           ! Debug: list unsigned short = ax+0 (used reg = )
09178 2914           50                         push	ax
09179                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09180 2915           E8         DCE0            call	_read_byte
09181 2918           83C4                   04  add	sp,*4
09182                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09183 291B           30E4                       xor	ah,ah
09184                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09185 291D           88C4                       mov	ah,al
09186 291F           30C0                       xor	al,al
09187                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09188 2921           0A86       FDBA            or	al,0+..FFFC[bp]
09189 2925           44                         inc	sp
09190 2926           44                         inc	sp
09191                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09192 2927           8986       FDE8            mov	-$218[bp],ax
09193                                           !BCC_EOS
09194                                           ! 1678           for(version=15;version>0;version--) {
09195                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09196 292B           B0                     0F  mov	al,*$F
09197 292D           8886       FDE5            mov	-$21B[bp],al
09198                                           !BCC_EOS
09199                                           !BCC_EOS
09200 2931           EB           22            jmp .20D
09201                       00002933            .20E:
09202                                           ! 1679             if((ataversion&(1<<version))!=0)
09203                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09204 2933           8A86       FDE5            mov	al,-$21B[bp]
09205 2937           30E4                       xor	ah,ah
09206 2939           89C3                       mov	bx,ax
09207 293B           B8                   0001  mov	ax,*1
09208 293E           89D9                       mov	cx,bx
09209 2940           D3E0                       shl	ax,cl
09210                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09211                                           ! Debug: expression subtree swapping
09212 2942           2386       FDE8            and	ax,-$218[bp]
09213                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09214 2946           85C0                       test	ax,ax
09215 2948           74           02            je  	.20F
09216                       0000294A            .210:
09217                                           ! 1680             break;
09218 294A           EB           11            jmp .20B
09219                                           !BCC_EOS
09220                                           ! 1681           }
09221                       0000294C            .20F:
09222                                           ! 1682           for(i=0;i<20;i++) {
09223                       0000294C            .20C:
09224                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09225 294C           8A86       FDE5            mov	al,-$21B[bp]
09226 2950           48                         dec	ax
09227 2951           8886       FDE5            mov	-$21B[bp],al
09228                       00002955            .20D:
09229                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09230 2955           8A86       FDE5            mov	al,-$21B[bp]
09231 2959           84C0                       test	al,al
09232 295B           75           D6            jne	.20E
09233                       0000295D            .211:
09234                       0000295D            .20B:
09235                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09236 295D           30C0                       xor	al,al
09237 295F           8886       FDE6            mov	-$21A[bp],al
09238                                           !BCC_EOS
09239                                           !BCC_EOS
09240 2963           EB           7B            jmp .214
09241                       00002965            .215:
09242                                           ! 1683             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09243                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09244 2965           8A86       FDE6            mov	al,-$21A[bp]
09245 2969           30E4                       xor	ah,ah
09246 296B           D1E0                       shl	ax,*1
09247                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09248 296D           89EB                       mov	bx,bp
09249 296F           01C3                       add	bx,ax
09250                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09251                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09252                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09253                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09254 2971           81C3                 FE31  add	bx,#-$1CF
09255 2975           53                         push	bx
09256                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09257 2976           E8         DCD8            call	_get_SS
09258                                           ! Debug: list unsigned short = ax+0 (used reg = )
09259 2979           50                         push	ax
09260                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09261 297A           E8         DC7B            call	_read_byte
09262 297D           83C4                   04  add	sp,*4
09263                                           ! Debug: list unsigned char = al+0 (used reg = )
09264 2980           30E4                       xor	ah,ah
09265 2982           50                         push	ax
09266                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09267 2983           8A86       FDE6            mov	al,-$21A[bp]
09268 2987           30E4                       xor	ah,ah
09269 2989           D1E0                       shl	ax,*1
09270                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09271 298B           89EB                       mov	bx,bp
09272 298D           01C3                       add	bx,ax
09273                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09274                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09275 298F           81C3                 FDBC  add	bx,#-$244
09276 2993           53                         push	bx
09277                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09278 2994           E8         DCBA            call	_get_SS
09279                                           ! Debug: list unsigned short = ax+0 (used reg = )
09280 2997           50                         push	ax
09281                                           ! Debug: func () void = write_byte+0 (used reg = )
09282 2998           E8         DC83            call	_write_byte
09283 299B           83C4                   06  add	sp,*6
09284                                           !BCC_EOS
09285                                           ! 1684             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09286                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09287 299E           8A86       FDE6            mov	al,-$21A[bp]
09288 29A2           30E4                       xor	ah,ah
09289 29A4           D1E0                       shl	ax,*1
09290                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09291 29A6           89EB                       mov	bx,bp
09292 29A8           01C3                       add	bx,ax
09293                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09294                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09295                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09296 29AA           81C3                 FE30  add	bx,#-$1D0
09297 29AE           53                         push	bx
09298                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09299 29AF           E8         DC9F            call	_get_SS
09300                                           ! Debug: list unsigned short = ax+0 (used reg = )
09301 29B2           50                         push	ax
09302                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09303 29B3           E8         DC42            call	_read_byte
09304 29B6           83C4                   04  add	sp,*4
09305                                           ! Debug: list unsigned char = al+0 (used reg = )
09306 29B9           30E4                       xor	ah,ah
09307 29BB           50                         push	ax
09308                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09309 29BC           8A86       FDE6            mov	al,-$21A[bp]
09310 29C0           30E4                       xor	ah,ah
09311 29C2           D1E0                       shl	ax,*1
09312                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09313 29C4           89EB                       mov	bx,bp
09314 29C6           01C3                       add	bx,ax
09315                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09316                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09317                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09318 29C8           81C3                 FDBD  add	bx,#-$243
09319 29CC           53                         push	bx
09320                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09321 29CD           E8         DC81            call	_get_SS
09322                                           ! Debug: list unsigned short = ax+0 (used reg = )
09323 29D0           50                         push	ax
09324                                           ! Debug: func () void = write_byte+0 (used reg = )
09325 29D1           E8         DC4A            call	_write_byte
09326 29D4           83C4                   06  add	sp,*6
09327                                           !BCC_EOS
09328                                           ! 1685           }
09329                                           ! 1686           write_byte(get_SS(),model+40,0x00);
09330                       000029D7            .213:
09331                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09332 29D7           8A86       FDE6            mov	al,-$21A[bp]
09333 29DB           40                         inc	ax
09334 29DC           8886       FDE6            mov	-$21A[bp],al
09335                       000029E0            .214:
09336                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09337 29E0           8A86       FDE6            mov	al,-$21A[bp]
09338 29E4           3C                     14  cmp	al,*$14
09339 29E6         0F82         FF7B            blo 	.215
09340                       000029EA            .216:
09341                       000029EA            .212:
09342                                           ! Debug: list int = const 0 (used reg = )
09343 29EA           31C0                       xor	ax,ax
09344 29EC           50                         push	ax
09345                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09346 29ED           8D9E       FDE4            lea	bx,-$21C[bp]
09347 29F1           53                         push	bx
09348                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09349 29F2           E8         DC5C            call	_get_SS
09350                                           ! Debug: list unsigned short = ax+0 (used reg = )
09351 29F5           50                         push	ax
09352                                           ! Debug: func () void = write_byte+0 (used reg = )
09353 29F6           E8         DC25            call	_write_byte
09354 29F9           83C4                   06  add	sp,*6
09355                                           !BCC_EOS
09356                                           ! 1687           for(i=39;i>0;i--){
09357                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09358 29FC           B0                     27  mov	al,*$27
09359 29FE           8886       FDE6            mov	-$21A[bp],al
09360                                           !BCC_EOS
09361                                           !BCC_EOS
09362 2A02           EB           46            jmp .219
09363                       00002A04            .21A:
09364                                           ! 1688             if(read_byte(get_SS(),model+i)==0x20)
09365                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09366 2A04           8A86       FDE6            mov	al,-$21A[bp]
09367 2A08           30E4                       xor	ah,ah
09368 2A0A           89EB                       mov	bx,bp
09369 2A0C           01C3                       add	bx,ax
09370                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09371                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09372 2A0E           81C3                 FDBC  add	bx,#-$244
09373 2A12           53                         push	bx
09374                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09375 2A13           E8         DC3B            call	_get_SS
09376                                           ! Debug: list unsigned short = ax+0 (used reg = )
09377 2A16           50                         push	ax
09378                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09379 2A17           E8         DBDE            call	_read_byte
09380 2A1A           83C4                   04  add	sp,*4
09381                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09382 2A1D           3C                     20  cmp	al,*$20
09383 2A1F           75           1E            jne 	.21B
09384                       00002A21            .21C:
09385                                           ! 1689               write_byte(get_SS(),model+i,0x00);
09386                                           ! Debug: list int = const 0 (used reg = )
09387 2A21           31C0                       xor	ax,ax
09388 2A23           50                         push	ax
09389                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09390 2A24           8A86       FDE6            mov	al,-$21A[bp]
09391 2A28           30E4                       xor	ah,ah
09392 2A2A           89EB                       mov	bx,bp
09393 2A2C           01C3                       add	bx,ax
09394                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09395                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09396 2A2E           81C3                 FDBC  add	bx,#-$244
09397 2A32           53                         push	bx
09398                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09399 2A33           E8         DC1B            call	_get_SS
09400                                           ! Debug: list unsigned short = ax+0 (used reg = )
09401 2A36           50                         push	ax
09402                                           ! Debug: func () void = write_byte+0 (used reg = )
09403 2A37           E8         DBE4            call	_write_byte
09404 2A3A           83C4                   06  add	sp,*6
09405                                           !BCC_EOS
09406                                           ! 1690             else break;
09407 2A3D           EB           02            jmp .21D
09408                       00002A3F            .21B:
09409 2A3F           EB           11            jmp .217
09410                                           !BCC_EOS
09411                                           ! 1691           }
09412                       00002A41            .21D:
09413                                           ! 1692           if (i>36) {
09414                       00002A41            .218:
09415                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09416 2A41           8A86       FDE6            mov	al,-$21A[bp]
09417 2A45           48                         dec	ax
09418 2A46           8886       FDE6            mov	-$21A[bp],al
09419                       00002A4A            .219:
09420                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09421 2A4A           8A86       FDE6            mov	al,-$21A[bp]
09422 2A4E           84C0                       test	al,al
09423 2A50           75           B2            jne	.21A
09424                       00002A52            .21E:
09425                       00002A52            .217:
09426                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09427 2A52           8A86       FDE6            mov	al,-$21A[bp]
09428 2A56           3C                     24  cmp	al,*$24
09429 2A58           76           48            jbe 	.21F
09430                       00002A5A            .220:
09431                                           ! 1693             write_byte(get_SS(),model+36,0x00);
09432                                           ! Debug: list int = const 0 (used reg = )
09433 2A5A           31C0                       xor	ax,ax
09434 2A5C           50                         push	ax
09435                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09436 2A5D           8D9E       FDE0            lea	bx,-$220[bp]
09437 2A61           53                         push	bx
09438                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09439 2A62           E8         DBEC            call	_get_SS
09440                                           ! Debug: list unsigned short = ax+0 (used reg = )
09441 2A65           50                         push	ax
09442                                           ! Debug: func () void = write_byte+0 (used reg = )
09443 2A66           E8         DBB5            call	_write_byte
09444 2A69           83C4                   06  add	sp,*6
09445                                           !BCC_EOS
09446                                           ! 1694             for(i=35;i>32;i--){
09447                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09448 2A6C           B0                     23  mov	al,*$23
09449 2A6E           8886       FDE6            mov	-$21A[bp],al
09450                                           !BCC_EOS
09451                                           !BCC_EOS
09452 2A72           EB           26            jmp .223
09453                       00002A74            .224:
09454                                           ! 1695               write_byte(get_SS(),model+i,0x2E);
09455                                           ! Debug: list int = const $2E (used reg = )
09456 2A74           B8                   002E  mov	ax,*$2E
09457 2A77           50                         push	ax
09458                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09459 2A78           8A86       FDE6            mov	al,-$21A[bp]
09460 2A7C           30E4                       xor	ah,ah
09461 2A7E           89EB                       mov	bx,bp
09462 2A80           01C3                       add	bx,ax
09463                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09464                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09465 2A82           81C3                 FDBC  add	bx,#-$244
09466 2A86           53                         push	bx
09467                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09468 2A87           E8         DBC7            call	_get_SS
09469                                           ! Debug: list unsigned short = ax+0 (used reg = )
09470 2A8A           50                         push	ax
09471                                           ! Debug: func () void = write_byte+0 (used reg = )
09472 2A8B           E8         DB90            call	_write_byte
09473 2A8E           83C4                   06  add	sp,*6
09474                                           !BCC_EOS
09475                                           ! 1696             }
09476                                           ! 1697           }
09477                       00002A91            .222:
09478                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09479 2A91           8A86       FDE6            mov	al,-$21A[bp]
09480 2A95           48                         dec	ax
09481 2A96           8886       FDE6            mov	-$21A[bp],al
09482                       00002A9A            .223:
09483                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09484 2A9A           8A86       FDE6            mov	al,-$21A[bp]
09485 2A9E           3C                     20  cmp	al,*$20
09486 2AA0           77           D2            ja 	.224
09487                       00002AA2            .225:
09488                       00002AA2            .221:
09489                                           ! 1698           break;
09490                       00002AA2            .21F:
09491 2AA2           EB           0E            jmp .206
09492                                           !BCC_EOS
09493                                           ! 1699       }
09494                                           ! 1700       switch (type) {
09495 2AA4           EB           0C            jmp .206
09496                       00002AA6            .208:
09497 2AA6           2C                     02  sub	al,*2
09498 2AA8         0F84         FDEF            beq 	.209
09499 2AAC           2C                     01  sub	al,*1
09500 2AAE         0F84         FE4A            beq 	.20A
09501                       00002AB2            .206:
09502                       FFFFFDBA            ..FFFC	=	-$246
09503 2AB2           8A46         FA            mov	al,-6[bp]
09504 2AB5           E9         01A2            br 	.228
09505                                           ! 1701         case 0x02:
09506                                           ! 1702           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09507                       00002AB8            .229:
09508 2AB8           8A86       FDF4            mov	al,-$20C[bp]
09509 2ABC           84C0                       test	al,al
09510 2ABE           74           05            je  	.22D
09511                       00002AC0            .22E:
09512 2AC0           BB                   D737  mov	bx,#.22B
09513 2AC3           EB           03            jmp .22F
09514                       00002AC5            .22D:
09515 2AC5           BB                   D730  mov	bx,#.22C
09516                       00002AC8            .22F:
09517                                           ! Debug: list * char = bx+0 (used reg = )
09518 2AC8           53                         push	bx
09519                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09520 2AC9           8A86       FDF5            mov	al,-$20B[bp]
09521 2ACD           30E4                       xor	ah,ah
09522 2ACF           50                         push	ax
09523                                           ! Debug: list * char = .22A+0 (used reg = )
09524 2AD0           BB                   D73E  mov	bx,#.22A
09525 2AD3           53                         push	bx
09526                                           ! Debug: list int = const 2 (used reg = )
09527 2AD4           B8                   0002  mov	ax,*2
09528 2AD7           50                         push	ax
09529                                           ! Debug: func () void = bios_printf+0 (used reg = )
09530 2AD8           E8         DECC            call	_bios_printf
09531 2ADB           83C4                   08  add	sp,*8
09532                                           !BCC_EOS
09533                                           ! 1703           i=0;
09534                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09535 2ADE           30C0                       xor	al,al
09536 2AE0           8886       FDE6            mov	-$21A[bp],al
09537                                           !BCC_EOS
09538                                           ! 1704           while(c=read_byte(get_SS(),model+i++))
09539                                           ! 1705             bios_printf(2, "%c",c);
09540 2AE4           EB           15            jmp .231
09541                       00002AE6            .232:
09542                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09543 2AE6           8A86       FDE7            mov	al,-$219[bp]
09544 2AEA           30E4                       xor	ah,ah
09545 2AEC           50                         push	ax
09546                                           ! Debug: list * char = .233+0 (used reg = )
09547 2AED           BB                   D72D  mov	bx,#.233
09548 2AF0           53                         push	bx
09549                                           ! Debug: list int = const 2 (used reg = )
09550 2AF1           B8                   0002  mov	ax,*2
09551 2AF4           50                         push	ax
09552                                           ! Debug: func () void = bios_printf+0 (used reg = )
09553 2AF5           E8         DEAF            call	_bios_printf
09554 2AF8           83C4                   06  add	sp,*6
09555                                           !BCC_EOS
09556                                           ! 1706           if (sizeinmb < (1UL<<16))
09557                       00002AFB            .231:
09558                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09559 2AFB           8A86       FDE6            mov	al,-$21A[bp]
09560 2AFF           40                         inc	ax
09561 2B00           8886       FDE6            mov	-$21A[bp],al
09562                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09563 2B04           48                         dec	ax
09564 2B05           30E4                       xor	ah,ah
09565 2B07           89EB                       mov	bx,bp
09566 2B09           01C3                       add	bx,ax
09567                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09568                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09569 2B0B           81C3                 FDBC  add	bx,#-$244
09570 2B0F           53                         push	bx
09571                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09572 2B10           E8         DB3E            call	_get_SS
09573                                           ! Debug: list unsigned short = ax+0 (used reg = )
09574 2B13           50                         push	ax
09575                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09576 2B14           E8         DAE1            call	_read_byte
09577 2B17           83C4                   04  add	sp,*4
09578                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09579 2B1A           8886       FDE7            mov	-$219[bp],al
09580 2B1E           84C0                       test	al,al
09581 2B20           75           C4            jne	.232
09582                       00002B22            .234:
09583                       00002B22            .230:
09584                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09585 2B22           31C0                       xor	ax,ax
09586 2B24           BB                   0001  mov	bx,*1
09587 2B27           8DBE       FDEA            lea	di,-$216[bp]
09588 2B2B           E8         D59D            call	lcmpul
09589 2B2E           76           1B            jbe 	.235
09590                       00002B30            .236:
09591                                           ! 1707             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09592                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
09593 2B30           FFB6       FDEA            push	-$216[bp]
09594                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09595 2B34           8A86       FDE5            mov	al,-$21B[bp]
09596 2B38           30E4                       xor	ah,ah
09597 2B3A           50                         push	ax
09598                                           ! Debug: list * char = .237+0 (used reg = )
09599 2B3B           BB                   D70D  mov	bx,#.237
09600 2B3E           53                         push	bx
09601                                           ! Debug: list int = const 2 (used reg = )
09602 2B3F           B8                   0002  mov	ax,*2
09603 2B42           50                         push	ax
09604                                           ! Debug: func () void = bios_printf+0 (used reg = )
09605 2B43           E8         DE61            call	_bios_printf
09606 2B46           83C4                   08  add	sp,*8
09607                                           !BCC_EOS
09608                                           ! 1708           else
09609                                           ! 1709             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09610 2B49           EB           2C            jmp .238
09611                       00002B4B            .235:
09612                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09613 2B4B           8B86       FDEA            mov	ax,-$216[bp]
09614 2B4F           8B9E       FDEC            mov	bx,-$214[bp]
09615 2B53           88E0                       mov	al,ah
09616 2B55           88DC                       mov	ah,bl
09617 2B57           88FB                       mov	bl,bh
09618 2B59           28FF                       sub	bh,bh
09619 2B5B           BF                   0002  mov	di,*2
09620 2B5E           E8         D5C8            call	lsrul
09621                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09622                                           ! Debug: list unsigned short = ax+0 (used reg = )
09623 2B61           50                         push	ax
09624                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09625 2B62           8A86       FDE5            mov	al,-$21B[bp]
09626 2B66           30E4                       xor	ah,ah
09627 2B68           50                         push	ax
09628                                           ! Debug: list * char = .239+0 (used reg = )
09629 2B69           BB                   D6ED  mov	bx,#.239
09630 2B6C           53                         push	bx
09631                                           ! Debug: list int = const 2 (used reg = )
09632 2B6D           B8                   0002  mov	ax,*2
09633 2B70           50                         push	ax
09634                                           ! Debug: func () void = bios_printf+0 (used reg = )
09635 2B71           E8         DE33            call	_bios_printf
09636 2B74           83C4                   08  add	sp,*8
09637                                           !BCC_EOS
09638                                           ! 1710           break;
09639                       00002B77            .238:
09640 2B77           E9         00F0            br 	.226
09641                                           !BCC_EOS
09642                                           ! 1711         case 0x03:
09643                                           ! 1712           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09644                       00002B7A            .23A:
09645 2B7A           8A86       FDF4            mov	al,-$20C[bp]
09646 2B7E           84C0                       test	al,al
09647 2B80           74           05            je  	.23E
09648                       00002B82            .23F:
09649 2B82           BB                   D6DB  mov	bx,#.23C
09650 2B85           EB           03            jmp .240
09651                       00002B87            .23E:
09652 2B87           BB                   D6D4  mov	bx,#.23D
09653                       00002B8A            .240:
09654                                           ! Debug: list * char = bx+0 (used reg = )
09655 2B8A           53                         push	bx
09656                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09657 2B8B           8A86       FDF5            mov	al,-$20B[bp]
09658 2B8F           30E4                       xor	ah,ah
09659 2B91           50                         push	ax
09660                                           ! Debug: list * char = .23B+0 (used reg = )
09661 2B92           BB                   D6E2  mov	bx,#.23B
09662 2B95           53                         push	bx
09663                                           ! Debug: list int = const 2 (used reg = )
09664 2B96           B8                   0002  mov	ax,*2
09665 2B99           50                         push	ax
09666                                           ! Debug: func () void = bios_printf+0 (used reg = )
09667 2B9A           E8         DE0A            call	_bios_printf
09668 2B9D           83C4                   08  add	sp,*8
09669                                           !BCC_EOS
09670                                           ! 1713           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09671                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09672 2BA0           30C0                       xor	al,al
09673 2BA2           8886       FDE6            mov	-$21A[bp],al
09674                                           !BCC_EOS
09675 2BA6           EB           15            jmp .242
09676                       00002BA8            .243:
09677                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09678 2BA8           8A86       FDE7            mov	al,-$219[bp]
09679 2BAC           30E4                       xor	ah,ah
09680 2BAE           50                         push	ax
09681                                           ! Debug: list * char = .244+0 (used reg = )
09682 2BAF           BB                   D6D1  mov	bx,#.244
09683 2BB2           53                         push	bx
09684                                           ! Debug: list int = const 2 (used reg = )
09685 2BB3           B8                   0002  mov	ax,*2
09686 2BB6           50                         push	ax
09687                                           ! Debug: func () void = bios_printf+0 (used reg = )
09688 2BB7           E8         DDED            call	_bios_printf
09689 2BBA           83C4                   06  add	sp,*6
09690                                           !BCC_EOS
09691                                           ! 1714           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.device
09692                       00002BBD            .242:
09693                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09694 2BBD           8A86       FDE6            mov	al,-$21A[bp]
09695 2BC1           40                         inc	ax
09696 2BC2           8886       FDE6            mov	-$21A[bp],al
09697                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09698 2BC6           48                         dec	ax
09699 2BC7           30E4                       xor	ah,ah
09700 2BC9           89EB                       mov	bx,bp
09701 2BCB           01C3                       add	bx,ax
09702                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09703                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09704 2BCD           81C3                 FDBC  add	bx,#-$244
09705 2BD1           53                         push	bx
09706                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09707 2BD2           E8         DA7C            call	_get_SS
09708                                           ! Debug: list unsigned short = ax+0 (used reg = )
09709 2BD5           50                         push	ax
09710                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09711 2BD6           E8         DA1F            call	_read_byte
09712 2BD9           83C4                   04  add	sp,*4
09713                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09714 2BDC           8886       FDE7            mov	-$219[bp],al
09715 2BE0           84C0                       test	al,al
09716 2BE2           75           C4            jne	.243
09717                       00002BE4            .245:
09718                       00002BE4            .241:
09719                                           ! 1714 s[device].device)==0x05)
09720                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09721 2BE4           8A46         FB            mov	al,-5[bp]
09722 2BE7           30E4                       xor	ah,ah
09723 2BE9           B9                   001E  mov	cx,*$1E
09724 2BEC           F7E9                       imul	cx
09725 2BEE           89C3                       mov	bx,ax
09726                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09727                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09728 2BF0           81C3                 0143  add	bx,#$143
09729 2BF4           53                         push	bx
09730                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09731 2BF5           FF76         FE            push	-2[bp]
09732                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09733 2BF8           E8         D9FD            call	_read_byte
09734 2BFB           83C4                   04  add	sp,*4
09735                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
09736 2BFE           3C                     05  cmp	al,*5
09737 2C00           75           17            jne 	.246
09738                       00002C02            .247:
09739                                           ! 1715             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09740                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09741 2C02           8A86       FDE5            mov	al,-$21B[bp]
09742 2C06           30E4                       xor	ah,ah
09743 2C08           50                         push	ax
09744                                           ! Debug: list * char = .248+0 (used reg = )
09745 2C09           BB                   D6B7  mov	bx,#.248
09746 2C0C           53                         push	bx
09747                                           ! Debug: list int = const 2 (used reg = )
09748 2C0D           B8                   0002  mov	ax,*2
09749 2C10           50                         push	ax
09750                                           ! Debug: func () void = bios_printf+0 (used reg = )
09751 2C11           E8         DD93            call	_bios_printf
09752 2C14           83C4                   06  add	sp,*6
09753                                           !BCC_EOS
09754                                           ! 1716           else
09755                                           ! 1717             bios_printf(2, " ATAPI-%d Device\n",version);
09756 2C17           EB           15            jmp .249
09757                       00002C19            .246:
09758                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09759 2C19           8A86       FDE5            mov	al,-$21B[bp]
09760 2C1D           30E4                       xor	ah,ah
09761 2C1F           50                         push	ax
09762                                           ! Debug: list * char = .24A+0 (used reg = )
09763 2C20           BB                   D6A5  mov	bx,#.24A
09764 2C23           53                         push	bx
09765                                           ! Debug: list int = const 2 (used reg = )
09766 2C24           B8                   0002  mov	ax,*2
09767 2C27           50                         push	ax
09768                                           ! Debug: func () void = bios_printf+0 (used reg = )
09769 2C28           E8         DD7C            call	_bios_printf
09770 2C2B           83C4                   06  add	sp,*6
09771                                           !BCC_EOS
09772                                           ! 1718           break;
09773                       00002C2E            .249:
09774 2C2E           EB           3A            jmp .226
09775                                           !BCC_EOS
09776                                           ! 1719         case 0x01:
09777                                           ! 1720           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09778                       00002C30            .24B:
09779 2C30           8A86       FDF4            mov	al,-$20C[bp]
09780 2C34           84C0                       test	al,al
09781 2C36           74           05            je  	.24F
09782                       00002C38            .250:
09783 2C38           BB                   D684  mov	bx,#.24D
09784 2C3B           EB           03            jmp .251
09785                       00002C3D            .24F:
09786 2C3D           BB                   D67D  mov	bx,#.24E
09787                       00002C40            .251:
09788                                           ! Debug: list * char = bx+0 (used reg = )
09789 2C40           53                         push	bx
09790                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09791 2C41           8A86       FDF5            mov	al,-$20B[bp]
09792 2C45           30E4                       xor	ah,ah
09793 2C47           50                         push	ax
09794                                           ! Debug: list * char = .24C+0 (used reg = )
09795 2C48           BB                   D68B  mov	bx,#.24C
09796 2C4B           53                         push	bx
09797                                           ! Debug: list int = const 2 (used reg = )
09798 2C4C           B8                   0002  mov	ax,*2
09799 2C4F           50                         push	ax
09800                                           ! Debug: func () void = bios_printf+0 (used reg = )
09801 2C50           E8         DD54            call	_bios_printf
09802 2C53           83C4                   08  add	sp,*8
09803                                           !BCC_EOS
09804                                           ! 1721           break;
09805 2C56           EB           12            jmp .226
09806                                           !BCC_EOS
09807                                           ! 1722       }
09808                                           ! 1723     }
09809 2C58           EB           10            jmp .226
09810                       00002C5A            .228:
09811 2C5A           2C                     01  sub	al,*1
09812 2C5C           74           D2            je 	.24B
09813 2C5E           2C                     01  sub	al,*1
09814 2C60         0F84         FE54            beq 	.229
09815 2C64           2C                     01  sub	al,*1
09816 2C66         0F84         FF10            beq 	.23A
09817                       00002C6A            .226:
09818                       FFFFFDBA            ..FFFB	=	-$246
09819 2C6A           83C4                   32  add	sp,*$32
09820                                           ! 1724   }
09821 2C6D           83C4                   0C  add	sp,*$C
09822                                           ! 1725   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
09823                       00002C70            .1A1:
09824                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
09825 2C70           8A46         FB            mov	al,-5[bp]
09826 2C73           40                         inc	ax
09827 2C74           8846         FB            mov	-5[bp],al
09828                       00002C77            .1A2:
09829                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
09830 2C77           8A46         FB            mov	al,-5[bp]
09831 2C7A           3C                     08  cmp	al,*8
09832 2C7C         0F82         F252            blo 	.1A3
09833                       00002C80            .252:
09834                       00002C80            .1A0:
09835                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09836 2C80           8A46         FD            mov	al,-3[bp]
09837 2C83           30E4                       xor	ah,ah
09838 2C85           50                         push	ax
09839                                           ! Debug: list * unsigned char = const $232 (used reg = )
09840 2C86           B8                   0232  mov	ax,#$232
09841 2C89           50                         push	ax
09842                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09843 2C8A           FF76         FE            push	-2[bp]
09844                                           ! Debug: func () void = write_byte+0 (used reg = )
09845 2C8D           E8         D98E            call	_write_byte
09846 2C90           83C4                   06  add	sp,*6
09847                                           !BCC_EOS
09848                                           ! 1726   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
09849                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
09850 2C93           8A46         FC            mov	al,-4[bp]
09851 2C96           30E4                       xor	ah,ah
09852 2C98           50                         push	ax
09853                                           ! Debug: list * unsigned char = const $23B (used reg = )
09854 2C99           B8                   023B  mov	ax,#$23B
09855 2C9C           50                         push	ax
09856                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09857 2C9D           FF76         FE            push	-2[bp]
09858                                           ! Debug: func () void = write_byte+0 (used reg = )
09859 2CA0           E8         D97B            call	_write_byte
09860 2CA3           83C4                   06  add	sp,*6
09861                                           !BCC_EOS
09862                                           ! 1727   write_byte(0x40,0x75, hdcount);
09863                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09864 2CA6           8A46         FD            mov	al,-3[bp]
09865 2CA9           30E4                       xor	ah,ah
09866 2CAB           50                         push	ax
09867                                           ! Debug: list int = const $75 (used reg = )
09868 2CAC           B8                   0075  mov	ax,*$75
09869 2CAF           50                         push	ax
09870                                           ! Debug: list int = const $40 (used reg = )
09871 2CB0           B8                   0040  mov	ax,*$40
09872 2CB3           50                         push	ax
09873                                           ! Debug: func () void = write_byte+0 (used reg = )
09874 2CB4           E8         D967            call	_write_byte
09875 2CB7           83C4                   06  add	sp,*6
09876                                           !BCC_EOS
09877                                           ! 1728   bios_printf(2, "\n");
09878                                           ! Debug: list * char = .253+0 (used reg = )
09879 2CBA           BB                   D67B  mov	bx,#.253
09880 2CBD           53                         push	bx
09881                                           ! Debug: list int = const 2 (used reg = )
09882 2CBE           B8                   0002  mov	ax,*2
09883 2CC1           50                         push	ax
09884                                           ! Debug: func () void = bios_printf+0 (used reg = )
09885 2CC2           E8         DCE2            call	_bios_printf
09886 2CC5           83C4                   04  add	sp,*4
09887                                           !BCC_EOS
09888                                           ! 1729 }
09889 2CC8           89EC                       mov	sp,bp
09890 2CCA           5D                         pop	bp
09891 2CCB           C3                         ret
09892                                           ! 1730 void ata_reset(device)
09893                                           ! Register BX used in function ata_detect
09894                                           ! 1731 Bit16u device;
09895                                           export	_ata_reset
09896                       00002CCC            _ata_reset:
09897                                           !BCC_EOS
09898                                           ! 1732 {
09899                                           ! 1733   Bit16u ebda_seg=read_word(0x0040,0x000E);
09900 2CCC           55                         push	bp
09901 2CCD           89E5                       mov	bp,sp
09902 2CCF           4C                         dec	sp
09903 2CD0           4C                         dec	sp
09904                                           ! Debug: list int = const $E (used reg = )
09905 2CD1           B8                   000E  mov	ax,*$E
09906 2CD4           50                         push	ax
09907                                           ! Debug: list int = const $40 (used reg = )
09908 2CD5           B8                   0040  mov	ax,*$40
09909 2CD8           50                         push	ax
09910                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09911 2CD9           E8         D92F            call	_read_word
09912 2CDC           83C4                   04  add	sp,*4
09913                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
09914 2CDF           8946         FE            mov	-2[bp],ax
09915                                           !BCC_EOS
09916                                           ! 1734   Bit16u iobase1, iobase2;
09917                                           !BCC_EOS
09918                                           ! 1735   Bit8u channel, slave, sn, sc;
09919                                           !BCC_EOS
09920                                           ! 1736   Bit8u type;
09921                                           !BCC_EOS
09922                                           ! 1737   Bit16u max;
09923                                           !BCC_EOS
09924                                           ! 1738   channel = device / 2;
09925 2CE2           83C4                   F4  add	sp,*-$C
09926                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09927 2CE5           8B46         04            mov	ax,4[bp]
09928 2CE8           D1E8                       shr	ax,*1
09929                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
09930 2CEA           8846         F9            mov	-7[bp],al
09931                                           !BCC_EOS
09932                                           ! 1739   slave = device % 2;
09933                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09934 2CED           8B46         04            mov	ax,4[bp]
09935 2CF0           24                     01  and	al,*1
09936                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
09937 2CF2           8846         F8            mov	-8[bp],al
09938                                           !BCC_EOS
09939                                           ! 1740   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
09940                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09941 2CF5           8A46         F9            mov	al,-7[bp]
09942 2CF8           30E4                       xor	ah,ah
09943 2CFA           B1                     03  mov	cl,*3
09944 2CFC           D3E0                       shl	ax,cl
09945 2CFE           89C3                       mov	bx,ax
09946                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09947                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
09948 2D00           81C3                 0124  add	bx,#$124
09949 2D04           53                         push	bx
09950                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09951 2D05           FF76         FE            push	-2[bp]
09952                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09953 2D08           E8         D900            call	_read_word
09954 2D0B           83C4                   04  add	sp,*4
09955                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
09956 2D0E           8946         FC            mov	-4[bp],ax
09957                                           !BCC_EOS
09958                                           ! 1741   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
09959                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09960 2D11           8A46         F9            mov	al,-7[bp]
09961 2D14           30E4                       xor	ah,ah
09962 2D16           B1                     03  mov	cl,*3
09963 2D18           D3E0                       shl	ax,cl
09964 2D1A           89C3                       mov	bx,ax
09965                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09966                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
09967 2D1C           81C3                 0126  add	bx,#$126
09968 2D20           53                         push	bx
09969                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09970 2D21           FF76         FE            push	-2[bp]
09971                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09972 2D24           E8         D8E4            call	_read_word
09973 2D27           83C4                   04  add	sp,*4
09974                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
09975 2D2A           8946         FA            mov	-6[bp],ax
09976                                           !BCC_EOS
09977                                           ! 1742   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09978                                           ! Debug: list int = const $E (used reg = )
09979 2D2D           B8                   000E  mov	ax,*$E
09980 2D30           50                         push	ax
09981                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
09982 2D31           8B46         FA            mov	ax,-6[bp]
09983                                           ! Debug: list unsigned int = ax+6 (used reg = )
09984 2D34           05                   0006  add	ax,*6
09985 2D37           50                         push	ax
09986                                           ! Debug: func () void = outb+0 (used reg = )
09987 2D38           E8         D81D            call	_outb
09988 2D3B           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1743   await_ide(1, iobase1, 20);
09991                                           ! Debug: list int = const $14 (used reg = )
09992 2D3E           B8                   0014  mov	ax,*$14
09993 2D41           50                         push	ax
09994                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
09995 2D42           FF76         FC            push	-4[bp]
09996                                           ! Debug: list int = const 1 (used reg = )
09997 2D45           B8                   0001  mov	ax,*1
09998 2D48           50                         push	ax
09999                                           ! Debug: func () int = await_ide+0 (used reg = )
10000 2D49           E8         EED8            call	_await_ide
10001 2D4C           83C4                   06  add	sp,*6
10002                                           !BCC_EOS
10003                                           ! 1744   outb(iobase2+6, 0x08 | 0x02);
10004                                           ! Debug: list int = const $A (used reg = )
10005 2D4F           B8                   000A  mov	ax,*$A
10006 2D52           50                         push	ax
10007                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10008 2D53           8B46         FA            mov	ax,-6[bp]
10009                                           ! Debug: list unsigned int = ax+6 (used reg = )
10010 2D56           05                   0006  add	ax,*6
10011 2D59           50                         push	ax
10012                                           ! Debug: func () void = outb+0 (used reg = )
10013 2D5A           E8         D7FB            call	_outb
10014 2D5D           83C4                   04  add	sp,*4
10015                                           !BCC_EOS
10016                                           ! 1745   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
10017                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10018 2D60           8B46         04            mov	ax,4[bp]
10019 2D63           B9                   001E  mov	cx,*$1E
10020 2D66           F7E9                       imul	cx
10021 2D68           89C3                       mov	bx,ax
10022                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
10023                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
10024 2D6A           81C3                 0142  add	bx,#$142
10025 2D6E           53                         push	bx
10026                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10027 2D6F           FF76         FE            push	-2[bp]
10028                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10029 2D72           E8         D883            call	_read_byte
10030 2D75           83C4                   04  add	sp,*4
10031                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
10032 2D78           8846         F5            mov	-$B[bp],al
10033                                           !BCC_EOS
10034                                           ! 1746   if (type != 0x00) {
10035                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
10036 2D7B           8A46         F5            mov	al,-$B[bp]
10037 2D7E           84C0                       test	al,al
10038 2D80         0F84         0084            beq 	.254
10039                       00002D84            .255:
10040                                           ! 1747     outb(iobase1+6, slave?0xb0:0xa0);
10041 2D84           8A46         F8            mov	al,-8[bp]
10042 2D87           84C0                       test	al,al
10043 2D89           74           04            je  	.256
10044                       00002D8B            .257:
10045 2D8B           B0                     B0  mov	al,#$B0
10046 2D8D           EB           02            jmp .258
10047                       00002D8F            .256:
10048 2D8F           B0                     A0  mov	al,#$A0
10049                       00002D91            .258:
10050                                           ! Debug: list char = al+0 (used reg = )
10051 2D91           30E4                       xor	ah,ah
10052 2D93           50                         push	ax
10053                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10054 2D94           8B46         FC            mov	ax,-4[bp]
10055                                           ! Debug: list unsigned int = ax+6 (used reg = )
10056 2D97           05                   0006  add	ax,*6
10057 2D9A           50                         push	ax
10058                                           ! Debug: func () void = outb+0 (used reg = )
10059 2D9B           E8         D7BA            call	_outb
10060 2D9E           83C4                   04  add	sp,*4
10061                                           !BCC_EOS
10062                                           ! 1748     sc = inb(iobase1+2);
10063                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10064 2DA1           8B46         FC            mov	ax,-4[bp]
10065                                           ! Debug: list unsigned int = ax+2 (used reg = )
10066 2DA4           40                         inc	ax
10067 2DA5           40                         inc	ax
10068 2DA6           50                         push	ax
10069                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10070 2DA7           E8         D798            call	_inb
10071 2DAA           44                         inc	sp
10072 2DAB           44                         inc	sp
10073                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10074 2DAC           8846         F6            mov	-$A[bp],al
10075                                           !BCC_EOS
10076                                           ! 1749     sn = inb(iobase1+3);
10077                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10078 2DAF           8B46         FC            mov	ax,-4[bp]
10079                                           ! Debug: list unsigned int = ax+3 (used reg = )
10080 2DB2           05                   0003  add	ax,*3
10081 2DB5           50                         push	ax
10082                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10083 2DB6           E8         D789            call	_inb
10084 2DB9           44                         inc	sp
10085 2DBA           44                         inc	sp
10086                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10087 2DBB           8846         F7            mov	-9[bp],al
10088                                           !BCC_EOS
10089                                           ! 1750     if ( (sc==0x01) && (sn==0x01) ) {
10090                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10091 2DBE           8A46         F6            mov	al,-$A[bp]
10092 2DC1           3C                     01  cmp	al,*1
10093 2DC3           75           32            jne 	.259
10094                       00002DC5            .25B:
10095                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10096 2DC5           8A46         F7            mov	al,-9[bp]
10097 2DC8           3C                     01  cmp	al,*1
10098 2DCA           75           2B            jne 	.259
10099                       00002DCC            .25A:
10100                                           ! 1751       if (type == 0x02)
10101                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10102 2DCC           8A46         F5            mov	al,-$B[bp]
10103 2DCF           3C                     02  cmp	al,*2
10104 2DD1           75           13            jne 	.25C
10105                       00002DD3            .25D:
10106                                           ! 1752         await_ide(5, iobase1, 32000u);
10107                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10108 2DD3           B8                   7D00  mov	ax,#$7D00
10109 2DD6           50                         push	ax
10110                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10111 2DD7           FF76         FC            push	-4[bp]
10112                                           ! Debug: list int = const 5 (used reg = )
10113 2DDA           B8                   0005  mov	ax,*5
10114 2DDD           50                         push	ax
10115                                           ! Debug: func () int = await_ide+0 (used reg = )
10116 2DDE           E8         EE43            call	_await_ide
10117 2DE1           83C4                   06  add	sp,*6
10118                                           !BCC_EOS
10119                                           ! 1753       else
10120                                           ! 1754         await_ide(2, iobase1, 32000u);
10121 2DE4           EB           11            jmp .25E
10122                       00002DE6            .25C:
10123                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10124 2DE6           B8                   7D00  mov	ax,#$7D00
10125 2DE9           50                         push	ax
10126                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10127 2DEA           FF76         FC            push	-4[bp]
10128                                           ! Debug: list int = const 2 (used reg = )
10129 2DED           B8                   0002  mov	ax,*2
10130 2DF0           50                         push	ax
10131                                           ! Debug: func () int = await_ide+0 (used reg = )
10132 2DF1           E8         EE30            call	_await_ide
10133 2DF4           83C4                   06  add	sp,*6
10134                                           !BCC_EOS
10135                                           ! 1755     }
10136                       00002DF7            .25E:
10137                                           ! 1756     await_ide(2, iobase1, 32000u);
10138                       00002DF7            .259:
10139                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10140 2DF7           B8                   7D00  mov	ax,#$7D00
10141 2DFA           50                         push	ax
10142                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10143 2DFB           FF76         FC            push	-4[bp]
10144                                           ! Debug: list int = const 2 (used reg = )
10145 2DFE           B8                   0002  mov	ax,*2
10146 2E01           50                         push	ax
10147                                           ! Debug: func () int = await_ide+0 (used reg = )
10148 2E02           E8         EE1F            call	_await_ide
10149 2E05           83C4                   06  add	sp,*6
10150                                           !BCC_EOS
10151                                           ! 1757   }
10152                                           ! 1758   outb(iobase2+6, 0x08);
10153                       00002E08            .254:
10154                                           ! Debug: list int = const 8 (used reg = )
10155 2E08           B8                   0008  mov	ax,*8
10156 2E0B           50                         push	ax
10157                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10158 2E0C           8B46         FA            mov	ax,-6[bp]
10159                                           ! Debug: list unsigned int = ax+6 (used reg = )
10160 2E0F           05                   0006  add	ax,*6
10161 2E12           50                         push	ax
10162                                           ! Debug: func () void = outb+0 (used reg = )
10163 2E13           E8         D742            call	_outb
10164 2E16           83C4                   04  add	sp,*4
10165                                           !BCC_EOS
10166                                           ! 1759 }
10167 2E19           89EC                       mov	sp,bp
10168 2E1B           5D                         pop	bp
10169 2E1C           C3                         ret
10170                                           ! 1760 Bit16u ata_cmd_non_data()
10171                                           ! Register BX used in function ata_reset
10172                                           ! 1761 {return 0;}
10173                                           export	_ata_cmd_non_data
10174                       00002E1D            _ata_cmd_non_data:
10175 2E1D           55                         push	bp
10176 2E1E           89E5                       mov	bp,sp
10177 2E20           31C0                       xor	ax,ax
10178 2E22           5D                         pop	bp
10179 2E23           C3                         ret
10180                                           !BCC_EOS
10181                                           ! 1762 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10182                                           ! 1763 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10183                                           export	_ata_cmd_data_in
10184                       00002E24            _ata_cmd_data_in:
10185                                           !BCC_EOS
10186                                           ! 1764 Bit32u lba_low, lba_high;
10187                                           !BCC_EOS
10188                                           ! 1765 {
10189                                           ! 1766   Bit16u ebda_seg=read_word(0x0040,0x000E);
10190 2E24           55                         push	bp
10191 2E25           89E5                       mov	bp,sp
10192 2E27           4C                         dec	sp
10193 2E28           4C                         dec	sp
10194                                           ! Debug: list int = const $E (used reg = )
10195 2E29           B8                   000E  mov	ax,*$E
10196 2E2C           50                         push	ax
10197                                           ! Debug: list int = const $40 (used reg = )
10198 2E2D           B8                   0040  mov	ax,*$40
10199 2E30           50                         push	ax
10200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10201 2E31           E8         D7D7            call	_read_word
10202 2E34           83C4                   04  add	sp,*4
10203                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10204 2E37           8946         FE            mov	-2[bp],ax
10205                                           !BCC_EOS
10206                                           ! 1767   Bit16u iobase1, iobase2, blksize;
10207                                           !BCC_EOS
10208                                           ! 1768   Bit8u channel, slave;
10209                                           !BCC_EOS
10210                                           ! 1769   Bit8u status, current, mode;
10211                                           !BCC_EOS
10212                                           ! 1770   channel = device / 2;
10213 2E3A           83C4                   F4  add	sp,*-$C
10214                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10215 2E3D           8B46         04            mov	ax,4[bp]
10216 2E40           D1E8                       shr	ax,*1
10217                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10218 2E42           8846         F7            mov	-9[bp],al
10219                                           !BCC_EOS
10220                                           ! 1771   slave = device % 2;
10221                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10222 2E45           8B46         04            mov	ax,4[bp]
10223 2E48           24                     01  and	al,*1
10224                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10225 2E4A           8846         F6            mov	-$A[bp],al
10226                                           !BCC_EOS
10227                                           ! 1772   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10228                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10229 2E4D           8A46         F7            mov	al,-9[bp]
10230 2E50           30E4                       xor	ah,ah
10231 2E52           B1                     03  mov	cl,*3
10232 2E54           D3E0                       shl	ax,cl
10233 2E56           89C3                       mov	bx,ax
10234                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10235                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10236 2E58           81C3                 0124  add	bx,#$124
10237 2E5C           53                         push	bx
10238                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10239 2E5D           FF76         FE            push	-2[bp]
10240                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10241 2E60           E8         D7A8            call	_read_word
10242 2E63           83C4                   04  add	sp,*4
10243                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10244 2E66           8946         FC            mov	-4[bp],ax
10245                                           !BCC_EOS
10246                                           ! 1773   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10247                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10248 2E69           8A46         F7            mov	al,-9[bp]
10249 2E6C           30E4                       xor	ah,ah
10250 2E6E           B1                     03  mov	cl,*3
10251 2E70           D3E0                       shl	ax,cl
10252 2E72           89C3                       mov	bx,ax
10253                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10254                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10255 2E74           81C3                 0126  add	bx,#$126
10256 2E78           53                         push	bx
10257                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10258 2E79           FF76         FE            push	-2[bp]
10259                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10260 2E7C           E8         D78C            call	_read_word
10261 2E7F           83C4                   04  add	sp,*4
10262                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10263 2E82           8946         FA            mov	-6[bp],ax
10264                                           !BCC_EOS
10265                                           ! 1774   mode = read_byte(ebda_seg, &((ebda
10266                                           ! 1774 _data_t *) 0)->ata.devices[device].mode);
10267                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10268 2E85           8B46         04            mov	ax,4[bp]
10269 2E88           B9                   001E  mov	cx,*$1E
10270 2E8B           F7E9                       imul	cx
10271 2E8D           89C3                       mov	bx,ax
10272                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10273                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10274 2E8F           81C3                 0146  add	bx,#$146
10275 2E93           53                         push	bx
10276                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10277 2E94           FF76         FE            push	-2[bp]
10278                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10279 2E97           E8         D75E            call	_read_byte
10280 2E9A           83C4                   04  add	sp,*4
10281                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10282 2E9D           8846         F3            mov	-$D[bp],al
10283                                           !BCC_EOS
10284                                           ! 1775   blksize = 0x200;
10285                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10286 2EA0           B8                   0200  mov	ax,#$200
10287 2EA3           8946         F8            mov	-8[bp],ax
10288                                           !BCC_EOS
10289                                           ! 1776   if (mode == 0x01) blksize>>=2;
10290                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10291 2EA6           8A46         F3            mov	al,-$D[bp]
10292 2EA9           3C                     01  cmp	al,*1
10293 2EAB           75           0C            jne 	.25F
10294                       00002EAD            .260:
10295                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10296 2EAD           8B46         F8            mov	ax,-8[bp]
10297 2EB0           D1E8                       shr	ax,*1
10298 2EB2           D1E8                       shr	ax,*1
10299 2EB4           8946         F8            mov	-8[bp],ax
10300                                           !BCC_EOS
10301                                           ! 1777   else blksize>>=1;
10302 2EB7           EB           08            jmp .261
10303                       00002EB9            .25F:
10304                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10305 2EB9           8B46         F8            mov	ax,-8[bp]
10306 2EBC           D1E8                       shr	ax,*1
10307 2EBE           8946         F8            mov	-8[bp],ax
10308                                           !BCC_EOS
10309                                           ! 1778   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10310                       00002EC1            .261:
10311                                           ! Debug: list int = const 0 (used reg = )
10312 2EC1           31C0                       xor	ax,ax
10313 2EC3           50                         push	ax
10314                                           ! Debug: list * unsigned short = const $254 (used reg = )
10315 2EC4           B8                   0254  mov	ax,#$254
10316 2EC7           50                         push	ax
10317                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10318 2EC8           FF76         FE            push	-2[bp]
10319                                           ! Debug: func () void = write_word+0 (used reg = )
10320 2ECB           E8         D768            call	_write_word
10321 2ECE           83C4                   06  add	sp,*6
10322                                           !BCC_EOS
10323                                           ! 1779   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10324                                           ! Debug: list long = const 0 (used reg = )
10325 2ED1           31C0                       xor	ax,ax
10326 2ED3           31DB                       xor	bx,bx
10327 2ED5           53                         push	bx
10328 2ED6           50                         push	ax
10329                                           ! Debug: list * unsigned long = const $256 (used reg = )
10330 2ED7           B8                   0256  mov	ax,#$256
10331 2EDA           50                         push	ax
10332                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10333 2EDB           FF76         FE            push	-2[bp]
10334                                           ! Debug: func () void = write_dword+0 (used reg = )
10335 2EDE           E8         D1BA            call	_write_dword
10336 2EE1           83C4                   08  add	sp,*8
10337                                           !BCC_EOS
10338                                           ! 1780   current = 0;
10339                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10340 2EE4           30C0                       xor	al,al
10341 2EE6           8846         F4            mov	-$C[bp],al
10342                                           !BCC_EOS
10343                                           ! 1781   status = inb(iobase1 + 7);
10344                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10345 2EE9           8B46         FC            mov	ax,-4[bp]
10346                                           ! Debug: list unsigned int = ax+7 (used reg = )
10347 2EEC           05                   0007  add	ax,*7
10348 2EEF           50                         push	ax
10349                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10350 2EF0           E8         D64F            call	_inb
10351 2EF3           44                         inc	sp
10352 2EF4           44                         inc	sp
10353                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10354 2EF5           8846         F5            mov	-$B[bp],al
10355                                           !BCC_EOS
10356                                           ! 1782   if (status & 0x80) return 1;
10357                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10358 2EF8           8A46         F5            mov	al,-$B[bp]
10359 2EFB           24                     80  and	al,#$80
10360 2EFD           84C0                       test	al,al
10361 2EFF           74           07            je  	.262
10362                       00002F01            .263:
10363 2F01           B8                   0001  mov	ax,*1
10364 2F04           89EC                       mov	sp,bp
10365 2F06           5D                         pop	bp
10366 2F07           C3                         ret
10367                                           !BCC_EOS
10368                                           ! 1783   outb(iobase2 + 6, 0x08 | 0x02);
10369                       00002F08            .262:
10370                                           ! Debug: list int = const $A (used reg = )
10371 2F08           B8                   000A  mov	ax,*$A
10372 2F0B           50                         push	ax
10373                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10374 2F0C           8B46         FA            mov	ax,-6[bp]
10375                                           ! Debug: list unsigned int = ax+6 (used reg = )
10376 2F0F           05                   0006  add	ax,*6
10377 2F12           50                         push	ax
10378                                           ! Debug: func () void = outb+0 (used reg = )
10379 2F13           E8         D642            call	_outb
10380 2F16           83C4                   04  add	sp,*4
10381                                           !BCC_EOS
10382                                           ! 1784   if (sector == 0) {
10383                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10384 2F19           8B46         0E            mov	ax,$E[bp]
10385 2F1C           85C0                       test	ax,ax
10386 2F1E         0F85         0167            bne 	.264
10387                       00002F22            .265:
10388                                           ! 1785     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
10389                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10390 2F22           8B46         08            mov	ax,8[bp]
10391 2F25           3D                   0100  cmp	ax,#$100
10392 2F28           72           04            jb 	.26A
10393 2F2A           B0                     01  mov	al,*1
10394 2F2C           EB           02            jmp	.26B
10395                       00002F2E            .26A:
10396 2F2E           30C0                       xor	al,al
10397                       00002F30            .26B:
10398                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10399 2F30           30E4                       xor	ah,ah
10400 2F32           99                         cwd
10401 2F33           89D3                       mov	bx,dx
10402 2F35           E8         D1DC            call	ltstl
10403 2F38           75           32            jne 	.267
10404                       00002F3A            .269:
10405 2F3A           8B46         14            mov	ax,$14[bp]
10406 2F3D           8B5E         16            mov	bx,$16[bp]
10407 2F40           E8         D1D1            call	ltstl
10408 2F43           75           27            jne 	.267
10409                       00002F45            .268:
10410                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10411 2F45           8B46         08            mov	ax,8[bp]
10412 2F48           31DB                       xor	bx,bx
10413                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10414                                           ! Debug: expression subtree swapping
10415 2F4A           8D7E         10            lea	di,$10[bp]
10416 2F4D           E8         D173            call	laddul
10417                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10418 2F50           53                         push	bx
10419 2F51           50                         push	ax
10420 2F52           31C0                       xor	ax,ax
10421 2F54           BB                   1000  mov	bx,#$1000
10422 2F57           53                         push	bx
10423 2F58           50                         push	ax
10424 2F59           8B46         EE            mov	ax,-$12[bp]
10425 2F5C           8B5E         F0            mov	bx,-$10[bp]
10426 2F5F           8D7E         EA            lea	di,-$16[bp]
10427 2F62           E8         D166            call	lcmpul
10428 2F65           8D66         F2            lea	sp,-$E[bp]
10429 2F68         0F82         00BC            blo 	.266
10430                       00002F6C            .267:
10431                                           ! 1786       outb(iobase1 + 1, 0x00);
10432                                           ! Debug: list int = const 0 (used reg = )
10433 2F6C           31C0                       xor	ax,ax
10434 2F6E           50                         push	ax
10435                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10436 2F6F           8B46         FC            mov	ax,-4[bp]
10437                                           ! Debug: list unsigned int = ax+1 (used reg = )
10438 2F72           40                         inc	ax
10439 2F73           50                         push	ax
10440                                           ! Debug: func () void = outb+0 (used reg = )
10441 2F74           E8         D5E1            call	_outb
10442 2F77           83C4                   04  add	sp,*4
10443                                           !BCC_EOS
10444                                           ! 1787       outb(iobase1 + 2, (count >> 8) & 0xff);
10445                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10446 2F7A           8B46         08            mov	ax,8[bp]
10447 2F7D           88E0                       mov	al,ah
10448 2F7F           30E4                       xor	ah,ah
10449                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10450                                           ! Debug: list unsigned char = al+0 (used reg = )
10451 2F81           30E4                       xor	ah,ah
10452 2F83           50                         push	ax
10453                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10454 2F84           8B46         FC            mov	ax,-4[bp]
10455                                           ! Debug: list unsigned int = ax+2 (used reg = )
10456 2F87           40                         inc	ax
10457 2F88           40                         inc	ax
10458 2F89           50                         push	ax
10459                                           ! Debug: func () void = outb+0 (used reg = )
10460 2F8A           E8         D5CB            call	_outb
10461 2F8D           83C4                   04  add	sp,*4
10462                                           !BCC_EOS
10463                                           ! 1788       outb(iobase1 + 3, lba_low >> 24);
10464                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10465 2F90           8B46         10            mov	ax,$10[bp]
10466 2F93           8B5E         12            mov	bx,$12[bp]
10467 2F96           93                         xchg	bx,ax
10468 2F97           88E0                       mov	al,ah
10469 2F99           30E4                       xor	ah,ah
10470 2F9B           31DB                       xor	bx,bx
10471                                           ! Debug: list unsigned long = bx+0 (used reg = )
10472 2F9D           53                         push	bx
10473 2F9E           50                         push	ax
10474                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10475 2F9F           8B46         FC            mov	ax,-4[bp]
10476                                           ! Debug: list unsigned int = ax+3 (used reg = )
10477 2FA2           05                   0003  add	ax,*3
10478 2FA5           50                         push	ax
10479                                           ! Debug: func () void = outb+0 (used reg = )
10480 2FA6           E8         D5AF            call	_outb
10481 2FA9           83C4                   06  add	sp,*6
10482                                           !BCC_EOS
10483                                           ! 1789       outb(iobase1 + 4, lba_high & 0xff);
10484                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10485                                           ! Debug: expression subtree swapping
10486 2FAC           B8                   00FF  mov	ax,#$FF
10487 2FAF           31DB                       xor	bx,bx
10488 2FB1           8D7E         14            lea	di,$14[bp]
10489 2FB4           E8         D104            call	landul
10490                                           ! Debug: list unsigned long = bx+0 (used reg = )
10491 2FB7           53                         push	bx
10492 2FB8           50                         push	ax
10493                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10494 2FB9           8B46         FC            mov	ax,-4[bp]
10495                                           ! Debug: list unsigned int = ax+4 (used reg = )
10496 2FBC           05                   0004  add	ax,*4
10497 2FBF           50                         push	ax
10498                                           ! Debug: func () void = outb+0 (used reg = )
10499 2FC0           E8         D595            call	_outb
10500 2FC3           83C4                   06  add	sp,*6
10501                                           !BCC_EOS
10502                                           ! 1790       outb(iobase1 + 5, lba_high >> 8);
10503                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10504 2FC6           8B46         14            mov	ax,$14[bp]
10505 2FC9           8B5E         16            mov	bx,$16[bp]
10506 2FCC           88E0                       mov	al,ah
10507 2FCE           88DC                       mov	ah,bl
10508 2FD0           88FB                       mov	bl,bh
10509 2FD2           28FF                       sub	bh,bh
10510                                           ! Debug: list unsigned long = bx+0 (used reg = )
10511 2FD4           53                         push	bx
10512 2FD5           50                         push	ax
10513                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10514 2FD6           8B46         FC            mov	ax,-4[bp]
10515                                           ! Debug: list unsigned int = ax+5 (used reg = )
10516 2FD9           05                   0005  add	ax,*5
10517 2FDC           50                         push	ax
10518                                           ! Debug: func () void = outb+0 (used reg = )
10519 2FDD           E8         D578            call	_outb
10520 2FE0           83C4                   06  add	sp,*6
10521                                           !BCC_EOS
10522                                           ! 1791       command |= 0x04;
10523                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10524 2FE3           8B46         06            mov	ax,6[bp]
10525 2FE6           0C                     04  or	al,*4
10526 2FE8           8946         06            mov	6[bp],ax
10527                                           !BCC_EOS
10528                                           ! 1792       count &= (1UL << 8) - 1;
10529                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10530 2FEB           8B46         08            mov	ax,8[bp]
10531 2FEE           31DB                       xor	bx,bx
10532 2FF0           53                         push	bx
10533 2FF1           50                         push	ax
10534 2FF2           B8                   00FF  mov	ax,#$FF
10535 2FF5           31DB                       xor	bx,bx
10536 2FF7           53                         push	bx
10537 2FF8           50                         push	ax
10538 2FF9           8B46         EE            mov	ax,-$12[bp]
10539 2FFC           8B5E         F0            mov	bx,-$10[bp]
10540 2FFF           8D7E         EA            lea	di,-$16[bp]
10541 3002           E8         D0B6            call	landul
10542 3005           8946         08            mov	8[bp],ax
10543 3008           83C4                   08  add	sp,*8
10544                                           !BCC_EOS
10545                                           ! 1793       lba_low &= (1UL << 24) - 1;
10546                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10547 300B           B8                   FFFF  mov	ax,#$FFFF
10548 300E           BB                   00FF  mov	bx,#$FF
10549 3011           53                         push	bx
10550 3012           50                         push	ax
10551 3013           8B46         10            mov	ax,$10[bp]
10552 3016           8B5E         12            mov	bx,$12[bp]
10553 3019           8D7E         EE            lea	di,-$12[bp]
10554 301C           E8         D09C            call	landul
10555 301F           8946         10            mov	$10[bp],ax
10556 3022           895E         12            mov	$12[bp],bx
10557 3025           83C4                   04  add	sp,*4
10558                                           !BCC_EOS
10559                                           ! 1794     }
10560                                           ! 1795     sector = (Bit16u) (lba_low & 0x000000ffL);
10561                       00003028            .266:
10562                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10563                                           ! Debug: expression subtree swapping
10564 3028           B8                   00FF  mov	ax,#$FF
10565 302B           31DB                       xor	bx,bx
10566 302D           8D7E         10            lea	di,$10[bp]
10567 3030           E8         D088            call	landul
10568                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10569                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10570 3033           8946         0E            mov	$E[bp],ax
10571                                           !BCC_EOS
10572                                           ! 1796     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10573                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10574 3036           8B46         10            mov	ax,$10[bp]
10575 3039           8B5E         12            mov	bx,$12[bp]
10576 303C           88E0                       mov	al,ah
10577 303E           88DC                       mov	ah,bl
10578 3040           88FB                       mov	bl,bh
10579 3042           28FF                       sub	bh,bh
10580                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10581 3044           53                         push	bx
10582 3045           50                         push	ax
10583 3046           B8                   FFFF  mov	ax,#$FFFF
10584 3049           31DB                       xor	bx,bx
10585 304B           53                         push	bx
10586 304C           50                         push	ax
10587 304D           8B46         EE            mov	ax,-$12[bp]
10588 3050           8B5E         F0            mov	bx,-$10[bp]
10589 3053           8D7E         EA            lea	di,-$16[bp]
10590 3056           E8         D062            call	landul
10591 3059           83C4                   08  add	sp,*8
10592                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10593                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10594 305C           8946         0A            mov	$A[bp],ax
10595                                           !BCC_EOS
10596                                           ! 1797     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10597                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10598 305F           8B46         10            mov	ax,$10[bp]
10599 3062           8B5E         12            mov	bx,$12[bp]
10600 3065           93                         xchg	bx,ax
10601 3066           88E0                       mov	al,ah
10602 3068           30E4                       xor	ah,ah
10603 306A           31DB                       xor	bx,bx
10604                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10605 306C           53                         push	bx
10606 306D           50                         push	ax
10607 306E           B8                   000F  mov	ax,*$F
10608 3071           31DB                       xor	bx,bx
10609 3073           53                         push	bx
10610 3074           50                         push	ax
10611 3075           8B46         EE            mov	ax,-$12[bp]
10612 3078           8B5E         F0            mov	bx,-$10[bp]
10613 307B           8D7E         EA            lea	di,-$16[bp]
10614 307E           E8         D03A            call	landul
10615 3081           83C4                   08  add	sp,*8
10616                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10617                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10618 3084           0C                     40  or	al,*$40
10619                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10620 3086           8946         0C            mov	$C[bp],ax
10621                                           !BCC_EOS
10622                                           ! 1798   }
10623                                           ! 1799   outb(iobase1 + 1, 0x00);
10624                       00003089            .264:
10625                                           ! Debug: list int = const 0 (used reg = )
10626 3089           31C0                       xor	ax,ax
10627 308B           50                         push	ax
10628                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10629 308C           8B46         FC            mov	ax,-4[bp]
10630                                           ! Debug: list unsigned int = ax+1 (used reg = )
10631 308F           40                         inc	ax
10632 3090           50                         push	ax
10633                                           ! Debug: func () void = outb+0 (used reg = )
10634 3091           E8         D4C4            call	_outb
10635 3094           83C4                   04  add	sp,*4
10636                                           !BCC_EOS
10637                                           ! 1800   outb(iobase1 + 2, count);
10638                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10639 3097           FF76         08            push	8[bp]
10640                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10641 309A           8B46         FC            mov	ax,-4[bp]
10642                                           ! Debug: list unsigned int = ax+2 (used reg = )
10643 309D           40                         inc	ax
10644 309E           40                         inc	ax
10645 309F           50                         push	ax
10646                                           ! Debug: func () void = outb+0 (used reg = )
10647 30A0           E8         D4B5            call	_outb
10648 30A3           83C4                   04  add	sp,*4
10649                                           !BCC_EOS
10650                                           ! 1801   outb(iobase1 + 3, sector);
10651                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10652 30A6           FF76         0E            push	$E[bp]
10653                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10654 30A9           8B46         FC            mov	ax,-4[bp]
10655                                           ! Debug: list unsigned int = ax+3 (used reg = )
10656 30AC           05                   0003  add	ax,*3
10657 30AF           50                         push	ax
10658                                           ! Debug: func () void = outb+0 (used reg = )
10659 30B0           E8         D4A5            call	_outb
10660 30B3           83C4                   04  add	sp,*4
10661                                           !BCC_EOS
10662                                           ! 1802   outb(iobase1 + 4, cylinder & 0x00ff);
10663                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10664 30B6           8A46         0A            mov	al,$A[bp]
10665                                           ! Debug: list unsigned char = al+0 (used reg = )
10666 30B9           30E4                       xor	ah,ah
10667 30BB           50                         push	ax
10668                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10669 30BC           8B46         FC            mov	ax,-4[bp]
10670                                           ! Debug: list unsigned int = ax+4 (used reg = )
10671 30BF           05                   0004  add	ax,*4
10672 30C2           50                         push	ax
10673                                           ! Debug: func () void = outb+0 (used reg = )
10674 30C3           E8         D492            call	_outb
10675 30C6           83C4                   04  add	sp,*4
10676                                           !BCC_EOS
10677                                           ! 1803   outb(iobase1 + 5, cylinder >> 8);
10678                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10679 30C9           8B46         0A            mov	ax,$A[bp]
10680 30CC           88E0                       mov	al,ah
10681 30CE           30E4                       xor	ah,ah
10682                                           ! Debug: list unsigned int = ax+0 (used reg = )
10683 30D0           50                         push	ax
10684                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10685 30D1           8B46         FC            mov	ax,-4[bp]
10686                                           ! Debug: list unsigned int = ax+5 (used reg = )
10687 30D4           05                   0005  add	ax,*5
10688 30D7           50                         push	ax
10689                                           ! Debug: func () void = outb+0 (used reg = )
10690 30D8           E8         D47D            call	_outb
10691 30DB           83C4                   04  add	sp,*4
10692                                           !BCC_EOS
10693                                           ! 1804   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10694 30DE           8A46         F6            mov	al,-$A[bp]
10695 30E1           84C0                       test	al,al
10696 30E3           74           04            je  	.26D
10697                       000030E5            .26E:
10698 30E5           B0                     B0  mov	al,#$B0
10699 30E7           EB           02            jmp .26F
10700                       000030E9            .26D:
10701 30E9           B0                     A0  mov	al,#$A0
10702                       000030EB            .26F:
10703                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10704 30EB           0A46         0C            or	al,$C[bp]
10705                                           ! Debug: list unsigned char = al+0 (used reg = )
10706 30EE           30E4                       xor	ah,ah
10707 30F0           50                         push	ax
10708                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10709 30F1           8B46         FC            mov	ax,-4[bp]
10710                                           ! Debug: list unsigned int = ax+6 (used reg = )
10711 30F4           05                   0006  add	ax,*6
10712 30F7           50                         push	ax
10713                                           ! Debug: func () void = outb+0 (used reg = )
10714 30F8           E8         D45D            call	_outb
10715 30FB           83C4                   04  add	sp,*4
10716                                           !BCC_EOS
10717                                           ! 1805   outb(iobase1 + 7, command);
10718                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10719 30FE           FF76         06            push	6[bp]
10720                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10721 3101           8B46         FC            mov	ax,-4[bp]
10722                                           ! Debug: list unsigned int = ax+7 (used reg = )
10723 3104           05                   0007  add	ax,*7
10724 3107           50                         push	ax
10725                                           ! Debug: func () void = outb+0 (used reg = )
10726 3108           E8         D44D            call	_outb
10727 310B           83C4                   04  add	sp,*4
10728                                           !BCC_EOS
10729                                           ! 1806   await_ide(3, iobase1, 32000u);
10730                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10731 310E           B8                   7D00  mov	ax,#$7D00
10732 3111           50                         push	ax
10733                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10734 3112           FF76         FC            push	-4[bp]
10735                                           ! Debug: list int = const 3 (used reg = )
10736 3115           B8                   0003  mov	ax,*3
10737 3118           50                         push	ax
10738                                           ! Debug: func () int = await_ide+0 (used reg = )
10739 3119           E8         EB08            call	_await_ide
10740 311C           83C4                   06  add	sp,*6
10741                                           !BCC_EOS
10742                                           ! 1807   status = inb(iobase1 + 7);
10743                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10744 311F           8B46         FC            mov	ax,-4[bp]
10745                                           ! Debug: list unsigned int = ax+7 (used reg = )
10746 3122           05                   0007  add	ax,*7
10747 3125           50                         push	ax
10748                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10749 3126           E8         D419            call	_inb
10750 3129           44                         inc	sp
10751 312A           44                         inc	sp
10752                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10753 312B           8846         F5            mov	-$B[bp],al
10754                                           !BCC_EOS
10755                                           ! 1808   if (status & 0x01) {
10756                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10757 312E           8A46         F5            mov	al,-$B[bp]
10758 3131           24                     01  and	al,*1
10759 3133           84C0                       test	al,al
10760 3135           74           09            je  	.270
10761                       00003137            .271:
10762                                           ! 1809     ;
10763                                           !BCC_EOS
10764                                           ! 1810     return 2;
10765 3137           B8                   0002  mov	ax,*2
10766 313A           89EC                       mov	sp,bp
10767 313C           5D                         pop	bp
10768 313D           C3                         ret
10769                                           !BCC_EOS
10770                                           ! 1811   } else if ( !(status & 0x08) ) {
10771 313E           EB           10            jmp .272
10772                       00003140            .270:
10773                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10774 3140           8A46         F5            mov	al,-$B[bp]
10775 3143           24                     08  and	al,*8
10776 3145           84C0                       test	al,al
10777 3147           75           07            jne 	.273
10778                       00003149            .274:
10779                                           ! 1812     ;
10780                                           !BCC_EOS
10781                                           ! 1813     return 3;
10782 3149           B8                   0003  mov	ax,*3
10783 314C           89EC                       mov	sp,bp
10784 314E           5D                         pop	bp
10785 314F           C3                         ret
10786                                           !BCC_EOS
10787                                           ! 1814   }
10788                                           ! 1815 #asm
10789                       00003150            .273:
10790                       00003150            .272:
10791                                           !BCC_EOS
10792                                           !BCC_ASM
10793                       00000016            _ata_cmd_data_in.count	set	$16
10794                       00000008            .ata_cmd_data_in.count	set	8
10795                       00000026            _ata_cmd_data_in.segment	set	$26
10796                       00000018            .ata_cmd_data_in.segment	set	$18
10797                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10798                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10799                       00000005            _ata_cmd_data_in.channel	set	5
10800                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10801                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10802                       00000010            .ata_cmd_data_in.lba_low	set	$10
10803                       00000022            _ata_cmd_data_in.lba_high	set	$22
10804                       00000014            .ata_cmd_data_in.lba_high	set	$14
10805                       0000001C            _ata_cmd_data_in.sector	set	$1C
10806                       0000000E            .ata_cmd_data_in.sector	set	$E
10807                       00000006            _ata_cmd_data_in.blksize	set	6
10808                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10809                       0000001A            _ata_cmd_data_in.head	set	$1A
10810                       0000000C            .ata_cmd_data_in.head	set	$C
10811                       00000018            _ata_cmd_data_in.cylinder	set	$18
10812                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10813                       00000012            _ata_cmd_data_in.device	set	$12
10814                       00000004            .ata_cmd_data_in.device	set	4
10815                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10816                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10817                       00000003            _ata_cmd_data_in.status	set	3
10818                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10819                       00000002            _ata_cmd_data_in.current	set	2
10820                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10821                       00000014            _ata_cmd_data_in.command	set	$14
10822                       00000006            .ata_cmd_data_in.command	set	6
10823                       00000001            _ata_cmd_data_in.mode	set	1
10824                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10825                       00000008            _ata_cmd_data_in.iobase2	set	8
10826                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10827                       00000028            _ata_cmd_data_in.offset	set	$28
10828                       0000001A            .ata_cmd_data_in.offset	set	$1A
10829                       00000004            _ata_cmd_data_in.slave	set	4
10830                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10831 3150           FB                                 sti ;; enable higher priority interrupts
10832                                           ! 1817 endasm
10833                                           !BCC_ENDASM
10834                                           !BCC_EOS
10835                                           ! 1818   while (1) {
10836                       00003151            .277:
10837                                           ! 1819 #asm
10838                                           !BCC_EOS
10839                                           !BCC_ASM
10840                       00000016            _ata_cmd_data_in.count	set	$16
10841                       00000008            .ata_cmd_data_in.count	set	8
10842                       00000026            _ata_cmd_data_in.segment	set	$26
10843                       00000018            .ata_cmd_data_in.segment	set	$18
10844                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10845                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10846                       00000005            _ata_cmd_data_in.channel	set	5
10847                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10848                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10849                       00000010            .ata_cmd_data_in.lba_low	set	$10
10850                       00000022            _ata_cmd_data_in.lba_high	set	$22
10851                       00000014            .ata_cmd_data_in.lba_high	set	$14
10852                       0000001C            _ata_cmd_data_in.sector	set	$1C
10853                       0000000E            .ata_cmd_data_in.sector	set	$E
10854                       00000006            _ata_cmd_data_in.blksize	set	6
10855                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10856                       0000001A            _ata_cmd_data_in.head	set	$1A
10857                       0000000C            .ata_cmd_data_in.head	set	$C
10858                       00000018            _ata_cmd_data_in.cylinder	set	$18
10859                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10860                       00000012            _ata_cmd_data_in.device	set	$12
10861                       00000004            .ata_cmd_data_in.device	set	4
10862                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10863                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10864                       00000003            _ata_cmd_data_in.status	set	3
10865                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10866                       00000002            _ata_cmd_data_in.current	set	2
10867                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10868                       00000014            _ata_cmd_data_in.command	set	$14
10869                       00000006            .ata_cmd_data_in.command	set	6
10870                       00000001            _ata_cmd_data_in.mode	set	1
10871                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10872                       00000008            _ata_cmd_data_in.iobase2	set	8
10873                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10874                       00000028            _ata_cmd_data_in.offset	set	$28
10875                       0000001A            .ata_cmd_data_in.offset	set	$1A
10876                       00000004            _ata_cmd_data_in.slave	set	4
10877                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10878 3151           55                                 push bp
10879 3152           89E5                               mov bp, sp
10880 3154           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
10881 3157           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10882 315A           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10883                                                   ;; adjust if there will be an overrun. 2K max sector size
10884 315D           81FF                 F800          cmp di, #0xf800 ;;
10885 3161           76           07                    jbe ata_in_no_adjust
10886                       00003163            ata_in_adjust:
10887 3163           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10888 3167           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10889                       0000316A            ata_in_no_adjust:
10890 316A           8EC0                               mov es, ax ;; segment in es
10891 316C           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10892 316F           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10893 3172           80FC                   01          cmp ah, #0x01
10894 3175           74           04                    je ata_in_32
10895                       00003177            ata_in_16:
10896 3177           F3                                 rep
10897 3178           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10898 3179           EB           03                    jmp ata_in_done
10899                       0000317B            ata_in_32:
10900 317B           F3                                 rep
10901 317C     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10902                       0000317E            ata_in_done:
10903 317E           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
10904 3181           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
10905 3184           5D                                 pop bp
10906                                           ! 1848 endasm
10907                                           !BCC_ENDASM
10908                                           !BCC_EOS
10909                                           ! 1849     current++;
10910                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
10911 3185           8A46         F4            mov	al,-$C[bp]
10912 3188           40                         inc	ax
10913 3189           8846         F4            mov	-$C[bp],al
10914                                           !BCC_EOS
10915                                           ! 1850     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
10916                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
10917 318C           8A46         F4            mov	al,-$C[bp]
10918 318F           30E4                       xor	ah,ah
10919 3191           50                         push	ax
10920                                           ! Debug: list * unsigned short = const $254 (used reg = )
10921 3192           B8                   0254  mov	ax,#$254
10922 3195           50                         push	ax
10923                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10924 3196           FF76         FE            push	-2[bp]
10925                                           ! Debug: func () void = write_word+0 (used reg = )
10926 3199           E8         D49A            call	_write_word
10927 319C           83C4                   06  add	sp,*6
10928                                           !BCC_EOS
10929                                           ! 1851     count--;
10930                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
10931 319F           8B46         08            mov	ax,8[bp]
10932 31A2           48                         dec	ax
10933 31A3           8946         08            mov	8[bp],ax
10934                                           !BCC_EOS
10935                                           ! 1852     await_ide(2, iobase1, 32000u);
10936                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10937 31A6           B8                   7D00  mov	ax,#$7D00
10938 31A9           50                         push	ax
10939                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10940 31AA           FF76         FC            push	-4[bp]
10941                                           ! Debug: list int = const 2 (used reg = )
10942 31AD           B8                   0002  mov	ax,*2
10943 31B0           50                         push	ax
10944                                           ! Debug: func () int = await_ide+0 (used reg = )
10945 31B1           E8         EA70            call	_await_ide
10946 31B4           83C4                   06  add	sp,*6
10947                                           !BCC_EOS
10948                                           ! 1853     status = inb(iobase1 + 7);
10949                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10950 31B7           8B46         FC            mov	ax,-4[bp]
10951                                           ! Debug: list unsigned int = ax+7 (used reg = )
10952 31BA           05                   0007  add	ax,*7
10953 31BD           50                         push	ax
10954                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10955 31BE           E8         D381            call	_inb
10956 31C1           44                         inc	sp
10957 31C2           44                         inc	sp
10958                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10959 31C3           8846         F5            mov	-$B[bp],al
10960                                           !BCC_EOS
10961                                           ! 1854     if (count == 0) {
10962                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
10963 31C6           8B46         08            mov	ax,8[bp]
10964 31C9           85C0                       test	ax,ax
10965 31CB           75           14            jne 	.278
10966                       000031CD            .279:
10967                                           ! 1855       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10968                                           ! 1856           != 0x40 ) {
10969                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10970 31CD           8A46         F5            mov	al,-$B[bp]
10971 31D0           24                     C9  and	al,#$C9
10972                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10973 31D2           3C                     40  cmp	al,*$40
10974 31D4           74           07            je  	.27A
10975                       000031D6            .27B:
10976                                           ! 1857         ;
10977                                           !BCC_EOS
10978                                           ! 1858         return 4;
10979 31D6           B8                   0004  mov	ax,*4
10980 31D9           89EC                       mov	sp,bp
10981 31DB           5D                         pop	bp
10982 31DC           C3                         ret
10983                                           !BCC_EOS
10984                                           ! 1859       }
10985                                           ! 1860       break;
10986                       000031DD            .27A:
10987 31DD           EB           17            jmp .275
10988                                           !BCC_EOS
10989                                           ! 1861     }
10990                                           ! 1862     else {
10991 31DF           EB           12            jmp .27C
10992                       000031E1            .278:
10993                                           ! 1863       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10994                                           ! 1864           != (0x40 | 0x08) ) {
10995                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10996 31E1           8A46         F5            mov	al,-$B[bp]
10997 31E4           24                     C9  and	al,#$C9
10998                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10999 31E6           3C                     48  cmp	al,*$48
11000 31E8           74           07            je  	.27D
11001                       000031EA            .27E:
11002                                           ! 1865         ;
11003                                           !BCC_EOS
11004                                           ! 1866         return 5;
11005 31EA           B8                   0005  mov	ax,*5
11006 31ED           89EC                       mov	sp,bp
11007 31EF           5D                         pop	bp
11008 31F0           C3                         ret
11009                                           !BCC_EOS
11010                                           ! 1867       }
11011                                           ! 1868       continue;
11012                       000031F1            .27D:
11013 31F1           EB           00            jmp .276
11014                                           !BCC_EOS
11015                                           ! 1869     }
11016                                           ! 1870   }
11017                       000031F3            .27C:
11018                                           ! 1871   outb(iobase2+6, 0x08);
11019                       000031F3            .276:
11020 31F3           E9         FF5B            jmp	.277
11021                       000031F6            .27F:
11022                       000031F6            .275:
11023                                           ! Debug: list int = const 8 (used reg = )
11024 31F6           B8                   0008  mov	ax,*8
11025 31F9           50                         push	ax
11026                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11027 31FA           8B46         FA            mov	ax,-6[bp]
11028                                           ! Debug: list unsigned int = ax+6 (used reg = )
11029 31FD           05                   0006  add	ax,*6
11030 3200           50                         push	ax
11031                                           ! Debug: func () void = outb+0 (used reg = )
11032 3201           E8         D354            call	_outb
11033 3204           83C4                   04  add	sp,*4
11034                                           !BCC_EOS
11035                                           ! 1872   return 0;
11036 3207           31C0                       xor	ax,ax
11037 3209           89EC                       mov	sp,bp
11038 320B           5D                         pop	bp
11039 320C           C3                         ret
11040                                           !BCC_EOS
11041                                           ! 1873 }
11042                                           ! 1874 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
11043                                           ! Register BX used in function ata_cmd_data_in
11044                                           ! 1875 Bit16u device, command, count, cylinder, head, sector, segment, offset;
11045                                           export	_ata_cmd_data_out
11046                       0000320D            _ata_cmd_data_out:
11047                                           !BCC_EOS
11048                                           ! 1876 Bit32u lba_low, lba_high;
11049                                           !BCC_EOS
11050                                           ! 1877 {
11051                                           ! 1878   Bit16u ebda_seg=read_word(0x0040,0x000E);
11052 320D           55                         push	bp
11053 320E           89E5                       mov	bp,sp
11054 3210           4C                         dec	sp
11055 3211           4C                         dec	sp
11056                                           ! Debug: list int = const $E (used reg = )
11057 3212           B8                   000E  mov	ax,*$E
11058 3215           50                         push	ax
11059                                           ! Debug: list int = const $40 (used reg = )
11060 3216           B8                   0040  mov	ax,*$40
11061 3219           50                         push	ax
11062                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11063 321A           E8         D3EE            call	_read_word
11064 321D           83C4                   04  add	sp,*4
11065                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11066 3220           8946         FE            mov	-2[bp],ax
11067                                           !BCC_EOS
11068                                           ! 1879   Bit16u iobase1, iobase2, blksize;
11069                                           !BCC_EOS
11070                                           ! 1880   Bit8u channel, slave;
11071                                           !BCC_EOS
11072                                           ! 1881   Bit8u status, current, mode;
11073                                           !BCC_EOS
11074                                           ! 1882   channel = device / 2;
11075 3223           83C4                   F4  add	sp,*-$C
11076                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11077 3226           8B46         04            mov	ax,4[bp]
11078 3229           D1E8                       shr	ax,*1
11079                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
11080 322B           8846         F7            mov	-9[bp],al
11081                                           !BCC_EOS
11082                                           ! 1883   slave = device % 2;
11083                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11084 322E           8B46         04            mov	ax,4[bp]
11085 3231           24                     01  and	al,*1
11086                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11087 3233           8846         F6            mov	-$A[bp],al
11088                                           !BCC_EOS
11089                                           ! 1884   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11090                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11091 3236           8A46         F7            mov	al,-9[bp]
11092 3239           30E4                       xor	ah,ah
11093 323B           B1                     03  mov	cl,*3
11094 323D           D3E0                       shl	ax,cl
11095 323F           89C3                       mov	bx,ax
11096                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11097                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11098 3241           81C3                 0124  add	bx,#$124
11099 3245           53                         push	bx
11100                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11101 3246           FF76         FE            push	-2[bp]
11102                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11103 3249           E8         D3BF            call	_read_word
11104 324C           83C4                   04  add	sp,*4
11105                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11106 324F           8946         FC            mov	-4[bp],ax
11107                                           !BCC_EOS
11108                                           ! 1885   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11109                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11110 3252           8A46         F7            mov	al,-9[bp]
11111 3255           30E4                       xor	ah,ah
11112 3257           B1                     03  mov	cl,*3
11113 3259           D3E0                       shl	ax,cl
11114 325B           89C3                       mov	bx,ax
11115                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11116                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11117 325D           81C3                 0126  add	bx,#$126
11118 3261           53                         push	bx
11119                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11120 3262           FF76         FE            push	-2[bp]
11121                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11122 3265           E8         D3A3            call	_read_word
11123 3268           83C4                   04  add	sp,*4
11124                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11125 326B           8946         FA            mov	-6[bp],ax
11126                                           !BCC_EOS
11127                                           ! 1886   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11128                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11129 326E           8B46         04            mov	ax,4[bp]
11130 3271           B9                   001E  mov	cx,*$1E
11131 3274           F7E9                       imul	cx
11132 3276           89C3                       mov	bx,ax
11133                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11134                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11135 3278           81C3                 0146  add	bx,#$146
11136 327C           53                         push	bx
11137                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11138 327D           FF76         FE            push	-2[bp]
11139                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11140 3280           E8         D375            call	_read_byte
11141 3283           83C4                   04  add	sp,*4
11142                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11143 3286           8846         F3            mov	-$D[bp],al
11144                                           !BCC_EOS
11145                                           ! 1887   blksize = 0x200;
11146                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11147 3289           B8                   0200  mov	ax,#$200
11148 328C           8946         F8            mov	-8[bp],ax
11149                                           !BCC_EOS
11150                                           ! 1888   if (mode == 0x01) blksize>>=2;
11151                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11152 328F           8A46         F3            mov	al,-$D[bp]
11153 3292           3C                     01  cmp	al,*1
11154 3294           75           0C            jne 	.280
11155                       00003296            .281:
11156                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11157 3296           8B46         F8            mov	ax,-8[bp]
11158 3299           D1E8                       shr	ax,*1
11159 329B           D1E8                       shr	ax,*1
11160 329D           8946         F8            mov	-8[bp],ax
11161                                           !BCC_EOS
11162                                           ! 1889   else blksize>>=1;
11163 32A0           EB           08            jmp .282
11164                       000032A2            .280:
11165                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11166 32A2           8B46         F8            mov	ax,-8[bp]
11167 32A5           D1E8                       shr	ax,*1
11168 32A7           8946         F8            mov	-8[bp],ax
11169                                           !BCC_EOS
11170                                           ! 1890   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11171                       000032AA            .282:
11172                                           ! Debug: list int = const 0 (used reg = )
11173 32AA           31C0                       xor	ax,ax
11174 32AC           50                         push	ax
11175                                           ! Debug: list * unsigned short = const $254 (used reg = )
11176 32AD           B8                   0254  mov	ax,#$254
11177 32B0           50                         push	ax
11178                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11179 32B1           FF76         FE            push	-2[bp]
11180                                           ! Debug: func () void = write_word+0 (used reg = )
11181 32B4           E8         D37F            call	_write_word
11182 32B7           83C4                   06  add	sp,*6
11183                                           !BCC_EOS
11184                                           ! 1891   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11185                                           ! Debug: list long = const 0 (used reg = )
11186 32BA           31C0                       xor	ax,ax
11187 32BC           31DB                       xor	bx,bx
11188 32BE           53                         push	bx
11189 32BF           50                         push	ax
11190                                           ! Debug: list * unsigned long = const $256 (used reg = )
11191 32C0           B8                   0256  mov	ax,#$256
11192 32C3           50                         push	ax
11193                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11194 32C4           FF76         FE            push	-2[bp]
11195                                           ! Debug: func () void = write_dword+0 (used reg = )
11196 32C7           E8         CDD1            call	_write_dword
11197 32CA           83C4                   08  add	sp,*8
11198                                           !BCC_EOS
11199                                           ! 1892   current = 0;
11200                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11201 32CD           30C0                       xor	al,al
11202 32CF           8846         F4            mov	-$C[bp],al
11203                                           !BCC_EOS
11204                                           ! 1893   status = inb(iobase1 + 7);
11205                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11206 32D2           8B46         FC            mov	ax,-4[bp]
11207                                           ! Debug: list unsigned int = ax+7 (used reg = )
11208 32D5           05                   0007  add	ax,*7
11209 32D8           50                         push	ax
11210                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11211 32D9           E8         D266            call	_inb
11212 32DC           44                         inc	sp
11213 32DD           44                         inc	sp
11214                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11215 32DE           8846         F5            mov	-$B[bp],al
11216                                           !BCC_EOS
11217                                           ! 1894   if (status & 0x80) return 1;
11218                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11219 32E1           8A46         F5            mov	al,-$B[bp]
11220 32E4           24                     80  and	al,#$80
11221 32E6           84C0                       test	al,al
11222 32E8           74           07            je  	.283
11223                       000032EA            .284:
11224 32EA           B8                   0001  mov	ax,*1
11225 32ED           89EC                       mov	sp,bp
11226 32EF           5D                         pop	bp
11227 32F0           C3                         ret
11228                                           !BCC_EOS
11229                                           ! 1895   outb(iobase2 + 6, 0x08 | 0x02);
11230                       000032F1            .283:
11231                                           ! Debug: list int = const $A (used reg = )
11232 32F1           B8                   000A  mov	ax,*$A
11233 32F4           50                         push	ax
11234                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11235 32F5           8B46         FA            mov	ax,-6[bp]
11236                                           ! Debug: list unsigned int = ax+6 (used reg = )
11237 32F8           05                   0006  add	ax,*6
11238 32FB           50                         push	ax
11239                                           ! Debug: func () void = outb+0 (used reg = )
11240 32FC           E8         D259            call	_outb
11241 32FF           83C4                   04  add	sp,*4
11242                                           !BCC_EOS
11243                                           ! 1896   if (sector == 0) {
11244                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11245 3302           8B46         0E            mov	ax,$E[bp]
11246 3305           85C0                       test	ax,ax
11247 3307         0F85         0167            bne 	.285
11248                       0000330B            .286:
11249                                           ! 1897     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11250                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11251 330B           8B46         08            mov	ax,8[bp]
11252 330E           3D                   0100  cmp	ax,#$100
11253 3311           72           04            jb 	.28B
11254 3313           B0                     01  mov	al,*1
11255 3315           EB           02            jmp	.28C
11256                       00003317            .28B:
11257 3317           30C0                       xor	al,al
11258                       00003319            .28C:
11259                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11260 3319           30E4                       xor	ah,ah
11261 331B           99                         cwd
11262 331C           89D3                       mov	bx,dx
11263 331E           E8         CDF3            call	ltstl
11264 3321           75           32            jne 	.288
11265                       00003323            .28A:
11266 3323           8B46         14            mov	ax,$14[bp]
11267 3326           8B5E         16            mov	bx,$16[bp]
11268 3329           E8         CDE8            call	ltstl
11269 332C           75           27            jne 	.288
11270                       0000332E            .289:
11271                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11272 332E           8B46         08            mov	ax,8[bp]
11273 3331           31DB                       xor	bx,bx
11274                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11275                                           ! Debug: expression subtree swapping
11276 3333           8D7E         10            lea	di,$10[bp]
11277 3336           E8         CD8A            call	laddul
11278                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11279 3339           53                         push	bx
11280 333A           50                         push	ax
11281 333B           31C0                       xor	ax,ax
11282 333D           BB                   1000  mov	bx,#$1000
11283 3340           53                         push	bx
11284 3341           50                         push	ax
11285 3342           8B46         EE            mov	ax,-$12[bp]
11286 3345           8B5E         F0            mov	bx,-$10[bp]
11287 3348           8D7E         EA            lea	di,-$16[bp]
11288 334B           E8         CD7D            call	lcmpul
11289 334E           8D66         F2            lea	sp,-$E[bp]
11290 3351         0F82         00BC            blo 	.287
11291                       00003355            .288:
11292                                           ! 1898       outb(iobase1 + 1, 0x00);
11293                                           ! Debug: list int = const 0 (used reg = )
11294 3355           31C0                       xor	ax,ax
11295 3357           50                         push	ax
11296                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11297 3358           8B46         FC            mov	ax,-4[bp]
11298                                           ! Debug: list unsigned int = ax+1 (used reg = )
11299 335B           40                         inc	ax
11300 335C           50                         push	ax
11301                                           ! Debug: func () void = outb+0 (used reg = )
11302 335D           E8         D1F8            call	_outb
11303 3360           83C4                   04  add	sp,*4
11304                                           !BCC_EOS
11305                                           ! 1899       outb(iobase1 + 2, (count >> 8) & 0xff);
11306                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11307 3363           8B46         08            mov	ax,8[bp]
11308 3366           88E0                       mov	al,ah
11309 3368           30E4                       xor	ah,ah
11310                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11311                                           ! Debug: list unsigned char = al+0 (used reg = )
11312 336A           30E4                       xor	ah,ah
11313 336C           50                         push	ax
11314                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11315 336D           8B46         FC            mov	ax,-4[bp]
11316                                           ! Debug: list unsigned int = ax+2 (used reg = )
11317 3370           40                         inc	ax
11318 3371           40                         inc	ax
11319 3372           50                         push	ax
11320                                           ! Debug: func () void = outb+0 (used reg = )
11321 3373           E8         D1E2            call	_outb
11322 3376           83C4                   04  add	sp,*4
11323                                           !BCC_EOS
11324                                           ! 1900       outb(iobase1 + 3, lba_low >> 24);
11325                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11326 3379           8B46         10            mov	ax,$10[bp]
11327 337C           8B5E         12            mov	bx,$12[bp]
11328 337F           93                         xchg	bx,ax
11329 3380           88E0                       mov	al,ah
11330 3382           30E4                       xor	ah,ah
11331 3384           31DB                       xor	bx,bx
11332                                           ! Debug: list unsigned long = bx+0 (used reg = )
11333 3386           53                         push	bx
11334 3387           50                         push	ax
11335                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11336 3388           8B46         FC            mov	ax,-4[bp]
11337                                           ! Debug: list unsigned int = ax+3 (used reg = )
11338 338B           05                   0003  add	ax,*3
11339 338E           50                         push	ax
11340                                           ! Debug: func () void = outb+0 (used reg = )
11341 338F           E8         D1C6            call	_outb
11342 3392           83C4                   06  add	sp,*6
11343                                           !BCC_EOS
11344                                           ! 1901       outb(iobase1 + 4, lba_high & 0xff);
11345                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11346                                           ! Debug: expression subtree swapping
11347 3395           B8                   00FF  mov	ax,#$FF
11348 3398           31DB                       xor	bx,bx
11349 339A           8D7E         14            lea	di,$14[bp]
11350 339D           E8         CD1B            call	landul
11351                                           ! Debug: list unsigned long = bx+0 (used reg = )
11352 33A0           53                         push	bx
11353 33A1           50                         push	ax
11354                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11355 33A2           8B46         FC            mov	ax,-4[bp]
11356                                           ! Debug: list unsigned int = ax+4 (used reg = )
11357 33A5           05                   0004  add	ax,*4
11358 33A8           50                         push	ax
11359                                           ! Debug: func () void = outb+0 (used reg = )
11360 33A9           E8         D1AC            call	_outb
11361 33AC           83C4                   06  add	sp,*6
11362                                           !BCC_EOS
11363                                           ! 1902       outb(io
11364                                           ! 1902 base1 + 5, lba_high >> 8);
11365                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11366 33AF           8B46         14            mov	ax,$14[bp]
11367 33B2           8B5E         16            mov	bx,$16[bp]
11368 33B5           88E0                       mov	al,ah
11369 33B7           88DC                       mov	ah,bl
11370 33B9           88FB                       mov	bl,bh
11371 33BB           28FF                       sub	bh,bh
11372                                           ! Debug: list unsigned long = bx+0 (used reg = )
11373 33BD           53                         push	bx
11374 33BE           50                         push	ax
11375                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11376 33BF           8B46         FC            mov	ax,-4[bp]
11377                                           ! Debug: list unsigned int = ax+5 (used reg = )
11378 33C2           05                   0005  add	ax,*5
11379 33C5           50                         push	ax
11380                                           ! Debug: func () void = outb+0 (used reg = )
11381 33C6           E8         D18F            call	_outb
11382 33C9           83C4                   06  add	sp,*6
11383                                           !BCC_EOS
11384                                           ! 1903       command |= 0x04;
11385                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11386 33CC           8B46         06            mov	ax,6[bp]
11387 33CF           0C                     04  or	al,*4
11388 33D1           8946         06            mov	6[bp],ax
11389                                           !BCC_EOS
11390                                           ! 1904       count &= (1UL << 8) - 1;
11391                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11392 33D4           8B46         08            mov	ax,8[bp]
11393 33D7           31DB                       xor	bx,bx
11394 33D9           53                         push	bx
11395 33DA           50                         push	ax
11396 33DB           B8                   00FF  mov	ax,#$FF
11397 33DE           31DB                       xor	bx,bx
11398 33E0           53                         push	bx
11399 33E1           50                         push	ax
11400 33E2           8B46         EE            mov	ax,-$12[bp]
11401 33E5           8B5E         F0            mov	bx,-$10[bp]
11402 33E8           8D7E         EA            lea	di,-$16[bp]
11403 33EB           E8         CCCD            call	landul
11404 33EE           8946         08            mov	8[bp],ax
11405 33F1           83C4                   08  add	sp,*8
11406                                           !BCC_EOS
11407                                           ! 1905       lba_low &= (1UL << 24) - 1;
11408                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11409 33F4           B8                   FFFF  mov	ax,#$FFFF
11410 33F7           BB                   00FF  mov	bx,#$FF
11411 33FA           53                         push	bx
11412 33FB           50                         push	ax
11413 33FC           8B46         10            mov	ax,$10[bp]
11414 33FF           8B5E         12            mov	bx,$12[bp]
11415 3402           8D7E         EE            lea	di,-$12[bp]
11416 3405           E8         CCB3            call	landul
11417 3408           8946         10            mov	$10[bp],ax
11418 340B           895E         12            mov	$12[bp],bx
11419 340E           83C4                   04  add	sp,*4
11420                                           !BCC_EOS
11421                                           ! 1906     }
11422                                           ! 1907     sector = (Bit16u) (lba_low & 0x000000ffL);
11423                       00003411            .287:
11424                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11425                                           ! Debug: expression subtree swapping
11426 3411           B8                   00FF  mov	ax,#$FF
11427 3414           31DB                       xor	bx,bx
11428 3416           8D7E         10            lea	di,$10[bp]
11429 3419           E8         CC9F            call	landul
11430                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11431                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11432 341C           8946         0E            mov	$E[bp],ax
11433                                           !BCC_EOS
11434                                           ! 1908     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11435                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11436 341F           8B46         10            mov	ax,$10[bp]
11437 3422           8B5E         12            mov	bx,$12[bp]
11438 3425           88E0                       mov	al,ah
11439 3427           88DC                       mov	ah,bl
11440 3429           88FB                       mov	bl,bh
11441 342B           28FF                       sub	bh,bh
11442                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11443 342D           53                         push	bx
11444 342E           50                         push	ax
11445 342F           B8                   FFFF  mov	ax,#$FFFF
11446 3432           31DB                       xor	bx,bx
11447 3434           53                         push	bx
11448 3435           50                         push	ax
11449 3436           8B46         EE            mov	ax,-$12[bp]
11450 3439           8B5E         F0            mov	bx,-$10[bp]
11451 343C           8D7E         EA            lea	di,-$16[bp]
11452 343F           E8         CC79            call	landul
11453 3442           83C4                   08  add	sp,*8
11454                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11455                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11456 3445           8946         0A            mov	$A[bp],ax
11457                                           !BCC_EOS
11458                                           ! 1909     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11459                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11460 3448           8B46         10            mov	ax,$10[bp]
11461 344B           8B5E         12            mov	bx,$12[bp]
11462 344E           93                         xchg	bx,ax
11463 344F           88E0                       mov	al,ah
11464 3451           30E4                       xor	ah,ah
11465 3453           31DB                       xor	bx,bx
11466                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11467 3455           53                         push	bx
11468 3456           50                         push	ax
11469 3457           B8                   000F  mov	ax,*$F
11470 345A           31DB                       xor	bx,bx
11471 345C           53                         push	bx
11472 345D           50                         push	ax
11473 345E           8B46         EE            mov	ax,-$12[bp]
11474 3461           8B5E         F0            mov	bx,-$10[bp]
11475 3464           8D7E         EA            lea	di,-$16[bp]
11476 3467           E8         CC51            call	landul
11477 346A           83C4                   08  add	sp,*8
11478                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11479                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11480 346D           0C                     40  or	al,*$40
11481                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11482 346F           8946         0C            mov	$C[bp],ax
11483                                           !BCC_EOS
11484                                           ! 1910   }
11485                                           ! 1911   outb(iobase1 + 1, 0x00);
11486                       00003472            .285:
11487                                           ! Debug: list int = const 0 (used reg = )
11488 3472           31C0                       xor	ax,ax
11489 3474           50                         push	ax
11490                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11491 3475           8B46         FC            mov	ax,-4[bp]
11492                                           ! Debug: list unsigned int = ax+1 (used reg = )
11493 3478           40                         inc	ax
11494 3479           50                         push	ax
11495                                           ! Debug: func () void = outb+0 (used reg = )
11496 347A           E8         D0DB            call	_outb
11497 347D           83C4                   04  add	sp,*4
11498                                           !BCC_EOS
11499                                           ! 1912   outb(iobase1 + 2, count);
11500                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11501 3480           FF76         08            push	8[bp]
11502                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11503 3483           8B46         FC            mov	ax,-4[bp]
11504                                           ! Debug: list unsigned int = ax+2 (used reg = )
11505 3486           40                         inc	ax
11506 3487           40                         inc	ax
11507 3488           50                         push	ax
11508                                           ! Debug: func () void = outb+0 (used reg = )
11509 3489           E8         D0CC            call	_outb
11510 348C           83C4                   04  add	sp,*4
11511                                           !BCC_EOS
11512                                           ! 1913   outb(iobase1 + 3, sector);
11513                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11514 348F           FF76         0E            push	$E[bp]
11515                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11516 3492           8B46         FC            mov	ax,-4[bp]
11517                                           ! Debug: list unsigned int = ax+3 (used reg = )
11518 3495           05                   0003  add	ax,*3
11519 3498           50                         push	ax
11520                                           ! Debug: func () void = outb+0 (used reg = )
11521 3499           E8         D0BC            call	_outb
11522 349C           83C4                   04  add	sp,*4
11523                                           !BCC_EOS
11524                                           ! 1914   outb(iobase1 + 4, cylinder & 0x00ff);
11525                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11526 349F           8A46         0A            mov	al,$A[bp]
11527                                           ! Debug: list unsigned char = al+0 (used reg = )
11528 34A2           30E4                       xor	ah,ah
11529 34A4           50                         push	ax
11530                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11531 34A5           8B46         FC            mov	ax,-4[bp]
11532                                           ! Debug: list unsigned int = ax+4 (used reg = )
11533 34A8           05                   0004  add	ax,*4
11534 34AB           50                         push	ax
11535                                           ! Debug: func () void = outb+0 (used reg = )
11536 34AC           E8         D0A9            call	_outb
11537 34AF           83C4                   04  add	sp,*4
11538                                           !BCC_EOS
11539                                           ! 1915   outb(iobase1 + 5, cylinder >> 8);
11540                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11541 34B2           8B46         0A            mov	ax,$A[bp]
11542 34B5           88E0                       mov	al,ah
11543 34B7           30E4                       xor	ah,ah
11544                                           ! Debug: list unsigned int = ax+0 (used reg = )
11545 34B9           50                         push	ax
11546                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11547 34BA           8B46         FC            mov	ax,-4[bp]
11548                                           ! Debug: list unsigned int = ax+5 (used reg = )
11549 34BD           05                   0005  add	ax,*5
11550 34C0           50                         push	ax
11551                                           ! Debug: func () void = outb+0 (used reg = )
11552 34C1           E8         D094            call	_outb
11553 34C4           83C4                   04  add	sp,*4
11554                                           !BCC_EOS
11555                                           ! 1916   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11556 34C7           8A46         F6            mov	al,-$A[bp]
11557 34CA           84C0                       test	al,al
11558 34CC           74           04            je  	.28E
11559                       000034CE            .28F:
11560 34CE           B0                     B0  mov	al,#$B0
11561 34D0           EB           02            jmp .290
11562                       000034D2            .28E:
11563 34D2           B0                     A0  mov	al,#$A0
11564                       000034D4            .290:
11565                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11566 34D4           0A46         0C            or	al,$C[bp]
11567                                           ! Debug: list unsigned char = al+0 (used reg = )
11568 34D7           30E4                       xor	ah,ah
11569 34D9           50                         push	ax
11570                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11571 34DA           8B46         FC            mov	ax,-4[bp]
11572                                           ! Debug: list unsigned int = ax+6 (used reg = )
11573 34DD           05                   0006  add	ax,*6
11574 34E0           50                         push	ax
11575                                           ! Debug: func () void = outb+0 (used reg = )
11576 34E1           E8         D074            call	_outb
11577 34E4           83C4                   04  add	sp,*4
11578                                           !BCC_EOS
11579                                           ! 1917   outb(iobase1 + 7, command);
11580                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11581 34E7           FF76         06            push	6[bp]
11582                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11583 34EA           8B46         FC            mov	ax,-4[bp]
11584                                           ! Debug: list unsigned int = ax+7 (used reg = )
11585 34ED           05                   0007  add	ax,*7
11586 34F0           50                         push	ax
11587                                           ! Debug: func () void = outb+0 (used reg = )
11588 34F1           E8         D064            call	_outb
11589 34F4           83C4                   04  add	sp,*4
11590                                           !BCC_EOS
11591                                           ! 1918   await_ide(3, iobase1, 32000u);
11592                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11593 34F7           B8                   7D00  mov	ax,#$7D00
11594 34FA           50                         push	ax
11595                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11596 34FB           FF76         FC            push	-4[bp]
11597                                           ! Debug: list int = const 3 (used reg = )
11598 34FE           B8                   0003  mov	ax,*3
11599 3501           50                         push	ax
11600                                           ! Debug: func () int = await_ide+0 (used reg = )
11601 3502           E8         E71F            call	_await_ide
11602 3505           83C4                   06  add	sp,*6
11603                                           !BCC_EOS
11604                                           ! 1919   status = inb(iobase1 + 7);
11605                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11606 3508           8B46         FC            mov	ax,-4[bp]
11607                                           ! Debug: list unsigned int = ax+7 (used reg = )
11608 350B           05                   0007  add	ax,*7
11609 350E           50                         push	ax
11610                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11611 350F           E8         D030            call	_inb
11612 3512           44                         inc	sp
11613 3513           44                         inc	sp
11614                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11615 3514           8846         F5            mov	-$B[bp],al
11616                                           !BCC_EOS
11617                                           ! 1920   if (status & 0x01) {
11618                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11619 3517           8A46         F5            mov	al,-$B[bp]
11620 351A           24                     01  and	al,*1
11621 351C           84C0                       test	al,al
11622 351E           74           09            je  	.291
11623                       00003520            .292:
11624                                           ! 1921     ;
11625                                           !BCC_EOS
11626                                           ! 1922     return 2;
11627 3520           B8                   0002  mov	ax,*2
11628 3523           89EC                       mov	sp,bp
11629 3525           5D                         pop	bp
11630 3526           C3                         ret
11631                                           !BCC_EOS
11632                                           ! 1923   } else if ( !(status & 0x08) ) {
11633 3527           EB           10            jmp .293
11634                       00003529            .291:
11635                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11636 3529           8A46         F5            mov	al,-$B[bp]
11637 352C           24                     08  and	al,*8
11638 352E           84C0                       test	al,al
11639 3530           75           07            jne 	.294
11640                       00003532            .295:
11641                                           ! 1924     ;
11642                                           !BCC_EOS
11643                                           ! 1925     return 3;
11644 3532           B8                   0003  mov	ax,*3
11645 3535           89EC                       mov	sp,bp
11646 3537           5D                         pop	bp
11647 3538           C3                         ret
11648                                           !BCC_EOS
11649                                           ! 1926   }
11650                                           ! 1927 #asm
11651                       00003539            .294:
11652                       00003539            .293:
11653                                           !BCC_EOS
11654                                           !BCC_ASM
11655                       00000016            _ata_cmd_data_out.count	set	$16
11656                       00000008            .ata_cmd_data_out.count	set	8
11657                       00000026            _ata_cmd_data_out.segment	set	$26
11658                       00000018            .ata_cmd_data_out.segment	set	$18
11659                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11660                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11661                       00000005            _ata_cmd_data_out.channel	set	5
11662                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11663                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11664                       00000010            .ata_cmd_data_out.lba_low	set	$10
11665                       00000022            _ata_cmd_data_out.lba_high	set	$22
11666                       00000014            .ata_cmd_data_out.lba_high	set	$14
11667                       0000001C            _ata_cmd_data_out.sector	set	$1C
11668                       0000000E            .ata_cmd_data_out.sector	set	$E
11669                       00000006            _ata_cmd_data_out.blksize	set	6
11670                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11671                       0000001A            _ata_cmd_data_out.head	set	$1A
11672                       0000000C            .ata_cmd_data_out.head	set	$C
11673                       00000018            _ata_cmd_data_out.cylinder	set	$18
11674                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11675                       00000012            _ata_cmd_data_out.device	set	$12
11676                       00000004            .ata_cmd_data_out.device	set	4
11677                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11678                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11679                       00000003            _ata_cmd_data_out.status	set	3
11680                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11681                       00000002            _ata_cmd_data_out.current	set	2
11682                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11683                       00000014            _ata_cmd_data_out.command	set	$14
11684                       00000006            .ata_cmd_data_out.command	set	6
11685                       00000001            _ata_cmd_data_out.mode	set	1
11686                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11687                       00000008            _ata_cmd_data_out.iobase2	set	8
11688                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11689                       00000028            _ata_cmd_data_out.offset	set	$28
11690                       0000001A            .ata_cmd_data_out.offset	set	$1A
11691                       00000004            _ata_cmd_data_out.slave	set	4
11692                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11693 3539           FB                                 sti ;; enable higher priority interrupts
11694                                           ! 1929 endasm
11695                                           !BCC_ENDASM
11696                                           !BCC_EOS
11697                                           ! 1930   while (1) {
11698                       0000353A            .298:
11699                                           ! 1931 #asm
11700                                           !BCC_EOS
11701                                           !BCC_ASM
11702                       00000016            _ata_cmd_data_out.count	set	$16
11703                       00000008            .ata_cmd_data_out.count	set	8
11704                       00000026            _ata_cmd_data_out.segment	set	$26
11705                       00000018            .ata_cmd_data_out.segment	set	$18
11706                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11707                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11708                       00000005            _ata_cmd_data_out.channel	set	5
11709                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11710                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11711                       00000010            .ata_cmd_data_out.lba_low	set	$10
11712                       00000022            _ata_cmd_data_out.lba_high	set	$22
11713                       00000014            .ata_cmd_data_out.lba_high	set	$14
11714                       0000001C            _ata_cmd_data_out.sector	set	$1C
11715                       0000000E            .ata_cmd_data_out.sector	set	$E
11716                       00000006            _ata_cmd_data_out.blksize	set	6
11717                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11718                       0000001A            _ata_cmd_data_out.head	set	$1A
11719                       0000000C            .ata_cmd_data_out.head	set	$C
11720                       00000018            _ata_cmd_data_out.cylinder	set	$18
11721                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11722                       00000012            _ata_cmd_data_out.device	set	$12
11723                       00000004            .ata_cmd_data_out.device	set	4
11724                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11725                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11726                       00000003            _ata_cmd_data_out.status	set	3
11727                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11728                       00000002            _ata_cmd_data_out.current	set	2
11729                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11730                       00000014            _ata_cmd_data_out.command	set	$14
11731                       00000006            .ata_cmd_data_out.command	set	6
11732                       00000001            _ata_cmd_data_out.mode	set	1
11733                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11734                       00000008            _ata_cmd_data_out.iobase2	set	8
11735                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11736                       00000028            _ata_cmd_data_out.offset	set	$28
11737                       0000001A            .ata_cmd_data_out.offset	set	$1A
11738                       00000004            _ata_cmd_data_out.slave	set	4
11739                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11740 353A           55                                 push bp
11741 353B           89E5                               mov bp, sp
11742 353D           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
11743 3540           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
11744 3543           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
11745                                                   ;; adjust if there will be an overrun. 2K max sector size
11746 3546           81FE                 F800          cmp si, #0xf800 ;;
11747 354A           76           07                    jbe ata_out_no_adjust
11748                       0000354C            ata_out_adjust:
11749 354C           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
11750 3550           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11751                       00003553            ata_out_no_adjust:
11752 3553           8EC0                               mov es, ax ;; segment in es
11753 3555           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
11754 3558           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
11755 355B           80FC                   01          cmp ah, #0x01
11756 355E           74           05                    je ata_out_32
11757                       00003560            ata_out_16:
11758 3560           26                                 seg ES
11759 3561           F3                                 rep
11760 3562           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
11761 3563           EB           04                    jmp ata_out_done
11762                       00003565            ata_out_32:
11763 3565           26                                 seg ES
11764 3566           F3                                 rep
11765 3567     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
11766                       00003569            ata_out_done:
11767 3569           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
11768 356C           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
11769 356F           5D                                 pop bp
11770                                           ! 1962 endasm
11771                                           !BCC_ENDASM
11772                                           !BCC_EOS
11773                                           ! 1963     current++;
11774                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11775 3570           8A46         F4            mov	al,-$C[bp]
11776 3573           40                         inc	ax
11777 3574           8846         F4            mov	-$C[bp],al
11778                                           !BCC_EOS
11779                                           ! 1964     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11780                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11781 3577           8A46         F4            mov	al,-$C[bp]
11782 357A           30E4                       xor	ah,ah
11783 357C           50                         push	ax
11784                                           ! Debug: list * unsigned short = const $254 (used reg = )
11785 357D           B8                   0254  mov	ax,#$254
11786 3580           50                         push	ax
11787                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11788 3581           FF76         FE            push	-2[bp]
11789                                           ! Debug: func () void = write_word+0 (used reg = )
11790 3584           E8         D0AF            call	_write_word
11791 3587           83C4                   06  add	sp,*6
11792                                           !BCC_EOS
11793                                           ! 1965     count--;
11794                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11795 358A           8B46         08            mov	ax,8[bp]
11796 358D           48                         dec	ax
11797 358E           8946         08            mov	8[bp],ax
11798                                           !BCC_EOS
11799                                           ! 1966     status = inb(iobase1 + 7);
11800                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11801 3591           8B46         FC            mov	ax,-4[bp]
11802                                           ! Debug: list unsigned int = ax+7 (used reg = )
11803 3594           05                   0007  add	ax,*7
11804 3597           50                         push	ax
11805                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11806 3598           E8         CFA7            call	_inb
11807 359B           44                         inc	sp
11808 359C           44                         inc	sp
11809                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11810 359D           8846         F5            mov	-$B[bp],al
11811                                           !BCC_EOS
11812                                           ! 1967     if (count == 0) {
11813                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11814 35A0           8B46         08            mov	ax,8[bp]
11815 35A3           85C0                       test	ax,ax
11816 35A5           75           14            jne 	.299
11817                       000035A7            .29A:
11818                                           ! 1968       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11819                                           ! 1969           != 0x40 ) {
11820                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
11821 35A7           8A46         F5            mov	al,-$B[bp]
11822 35AA           24                     E9  and	al,#$E9
11823                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11824 35AC           3C                     40  cmp	al,*$40
11825 35AE           74           07            je  	.29B
11826                       000035B0            .29C:
11827                                           ! 1970         ;
11828                                           !BCC_EOS
11829                                           ! 1971         re
11830                                           ! 1971 turn 6;
11831 35B0           B8                   0006  mov	ax,*6
11832 35B3           89EC                       mov	sp,bp
11833 35B5           5D                         pop	bp
11834 35B6           C3                         ret
11835                                           !BCC_EOS
11836                                           ! 1972       }
11837                                           ! 1973       break;
11838                       000035B7            .29B:
11839 35B7           EB           17            jmp .296
11840                                           !BCC_EOS
11841                                           ! 1974     }
11842                                           ! 1975     else {
11843 35B9           EB           12            jmp .29D
11844                       000035BB            .299:
11845                                           ! 1976       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11846                                           ! 1977           != (0x40 | 0x08) ) {
11847                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11848 35BB           8A46         F5            mov	al,-$B[bp]
11849 35BE           24                     C9  and	al,#$C9
11850                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11851 35C0           3C                     48  cmp	al,*$48
11852 35C2           74           07            je  	.29E
11853                       000035C4            .29F:
11854                                           ! 1978         ;
11855                                           !BCC_EOS
11856                                           ! 1979         return 7;
11857 35C4           B8                   0007  mov	ax,*7
11858 35C7           89EC                       mov	sp,bp
11859 35C9           5D                         pop	bp
11860 35CA           C3                         ret
11861                                           !BCC_EOS
11862                                           ! 1980       }
11863                                           ! 1981       continue;
11864                       000035CB            .29E:
11865 35CB           EB           00            jmp .297
11866                                           !BCC_EOS
11867                                           ! 1982     }
11868                                           ! 1983   }
11869                       000035CD            .29D:
11870                                           ! 1984   outb(iobase2+6, 0x08);
11871                       000035CD            .297:
11872 35CD           E9         FF6A            jmp	.298
11873                       000035D0            .2A0:
11874                       000035D0            .296:
11875                                           ! Debug: list int = const 8 (used reg = )
11876 35D0           B8                   0008  mov	ax,*8
11877 35D3           50                         push	ax
11878                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11879 35D4           8B46         FA            mov	ax,-6[bp]
11880                                           ! Debug: list unsigned int = ax+6 (used reg = )
11881 35D7           05                   0006  add	ax,*6
11882 35DA           50                         push	ax
11883                                           ! Debug: func () void = outb+0 (used reg = )
11884 35DB           E8         CF7A            call	_outb
11885 35DE           83C4                   04  add	sp,*4
11886                                           !BCC_EOS
11887                                           ! 1985   return 0;
11888 35E1           31C0                       xor	ax,ax
11889 35E3           89EC                       mov	sp,bp
11890 35E5           5D                         pop	bp
11891 35E6           C3                         ret
11892                                           !BCC_EOS
11893                                           ! 1986 }
11894                                           ! 1987 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
11895                                           ! Register BX used in function ata_cmd_data_out
11896                                           ! 1988 Bit8u cmdlen,inout;
11897                                           export	_ata_cmd_packet
11898                       000035E7            _ata_cmd_packet:
11899                                           !BCC_EOS
11900                                           ! 1989 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
11901                                           !BCC_EOS
11902                                           ! 1990 Bit16u header;
11903                                           !BCC_EOS
11904                                           ! 1991 Bit32u length;
11905                                           !BCC_EOS
11906                                           ! 1992 {
11907                                           ! 1993   Bit16u ebda_seg=read_word(0x0040,0x000E);
11908 35E7           55                         push	bp
11909 35E8           89E5                       mov	bp,sp
11910 35EA           4C                         dec	sp
11911 35EB           4C                         dec	sp
11912                                           ! Debug: list int = const $E (used reg = )
11913 35EC           B8                   000E  mov	ax,*$E
11914 35EF           50                         push	ax
11915                                           ! Debug: list int = const $40 (used reg = )
11916 35F0           B8                   0040  mov	ax,*$40
11917 35F3           50                         push	ax
11918                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11919 35F4           E8         D014            call	_read_word
11920 35F7           83C4                   04  add	sp,*4
11921                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11922 35FA           8946         FE            mov	-2[bp],ax
11923                                           !BCC_EOS
11924                                           ! 1994   Bit16u iobase1, iobase2;
11925                                           !BCC_EOS
11926                                           ! 1995   Bit16u lcount, lbefore, lafter, count;
11927                                           !BCC_EOS
11928                                           ! 1996   Bit8u channel, slave;
11929                                           !BCC_EOS
11930                                           ! 1997   Bit8u status, mode, lmode;
11931                                           !BCC_EOS
11932                                           ! 1998   Bit32u total, transfer;
11933                                           !BCC_EOS
11934                                           ! 1999   channel = device / 2;
11935 35FD           83C4                   E6  add	sp,*-$1A
11936                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11937 3600           8B46         04            mov	ax,4[bp]
11938 3603           D1E8                       shr	ax,*1
11939                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
11940 3605           8846         F1            mov	-$F[bp],al
11941                                           !BCC_EOS
11942                                           ! 2000   slave = device % 2;
11943                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11944 3608           8B46         04            mov	ax,4[bp]
11945 360B           24                     01  and	al,*1
11946                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
11947 360D           8846         F0            mov	-$10[bp],al
11948                                           !BCC_EOS
11949                                           ! 2001   if (inout == 0x02) {
11950                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
11951 3610           8A46         12            mov	al,$12[bp]
11952 3613           3C                     02  cmp	al,*2
11953 3615           75           15            jne 	.2A1
11954                       00003617            .2A2:
11955                                           ! 2002     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
11956                                           ! Debug: list * char = .2A3+0 (used reg = )
11957 3617           BB                   D64F  mov	bx,#.2A3
11958 361A           53                         push	bx
11959                                           ! Debug: list int = const 4 (used reg = )
11960 361B           B8                   0004  mov	ax,*4
11961 361E           50                         push	ax
11962                                           ! Debug: func () void = bios_printf+0 (used reg = )
11963 361F           E8         D385            call	_bios_printf
11964 3622           83C4                   04  add	sp,*4
11965                                           !BCC_EOS
11966                                           ! 2003     return 1;
11967 3625           B8                   0001  mov	ax,*1
11968 3628           89EC                       mov	sp,bp
11969 362A           5D                         pop	bp
11970 362B           C3                         ret
11971                                           !BCC_EOS
11972                                           ! 2004   }
11973                                           ! 2005   if (header & 1) {
11974                       0000362C            .2A1:
11975                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
11976 362C           8A46         0C            mov	al,$C[bp]
11977 362F           24                     01  and	al,*1
11978 3631           84C0                       test	al,al
11979 3633           74           07            je  	.2A4
11980                       00003635            .2A5:
11981                                           ! 2006     ;
11982                                           !BCC_EOS
11983                                           ! 2007     return 1;
11984 3635           B8                   0001  mov	ax,*1
11985 3638           89EC                       mov	sp,bp
11986 363A           5D                         pop	bp
11987 363B           C3                         ret
11988                                           !BCC_EOS
11989                                           ! 2008   }
11990                                           ! 2009   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11991                       0000363C            .2A4:
11992                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11993 363C           8A46         F1            mov	al,-$F[bp]
11994 363F           30E4                       xor	ah,ah
11995 3641           B1                     03  mov	cl,*3
11996 3643           D3E0                       shl	ax,cl
11997 3645           89C3                       mov	bx,ax
11998                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11999                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
12000 3647           81C3                 0124  add	bx,#$124
12001 364B           53                         push	bx
12002                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12003 364C           FF76         FE            push	-2[bp]
12004                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12005 364F           E8         CFB9            call	_read_word
12006 3652           83C4                   04  add	sp,*4
12007                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12008 3655           8946         FC            mov	-4[bp],ax
12009                                           !BCC_EOS
12010                                           ! 2010   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
12011                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12012 3658           8A46         F1            mov	al,-$F[bp]
12013 365B           30E4                       xor	ah,ah
12014 365D           B1                     03  mov	cl,*3
12015 365F           D3E0                       shl	ax,cl
12016 3661           89C3                       mov	bx,ax
12017                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
12018                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
12019 3663           81C3                 0126  add	bx,#$126
12020 3667           53                         push	bx
12021                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12022 3668           FF76         FE            push	-2[bp]
12023                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12024 366B           E8         CF9D            call	_read_word
12025 366E           83C4                   04  add	sp,*4
12026                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
12027 3671           8946         FA            mov	-6[bp],ax
12028                                           !BCC_EOS
12029                                           ! 2011   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
12030                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
12031 3674           8B46         04            mov	ax,4[bp]
12032 3677           B9                   001E  mov	cx,*$1E
12033 367A           F7E9                       imul	cx
12034 367C           89C3                       mov	bx,ax
12035                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
12036                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
12037 367E           81C3                 0146  add	bx,#$146
12038 3682           53                         push	bx
12039                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12040 3683           FF76         FE            push	-2[bp]
12041                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12042 3686           E8         CF6F            call	_read_byte
12043 3689           83C4                   04  add	sp,*4
12044                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
12045 368C           8846         EE            mov	-$12[bp],al
12046                                           !BCC_EOS
12047                                           ! 2012   transfer= 0L;
12048                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
12049 368F           31C0                       xor	ax,ax
12050 3691           31DB                       xor	bx,bx
12051 3693           8946         E4            mov	-$1C[bp],ax
12052 3696           895E         E6            mov	-$1A[bp],bx
12053                                           !BCC_EOS
12054                                           ! 2013   if (cmdlen < 12) cmdlen=12;
12055                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12056 3699           8A46         06            mov	al,6[bp]
12057 369C           3C                     0C  cmp	al,*$C
12058 369E           73           05            jae 	.2A6
12059                       000036A0            .2A7:
12060                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12061 36A0           B0                     0C  mov	al,*$C
12062 36A2           8846         06            mov	6[bp],al
12063                                           !BCC_EOS
12064                                           ! 2014   if (cmdlen > 12) cmdlen=16;
12065                       000036A5            .2A6:
12066                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12067 36A5           8A46         06            mov	al,6[bp]
12068 36A8           3C                     0C  cmp	al,*$C
12069 36AA           76           05            jbe 	.2A8
12070                       000036AC            .2A9:
12071                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12072 36AC           B0                     10  mov	al,*$10
12073 36AE           8846         06            mov	6[bp],al
12074                                           !BCC_EOS
12075                                           ! 2015   cmdlen>>=1;
12076                       000036B1            .2A8:
12077                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12078 36B1           8A46         06            mov	al,6[bp]
12079 36B4           30E4                       xor	ah,ah
12080 36B6           D1E8                       shr	ax,*1
12081 36B8           8846         06            mov	6[bp],al
12082                                           !BCC_EOS
12083                                           ! 2016   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
12084                                           ! Debug: list int = const 0 (used reg = )
12085 36BB           31C0                       xor	ax,ax
12086 36BD           50                         push	ax
12087                                           ! Debug: list * unsigned short = const $254 (used reg = )
12088 36BE           B8                   0254  mov	ax,#$254
12089 36C1           50                         push	ax
12090                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
12091 36C2           FF76         FE            push	-2[bp]
12092                                           ! Debug: func () void = write_word+0 (used reg = )
12093 36C5           E8         CF6E            call	_write_word
12094 36C8           83C4                   06  add	sp,*6
12095                                           !BCC_EOS
12096                                           ! 2017   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
12097                                           ! Debug: list long = const 0 (used reg = )
12098 36CB           31C0                       xor	ax,ax
12099 36CD           31DB                       xor	bx,bx
12100 36CF           53                         push	bx
12101 36D0           50                         push	ax
12102                                           ! Debug: list * unsigned long = const $256 (used reg = )
12103 36D1           B8                   0256  mov	ax,#$256
12104 36D4           50                         push	ax
12105                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12106 36D5           FF76         FE            push	-2[bp]
12107                                           ! Debug: func () void = write_dword+0 (used reg = )
12108 36D8           E8         C9C0            call	_write_dword
12109 36DB           83C4                   08  add	sp,*8
12110                                           !BCC_EOS
12111                                           ! 2018   status = inb(iobase1 + 7);
12112                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12113 36DE           8B46         FC            mov	ax,-4[bp]
12114                                           ! Debug: list unsigned int = ax+7 (used reg = )
12115 36E1           05                   0007  add	ax,*7
12116 36E4           50                         push	ax
12117                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12118 36E5           E8         CE5A            call	_inb
12119 36E8           44                         inc	sp
12120 36E9           44                         inc	sp
12121                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12122 36EA           8846         EF            mov	-$11[bp],al
12123                                           !BCC_EOS
12124                                           ! 2019   if (status & 0x80) return 2;
12125                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12126 36ED           8A46         EF            mov	al,-$11[bp]
12127 36F0           24                     80  and	al,#$80
12128 36F2           84C0                       test	al,al
12129 36F4           74           07            je  	.2AA
12130                       000036F6            .2AB:
12131 36F6           B8                   0002  mov	ax,*2
12132 36F9           89EC                       mov	sp,bp
12133 36FB           5D                         pop	bp
12134 36FC           C3                         ret
12135                                           !BCC_EOS
12136                                           ! 2020   outb(iobase2 + 6, 0x08 | 0x02);
12137                       000036FD            .2AA:
12138                                           ! Debug: list int = const $A (used reg = )
12139 36FD           B8                   000A  mov	ax,*$A
12140 3700           50                         push	ax
12141                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12142 3701           8B46         FA            mov	ax,-6[bp]
12143                                           ! Debug: list unsigned int = ax+6 (used reg = )
12144 3704           05                   0006  add	ax,*6
12145 3707           50                         push	ax
12146                                           ! Debug: func () void = outb+0 (used reg = )
12147 3708           E8         CE4D            call	_outb
12148 370B           83C4                   04  add	sp,*4
12149                                           !BCC_EOS
12150                                           ! 2021   outb(iobase1 + 1, 0x00);
12151                                           ! Debug: list int = const 0 (used reg = )
12152 370E           31C0                       xor	ax,ax
12153 3710           50                         push	ax
12154                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12155 3711           8B46         FC            mov	ax,-4[bp]
12156                                           ! Debug: list unsigned int = ax+1 (used reg = )
12157 3714           40                         inc	ax
12158 3715           50                         push	ax
12159                                           ! Debug: func () void = outb+0 (used reg = )
12160 3716           E8         CE3F            call	_outb
12161 3719           83C4                   04  add	sp,*4
12162                                           !BCC_EOS
12163                                           ! 2022   outb(iobase1 + 2, 0x00);
12164                                           ! Debug: list int = const 0 (used reg = )
12165 371C           31C0                       xor	ax,ax
12166 371E           50                         push	ax
12167                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12168 371F           8B46         FC            mov	ax,-4[bp]
12169                                           ! Debug: list unsigned int = ax+2 (used reg = )
12170 3722           40                         inc	ax
12171 3723           40                         inc	ax
12172 3724           50                         push	ax
12173                                           ! Debug: func () void = outb+0 (used reg = )
12174 3725           E8         CE30            call	_outb
12175 3728           83C4                   04  add	sp,*4
12176                                           !BCC_EOS
12177                                           ! 2023   outb(iobase1 + 3, 0x00);
12178                                           ! Debug: list int = const 0 (used reg = )
12179 372B           31C0                       xor	ax,ax
12180 372D           50                         push	ax
12181                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12182 372E           8B46         FC            mov	ax,-4[bp]
12183                                           ! Debug: list unsigned int = ax+3 (used reg = )
12184 3731           05                   0003  add	ax,*3
12185 3734           50                         push	ax
12186                                           ! Debug: func () void = outb+0 (used reg = )
12187 3735           E8         CE20            call	_outb
12188 3738           83C4                   04  add	sp,*4
12189                                           !BCC_EOS
12190                                           ! 2024   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12191                                           ! Debug: list unsigned int = const $F0 (used reg = )
12192 373B           B8                   00F0  mov	ax,#$F0
12193 373E           50                         push	ax
12194                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12195 373F           8B46         FC            mov	ax,-4[bp]
12196                                           ! Debug: list unsigned int = ax+4 (used reg = )
12197 3742           05                   0004  add	ax,*4
12198 3745           50                         push	ax
12199                                           ! Debug: func () void = outb+0 (used reg = )
12200 3746           E8         CE0F            call	_outb
12201 3749           83C4                   04  add	sp,*4
12202                                           !BCC_EOS
12203                                           ! 2025   outb(iobase1 + 5, 0xfff0 >> 8);
12204                                           ! Debug: list unsigned int = const $FF (used reg = )
12205 374C           B8                   00FF  mov	ax,#$FF
12206 374F           50                         push	ax
12207                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12208 3750           8B46         FC            mov	ax,-4[bp]
12209                                           ! Debug: list unsigned int = ax+5 (used reg = )
12210 3753           05                   0005  add	ax,*5
12211 3756           50                         push	ax
12212                                           ! Debug: func () void = outb+0 (used reg = )
12213 3757           E8         CDFE            call	_outb
12214 375A           83C4                   04  add	sp,*4
12215                                           !BCC_EOS
12216                                           ! 2026   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12217 375D           8A46         F0            mov	al,-$10[bp]
12218 3760           84C0                       test	al,al
12219 3762           74           04            je  	.2AC
12220                       00003764            .2AD:
12221 3764           B0                     B0  mov	al,#$B0
12222 3766           EB           02            jmp .2AE
12223                       00003768            .2AC:
12224 3768           B0                     A0  mov	al,#$A0
12225                       0000376A            .2AE:
12226                                           ! Debug: list char = al+0 (used reg = )
12227 376A           30E4                       xor	ah,ah
12228 376C           50                         push	ax
12229                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12230 376D           8B46         FC            mov	ax,-4[bp]
12231                                           ! Debug: list unsigned int = ax+6 (used reg = )
12232 3770           05                   0006  add	ax,*6
12233 3773           50                         push	ax
12234                                           ! Debug: func () void = outb+0 (used reg = )
12235 3774           E8         CDE1            call	_outb
12236 3777           83C4                   04  add	sp,*4
12237                                           !BCC_EOS
12238                                           ! 2027   outb(iobase1 + 7, 0xA0);
12239                                           ! Debug: list int = const $A0 (used reg = )
12240 377A           B8                   00A0  mov	ax,#$A0
12241 377D           50                         push	ax
12242                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12243 377E           8B46         FC            mov	ax,-4[bp]
12244                                           ! Debug: list unsigned int = ax+7 (used reg = )
12245 3781           05                   0007  add	ax,*7
12246 3784           50                         push	ax
12247                                           ! Debug: func () void = outb+0 (used reg = )
12248 3785           E8         CDD0            call	_outb
12249 3788           83C4                   04  add	sp,*4
12250                                           !BCC_EOS
12251                                           ! 2028   await_ide(3, iobase1, 32000u);
12252                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12253 378B           B8                   7D00  mov	ax,#$7D00
12254 378E           50                         push	ax
12255                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12256 378F           FF76         FC            push	-4[bp]
12257                                           ! Debug: list int = const 3 (used reg = )
12258 3792           B8                   0003  mov	ax,*3
12259 3795           50                         push	ax
12260                                           ! Debug: func () int = await_ide+0 (used reg = )
12261 3796           E8         E48B            call	_await_ide
12262 3799           83C4                   06  add	sp,*6
12263                                           !BCC_EOS
12264                                           ! 2029   status = inb(iobase1 + 7);
12265                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12266 379C           8B46         FC            mov	ax,-4[bp]
12267                                           ! Debug: list unsigned int = ax+7 (used reg = )
12268 379F           05                   0007  add	ax,*7
12269 37A2           50                         push	ax
12270                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12271 37A3           E8         CD9C            call	_inb
12272 37A6           44                         inc	sp
12273 37A7           44                         inc	sp
12274                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12275 37A8           8846         EF            mov	-$11[bp],al
12276                                           !BCC_EOS
12277                                           ! 2030   if (status & 0x01) {
12278                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12279 37AB           8A46         EF            mov	al,-$11[bp]
12280 37AE           24                     01  and	al,*1
12281 37B0           84C0                       test	al,al
12282 37B2           74           09            je  	.2AF
12283                       000037B4            .2B0:
12284                                           ! 2031     ;
12285                                           !BCC_EOS
12286                                           ! 2032     return 3;
12287 37B4           B8                   0003  mov	ax,*3
12288 37B7           89EC                       mov	sp,bp
12289 37B9           5D                         pop	bp
12290 37BA           C3                         ret
12291                                           !BCC_EOS
12292                                           ! 2033   } else if ( !(status & 0x08) ) {
12293 37BB           EB           10            jmp .2B1
12294                       000037BD            .2AF:
12295                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12296 37BD           8A46         EF            mov	al,-$11[bp]
12297 37C0           24                     08  and	al,*8
12298 37C2           84C0                       test	al,al
12299 37C4           75           07            jne 	.2B2
12300                       000037C6            .2B3:
12301                                           ! 2034     ;
12302                                           !BCC_EOS
12303                                           ! 2035     return 4;
12304 37C6           B8                   0004  mov	ax,*4
12305 37C9           89EC                       mov	sp,bp
12306 37CB           5D                         pop	bp
12307 37CC           C3                         ret
12308                                           !BCC_EOS
12309                                           ! 2036   }
12310                                           ! 2037   cmdseg += (cmdoff / 16);
12311                       000037CD            .2B2:
12312                       000037CD            .2B1:
12313                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12314 37CD           8B46         0A            mov	ax,$A[bp]
12315 37D0           B1                     04  mov	cl,*4
12316 37D2           D3E8                       shr	ax,cl
12317                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12318 37D4           0346         08            add	ax,8[bp]
12319 37D7           8946         08            mov	8[bp],ax
12320                                           !BCC_EOS
12321                                           ! 2038   cmdoff %= 16;
12322                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12323 37DA           8B46         0A            mov	ax,$A[bp]
12324 37DD           24                     0F  and	al,*$F
12325 37DF           30E4                       xor	ah,ah
12326 37E1           8946         0A            mov	$A[bp],ax
12327                                           !BCC_EOS
12328                                           ! 2039 #asm
12329                                           !BCC_EOS
12330                                           !BCC_ASM
12331                       00000026            _ata_cmd_packet.cmdoff	set	$26
12332                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12333                       00000028            _ata_cmd_packet.header	set	$28
12334                       0000000C            .ata_cmd_packet.header	set	$C
12335                       0000000E            _ata_cmd_packet.count	set	$E
12336                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12337                       00000010            _ata_cmd_packet.lafter	set	$10
12338                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12339                       00000018            _ata_cmd_packet.iobase1	set	$18
12340                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12341                       0000000D            _ata_cmd_packet.channel	set	$D
12342                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12343                       00000024            _ata_cmd_packet.cmdseg	set	$24
12344                       00000008            .ata_cmd_packet.cmdseg	set	8
12345                       00000022            _ata_cmd_packet.cmdlen	set	$22
12346                       00000006            .ata_cmd_packet.cmdlen	set	6
12347                       00000009            _ata_cmd_packet.lmode	set	9
12348                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12349                       00000020            _ata_cmd_packet.device	set	$20
12350                       00000004            .ata_cmd_packet.device	set	4
12351                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12352                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12353                       00000014            _ata_cmd_packet.lcount	set	$14
12354                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12355                       00000004            _ata_cmd_packet.total	set	4
12356                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12357                       0000000B            _ata_cmd_packet.status	set	$B
12358                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12359                       0000000A            _ata_cmd_packet.mode	set	$A
12360                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12361                       00000032            _ata_cmd_packet.bufoff	set	$32
12362                       00000016            .ata_cmd_packet.bufoff	set	$16
12363                       00000000            _ata_cmd_packet.transfer	set	0
12364                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12365                       00000016            _ata_cmd_packet.iobase2	set	$16
12366                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12367                       00000012            _ata_cmd_packet.lbefore	set	$12
12368                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12369                       00000030            _ata_cmd_packet.bufseg	set	$30
12370                       00000014            .ata_cmd_packet.bufseg	set	$14
12371                       0000000C            _ata_cmd_packet.slave	set	$C
12372                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12373                       0000002E            _ata_cmd_packet.inout	set	$2E
12374                       00000012            .ata_cmd_packet.inout	set	$12
12375                       0000002A            _ata_cmd_packet.length	set	$2A
12376                       0000000E            .ata_cmd_packet.length	set	$E
12377 37E4           FB                               sti ;; enable higher priority interrupts
12378 37E5           55                               push bp
12379 37E6           89E5                             mov bp, sp
12380 37E8           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12381 37EB           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12382 37EE           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12383 37F1           8EC0                             mov es, ax ;; segment in es
12384 37F3           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12385 37F6           26                               seg ES
12386 37F7           F3                               rep
12387 37F8           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12388 37F9           5D                               pop bp
12389                                           ! 2052 endasm
12390                                           !BCC_ENDASM
12391                                           !BCC_EOS
12392                                           ! 2053   if (inout == 0x00) {
12393                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12394 37FA           8A46         12            mov	al,$12[bp]
12395 37FD           84C0                       test	al,al
12396 37FF           75           23            jne 	.2B4
12397                       00003801            .2B5:
12398                                           ! 2054     await_ide(2, iobase1, 32000u);
12399                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12400 3801           B8                   7D00  mov	ax,#$7D00
12401 3804           50                         push	ax
12402                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12403 3805           FF76         FC            push	-4[bp]
12404                                           ! Debug: list int = const 2 (used reg = )
12405 3808           B8                   0002  mov	ax,*2
12406 380B           50                         push	ax
12407                                           ! Debug: func () int = await_ide+0 (used reg = )
12408 380C           E8         E415            call	_await_ide
12409 380F           83C4                   06  add	sp,*6
12410                                           !BCC_EOS
12411                                           ! 2055     status = inb(iobase1 + 7);
12412                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12413 3812           8B46         FC            mov	ax,-4[bp]
12414                                           ! Debug: list unsigned int = ax+7 (used reg = )
12415 3815           05                   0007  add	ax,*7
12416 3818           50                         push	ax
12417                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12418 3819           E8         CD26            call	_inb
12419 381C           44                         inc	sp
12420 381D           44                         inc	sp
12421                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12422 381E           8846         EF            mov	-$11[bp],al
12423                                           !BCC_EOS
12424                                           ! 2056   }
12425                                           ! 2057   else {
12426 3821           E9         027B            br 	.2B6
12427                       00003824            .2B4:
12428                                           ! 2058     Bit16u loops = 0;
12429 3824           4C                         dec	sp
12430 3825           4C                         dec	sp
12431                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12432 3826           31C0                       xor	ax,ax
12433 3828           8946         E2            mov	-$1E[bp],ax
12434                                           !BCC_EOS
12435                                           ! 2059     Bit8u sc;
12436                                           !BCC_EOS
12437                                           ! 2060     while (1) {
12438 382B           4C                         dec	sp
12439 382C           4C                         dec	sp
12440                       0000382D            .2B9:
12441                                           ! 2061       if (loops == 0) {
12442                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12443 382D           8B46         E2            mov	ax,-$1E[bp]
12444 3830           85C0                       test	ax,ax
12445 3832           75           22            jne 	.2BA
12446                       00003834            .2BB:
12447                                           ! 2062         status = inb(iobase2 + 6);
12448                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12449 3834           8B46         FA            mov	ax,-6[bp]
12450                                           ! Debug: list unsigned int = ax+6 (used reg = )
12451 3837           05                   0006  add	ax,*6
12452 383A           50                         push	ax
12453                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12454 383B           E8         CD04            call	_inb
12455 383E           44                         inc	sp
12456 383F           44                         inc	sp
12457                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12458 3840           8846         EF            mov	-$11[bp],al
12459                                           !BCC_EOS
12460                                           ! 2063         await_ide(3, iobase1, 32000u);
12461                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12462 3843           B8                   7D00  mov	ax,#$7D00
12463 3846           50                         push	ax
12464                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12465 3847           FF76         FC            push	-4[bp]
12466                                           ! Debug: list int = const 3 (used reg = )
12467 384A           B8                   0003  mov	ax,*3
12468 384D           50                         push	ax
12469                                           ! Debug: func () int = await_ide+0 (used reg = )
12470 384E           E8         E3D3            call	_await_ide
12471 3851           83C4                   06  add	sp,*6
12472                                           !BCC_EOS
12473                                           ! 2064       }
12474                                           ! 2065       else
12475                                           ! 2066         await_ide(2, iobase1, 32000u);
12476 3854           EB           11            jmp .2BC
12477                       00003856            .2BA:
12478                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12479 3856           B8                   7D00  mov	ax,#$7D00
12480 3859           50                         push	ax
12481                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12482 385A           FF76         FC            push	-4[bp]
12483                                           ! Debug: list int = const 2 (used reg = )
12484 385D           B8                   0002  mov	ax,*2
12485 3860           50                         push	ax
12486                                           ! Debug: func () int = await_ide+0 (used reg = )
12487 3861           E8         E3C0            call	_await_ide
12488 3864           83C4                   06  add	sp,*6
12489                                           !BCC_EOS
12490                                           ! 2067       loops++;
12491                       00003867            .2BC:
12492                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12493 3867           8B46         E2            mov	ax,-$1E[bp]
12494 386A           40                         inc	ax
12495 386B           8946         E2            mov	-$1E[bp],ax
12496                                           !BCC_EOS
12497                                           ! 2068       status = inb(iobase1 + 7);
12498                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-6] (used reg = )
12499 386E           8B46         FC            mov	ax,-4[bp]
12500                                           ! Debug: list unsigned int = ax+7 (used reg = )
12501 3871           05                   0007  add	ax,*7
12502 3874           50                         push	ax
12503                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12504 3875           E8         CCCA            call	_inb
12505 3878           44                         inc	sp
12506 3879           44                         inc	sp
12507                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12508 387A           8846         EF            mov	-$11[bp],al
12509                                           !BCC_EOS
12510                                           ! 2069       sc = inb(iobase1 + 2);
12511                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12512 387D           8B46         FC            mov	ax,-4[bp]
12513                                           ! Debug: list unsigned int = ax+2 (used reg = )
12514 3880           40                         inc	ax
12515 3881           40                         inc	ax
12516 3882           50                         push	ax
12517                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12518 3883           E8         CCBC            call	_inb
12519 3886           44                         inc	sp
12520 3887           44                         inc	sp
12521                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12522 3888           8846         E1            mov	-$1F[bp],al
12523                                           !BCC_EOS
12524                                           ! 2070       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12525                                           ! 2071          ((status & (0x40 | 0x01)) == 0x40)) break;
12526                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12527 388B           8B46         FC            mov	ax,-4[bp]
12528                                           ! Debug: list unsigned int = ax+2 (used reg = )
12529 388E           40                         inc	ax
12530 388F           40                         inc	ax
12531 3890           50                         push	ax
12532                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12533 3891           E8         CCAE            call	_inb
12534 3894           44                         inc	sp
12535 3895           44                         inc	sp
12536                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12537 3896           24                     07  and	al,*7
12538                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12539 3898           3C                     03  cmp	al,*3
12540 389A           75           0C            jne 	.2BD
12541                       0000389C            .2BF:
12542                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12543 389C           8A46         EF            mov	al,-$11[bp]
12544 389F           24                     41  and	al,*$41
12545                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12546 38A1           3C                     40  cmp	al,*$40
12547 38A3           75           03            jne 	.2BD
12548                       000038A5            .2BE:
12549 38A5           E9         01F4            br 	.2B7
12550                                           !BCC_EOS
12551                                           ! 2072       if (status & 0x01) {
12552                       000038A8            .2BD:
12553                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12554 38A8           8A46         EF            mov	al,-$11[bp]
12555 38AB           24                     01  and	al,*1
12556 38AD           84C0                       test	al,al
12557 38AF           74           07            je  	.2C0
12558                       000038B1            .2C1:
12559                                           ! 2073         ;
12560                                           !BCC_EOS
12561                                           ! 2074         return 3;
12562 38B1           B8                   0003  mov	ax,*3
12563 38B4           89EC                       mov	sp,bp
12564 38B6           5D                         pop	bp
12565 38B7           C3                         ret
12566                                           !BCC_EOS
12567                                           ! 2075       }
12568                                           ! 2076       bufseg += (bufoff / 16);
12569                       000038B8            .2C0:
12570                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12571 38B8           8B46         16            mov	ax,$16[bp]
12572 38BB           B1                     04  mov	cl,*4
12573 38BD           D3E8                       shr	ax,cl
12574                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12575 38BF           0346         14            add	ax,$14[bp]
12576 38C2           8946         14            mov	$14[bp],ax
12577                                           !BCC_EOS
12578                                           ! 2077       bufoff %= 16;
12579                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12580 38C5           8B46         16            mov	ax,$16[bp]
12581 38C8           24                     0F  and	al,*$F
12582 38CA           30E4                       xor	ah,ah
12583 38CC           8946         16            mov	$16[bp],ax
12584                                           !BCC_EOS
12585                                           ! 2078       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12586                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12587 38CF           8B46         FC            mov	ax,-4[bp]
12588                                           ! Debug: list unsigned int = ax+4 (used reg = )
12589 38D2           05                   0004  add	ax,*4
12590 38D5           50                         push	ax
12591                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12592 38D6           E8         CC69            call	_inb
12593 38D9           44                         inc	sp
12594 38DA           44                         inc	sp
12595 38DB           50                         push	ax
12596                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12597 38DC           8B46         FC            mov	ax,-4[bp]
12598                                           ! Debug: list unsigned int = ax+5 (used reg = )
12599 38DF           05                   0005  add	ax,*5
12600 38E2           50                         push	ax
12601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12602 38E3           E8         CC5C            call	_inb
12603 38E6           44                         inc	sp
12604 38E7           44                         inc	sp
12605                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12606 38E8           30E4                       xor	ah,ah
12607                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12608 38EA           88C4                       mov	ah,al
12609 38EC           30C0                       xor	al,al
12610                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12611 38EE           0246         DE            add	al,-$22[bp]
12612 38F1           80D4                   00  adc	ah,*0
12613 38F4           44                         inc	sp
12614 38F5           44                         inc	sp
12615                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12616 38F6           8946         F8            mov	-8[bp],ax
12617                                           !BCC_EOS
12618                                           ! 2079       if(header>lcount) {
12619                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12620 38F9           8B46         0C            mov	ax,$C[bp]
12621 38FC           3B46         F8            cmp	ax,-8[bp]
12622 38FF           76           16            jbe 	.2C2
12623                       00003901            .2C3:
12624                                           ! 2080          lbefore=lcount;
12625                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12626 3901           8B46         F8            mov	ax,-8[bp]
12627 3904           8946         F6            mov	-$A[bp],ax
12628                                           !BCC_EOS
12629                                           ! 2081          header-=lcount;
12630                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12631 3907           8B46         0C            mov	ax,$C[bp]
12632 390A           2B46         F8            sub	ax,-8[bp]
12633 390D           8946         0C            mov	$C[bp],ax
12634                                           !BCC_EOS
12635                                           ! 2082          lcount=0;
12636                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12637 3910           31C0                       xor	ax,ax
12638 3912           8946         F8            mov	-8[bp],ax
12639                                           !BCC_EOS
12640                                           ! 2083       }
12641                                           ! 2084       else {
12642 3915           EB           14            jmp .2C4
12643                       00003917            .2C2:
12644                                           ! 2085         lbefore=header;
12645                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12646 3917           8B46         0C            mov	ax,$C[bp]
12647 391A           8946         F6            mov	-$A[bp],ax
12648                                           !BCC_EOS
12649                                           ! 2086         header=0;
12650                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12651 391D           31C0                       xor	ax,ax
12652 391F           8946         0C            mov	$C[bp],ax
12653                                           !BCC_EOS
12654                                           ! 2087         lcount-=lbefore;
12655                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12656 3922           8B46         F8            mov	ax,-8[bp]
12657 3925           2B46         F6            sub	ax,-$A[bp]
12658 3928           8946         F8            mov	-8[bp],ax
12659                                           !BCC_EOS
12660                                           ! 2088       }
12661                                           ! 2089       if(lcount>length) {
12662                       0000392B            .2C4:
12663                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12664 392B           8B46         F8            mov	ax,-8[bp]
12665 392E           31DB                       xor	bx,bx
12666                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12667 3930           8D7E         0E            lea	di,$E[bp]
12668 3933           E8         C795            call	lcmpul
12669 3936           76           20            jbe 	.2C5
12670                       00003938            .2C6:
12671                                           ! 2090         lafter=lcount-length;
12672                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12673 3938           8B46         F8            mov	ax,-8[bp]
12674 393B           31DB                       xor	bx,bx
12675                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12676 393D           8D7E         0E            lea	di,$E[bp]
12677 3940           E8         C79E            call	lsubul
12678                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12679 3943           8946         F4            mov	-$C[bp],ax
12680                                           !BCC_EOS
12681                                           ! 2091         lcount=length;
12682                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12683 3946           8B46         0E            mov	ax,$E[bp]
12684 3949           8946         F8            mov	-8[bp],ax
12685                                           !BCC_EOS
12686                                           ! 2092         length=0;
12687                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12688 394C           31C0                       xor	ax,ax
12689 394E           31DB                       xor	bx,bx
12690 3950           8946         0E            mov	$E[bp],ax
12691 3953           895E         10            mov	$10[bp],bx
12692                                           !BCC_EOS
12693                                           ! 2093       }
12694                                           ! 2094       else {
12695 3956           EB           21            jmp .2C7
12696                       00003958            .2C5:
12697                                           ! 2095         lafter=0;
12698                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12699 3958           31C0                       xor	ax,ax
12700 395A           8946         F4            mov	-$C[bp],ax
12701                                           !BCC_EOS
12702                                           ! 2096         length-=lcount;
12703                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12704 395D           8B46         F8            mov	ax,-8[bp]
12705 3960           31DB                       xor	bx,bx
12706                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12707 3962           53                         push	bx
12708 3963           50                         push	ax
12709 3964           8B46         0E            mov	ax,$E[bp]
12710 3967           8B5E         10            mov	bx,$10[bp]
12711 396A           8D7E         DC            lea	di,-$24[bp]
12712 396D           E8         C771            call	lsubul
12713 3970           8946         0E            mov	$E[bp],ax
12714 3973           895E         10            mov	$10[bp],bx
12715 3976           83C4                   04  add	sp,*4
12716                                           !BCC_EOS
12717                                           ! 2097       }
12718                                           ! 2098       count = lcount;
12719                       00003979            .2C7:
12720                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12721 3979           8B46         F8            mov	ax,-8[bp]
12722 397C           8946         F2            mov	-$E[bp],ax
12723                                           !BCC_EOS
12724                                           ! 2099       ;
12725                                           !BCC_EOS
12726                                           ! 2100       ;
12727                                           !BCC_EOS
12728                                           ! 2101       lmode = mode;
12729                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
12730 397F           8A46         EE            mov	al,-$12[bp]
12731 3982           8846         ED            mov	-$13[bp],al
12732                                           !BCC_EOS
12733                                           ! 2102       if (lbefore & 0x03) lmode=0x00;
12734                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
12735 3985           8A46         F6            mov	al,-$A[bp]
12736 3988           24                     03  and	al,*3
12737 398A           84C0                       test	al,al
12738 398C           74           05            je  	.2C8
12739                       0000398E            .2C9:
12740                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12741 398E           30C0                       xor	al,al
12742 3990           8846         ED            mov	-$13[bp],al
12743                                           !BCC_EOS
12744                                           ! 2103       if (lcount & 0x03) lmode=0x00;
12745                       00003993            .2C8:
12746                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
12747 3993           8A46         F8            mov	al,-8[bp]
12748 3996           24                     03  and	al,*3
12749 3998           84C0                       test	al,al
12750 399A           74           05            je  	.2CA
12751                       0000399C            .2CB:
12752                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12753 399C           30C0                       xor	al,al
12754 399E           8846         ED            mov	-$13[bp],al
12755                                           !BCC_EOS
12756                                           ! 2104       if (lafter & 0x03) lmode=0x00;
12757                       000039A1            .2CA:
12758                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
12759 39A1           8A46         F4            mov	al,-$C[bp]
12760 39A4           24                     03  and	al,*3
12761 39A6           84C0                       test	al,al
12762 39A8           74           05            je  	.2CC
12763                       000039AA            .2CD:
12764                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12765 39AA           30C0                       xor	al,al
12766 39AC           8846         ED            mov	-$13[bp],al
12767                                           !BCC_EOS
12768                                           ! 2105       if (lcount & 0x01) {
12769                       000039AF            .2CC:
12770                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12771 39AF           8A46         F8            mov	al,-8[bp]
12772 39B2           24                     01  and	al,*1
12773 39B4           84C0                       test	al,al
12774 39B6           74           1E            je  	.2CE
12775                       000039B8            .2CF:
12776                                           ! 2106         lcount+=1;
12777                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12778 39B8           8B46         F8            mov	ax,-8[bp]
12779 39BB           40                         inc	ax
12780 39BC           8946         F8            mov	-8[bp],ax
12781                                           !BCC_EOS
12782                                           ! 2107         if ((lafter > 0) && (lafter & 0x01)) {
12783                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12784 39BF           8B46         F4            mov	ax,-$C[bp]
12785 39C2           85C0                       test	ax,ax
12786 39C4           74           10            je  	.2D0
12787                       000039C6            .2D2:
12788                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12789 39C6           8A46         F4            mov	al,-$C[bp]
12790 39C9           24                     01  and	al,*1
12791 39CB           84C0                       test	al,al
12792 39CD           74           07            je  	.2D0
12793                       000039CF            .2D1:
12794                                           ! 2108           lafter-=1;
12795                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12796 39CF           8B46         F4            mov	ax,-$C[bp]
12797 39D2           48                         dec	ax
12798 39D3           8946         F4            mov	-$C[bp],ax
12799                                           !BCC_EOS
12800                                           ! 2109         }
12801                                           ! 2110       }
12802                       000039D6            .2D0:
12803                                           ! 2111       if (lmode == 0x01) {
12804                       000039D6            .2CE:
12805                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
12806 39D6           8A46         ED            mov	al,-$13[bp]
12807 39D9           3C                     01  cmp	al,*1
12808 39DB           75           20            jne 	.2D3
12809                       000039DD            .2D4:
12810                                           ! 2112         lcount>>=2; lbefore>>=2; lafter>>=2;
12811                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
12812 39DD           8B46         F8            mov	ax,-8[bp]
12813 39E0           D1E8                       shr	ax,*1
12814 39E2           D1E8                       shr	ax,*1
12815 39E4           8946         F8            mov	-8[bp],ax
12816                                           !BCC_EOS
12817                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
12818 39E7           8B46         F6            mov	ax,-$A[bp]
12819 39EA           D1E8                       shr	ax,*1
12820 39EC           D1E8                       shr	ax,*1
12821 39EE           8946         F6            mov	-$A[bp],ax
12822                                           !BCC_EOS
12823                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
12824 39F1           8B46         F4            mov	ax,-$C[bp]
12825 39F4           D1E8                       shr	ax,*1
12826 39F6           D1E8                       shr	ax,*1
12827 39F8           8946         F4            mov	-$C[bp],ax
12828                                           !BCC_EOS
12829                                           ! 2113       }
12830                                           ! 2114       else {
12831 39FB           EB           18            jmp .2D5
12832                       000039FD            .2D3:
12833                                           ! 2115         lcount>>=1; lbefore>>=1; lafter>>=1;
12834                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12835 39FD           8B46         F8            mov	ax,-8[bp]
12836 3A00           D1E8                       shr	ax,*1
12837 3A02           8946         F8            mov	-8[bp],ax
12838                                           !BCC_EOS
12839                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
12840 3A05           8B46         F6            mov	ax,-$A[bp]
12841 3A08           D1E8                       shr	ax,*1
12842 3A0A           8946         F6            mov	-$A[bp],ax
12843                                           !BCC_EOS
12844                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12845 3A0D           8B46         F4            mov	ax,-$C[bp]
12846 3A10           D1E8                       shr	ax,*1
12847 3A12           8946         F4            mov	-$C[bp],ax
12848                                           !BCC_EOS
12849                                           ! 2116       }
12850                                           ! 2117        ;
12851                       00003A15            .2D5:
12852                                           !BCC_EOS
12853                                           ! 2118 #asm
12854                                           !BCC_EOS
12855                                           !BCC_ASM
12856                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
12857                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12858                       0000002C            _ata_cmd_packet.header	set	$2C
12859                       0000000C            .ata_cmd_packet.header	set	$C
12860                       00000012            _ata_cmd_packet.count	set	$12
12861                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12862                       00000014            _ata_cmd_packet.lafter	set	$14
12863                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12864                       0000001C            _ata_cmd_packet.iobase1	set	$1C
12865                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12866                       00000011            _ata_cmd_packet.channel	set	$11
12867                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12868                       00000028            _ata_cmd_packet.cmdseg	set	$28
12869                       00000008            .ata_cmd_packet.cmdseg	set	8
12870                       00000026            _ata_cmd_packet.cmdlen	set	$26
12871                       00000006            .ata_cmd_packet.cmdlen	set	6
12872                       0000000D            _ata_cmd_packet.lmode	set	$D
12873                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12874                       00000024            _ata_cmd_packet.device	set	$24
12875                       00000004            .ata_cmd_packet.device	set	4
12876                       00000002            _ata_cmd_packet.loops	set	2
12877                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
12878                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
12879                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12880                       00000018            _ata_cmd_packet.lcount	set	$18
12881                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12882                       00000008            _ata_cmd_packet.total	set	8
12883                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12884                       0000000F            _ata_cmd_packet.status	set	$F
12885                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12886                       0000000E            _ata_cmd_packet.mode	set	$E
12887                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12888                       00000036            _ata_cmd_packet.bufoff	set	$36
12889                       00000016            .ata_cmd_packet.bufoff	set	$16
12890                       00000004            _ata_cmd_packet.transfer	set	4
12891                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12892                       00000001            _ata_cmd_packet.sc	set	1
12893                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
12894                       0000001A            _ata_cmd_packet.iobase2	set	$1A
12895                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12896                       00000016            _ata_cmd_packet.lbefore	set	$16
12897                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12898                       00000034            _ata_cmd_packet.bufseg	set	$34
12899                       00000014            .ata_cmd_packet.bufseg	set	$14
12900                       00000010            _ata_cmd_packet.slave	set	$10
12901                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12902                       00000032            _ata_cmd_packet.inout	set	$32
12903                       00000012            .ata_cmd_packet.inout	set	$12
12904                       0000002E            _ata_cmd_packet.length	set	$2E
12905                       0000000E            .ata_cmd_packet.length	set	$E
12906 3A15           55                                 push bp
12907 3A16           89E5                               mov bp, sp
12908 3A18           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
12909 3A1B           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
12910 3A1E           E3           15                    jcxz ata_packet_no_before
12911 3A20           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12912 3A23           80FC                   01          cmp ah, #0x01
12913 3A26           74           05                    je ata_packet_in_before_32
12914                       00003A28            ata_packet_in_before_16:
12915 3A28           ED                                 in ax, dx
12916 3A29           E2           FD                    loop ata_packet_in_before_16
12917 3A2B           EB           08                    jmp ata_packet_no_before
12918                       00003A2D            ata_packet_in_before_32:
12919 3A2D     66    50                                 push eax
12920                       00003A2F            ata_packet_in_before_32_loop:
12921 3A2F     66    ED                                 in eax, dx
12922 3A31           E2           FC                    loop ata_packet_in_before_32_loop
12923 3A33     66    58                                 pop eax
12924                       00003A35            ata_packet_no_before:
12925 3A35           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
12926 3A38           E3           17                    jcxz ata_packet_after
12927 3A3A           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
12928 3A3D           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
12929 3A40           8EC0                               mov es, ax
12930 3A42           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12931 3A45           80FC                   01          cmp ah, #0x01
12932 3A48           74           04                    je ata_packet_in_32
12933                       00003A4A            ata_packet_in_16:
12934 3A4A           F3                                 rep
12935 3A4B           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
12936 3A4C           EB           03                    jmp ata_packet_after
12937                       00003A4E            ata_packet_in_32:
12938 3A4E           F3                                 rep
12939 3A4F     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
12940                       00003A51            ata_packet_after:
12941 3A51           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
12942 3A54           E3           15                    jcxz ata_packet_done
12943 3A56           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12944 3A59           80FC                   01          cmp ah, #0x01
12945 3A5C           74           05                    je ata_packet_in_after_32
12946                       00003A5E            ata_packet_in_after_16:
12947 3A5E           ED                                 in ax, dx
12948 3A5F           E2           FD                    loop ata_packet_in_after_16
12949 3A61           EB           08                    jmp ata_packet_done
12950                       00003A63            ata_packet_in_after_32:
12951 3A63     66    50                                 push eax
12952                       00003A65            ata_packet_in_after_32_loop:
12953 3A65     66    ED                                 in eax, dx
12954 3A67           E2           FC                    loop ata_packet_in_after_32_loop
12955 3A69     66    58                                 pop eax
12956                       00003A6B            ata_packet_done:
12957 3A6B           5D                                 pop bp
12958                                           ! 2171 endasm
12959                                           !BCC_ENDASM
12960                                           !BCC_EOS
12961                                           ! 2172       bufoff += count;
12962                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
12963 3A6C           8B46         16            mov	ax,$16[bp]
12964 3A6F           0346         F2            add	ax,-$E[bp]
12965 3A72           8946         16            mov	$16[bp],ax
12966                                           !BCC_EOS
12967                                           ! 2173       transfer += count;
12968                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
12969 3A75           8B46         F2            mov	ax,-$E[bp]
12970 3A78           31DB                       xor	bx,bx
12971                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
12972 3A7A           8D7E         E4            lea	di,-$1C[bp]
12973 3A7D           E8         C643            call	laddul
12974 3A80           8946         E4            mov	-$1C[bp],ax
12975 3A83           895E         E6            mov	-$1A[bp],bx
12976                                           !BCC_EOS
12977                                           ! 2174       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
12978                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
12979 3A86           FF76         E6            push	-$1A[bp]
12980 3A89           FF76         E4            push	-$1C[bp]
12981                                           ! Debug: list * unsigned long = const $256 (used reg = )
12982 3A8C           B8                   0256  mov	ax,#$256
12983 3A8F           50                         push	ax
12984                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
12985 3A90           FF76         FE            push	-2[bp]
12986                                           ! Debug: func () void = write_dword+0 (used reg = )
12987 3A93           E8         C605            call	_write_dword
12988 3A96           83C4                   08  add	sp,*8
12989                                           !BCC_EOS
12990                                           ! 2175     }
12991                                           ! 2176   }
12992                       00003A99            .2B8:
12993 3A99           E9         FD91            br 	.2B9
12994                       00003A9C            .2D6:
12995                       00003A9C            .2B7:
12996 3A9C           83C4                   04  add	sp,*4
12997                                           ! 2177   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
12998                       00003A9F            .2B6:
12999                                           ! 2178          != 0x40 ) {
13000                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
13001 3A9F           8A46         EF            mov	al,-$11[bp]
13002 3AA2           24                     E9  and	al,#$E9
13003                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
13004 3AA4           3C                     40  cmp	al,*$40
13005 3AA6           74           07            je  	.2D7
13006                       00003AA8            .2D8:
13007                                           ! 2179     ;
13008                                           !BCC_EOS
13009                                           ! 2180     return 4;
13010 3AA8           B8                   0004  mov	ax,*4
13011 3AAB           89EC                       mov	sp,bp
13012 3AAD           5D                         pop	bp
13013 3AAE           C3                         ret
13014                                           !BCC_EOS
13015                                           ! 2181   }
13016                                           ! 2182   outb(iobase2+6, 0x08);
13017                       00003AAF            .2D7:
13018                                           ! Debug: list int = const 8 (used reg = )
13019 3AAF           B8                   0008  mov	ax,*8
13020 3AB2           50                         push	ax
13021                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
13022 3AB3           8B46         FA            mov	ax,-6[bp]
13023                                           ! Debug: list unsigned int = ax+6 (used reg = )
13024 3AB6           05                   0006  add	ax,*6
13025 3AB9           50                         push	ax
13026                                           ! Debug: func () void = outb+0 (used reg = )
13027 3ABA           E8         CA9B            call	_outb
13028 3ABD           83C4                   04  add	sp,*4
13029                                           !BCC_EOS
13030                                           ! 2183   return 0;
13031 3AC0           31C0                       xor	ax,ax
13032 3AC2           89EC                       mov	sp,bp
13033 3AC4           5D                         pop	bp
13034 3AC5           C3                         ret
13035                                           !BCC_EOS
13036                                           ! 2184 }
13037                                           ! 2185   Bit16u
13038                                           ! Register BX used in function ata_cmd_packet
13039                                           ! 2186 atapi_get_sense(device, seg, asc, ascq)
13040                                           ! 2187   Bit16u device;
13041                                           export	_atapi_get_sense
13042                       00003AC6            _atapi_get_sense:
13043                                           !BCC_EOS
13044                                           ! 2188 {
13045                                           ! 2189   Bit8u atacmd[12];
13046                                           !BCC_EOS
13047                                           ! 2190   Bit8u buffer[18];
13048                                           !BCC_EOS
13049                                           ! 2191   Bit8u i;
13050                                           !BCC_EOS
13051                                           ! 2192   memsetb(get_SS(),atacmd,0,12);
13052 3AC6           55                         push	bp
13053 3AC7           89E5                       mov	bp,sp
13054 3AC9           83C4                   E0  add	sp,*-$20
13055                                           ! Debug: list int = const $C (used reg = )
13056 3ACC           B8                   000C  mov	ax,*$C
13057 3ACF           50                         push	ax
13058                                           ! Debug: list int = const 0 (used reg = )
13059 3AD0           31C0                       xor	ax,ax
13060 3AD2           50                         push	ax
13061                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
13062 3AD3           8D5E         F4            lea	bx,-$C[bp]
13063 3AD6           53                         push	bx
13064                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13065 3AD7           E8         CB77            call	_get_SS
13066                                           ! Debug: list unsigned short = ax+0 (used reg = )
13067 3ADA           50                         push	ax
13068                                           ! Debug: func () void = memsetb+0 (used reg = )
13069 3ADB           E8         C522            call	_memsetb
13070 3ADE           83C4                   08  add	sp,*8
13071                                           !BCC_EOS
13072                                           ! 2193   atacmd[0]=0x03;
13073                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
13074 3AE1           B0                     03  mov	al,*3
13075 3AE3           8846         F4            mov	-$C[bp],al
13076                                           !BCC_EOS
13077                                           ! 2194   atacmd[4]=sizeof(buffer);
13078                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
13079 3AE6           B0                     12  mov	al,*$12
13080 3AE8           8846         F8            mov	-8[bp],al
13081                                           !BCC_EOS
13082                                           ! 2195   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
13083                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
13084 3AEB           8D5E         E2            lea	bx,-$1E[bp]
13085 3AEE           53                         push	bx
13086                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13087 3AEF           E8         CB5F            call	_get_SS
13088                                           ! Debug: list unsigned short = ax+0 (used reg = )
13089 3AF2           50                         push	ax
13090                                           ! Debug: list int = const 1 (used reg = )
13091 3AF3           B8                   0001  mov	ax,*1
13092 3AF6           50                         push	ax
13093                                           ! Debug: list long = const $12 (used reg = )
13094 3AF7           B8                   0012  mov	ax,*$12
13095 3AFA           31DB                       xor	bx,bx
13096 3AFC           53                         push	bx
13097 3AFD           50                         push	ax
13098                                           ! Debug: list int = const 0 (used reg = )
13099 3AFE           31C0                       xor	ax,ax
13100 3B00           50                         push	ax
13101                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
13102 3B01           8D5E         F4            lea	bx,-$C[bp]
13103 3B04           53                         push	bx
13104                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13105 3B05           E8         CB49            call	_get_SS
13106                                           ! Debug: list unsigned short = ax+0 (used reg = )
13107 3B08           50                         push	ax
13108                                           ! Debug: list int = const $C (used reg = )
13109 3B09           B8                   000C  mov	ax,*$C
13110 3B0C           50                         push	ax
13111                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
13112 3B0D           FF76         04            push	4[bp]
13113                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13114 3B10           E8         FAD4            call	_ata_cmd_packet
13115 3B13           83C4                   14  add	sp,*$14
13116                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13117 3B16           85C0                       test	ax,ax
13118 3B18           74           07            je  	.2D9
13119                       00003B1A            .2DA:
13120                                           ! 2196     return 0x0002;
13121 3B1A           B8                   0002  mov	ax,*2
13122 3B1D           89EC                       mov	sp,bp
13123 3B1F           5D                         pop	bp
13124 3B20           C3                         ret
13125                                           !BCC_EOS
13126                                           ! 2197   write_byte(seg,asc,buffer[12]);
13127                       00003B21            .2D9:
13128                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
13129 3B21           8A46         EE            mov	al,-$12[bp]
13130 3B24           30E4                       xor	ah,ah
13131 3B26           50                         push	ax
13132                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13133 3B27           FF76         08            push	8[bp]
13134                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13135 3B2A           FF76         06            push	6[bp]
13136                                           ! Debug: func () void = write_byte+0 (used reg = )
13137 3B2D           E8         CAEE            call	_write_byte
13138 3B30           83C4                   06  add	sp,*6
13139                                           !BCC_EOS
13140                                           ! 2198   write_byte(seg,ascq,buffer[13]);
13141                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13142 3B33           8A46         EF            mov	al,-$11[bp]
13143 3B36           30E4                       xor	ah,ah
13144 3B38           50                         push	ax
13145                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13146 3B39           FF76         0A            push	$A[bp]
13147                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13148 3B3C           FF76         06            push	6[bp]
13149                                           ! Debug: func () void = write_byte+0 (used reg = )
13150 3B3F           E8         CADC            call	_write_byte
13151 3B42           83C4                   06  add	sp,*6
13152                                           !BCC_EOS
13153                                           ! 2199   return 0;
13154 3B45           31C0                       xor	ax,ax
13155 3B47           89EC                       mov	sp,bp
13156 3B49           5D                         pop	bp
13157 3B4A           C3                         ret
13158                                           !BCC_EOS
13159                                           ! 2200 }
13160                                           ! 2201   Bit16u
13161                                           ! Register BX used in function atapi_get_sense
13162                                           ! 2202 atapi_is_ready(device)
13163                                           ! 2203   Bit16u device;
13164                                           export	_atapi_is_ready
13165                       00003B4B            _atapi_is_ready:
13166                                           !BCC_EOS
13167                                           ! 2204 {
13168                                           ! 2205   Bit8u packet[12];
13169                                           !BCC_EOS
13170                                           ! 2206   Bit8u buf[8];
13171                                           !BCC_EOS
13172                                           ! 2207   Bit32u block_len;
13173                                           !BCC_EOS
13174                                           ! 2208   Bit32u sectors;
13175                                           !BCC_EOS
13176                                           ! 2209   Bit32u timeout;
13177                                           !BCC_EOS
13178                                           ! 2210   Bit32u time;
13179                                           !BCC_EOS
13180                                           ! 2211   Bit8u asc, ascq;
13181                                           !BCC_EOS
13182                                           ! 2212   Bit8u in_progress;
13183                                           !BCC_EOS
13184                                           ! 2213   Bit16u ebda_s
13185                                           ! 2213 eg = read_word(0x0040,0x000E);
13186 3B4B           55                         push	bp
13187 3B4C           89E5                       mov	bp,sp
13188 3B4E           83C4                   D6  add	sp,*-$2A
13189                                           ! Debug: list int = const $E (used reg = )
13190 3B51           B8                   000E  mov	ax,*$E
13191 3B54           50                         push	ax
13192                                           ! Debug: list int = const $40 (used reg = )
13193 3B55           B8                   0040  mov	ax,*$40
13194 3B58           50                         push	ax
13195                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13196 3B59           E8         CAAF            call	_read_word
13197 3B5C           83C4                   04  add	sp,*4
13198                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13199 3B5F           8946         D6            mov	-$2A[bp],ax
13200                                           !BCC_EOS
13201                                           ! 2214   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13202                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13203 3B62           8B46         04            mov	ax,4[bp]
13204 3B65           B9                   001E  mov	cx,*$1E
13205 3B68           F7E9                       imul	cx
13206 3B6A           89C3                       mov	bx,ax
13207                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13208                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13209 3B6C           81C3                 0142  add	bx,#$142
13210 3B70           53                         push	bx
13211                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13212 3B71           FF76         D6            push	-$2A[bp]
13213                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13214 3B74           E8         CA81            call	_read_byte
13215 3B77           83C4                   04  add	sp,*4
13216                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13217 3B7A           3C                     03  cmp	al,*3
13218 3B7C           74           15            je  	.2DB
13219                       00003B7E            .2DC:
13220                                           ! 2215     bios_printf(2, "not implemented for non-ATAPI device\n");
13221                                           ! Debug: list * char = .2DD+0 (used reg = )
13222 3B7E           BB                   D629  mov	bx,#.2DD
13223 3B81           53                         push	bx
13224                                           ! Debug: list int = const 2 (used reg = )
13225 3B82           B8                   0002  mov	ax,*2
13226 3B85           50                         push	ax
13227                                           ! Debug: func () void = bios_printf+0 (used reg = )
13228 3B86           E8         CE1E            call	_bios_printf
13229 3B89           83C4                   04  add	sp,*4
13230                                           !BCC_EOS
13231                                           ! 2216     return -1;
13232 3B8C           B8                   FFFF  mov	ax,#$FFFF
13233 3B8F           89EC                       mov	sp,bp
13234 3B91           5D                         pop	bp
13235 3B92           C3                         ret
13236                                           !BCC_EOS
13237                                           ! 2217   }
13238                                           ! 2218   ;
13239                       00003B93            .2DB:
13240                                           !BCC_EOS
13241                                           ! 2219   memsetb(get_SS(),packet, 0, sizeof packet);
13242                                           ! Debug: list int = const $C (used reg = )
13243 3B93           B8                   000C  mov	ax,*$C
13244 3B96           50                         push	ax
13245                                           ! Debug: list int = const 0 (used reg = )
13246 3B97           31C0                       xor	ax,ax
13247 3B99           50                         push	ax
13248                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13249 3B9A           8D5E         F4            lea	bx,-$C[bp]
13250 3B9D           53                         push	bx
13251                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13252 3B9E           E8         CAB0            call	_get_SS
13253                                           ! Debug: list unsigned short = ax+0 (used reg = )
13254 3BA1           50                         push	ax
13255                                           ! Debug: func () void = memsetb+0 (used reg = )
13256 3BA2           E8         C45B            call	_memsetb
13257 3BA5           83C4                   08  add	sp,*8
13258                                           !BCC_EOS
13259                                           ! 2220   packet[0] = 0x25;
13260                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13261 3BA8           B0                     25  mov	al,*$25
13262 3BAA           8846         F4            mov	-$C[bp],al
13263                                           !BCC_EOS
13264                                           ! 2221   timeout = 5000;
13265                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13266 3BAD           B8                   1388  mov	ax,#$1388
13267 3BB0           31DB                       xor	bx,bx
13268 3BB2           8946         E0            mov	-$20[bp],ax
13269 3BB5           895E         E2            mov	-$1E[bp],bx
13270                                           !BCC_EOS
13271                                           ! 2222   time = 0;
13272                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13273 3BB8           31C0                       xor	ax,ax
13274 3BBA           31DB                       xor	bx,bx
13275 3BBC           8946         DC            mov	-$24[bp],ax
13276 3BBF           895E         DE            mov	-$22[bp],bx
13277                                           !BCC_EOS
13278                                           ! 2223   in_progress = 0;
13279                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13280 3BC2           30C0                       xor	al,al
13281 3BC4           8846         D9            mov	-$27[bp],al
13282                                           !BCC_EOS
13283                                           ! 2224   while (time < timeout) {
13284 3BC7           E9         00AB            br 	.2DF
13285                       00003BCA            .2E0:
13286                                           ! 2225     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13287                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13288 3BCA           8D5E         EC            lea	bx,-$14[bp]
13289 3BCD           53                         push	bx
13290                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13291 3BCE           E8         CA80            call	_get_SS
13292                                           ! Debug: list unsigned short = ax+0 (used reg = )
13293 3BD1           50                         push	ax
13294                                           ! Debug: list int = const 1 (used reg = )
13295 3BD2           B8                   0001  mov	ax,*1
13296 3BD5           50                         push	ax
13297                                           ! Debug: list long = const 8 (used reg = )
13298 3BD6           B8                   0008  mov	ax,*8
13299 3BD9           31DB                       xor	bx,bx
13300 3BDB           53                         push	bx
13301 3BDC           50                         push	ax
13302                                           ! Debug: list int = const 0 (used reg = )
13303 3BDD           31C0                       xor	ax,ax
13304 3BDF           50                         push	ax
13305                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13306 3BE0           8D5E         F4            lea	bx,-$C[bp]
13307 3BE3           53                         push	bx
13308                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13309 3BE4           E8         CA6A            call	_get_SS
13310                                           ! Debug: list unsigned short = ax+0 (used reg = )
13311 3BE7           50                         push	ax
13312                                           ! Debug: list int = const $C (used reg = )
13313 3BE8           B8                   000C  mov	ax,*$C
13314 3BEB           50                         push	ax
13315                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13316 3BEC           FF76         04            push	4[bp]
13317                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13318 3BEF           E8         F9F5            call	_ata_cmd_packet
13319 3BF2           83C4                   14  add	sp,*$14
13320                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13321 3BF5           85C0                       test	ax,ax
13322 3BF7           75           06            jne 	.2E1
13323                       00003BF9            .2E2:
13324                                           ! 2226       goto ok;
13325 3BF9           83C4                   00  add	sp,#..FFFA+$2C
13326 3BFC           E9         008D            br 	.FFFA
13327                                           !BCC_EOS
13328                                           ! 2227     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13329                       00003BFF            .2E1:
13330                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13331 3BFF           8D5E         DA            lea	bx,-$26[bp]
13332 3C02           53                         push	bx
13333                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13334 3C03           8D5E         DB            lea	bx,-$25[bp]
13335 3C06           53                         push	bx
13336                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13337 3C07           E8         CA47            call	_get_SS
13338                                           ! Debug: list unsigned short = ax+0 (used reg = )
13339 3C0A           50                         push	ax
13340                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13341 3C0B           FF76         04            push	4[bp]
13342                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13343 3C0E           E8         FEB5            call	_atapi_get_sense
13344 3C11           83C4                   08  add	sp,*8
13345                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13346 3C14           85C0                       test	ax,ax
13347 3C16           75           41            jne 	.2E3
13348                       00003C18            .2E4:
13349                                           ! 2228       if (asc == 0x3a) {
13350                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13351 3C18           8A46         DB            mov	al,-$25[bp]
13352 3C1B           3C                     3A  cmp	al,*$3A
13353 3C1D           75           07            jne 	.2E5
13354                       00003C1F            .2E6:
13355                                           ! 2229         ;
13356                                           !BCC_EOS
13357                                           ! 2230         return -1;
13358 3C1F           B8                   FFFF  mov	ax,#$FFFF
13359 3C22           89EC                       mov	sp,bp
13360 3C24           5D                         pop	bp
13361 3C25           C3                         ret
13362                                           !BCC_EOS
13363                                           ! 2231       }
13364                                           ! 2232       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13365                       00003C26            .2E5:
13366                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13367 3C26           8A46         DB            mov	al,-$25[bp]
13368 3C29           3C                     04  cmp	al,*4
13369 3C2B           75           2C            jne 	.2E7
13370                       00003C2D            .2EA:
13371                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13372 3C2D           8A46         DA            mov	al,-$26[bp]
13373 3C30           3C                     01  cmp	al,*1
13374 3C32           75           25            jne 	.2E7
13375                       00003C34            .2E9:
13376 3C34           8A46         D9            mov	al,-$27[bp]
13377 3C37           84C0                       test	al,al
13378 3C39           75           1E            jne 	.2E7
13379                       00003C3B            .2E8:
13380                                           ! 2233         bios_printf(2, "Waiting for device to detect medium... ");
13381                                           ! Debug: list * char = .2EB+0 (used reg = )
13382 3C3B           BB                   D601  mov	bx,#.2EB
13383 3C3E           53                         push	bx
13384                                           ! Debug: list int = const 2 (used reg = )
13385 3C3F           B8                   0002  mov	ax,*2
13386 3C42           50                         push	ax
13387                                           ! Debug: func () void = bios_printf+0 (used reg = )
13388 3C43           E8         CD61            call	_bios_printf
13389 3C46           83C4                   04  add	sp,*4
13390                                           !BCC_EOS
13391                                           ! 2234         timeout = 30000;
13392                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13393 3C49           B8                   7530  mov	ax,#$7530
13394 3C4C           31DB                       xor	bx,bx
13395 3C4E           8946         E0            mov	-$20[bp],ax
13396 3C51           895E         E2            mov	-$1E[bp],bx
13397                                           !BCC_EOS
13398                                           ! 2235         in_progress = 1;
13399                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13400 3C54           B0                     01  mov	al,*1
13401 3C56           8846         D9            mov	-$27[bp],al
13402                                           !BCC_EOS
13403                                           ! 2236       }
13404                                           ! 2237     }
13405                       00003C59            .2E7:
13406                                           ! 2238     time += 100;
13407                       00003C59            .2E3:
13408                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13409 3C59           B8                   0064  mov	ax,*$64
13410 3C5C           31DB                       xor	bx,bx
13411 3C5E           53                         push	bx
13412 3C5F           50                         push	ax
13413 3C60           8B46         DC            mov	ax,-$24[bp]
13414 3C63           8B5E         DE            mov	bx,-$22[bp]
13415 3C66           8D7E         D2            lea	di,-$2E[bp]
13416 3C69           E8         C457            call	laddul
13417 3C6C           8946         DC            mov	-$24[bp],ax
13418 3C6F           895E         DE            mov	-$22[bp],bx
13419 3C72           83C4                   04  add	sp,*4
13420                                           !BCC_EOS
13421                                           ! 2239   }
13422                                           ! 2240   ;
13423                       00003C75            .2DF:
13424                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13425 3C75           8B46         E0            mov	ax,-$20[bp]
13426 3C78           8B5E         E2            mov	bx,-$1E[bp]
13427 3C7B           8D7E         DC            lea	di,-$24[bp]
13428 3C7E           E8         C44A            call	lcmpul
13429 3C81         0F87         FF45            bhi 	.2E0
13430                       00003C85            .2EC:
13431                       00003C85            .2DE:
13432                                           !BCC_EOS
13433                                           ! 2241   return -1;
13434 3C85           B8                   FFFF  mov	ax,#$FFFF
13435 3C88           89EC                       mov	sp,bp
13436 3C8A           5D                         pop	bp
13437 3C8B           C3                         ret
13438                                           !BCC_EOS
13439                                           ! 2242 ok:
13440                       00003C8C            .FFFA:
13441                       FFFFFFD4            ..FFFA	=	-$2C
13442                                           ! 2243   block_len = (Bit32u) buf[4] << 24
13443                                           ! 2244     | (Bit32u) buf[5] << 16
13444                                           ! 2245     | (Bit32u) buf[6] << 8
13445                                           ! 2246     | (Bit32u) buf[7] << 0;
13446                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13447 3C8C           8A46         F3            mov	al,-$D[bp]
13448 3C8F           30E4                       xor	ah,ah
13449 3C91           31DB                       xor	bx,bx
13450                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13451 3C93           53                         push	bx
13452 3C94           50                         push	ax
13453                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13454 3C95           8A46         F2            mov	al,-$E[bp]
13455 3C98           30E4                       xor	ah,ah
13456 3C9A           31DB                       xor	bx,bx
13457                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13458 3C9C           88DF                       mov	bh,bl
13459 3C9E           88E3                       mov	bl,ah
13460 3CA0           88C4                       mov	ah,al
13461 3CA2           30C0                       xor	al,al
13462 3CA4           53                         push	bx
13463 3CA5           50                         push	ax
13464                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13465 3CA6           8A46         F1            mov	al,-$F[bp]
13466 3CA9           30E4                       xor	ah,ah
13467 3CAB           31DB                       xor	bx,bx
13468                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13469 3CAD           93                         xchg	bx,ax
13470 3CAE           31C0                       xor	ax,ax
13471 3CB0           53                         push	bx
13472 3CB1           50                         push	ax
13473                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13474 3CB2           8A46         F0            mov	al,-$10[bp]
13475 3CB5           30E4                       xor	ah,ah
13476 3CB7           31DB                       xor	bx,bx
13477                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13478 3CB9           88C4                       mov	ah,al
13479 3CBB           30C0                       xor	al,al
13480 3CBD           93                         xchg	bx,ax
13481 3CBE           31C0                       xor	ax,ax
13482                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13483 3CC0           8D7E         CA            lea	di,-$36[bp]
13484 3CC3           E8         C441            call	lorul
13485 3CC6           83C4                   04  add	sp,*4
13486                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13487 3CC9           8D7E         CE            lea	di,-$32[bp]
13488 3CCC           E8         C438            call	lorul
13489 3CCF           83C4                   04  add	sp,*4
13490                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13491 3CD2           8D7E         D2            lea	di,-$2E[bp]
13492 3CD5           E8         C42F            call	lorul
13493 3CD8           83C4                   04  add	sp,*4
13494                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13495 3CDB           8946         E8            mov	-$18[bp],ax
13496 3CDE           895E         EA            mov	-$16[bp],bx
13497                                           !BCC_EOS
13498                                           ! 2247   ;
13499                                           !BCC_EOS
13500                                           ! 2248   if (block_len!= 2048 && block_len!= 512)
13501                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13502                                           ! Debug: expression subtree swapping
13503 3CE1           B8                   0800  mov	ax,#$800
13504 3CE4           31DB                       xor	bx,bx
13505 3CE6           53                         push	bx
13506 3CE7           50                         push	ax
13507 3CE8           8B46         E8            mov	ax,-$18[bp]
13508 3CEB           8B5E         EA            mov	bx,-$16[bp]
13509 3CEE           8D7E         D2            lea	di,-$2E[bp]
13510 3CF1           E8         C3D7            call	lcmpul
13511 3CF4           8D66         D6            lea	sp,-$2A[bp]
13512 3CF7           74           33            je  	.2ED
13513                       00003CF9            .2EF:
13514                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13515                                           ! Debug: expression subtree swapping
13516 3CF9           B8                   0200  mov	ax,#$200
13517 3CFC           31DB                       xor	bx,bx
13518 3CFE           53                         push	bx
13519 3CFF           50                         push	ax
13520 3D00           8B46         E8            mov	ax,-$18[bp]
13521 3D03           8B5E         EA            mov	bx,-$16[bp]
13522 3D06           8D7E         D2            lea	di,-$2E[bp]
13523 3D09           E8         C3BF            call	lcmpul
13524 3D0C           8D66         D6            lea	sp,-$2A[bp]
13525 3D0F           74           1B            je  	.2ED
13526                       00003D11            .2EE:
13527                                           ! 2249   {
13528                                           ! 2250     bios_printf(2, "Unsupported sector size %u\n", block_len);
13529                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13530 3D11           FF76         EA            push	-$16[bp]
13531 3D14           FF76         E8            push	-$18[bp]
13532                                           ! Debug: list * char = .2F0+0 (used reg = )
13533 3D17           BB                   D5E5  mov	bx,#.2F0
13534 3D1A           53                         push	bx
13535                                           ! Debug: list int = const 2 (used reg = )
13536 3D1B           B8                   0002  mov	ax,*2
13537 3D1E           50                         push	ax
13538                                           ! Debug: func () void = bios_printf+0 (used reg = )
13539 3D1F           E8         CC85            call	_bios_printf
13540 3D22           83C4                   08  add	sp,*8
13541                                           !BCC_EOS
13542                                           ! 2251     return -1;
13543 3D25           B8                   FFFF  mov	ax,#$FFFF
13544 3D28           89EC                       mov	sp,bp
13545 3D2A           5D                         pop	bp
13546 3D2B           C3                         ret
13547                                           !BCC_EOS
13548                                           ! 2252   }
13549                                           ! 2253   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13550                       00003D2C            .2ED:
13551                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13552 3D2C           FF76         EA            push	-$16[bp]
13553 3D2F           FF76         E8            push	-$18[bp]
13554                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13555 3D32           8B46         04            mov	ax,4[bp]
13556 3D35           B9                   001E  mov	cx,*$1E
13557 3D38           F7E9                       imul	cx
13558 3D3A           89C3                       mov	bx,ax
13559                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13560                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13561 3D3C           81C3                 0148  add	bx,#$148
13562 3D40           53                         push	bx
13563                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13564 3D41           FF76         D6            push	-$2A[bp]
13565                                           ! Debug: func () void = write_dword+0 (used reg = )
13566 3D44           E8         C354            call	_write_dword
13567 3D47           83C4                   08  add	sp,*8
13568                                           !BCC_EOS
13569                                           ! 2254   sectors = (Bit32u) buf[0] << 24
13570                                           ! 2255     | (Bit32u) buf[1] << 16
13571                                           ! 2256     | (Bit32u) buf[2] << 8
13572                                           ! 2257     | (Bit32u) buf[3] << 0;
13573                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13574 3D4A           8A46         EF            mov	al,-$11[bp]
13575 3D4D           30E4                       xor	ah,ah
13576 3D4F           31DB                       xor	bx,bx
13577                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13578 3D51           53                         push	bx
13579 3D52           50                         push	ax
13580                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13581 3D53           8A46         EE            mov	al,-$12[bp]
13582 3D56           30E4                       xor	ah,ah
13583 3D58           31DB                       xor	bx,bx
13584                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13585 3D5A           88DF                       mov	bh,bl
13586 3D5C           88E3                       mov	bl,ah
13587 3D5E           88C4                       mov	ah,al
13588 3D60           30C0                       xor	al,al
13589 3D62           53                         push	bx
13590 3D63           50                         push	ax
13591                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13592 3D64           8A46         ED            mov	al,-$13[bp]
13593 3D67           30E4                       xor	ah,ah
13594 3D69           31DB                       xor	bx,bx
13595                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13596 3D6B           93                         xchg	bx,ax
13597 3D6C           31C0                       xor	ax,ax
13598 3D6E           53                         push	bx
13599 3D6F           50                         push	ax
13600                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13601 3D70           8A46         EC            mov	al,-$14[bp]
13602 3D73           30E4                       xor	ah,ah
13603 3D75           31DB                       xor	bx,bx
13604                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13605 3D77           88C4                       mov	ah,al
13606 3D79           30C0                       xor	al,al
13607 3D7B           93                         xchg	bx,ax
13608 3D7C           31C0                       xor	ax,ax
13609                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13610 3D7E           8D7E         CA            lea	di,-$36[bp]
13611 3D81           E8         C383            call	lorul
13612 3D84           83C4                   04  add	sp,*4
13613                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13614 3D87           8D7E         CE            lea	di,-$32[bp]
13615 3D8A           E8         C37A            call	lorul
13616 3D8D           83C4                   04  add	sp,*4
13617                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13618 3D90           8D7E         D2            lea	di,-$2E[bp]
13619 3D93           E8         C371            call	lorul
13620 3D96           83C4                   04  add	sp,*4
13621                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13622 3D99           8946         E4            mov	-$1C[bp],ax
13623 3D9C           895E         E6            mov	-$1A[bp],bx
13624                                           !BCC_EOS
13625                                           ! 2258   ;
13626                                           !BCC_EOS
13627                                           ! 2259   if (block_len == 2048)
13628                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13629                                           ! Debug: expression subtree swapping
13630 3D9F           B8                   0800  mov	ax,#$800
13631 3DA2           31DB                       xor	bx,bx
13632 3DA4           53                         push	bx
13633 3DA5           50                         push	ax
13634 3DA6           8B46         E8            mov	ax,-$18[bp]
13635 3DA9           8B5E         EA            mov	bx,-$16[bp]
13636 3DAC           8D7E         D2            lea	di,-$2E[bp]
13637 3DAF           E8         C319            call	lcmpul
13638 3DB2           8D66         D6            lea	sp,-$2A[bp]
13639 3DB5           75           12            jne 	.2F1
13640                       00003DB7            .2F2:
13641                                           ! 2260     sectors <<= 2;
13642                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13643 3DB7           8B46         E4            mov	ax,-$1C[bp]
13644 3DBA           8B5E         E6            mov	bx,-$1A[bp]
13645 3DBD           BF                   0002  mov	di,*2
13646 3DC0           E8         C384            call	lslul
13647 3DC3           8946         E4            mov	-$1C[bp],ax
13648 3DC6           895E         E6            mov	-$1A[bp],bx
13649                                           !BCC_EOS
13650                                           ! 2261   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13651                       00003DC9            .2F1:
13652                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13653 3DC9           8B46         04            mov	ax,4[bp]
13654 3DCC           B9                   001E  mov	cx,*$1E
13655 3DCF           F7E9                       imul	cx
13656 3DD1           89C3                       mov	bx,ax
13657                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13658                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13659 3DD3           81C3                 0158  add	bx,#$158
13660 3DD7           53                         push	bx
13661                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13662 3DD8           FF76         D6            push	-$2A[bp]
13663                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13664 3DDB           E8         C2A5            call	_read_dword
13665 3DDE           89D3                       mov	bx,dx
13666 3DE0           83C4                   04  add	sp,*4
13667                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13668                                           ! Debug: expression subtree swapping
13669 3DE3           8D7E         E4            lea	di,-$1C[bp]
13670 3DE6           E8         C2E2            call	lcmpul
13671 3DE9           74           24            je  	.2F3
13672                       00003DEB            .2F4:
13673                                           ! 2262     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13674                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13675 3DEB           8B46         E4            mov	ax,-$1C[bp]
13676 3DEE           8B5E         E6            mov	bx,-$1A[bp]
13677 3DF1           88E0                       mov	al,ah
13678 3DF3           88DC                       mov	ah,bl
13679 3DF5           88FB                       mov	bl,bh
13680 3DF7           28FF                       sub	bh,bh
13681 3DF9           BF                   0003  mov	di,*3
13682 3DFC           E8         C32A            call	lsrul
13683                                           ! Debug: list unsigned long = bx+0 (used reg = )
13684 3DFF           53                         push	bx
13685 3E00           50                         push	ax
13686                                           ! Debug: list * char = .2F5+0 (used reg = )
13687 3E01           BB                   D5CF  mov	bx,#.2F5
13688 3E04           53                         push	bx
13689                                           ! Debug: list int = const 2 (used reg = )
13690 3E05           B8                   0002  mov	ax,*2
13691 3E08           50                         push	ax
13692                                           ! Debug: func () void = bios_printf+0 (used reg = )
13693 3E09           E8         CB9B            call	_bios_printf
13694 3E0C           83C4                   08  add	sp,*8
13695                                           !BCC_EOS
13696                                           ! 2263   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13697                       00003E0F            .2F3:
13698                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13699 3E0F           FF76         E6            push	-$1A[bp]
13700 3E12           FF76         E4            push	-$1C[bp]
13701                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13702 3E15           8B46         04            mov	ax,4[bp]
13703 3E18           B9                   001E  mov	cx,*$1E
13704 3E1B           F7E9                       imul	cx
13705 3E1D           89C3                       mov	bx,ax
13706                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13707                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13708 3E1F           81C3                 0158  add	bx,#$158
13709 3E23           53                         push	bx
13710                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13711 3E24           FF76         D6            push	-$2A[bp]
13712                                           ! Debug: func () void = write_dword+0 (used reg = )
13713 3E27           E8         C271            call	_write_dword
13714 3E2A           83C4                   08  add	sp,*8
13715                                           !BCC_EOS
13716                                           ! 2264   return 0;
13717 3E2D           31C0                       xor	ax,ax
13718 3E2F           89EC                       mov	sp,bp
13719 3E31           5D                         pop	bp
13720 3E32           C3                         ret
13721                                           !BCC_EOS
13722                                           ! 2265 }
13723                                           ! 2266   Bit16u
13724                                           ! Register BX used in function atapi_is_ready
13725                                           ! 2267 atapi_is_cdrom(device)
13726                                           ! 2268   Bit8u device;
13727                                           export	_atapi_is_cdrom
13728                       00003E33            _atapi_is_cdrom:
13729                                           !BCC_EOS
13730                                           ! 2269 {
13731                                           ! 2270   Bit16u ebda_seg=read_word(0x0040,0x000E);
13732 3E33           55                         push	bp
13733 3E34           89E5                       mov	bp,sp
13734 3E36           4C                         dec	sp
13735 3E37           4C                         dec	sp
13736                                           ! Debug: list int = const $E (used reg = )
13737 3E38           B8                   000E  mov	ax,*$E
13738 3E3B           50                         push	ax
13739                                           ! Debug: list int = const $40 (used reg = )
13740 3E3C           B8                   0040  mov	ax,*$40
13741 3E3F           50                         push	ax
13742                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13743 3E40           E8         C7C8            call	_read_word
13744 3E43           83C4                   04  add	sp,*4
13745                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13746 3E46           8946         FE            mov	-2[bp],ax
13747                                           !BCC_EOS
13748                                           ! 2271   if (device >= (4*2))
13749                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
13750 3E49           8A46         04            mov	al,4[bp]
13751 3E4C           3C                     08  cmp	al,*8
13752 3E4E           72           06            jb  	.2F6
13753                       00003E50            .2F7:
13754                                           ! 2272     return 0;
13755 3E50           31C0                       xor	ax,ax
13756 3E52           89EC                       mov	sp,bp
13757 3E54           5D                         pop	bp
13758 3E55           C3                         ret
13759                                           !BCC_EOS
13760                                           ! 2273   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
13761                       00003E56            .2F6:
13762                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13763 3E56           8A46         04            mov	al,4[bp]
13764 3E59           30E4                       xor	ah,ah
13765 3E5B           B9                   001E  mov	cx,*$1E
13766 3E5E           F7E9                       imul	cx
13767 3E60           89C3                       mov	bx,ax
13768                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13769                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13770 3E62           81C3                 0142  add	bx,#$142
13771 3E66           53                         push	bx
13772                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13773 3E67           FF76         FE            push	-2[bp]
13774                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13775 3E6A           E8         C78B            call	_read_byte
13776 3E6D           83C4                   04  add	sp,*4
13777                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13778 3E70           3C                     03  cmp	al,*3
13779 3E72           74           06            je  	.2F8
13780                       00003E74            .2F9:
13781                                           ! 2274     return 0;
13782 3E74           31C0                       xor	ax,ax
13783 3E76           89EC                       mov	sp,bp
13784 3E78           5D                         pop	bp
13785 3E79           C3                         ret
13786                                           !BCC_EOS
13787                                           ! 2275   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
13788                       00003E7A            .2F8:
13789                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13790 3E7A           8A46         04            mov	al,4[bp]
13791 3E7D           30E4                       xor	ah,ah
13792 3E7F           B9                   001E  mov	cx,*$1E
13793 3E82           F7E9                       imul	cx
13794 3E84           89C3                       mov	bx,ax
13795                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
13796                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
13797 3E86           81C3                 0143  add	bx,#$143
13798 3E8A           53                         push	bx
13799                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13800 3E8B           FF76         FE            push	-2[bp]
13801                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13802 3E8E           E8         C767            call	_read_byte
13803 3E91           83C4                   04  add	sp,*4
13804                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
13805 3E94           3C                     05  cmp	al,*5
13806 3E96           74           06            je  	.2FA
13807                       00003E98            .2FB:
13808                                           ! 2276     return 0;
13809 3E98           31C0                       xor	ax,ax
13810 3E9A           89EC                       mov	sp,bp
13811 3E9C           5D                         pop	bp
13812 3E9D           C3                         ret
13813                                           !BCC_EOS
13814                                           ! 2277   return 1;
13815                       00003E9E            .2FA:
13816 3E9E           B8                   0001  mov	ax,*1
13817 3EA1           89EC                       mov	sp,bp
13818 3EA3           5D                         pop	bp
13819 3EA4           C3                         ret
13820                                           !BCC_EOS
13821                                           ! 2278 }
13822                                           ! 2279   void
13823                                           ! Register BX used in function atapi_is_cdrom
13824                                           ! 2280 cdemu_init()
13825                                           ! 2281 {
13826                                           export	_cdemu_init
13827                       00003EA5            _cdemu_init:
13828                                           ! 2282   Bit16u ebda_seg=read_word(0x0040,0x000E);
13829 3EA5           55                         push	bp
13830 3EA6           89E5                       mov	bp,sp
13831 3EA8           4C                         dec	sp
13832 3EA9           4C                         dec	sp
13833                                           ! Debug: list int = const $E (used reg = )
13834 3EAA           B8                   000E  mov	ax,*$E
13835 3EAD           50                         push	ax
13836                                           ! Debug: list int = const $40 (used reg = )
13837 3EAE           B8                   0040  mov	ax,*$40
13838 3EB1           50                         push	ax
13839                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13840 3EB2           E8         C756            call	_read_word
13841 3EB5           83C4                   04  add	sp,*4
13842                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13843 3EB8           8946         FE            mov	-2[bp],ax
13844                                           !BCC_EOS
13845                                           ! 2283   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
13846                                           ! Debug: list int = const 0 (used reg = )
13847 3EBB           31C0                       xor	ax,ax
13848 3EBD           50                         push	ax
13849                                           ! Debug: list * unsigned char = const $25A (used reg = )
13850 3EBE           B8                   025A  mov	ax,#$25A
13851 3EC1           50                         push	ax
13852                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
13853 3EC2           FF76         FE            push	-2[bp]
13854                                           ! Debug: func () void = write_byte+0 (used reg = )
13855 3EC5           E8         C756            call	_write_byte
13856 3EC8           83C4                   06  add	sp,*6
13857                                           !BCC_EOS
13858                                           ! 2284 }
13859 3ECB           89EC                       mov	sp,bp
13860 3ECD           5D                         pop	bp
13861 3ECE           C3                         ret
13862                                           ! 2285   Bit
13863                                           ! 2285 8u
13864                                           ! 2286 cdemu_isactive()
13865                                           ! 2287 {
13866                                           export	_cdemu_isactive
13867                       00003ECF            _cdemu_isactive:
13868                                           ! 2288   Bit16u ebda_seg=read_word(0x0040,0x000E);
13869 3ECF           55                         push	bp
13870 3ED0           89E5                       mov	bp,sp
13871 3ED2           4C                         dec	sp
13872 3ED3           4C                         dec	sp
13873                                           ! Debug: list int = const $E (used reg = )
13874 3ED4           B8                   000E  mov	ax,*$E
13875 3ED7           50                         push	ax
13876                                           ! Debug: list int = const $40 (used reg = )
13877 3ED8           B8                   0040  mov	ax,*$40
13878 3EDB           50                         push	ax
13879                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13880 3EDC           E8         C72C            call	_read_word
13881 3EDF           83C4                   04  add	sp,*4
13882                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13883 3EE2           8946         FE            mov	-2[bp],ax
13884                                           !BCC_EOS
13885                                           ! 2289   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
13886                                           ! Debug: list * unsigned char = const $25A (used reg = )
13887 3EE5           B8                   025A  mov	ax,#$25A
13888 3EE8           50                         push	ax
13889                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13890 3EE9           FF76         FE            push	-2[bp]
13891                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13892 3EEC           E8         C709            call	_read_byte
13893 3EEF           83C4                   04  add	sp,*4
13894                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13895 3EF2           89EC                       mov	sp,bp
13896 3EF4           5D                         pop	bp
13897 3EF5           C3                         ret
13898                                           !BCC_EOS
13899                                           ! 2290 }
13900                                           ! 2291   Bit8u
13901                                           ! 2292 cdemu_emulated_drive()
13902                                           ! 2293 {
13903                                           export	_cdemu_emulated_drive
13904                       00003EF6            _cdemu_emulated_drive:
13905                                           ! 2294   Bit16u ebda_seg=read_word(0x0040,0x000E);
13906 3EF6           55                         push	bp
13907 3EF7           89E5                       mov	bp,sp
13908 3EF9           4C                         dec	sp
13909 3EFA           4C                         dec	sp
13910                                           ! Debug: list int = const $E (used reg = )
13911 3EFB           B8                   000E  mov	ax,*$E
13912 3EFE           50                         push	ax
13913                                           ! Debug: list int = const $40 (used reg = )
13914 3EFF           B8                   0040  mov	ax,*$40
13915 3F02           50                         push	ax
13916                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13917 3F03           E8         C705            call	_read_word
13918 3F06           83C4                   04  add	sp,*4
13919                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13920 3F09           8946         FE            mov	-2[bp],ax
13921                                           !BCC_EOS
13922                                           ! 2295   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
13923                                           ! Debug: list * unsigned char = const $25C (used reg = )
13924 3F0C           B8                   025C  mov	ax,#$25C
13925 3F0F           50                         push	ax
13926                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13927 3F10           FF76         FE            push	-2[bp]
13928                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13929 3F13           E8         C6E2            call	_read_byte
13930 3F16           83C4                   04  add	sp,*4
13931                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13932 3F19           89EC                       mov	sp,bp
13933 3F1B           5D                         pop	bp
13934 3F1C           C3                         ret
13935                                           !BCC_EOS
13936                                           ! 2296 }
13937                                           ! 2297 static char isotag[6]="CD001";
13938                                           
13939                       00003F1D            _isotag:
13940                       00003F1D            .2FC:
13941 3F1D                        43            .ascii	"CD001"
13942 3F22                        00            .byte	0
13943                                           !BCC_EOS
13944                                           ! 2298 static char eltorito[24]="EL TORITO SPECIFICATION";
13945                       00003F23            _eltorito:
13946                       00003F23            .2FD:
13947 3F23                        45            .ascii	"EL TORITO SPECIFICATION"
13948 3F3A                        00            .byte	0
13949                                           !BCC_EOS
13950                                           ! 2299   Bit16u
13951                                           ! 2300 cdrom_boot()
13952                                           ! 2301 {
13953                                           
13954                                           export	_cdrom_boot
13955                       00003F3B            _cdrom_boot:
13956                                           ! 2302   Bit16u ebda_seg=read_word(0x0040,0x000E);
13957 3F3B           55                         push	bp
13958 3F3C           89E5                       mov	bp,sp
13959 3F3E           4C                         dec	sp
13960 3F3F           4C                         dec	sp
13961                                           ! Debug: list int = const $E (used reg = )
13962 3F40           B8                   000E  mov	ax,*$E
13963 3F43           50                         push	ax
13964                                           ! Debug: list int = const $40 (used reg = )
13965 3F44           B8                   0040  mov	ax,*$40
13966 3F47           50                         push	ax
13967                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13968 3F48           E8         C6C0            call	_read_word
13969 3F4B           83C4                   04  add	sp,*4
13970                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13971 3F4E           8946         FE            mov	-2[bp],ax
13972                                           !BCC_EOS
13973                                           ! 2303   Bit8u atacmd[12], buffer[2048];
13974                                           !BCC_EOS
13975                                           ! 2304   Bit32u lba;
13976                                           !BCC_EOS
13977                                           ! 2305   Bit16u boot_segment, nbsectors, i, error;
13978                                           !BCC_EOS
13979                                           ! 2306   Bit8u device;
13980                                           !BCC_EOS
13981                                           ! 2307   for (device=0; device<(4*2);device++) {
13982 3F51           81C4                 F7E6  add	sp,#-$81A
13983                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
13984 3F55           30C0                       xor	al,al
13985 3F57           8886       F7E5            mov	-$81B[bp],al
13986                                           !BCC_EOS
13987                                           !BCC_EOS
13988 3F5B           EB           1B            jmp .300
13989                       00003F5D            .301:
13990                                           ! 2308     if (atapi_is_cdrom(device)) break;
13991                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
13992 3F5D           8A86       F7E5            mov	al,-$81B[bp]
13993 3F61           30E4                       xor	ah,ah
13994 3F63           50                         push	ax
13995                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
13996 3F64           E8         FECC            call	_atapi_is_cdrom
13997 3F67           44                         inc	sp
13998 3F68           44                         inc	sp
13999 3F69           85C0                       test	ax,ax
14000 3F6B           74           02            je  	.302
14001                       00003F6D            .303:
14002 3F6D           EB           11            jmp .2FE
14003                                           !BCC_EOS
14004                                           ! 2309   }
14005                       00003F6F            .302:
14006                                           ! 2310   if(device >= (4*2)) return 2;
14007                       00003F6F            .2FF:
14008                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
14009 3F6F           8A86       F7E5            mov	al,-$81B[bp]
14010 3F73           40                         inc	ax
14011 3F74           8886       F7E5            mov	-$81B[bp],al
14012                       00003F78            .300:
14013                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14014 3F78           8A86       F7E5            mov	al,-$81B[bp]
14015 3F7C           3C                     08  cmp	al,*8
14016 3F7E           72           DD            jb 	.301
14017                       00003F80            .304:
14018                       00003F80            .2FE:
14019                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14020 3F80           8A86       F7E5            mov	al,-$81B[bp]
14021 3F84           3C                     08  cmp	al,*8
14022 3F86           72           07            jb  	.305
14023                       00003F88            .306:
14024 3F88           B8                   0002  mov	ax,*2
14025 3F8B           89EC                       mov	sp,bp
14026 3F8D           5D                         pop	bp
14027 3F8E           C3                         ret
14028                                           !BCC_EOS
14029                                           ! 2311   if(error = atapi_is_ready(device) != 0)
14030                       00003F8F            .305:
14031                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14032 3F8F           8A86       F7E5            mov	al,-$81B[bp]
14033 3F93           30E4                       xor	ah,ah
14034 3F95           50                         push	ax
14035                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
14036 3F96           E8         FBB2            call	_atapi_is_ready
14037 3F99           44                         inc	sp
14038 3F9A           44                         inc	sp
14039                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14040 3F9B           85C0                       test	ax,ax
14041 3F9D           74           04            je 	.309
14042 3F9F           B0                     01  mov	al,*1
14043 3FA1           EB           02            jmp	.30A
14044                       00003FA3            .309:
14045 3FA3           30C0                       xor	al,al
14046                       00003FA5            .30A:
14047                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14048 3FA5           30E4                       xor	ah,ah
14049 3FA7           8986       F7E6            mov	-$81A[bp],ax
14050 3FAB           85C0                       test	ax,ax
14051 3FAD           74           12            je  	.307
14052                       00003FAF            .308:
14053                                           ! 2312     bios_printf(4, "ata_is_ready returned %d\n",error);
14054                                           ! Debug: list unsigned short error = [S+$81E-$81C] (used reg = )
14055 3FAF           FFB6       F7E6            push	-$81A[bp]
14056                                           ! Debug: list * char = .30B+0 (used reg = )
14057 3FB3           BB                   D5B5  mov	bx,#.30B
14058 3FB6           53                         push	bx
14059                                           ! Debug: list int = const 4 (used reg = )
14060 3FB7           B8                   0004  mov	ax,*4
14061 3FBA           50                         push	ax
14062                                           ! Debug: func () void = bios_printf+0 (used reg = )
14063 3FBB           E8         C9E9            call	_bios_printf
14064 3FBE           83C4                   06  add	sp,*6
14065                                           !BCC_EOS
14066                                           ! 2313   memsetb(get_SS(),atacmd,0,12);
14067                       00003FC1            .307:
14068                                           ! Debug: list int = const $C (used reg = )
14069 3FC1           B8                   000C  mov	ax,*$C
14070 3FC4           50                         push	ax
14071                                           ! Debug: list int = const 0 (used reg = )
14072 3FC5           31C0                       xor	ax,ax
14073 3FC7           50                         push	ax
14074                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14075 3FC8           8D5E         F2            lea	bx,-$E[bp]
14076 3FCB           53                         push	bx
14077                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14078 3FCC           E8         C682            call	_get_SS
14079                                           ! Debug: list unsigned short = ax+0 (used reg = )
14080 3FCF           50                         push	ax
14081                                           ! Debug: func () void = memsetb+0 (used reg = )
14082 3FD0           E8         C02D            call	_memsetb
14083 3FD3           83C4                   08  add	sp,*8
14084                                           !BCC_EOS
14085                                           ! 2314   atacmd[0]=0x28;
14086                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14087 3FD6           B0                     28  mov	al,*$28
14088 3FD8           8846         F2            mov	-$E[bp],al
14089                                           !BCC_EOS
14090                                           ! 2315   atacmd[7]=(0x01 & 0xff00) >> 8;
14091                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14092 3FDB           30C0                       xor	al,al
14093 3FDD           8846         F9            mov	-7[bp],al
14094                                           !BCC_EOS
14095                                           ! 2316   atacmd[8]=(0x01 & 0x00ff);
14096                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14097 3FE0           B0                     01  mov	al,*1
14098 3FE2           8846         FA            mov	-6[bp],al
14099                                           !BCC_EOS
14100                                           ! 2317   atacmd[2]=(0x11 & 0xff000000) >> 24;
14101                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14102 3FE5           30C0                       xor	al,al
14103 3FE7           8846         F4            mov	-$C[bp],al
14104                                           !BCC_EOS
14105                                           ! 2318   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
14106                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14107 3FEA           30C0                       xor	al,al
14108 3FEC           8846         F5            mov	-$B[bp],al
14109                                           !BCC_EOS
14110                                           ! 2319   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
14111                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14112 3FEF           30C0                       xor	al,al
14113 3FF1           8846         F6            mov	-$A[bp],al
14114                                           !BCC_EOS
14115                                           ! 2320   atacmd[5]=(0x11 & 0x000000ff);
14116                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14117 3FF4           B0                     11  mov	al,*$11
14118 3FF6           8846         F7            mov	-9[bp],al
14119                                           !BCC_EOS
14120                                           ! 2321   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14121                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14122 3FF9           8D9E       F7F2            lea	bx,-$80E[bp]
14123 3FFD           53                         push	bx
14124                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14125 3FFE           E8         C650            call	_get_SS
14126                                           ! Debug: list unsigned short = ax+0 (used reg = )
14127 4001           50                         push	ax
14128                                           ! Debug: list int = const 1 (used reg = )
14129 4002           B8                   0001  mov	ax,*1
14130 4005           50                         push	ax
14131                                           ! Debug: list long = const $800 (used reg = )
14132 4006           B8                   0800  mov	ax,#$800
14133 4009           31DB                       xor	bx,bx
14134 400B           53                         push	bx
14135 400C           50                         push	ax
14136                                           ! Debug: list int = const 0 (used reg = )
14137 400D           31C0                       xor	ax,ax
14138 400F           50                         push	ax
14139                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14140 4010           8D5E         F2            lea	bx,-$E[bp]
14141 4013           53                         push	bx
14142                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14143 4014           E8         C63A            call	_get_SS
14144                                           ! Debug: list unsigned short = ax+0 (used reg = )
14145 4017           50                         push	ax
14146                                           ! Debug: list int = const $C (used reg = )
14147 4018           B8                   000C  mov	ax,*$C
14148 401B           50                         push	ax
14149                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14150 401C           8A86       F7E5            mov	al,-$81B[bp]
14151 4020           30E4                       xor	ah,ah
14152 4022           50                         push	ax
14153                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14154 4023           E8         F5C1            call	_ata_cmd_packet
14155 4026           83C4                   14  add	sp,*$14
14156                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14157 4029           8986       F7E6            mov	-$81A[bp],ax
14158                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14159 402D           85C0                       test	ax,ax
14160 402F           74           07            je  	.30C
14161                       00004031            .30D:
14162                                           ! 2322     return 3;
14163 4031           B8                   0003  mov	ax,*3
14164 4034           89EC                       mov	sp,bp
14165 4036           5D                         pop	bp
14166 4037           C3                         ret
14167                                           !BCC_EOS
14168                                           ! 2323   if(buffer[0]!=0) return 4;
14169                       00004038            .30C:
14170                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14171 4038           8A86       F7F2            mov	al,-$80E[bp]
14172 403C           84C0                       test	al,al
14173 403E           74           07            je  	.30E
14174                       00004040            .30F:
14175 4040           B8                   0004  mov	ax,*4
14176 4043           89EC                       mov	sp,bp
14177 4045           5D                         pop	bp
14178 4046           C3                         ret
14179                                           !BCC_EOS
14180                                           ! 2324   for(i=0;i<5;i++){
14181                       00004047            .30E:
14182                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14183 4047           31C0                       xor	ax,ax
14184 4049           8986       F7E8            mov	-$818[bp],ax
14185                                           !BCC_EOS
14186                                           !BCC_EOS
14187 404D           EB           3B            jmp .312
14188                       0000404F            .313:
14189                                           ! 2325     if(buffer[1+i]!=read_byte(0xf000,&isotag[i])) return 5;
14190                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14191 404F           8B9E       F7E8            mov	bx,-$818[bp]
14192                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14193                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14194 4053           81C3                 3F1D  add	bx,#_isotag
14195 4057           53                         push	bx
14196                                           ! Debug: list unsigned int = const $F000 (used reg = )
14197 4058           B8                   F000  mov	ax,#$F000
14198 405B           50                         push	ax
14199                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14200 405C           E8         C599            call	_read_byte
14201 405F           83C4                   04  add	sp,*4
14202 4062           50                         push	ax
14203                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14204                                           ! Debug: expression subtree swapping
14205 4063           8B86       F7E8            mov	ax,-$818[bp]
14206                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14207 4067           40                         inc	ax
14208 4068           89EB                       mov	bx,bp
14209 406A           01C3                       add	bx,ax
14210                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
14211 406C           8A87       F7F2            mov	al,-$80E[bx]
14212 4070           3A86       F7E2            cmp	al,-$81E[bp]
14213 4074           8DA6       F7E4            lea	sp,-$81C[bp]
14214 4078           74           07            je  	.314
14215                       0000407A            .315:
14216 407A           B8                   0005  mov	ax,*5
14217 407D           89EC                       mov	sp,bp
14218 407F           5D                         pop	bp
14219 4080           C3                         ret
14220                                           !BCC_EOS
14221                                           ! 2326   }
14222                       00004081            .314:
14223                                           ! 2327   for(i=0;i<23;i++)
14224                       00004081            .311:
14225                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14226 4081           8B86       F7E8            mov	ax,-$818[bp]
14227 4085           40                         inc	ax
14228 4086           8986       F7E8            mov	-$818[bp],ax
14229                       0000408A            .312:
14230                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14231 408A           8B86       F7E8            mov	ax,-$818[bp]
14232 408E           3D                   0005  cmp	ax,*5
14233 4091           72           BC            jb 	.313
14234                       00004093            .316:
14235                       00004093            .310:
14236                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14237 4093           31C0                       xor	ax,ax
14238 4095           8986       F7E8            mov	-$818[bp],ax
14239                                           !BCC_EOS
14240                                           !BCC_EOS
14241                                           ! 2328     if(buffer[7+i]!=read_byte(0xf000,&eltorito[i])) return 6;
14242 4099           EB           3D            jmp .319
14243                       0000409B            .31A:
14244                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14245 409B           8B9E       F7E8            mov	bx,-$818[bp]
14246                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14247                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14248 409F           81C3                 3F23  add	bx,#_eltorito
14249 40A3           53                         push	bx
14250                                           ! Debug: list unsigned int = const $F000 (used reg = )
14251 40A4           B8                   F000  mov	ax,#$F000
14252 40A7           50                         push	ax
14253                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14254 40A8           E8         C54D            call	_read_byte
14255 40AB           83C4                   04  add	sp,*4
14256 40AE           50                         push	ax
14257                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14258                                           ! Debug: expression subtree swapping
14259 40AF           8B86       F7E8            mov	ax,-$818[bp]
14260                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14261 40B3           05                   0007  add	ax,*7
14262 40B6           89EB                       mov	bx,bp
14263 40B8           01C3                       add	bx,ax
14264                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
14265 40BA           8A87       F7F2            mov	al,-$80E[bx]
14266 40BE           3A86       F7E2            cmp	al,-$81E[bp]
14267 40C2           8DA6       F7E4            lea	sp,-$81C[bp]
14268 40C6           74           07            je  	.31B
14269                       000040C8            .31C:
14270 40C8           B8                   0006  mov	ax,*6
14271 40CB           89EC                       mov	sp,bp
14272 40CD           5D                         pop	bp
14273 40CE           C3                         ret
14274                                           !BCC_EOS
14275                                           ! 2329   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14276                       000040CF            .31B:
14277                       000040CF            .318:
14278                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14279 40CF           8B86       F7E8            mov	ax,-$818[bp]
14280 40D3           40                         inc	ax
14281 40D4           8986       F7E8            mov	-$818[bp],ax
14282                       000040D8            .319:
14283                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14284 40D8           8B86       F7E8            mov	ax,-$818[bp]
14285 40DC           3D                   0017  cmp	ax,*$17
14286 40DF           72           BA            jb 	.31A
14287                       000040E1            .31D:
14288                       000040E1            .317:
14289                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14290 40E1           8A86       F839            mov	al,-$7C7[bp]
14291 40E5           30E4                       xor	ah,ah
14292 40E7           31DB                       xor	bx,bx
14293 40E9           53                         push	bx
14294 40EA           50                         push	ax
14295                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14296 40EB           8A86       F83A            mov	al,-$7C6[bp]
14297 40EF           30E4                       xor	ah,ah
14298 40F1           B9                   0100  mov	cx,#$100
14299 40F4           F7E9                       imul	cx
14300                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14301 40F6           31DB                       xor	bx,bx
14302 40F8           53                         push	bx
14303 40F9           50                         push	ax
14304                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14305 40FA           8A86       F83B            mov	al,-$7C5[bp]
14306 40FE           30E4                       xor	ah,ah
14307 4100           31DB                       xor	bx,bx
14308                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14309 4102           53                         push	bx
14310 4103           50                         push	ax
14311 4104           31C0                       xor	ax,ax
14312 4106           BB                   0001  mov	bx,*1
14313 4109           53                         push	bx
14314 410A           50                         push	ax
14315 410B           8B86       F7D8            mov	ax,-$828[bp]
14316 410F           8B9E       F7DA            mov	bx,-$826[bp]
14317 4113           8DBE       F7D4            lea	di,-$82C[bp]
14318 4117           E8         BFCF            call	lmulul
14319 411A           83C4                   08  add	sp,*8
14320 411D           53                         push	bx
14321 411E           50                         push	ax
14322                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14323 411F           8A86       F83C            mov	al,-$7C4[bp]
14324 4123           30E4                       xor	ah,ah
14325 4125           31DB                       xor	bx,bx
14326                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14327 4127           53                         push	bx
14328 4128           50                         push	ax
14329 4129           31C0                       xor	ax,ax
14330 412B           BB                   0100  mov	bx,#$100
14331 412E           53                         push	bx
14332 412F           50                         push	ax
14333 4130           8B86       F7D4            mov	ax,-$82C[bp]
14334 4134           8B9E       F7D6            mov	bx,-$82A[bp]
14335 4138           8DBE       F7D0            lea	di,-$830[bp]
14336 413C           E8         BFAA            call	lmulul
14337 413F           83C4                   08  add	sp,*8
14338                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14339 4142           8DBE       F7D8            lea	di,-$828[bp]
14340 4146           E8         BF7A            call	laddul
14341 4149           83C4                   04  add	sp,*4
14342                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14343 414C           8DBE       F7DC            lea	di,-$824[bp]
14344 4150           E8         BF70            call	laddul
14345 4153           83C4                   04  add	sp,*4
14346                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14347 4156           8DBE       F7E0            lea	di,-$820[bp]
14348 415A           E8         BF66            call	laddul
14349 415D           83C4                   04  add	sp,*4
14350                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14351 4160           8986       F7EE            mov	-$812[bp],ax
14352 4164           899E       F7F0            mov	-$810[bp],bx
14353                                           !BCC_EOS
14354                                           ! 2330   memsetb(get_SS(),atacmd,0,12);
14355                                           ! Debug: list int = const $C (used reg = )
14356 4168           B8                   000C  mov	ax,*$C
14357 416B           50                         push	ax
14358                                           ! Debug: list int = const 0 (used reg = )
14359 416C           31C0                       xor	ax,ax
14360 416E           50                         push	ax
14361                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14362 416F           8D5E         F2            lea	bx,-$E[bp]
14363 4172           53                         push	bx
14364                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14365 4173           E8         C4DB            call	_get_SS
14366                                           ! Debug: list unsigned short = ax+0 (used reg = )
14367 4176           50                         push	ax
14368                                           ! Debug: func () void = memsetb+0 (used reg = )
14369 4177           E8         BE86            call	_memsetb
14370 417A           83C4                   08  add	sp,*8
14371                                           !BCC_EOS
14372                                           ! 2331   atacmd[0]=0x28;
14373                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14374 417D           B0                     28  mov	al,*$28
14375 417F           8846         F2            mov	-$E[bp],al
14376                                           !BCC_EOS
14377                                           ! 2332   atacmd[7]=(0x01 & 0xff00) >> 8;
14378                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14379 4182           30C0                       xor	al,al
14380 4184           8846         F9            mov	-7[bp],al
14381                                           !BCC_EOS
14382                                           ! 2333   atacmd[8]=(0x01 & 0x00ff);
14383                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14384 4187           B0                     01  mov	al,*1
14385 4189           8846         FA            mov	-6[bp],al
14386                                           !BCC_EOS
14387                                           ! 2334   atacmd[2]=(lba & 0xff000000) >> 24;
14388                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14389                                           ! Debug: expression subtree swapping
14390 418C           31C0                       xor	ax,ax
14391 418E           BB                   FF00  mov	bx,#$FF00
14392 4191           8DBE       F7EE            lea	di,-$812[bp]
14393 4195           E8         BF23            call	landul
14394                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14395 4198           93                         xchg	bx,ax
14396 4199           88E0                       mov	al,ah
14397 419B           30E4                       xor	ah,ah
14398 419D           31DB                       xor	bx,bx
14399                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14400 419F           8846         F4            mov	-$C[bp],al
14401                                           !BCC_EOS
14402                                           ! 2335   atacmd[3]=(lba & 0x00ff0000) >> 16;
14403                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14404                                           ! Debug: expression subtree swapping
14405 41A2           31C0                       xor	ax,ax
14406 41A4           BB                   00FF  mov	bx,#$FF
14407 41A7           8DBE       F7EE            lea	di,-$812[bp]
14408 41AB           E8         BF0D            call	landul
14409                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14410 41AE           93                         xchg	bx,ax
14411 41AF           31DB                       xor	bx,bx
14412                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14413 41B1           8846         F5            mov	-$B[bp],al
14414                                           !BCC_EOS
14415                                           ! 2336   atacmd[4]=(lba & 0x0000ff00) >> 8;
14416                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14417                                           ! Debug: expression subtree swapping
14418 41B4           B8                   FF00  mov	ax,#$FF00
14419 41B7           31DB                       xor	bx,bx
14420 41B9           8DBE       F7EE            lea	di,-$812[bp]
14421 41BD           E8         BEFB            call	landul
14422                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14423 41C0           88E0                       mov	al,ah
14424 41C2           88DC                       mov	ah,bl
14425 41C4           88FB                       mov	bl,bh
14426 41C6           28FF                       sub	bh,bh
14427                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14428 41C8           8846         F6            mov	-$A[bp],al
14429                                           !BCC_EOS
14430                                           ! 2337   atacmd[5]=(lba & 0x000000ff);
14431                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14432                                           ! Debug: expression subtree swapping
14433 41CB           B8                   00FF  mov	ax,#$FF
14434 41CE           31DB                       xor	bx,bx
14435 41D0           8DBE       F7EE            lea	di,-$812[bp]
14436 41D4           E8         BEE4            call	landul
14437                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14438 41D7           8846         F7            mov	-9[bp],al
14439                                           !BCC_EOS
14440                                           ! 2338   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14441                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14442 41DA           8D9E       F7F2            lea	bx,-$80E[bp]
14443 41DE           53                         push	bx
14444                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14445 41DF           E8         C46F            call	_get_SS
14446                                           ! Debug: list unsigned short = ax+0 (used reg = )
14447 41E2           50                         push	ax
14448                                           ! Debug: list int = const 1 (used reg = )
14449 41E3           B8                   0001  mov	ax,*1
14450 41E6           50                         push	ax
14451                                           ! Debug: list long = const $800 (used reg = )
14452 41E7           B8                   0800  mov	ax,#$800
14453 41EA           31DB                       xor	bx,bx
14454 41EC           53                         push	bx
14455 41ED           50                         push	ax
14456                                           ! Debug: list int = const 0 (used reg = )
14457 41EE           31C0                       xor	ax,ax
14458 41F0           50                         push	ax
14459                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14460 41F1           8D5E         F2            lea	bx,-$E[bp]
14461 41F4           53                         push	bx
14462                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14463 41F5           E8         C459            call	_get_SS
14464                                           ! Debug: list unsigned short = ax+0 (used reg = )
14465 41F8           50                         push	ax
14466                                           ! Debug: list int = const $C (used reg = )
14467 41F9           B8                   000C  mov	ax,*$C
14468 41FC           50                         push	ax
14469                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14470 41FD           8A86       F7E5            mov	al,-$81B[bp]
14471 4201           30E4                       xor	ah,ah
14472 4203           50                         push	ax
14473                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14474 4204           E8         F3E0            call	_ata_cmd_packet
14475 4207           83C4                   14  add	sp,*$14
14476                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14477 420A           8986       F7E6            mov	-$81A[bp],ax
14478                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14479 420E           85C0                       test	ax,ax
14480 4210           74           07            je  	.31E
14481                       00004212            .31F:
14482                                           ! 2339     return 7;
14483 4212           B8                   0007  mov	ax,*7
14484 4215           89EC                       mov	sp,bp
14485 4217           5D                         pop	bp
14486 4218           C3                         ret
14487                                           !BCC_EOS
14488                                           ! 2340   if(buffer[0x00]!=0x01)return 8;
14489                       00004219            .31E:
14490                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14491 4219           8A86       F7F2            mov	al,-$80E[bp]
14492 421D           3C                     01  cmp	al,*1
14493 421F           74           07            je  	.320
14494                       00004221            .321:
14495 4221           B8                   0008  mov	ax,*8
14496 4224           89EC                       mov	sp,bp
14497 4226           5D                         pop	bp
14498 4227           C3                         ret
14499                                           !BCC_EOS
14500                                           ! 2341   if(buffer[0x01]!=0x00)return 9;
14501                       00004228            .320:
14502                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14503 4228           8A86       F7F3            mov	al,-$80D[bp]
14504 422C           84C0                       test	al,al
14505 422E           74           07            je  	.322
14506                       00004230            .323:
14507 4230           B8                   0009  mov	ax,*9
14508 4233           89EC                       mov	sp,bp
14509 4235           5D                         pop	bp
14510 4236           C3                         ret
14511                                           !BCC_EOS
14512                                           ! 2342   if(buffer[0x1E]!=0x55)return 10;
14513                       00004237            .322:
14514                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14515 4237           8A86       F810            mov	al,-$7F0[bp]
14516 423B           3C                     55  cmp	al,*$55
14517 423D           74           07            je  	.324
14518                       0000423F            .325:
14519 423F           B8                   000A  mov	ax,*$A
14520 4242           89EC                       mov	sp,bp
14521 4244           5D                         pop	bp
14522 4245           C3                         ret
14523                                           !BCC_EOS
14524                                           ! 2343   if(buffer[0x1F]!=0xAA)return 10;
14525                       00004246            .324:
14526                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14527 4246           8A86       F811            mov	al,-$7EF[bp]
14528 424A           3C                     AA  cmp	al,#$AA
14529 424C           74           07            je  	.326
14530                       0000424E            .327:
14531 424E           B8                   000A  mov	ax,*$A
14532 4251           89EC                       mov	sp,bp
14533 4253           5D                         pop	bp
14534 4254           C3                         ret
14535                                           !BCC_EOS
14536                                           ! 2344   if(buffer[0x20]!=0x88)return 11;
14537                       00004255            .326:
14538                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14539 4255           8A86       F812            mov	al,-$7EE[bp]
14540 4259           3C                     88  cmp	al,#$88
14541 425B           74           07            je  	.328
14542                       0000425D            .329:
14543 425D           B8                   000B  mov	ax,*$B
14544 4260           89EC                       mov	sp,bp
14545 4262           5D                         pop	bp
14546 4263           C3                         ret
14547                                           !BCC_EOS
14548                                           ! 2345   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14549                       00004264            .328:
14550                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14551 4264           8A86       F813            mov	al,-$7ED[bp]
14552 4268           30E4                       xor	ah,ah
14553 426A           50                         push	ax
14554                                           ! Debug: list * unsigned char = const $25B (used reg = )
14555 426B           B8                   025B  mov	ax,#$25B
14556 426E           50                         push	ax
14557                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14558 426F           FF76         FE            push	-2[bp]
14559                                           ! Debug: func () void = write_byte+0 (used reg = )
14560 4272           E8         C3A9            call	_write_byte
14561 4275           83C4                   06  add	sp,*6
14562                                           !BCC_EOS
14563                                           ! 2346   if(buffer[0x2
14564                                           ! 2346 1]==0){
14565                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14566 4278           8A86       F813            mov	al,-$7ED[bp]
14567 427C           84C0                       test	al,al
14568 427E           75           13            jne 	.32A
14569                       00004280            .32B:
14570                                           ! 2347     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14571                                           ! Debug: list int = const $E0 (used reg = )
14572 4280           B8                   00E0  mov	ax,#$E0
14573 4283           50                         push	ax
14574                                           ! Debug: list * unsigned char = const $25C (used reg = )
14575 4284           B8                   025C  mov	ax,#$25C
14576 4287           50                         push	ax
14577                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14578 4288           FF76         FE            push	-2[bp]
14579                                           ! Debug: func () void = write_byte+0 (used reg = )
14580 428B           E8         C390            call	_write_byte
14581 428E           83C4                   06  add	sp,*6
14582                                           !BCC_EOS
14583                                           ! 2348   }
14584                                           ! 2349   else if(buffer[0x21]<4)
14585 4291           EB           2B            jmp .32C
14586                       00004293            .32A:
14587                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14588 4293           8A86       F813            mov	al,-$7ED[bp]
14589 4297           3C                     04  cmp	al,*4
14590 4299           73           12            jae 	.32D
14591                       0000429B            .32E:
14592                                           ! 2350     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14593                                           ! Debug: list int = const 0 (used reg = )
14594 429B           31C0                       xor	ax,ax
14595 429D           50                         push	ax
14596                                           ! Debug: list * unsigned char = const $25C (used reg = )
14597 429E           B8                   025C  mov	ax,#$25C
14598 42A1           50                         push	ax
14599                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14600 42A2           FF76         FE            push	-2[bp]
14601                                           ! Debug: func () void = write_byte+0 (used reg = )
14602 42A5           E8         C376            call	_write_byte
14603 42A8           83C4                   06  add	sp,*6
14604                                           !BCC_EOS
14605                                           ! 2351   else
14606                                           ! 2352     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14607 42AB           EB           11            jmp .32F
14608                       000042AD            .32D:
14609                                           ! Debug: list int = const $80 (used reg = )
14610 42AD           B8                   0080  mov	ax,#$80
14611 42B0           50                         push	ax
14612                                           ! Debug: list * unsigned char = const $25C (used reg = )
14613 42B1           B8                   025C  mov	ax,#$25C
14614 42B4           50                         push	ax
14615                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14616 42B5           FF76         FE            push	-2[bp]
14617                                           ! Debug: func () void = write_byte+0 (used reg = )
14618 42B8           E8         C363            call	_write_byte
14619 42BB           83C4                   06  add	sp,*6
14620                                           !BCC_EOS
14621                                           ! 2353   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
14622                       000042BE            .32F:
14623                       000042BE            .32C:
14624                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14625 42BE           8A86       F7E5            mov	al,-$81B[bp]
14626 42C2           30E4                       xor	ah,ah
14627 42C4           D1E8                       shr	ax,*1
14628                                           ! Debug: list unsigned int = ax+0 (used reg = )
14629 42C6           50                         push	ax
14630                                           ! Debug: list * unsigned char = const $25D (used reg = )
14631 42C7           B8                   025D  mov	ax,#$25D
14632 42CA           50                         push	ax
14633                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14634 42CB           FF76         FE            push	-2[bp]
14635                                           ! Debug: func () void = write_byte+0 (used reg = )
14636 42CE           E8         C34D            call	_write_byte
14637 42D1           83C4                   06  add	sp,*6
14638                                           !BCC_EOS
14639                                           ! 2354   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14640                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14641 42D4           8A86       F7E5            mov	al,-$81B[bp]
14642 42D8           30E4                       xor	ah,ah
14643 42DA           24                     01  and	al,*1
14644                                           ! Debug: list unsigned char = al+0 (used reg = )
14645 42DC           30E4                       xor	ah,ah
14646 42DE           50                         push	ax
14647                                           ! Debug: list * unsigned short = const $25E (used reg = )
14648 42DF           B8                   025E  mov	ax,#$25E
14649 42E2           50                         push	ax
14650                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14651 42E3           FF76         FE            push	-2[bp]
14652                                           ! Debug: func () void = write_byte+0 (used reg = )
14653 42E6           E8         C335            call	_write_byte
14654 42E9           83C4                   06  add	sp,*6
14655                                           !BCC_EOS
14656                                           ! 2355   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14657                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14658 42EC           8A86       F815            mov	al,-$7EB[bp]
14659 42F0           30E4                       xor	ah,ah
14660 42F2           B9                   0100  mov	cx,#$100
14661 42F5           F7E9                       imul	cx
14662                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14663 42F7           0286       F814            add	al,-$7EC[bp]
14664 42FB           80D4                   00  adc	ah,*0
14665                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14666 42FE           8986       F7EC            mov	-$814[bp],ax
14667                                           !BCC_EOS
14668                                           ! 2356   if(boot_segment==0x0000)boot_segment=0x07C0;
14669                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14670 4302           8B86       F7EC            mov	ax,-$814[bp]
14671 4306           85C0                       test	ax,ax
14672 4308           75           07            jne 	.330
14673                       0000430A            .331:
14674                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14675 430A           B8                   07C0  mov	ax,#$7C0
14676 430D           8986       F7EC            mov	-$814[bp],ax
14677                                           !BCC_EOS
14678                                           ! 2357   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14679                       00004311            .330:
14680                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14681 4311           FFB6       F7EC            push	-$814[bp]
14682                                           ! Debug: list * unsigned short = const $266 (used reg = )
14683 4315           B8                   0266  mov	ax,#$266
14684 4318           50                         push	ax
14685                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14686 4319           FF76         FE            push	-2[bp]
14687                                           ! Debug: func () void = write_word+0 (used reg = )
14688 431C           E8         C317            call	_write_word
14689 431F           83C4                   06  add	sp,*6
14690                                           !BCC_EOS
14691                                           ! 2358   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14692                                           ! Debug: list int = const 0 (used reg = )
14693 4322           31C0                       xor	ax,ax
14694 4324           50                         push	ax
14695                                           ! Debug: list * unsigned short = const $264 (used reg = )
14696 4325           B8                   0264  mov	ax,#$264
14697 4328           50                         push	ax
14698                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14699 4329           FF76         FE            push	-2[bp]
14700                                           ! Debug: func () void = write_word+0 (used reg = )
14701 432C           E8         C307            call	_write_word
14702 432F           83C4                   06  add	sp,*6
14703                                           !BCC_EOS
14704                                           ! 2359   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14705                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14706 4332           8A86       F819            mov	al,-$7E7[bp]
14707 4336           30E4                       xor	ah,ah
14708 4338           B9                   0100  mov	cx,#$100
14709 433B           F7E9                       imul	cx
14710                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
14711 433D           0286       F818            add	al,-$7E8[bp]
14712 4341           80D4                   00  adc	ah,*0
14713                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14714 4344           8986       F7EA            mov	-$816[bp],ax
14715                                           !BCC_EOS
14716                                           ! 2360   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
14717                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
14718 4348           FFB6       F7EA            push	-$816[bp]
14719                                           ! Debug: list * unsigned short = const $268 (used reg = )
14720 434C           B8                   0268  mov	ax,#$268
14721 434F           50                         push	ax
14722                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14723 4350           FF76         FE            push	-2[bp]
14724                                           ! Debug: func () void = write_word+0 (used reg = )
14725 4353           E8         C2E0            call	_write_word
14726 4356           83C4                   06  add	sp,*6
14727                                           !BCC_EOS
14728                                           ! 2361   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
14729                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
14730 4359           8A86       F81A            mov	al,-$7E6[bp]
14731 435D           30E4                       xor	ah,ah
14732 435F           31DB                       xor	bx,bx
14733 4361           53                         push	bx
14734 4362           50                         push	ax
14735                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
14736 4363           8A86       F81B            mov	al,-$7E5[bp]
14737 4367           30E4                       xor	ah,ah
14738 4369           B9                   0100  mov	cx,#$100
14739 436C           F7E9                       imul	cx
14740                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14741 436E           31DB                       xor	bx,bx
14742 4370           53                         push	bx
14743 4371           50                         push	ax
14744                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
14745 4372           8A86       F81C            mov	al,-$7E4[bp]
14746 4376           30E4                       xor	ah,ah
14747 4378           31DB                       xor	bx,bx
14748                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14749 437A           53                         push	bx
14750 437B           50                         push	ax
14751 437C           31C0                       xor	ax,ax
14752 437E           BB                   0001  mov	bx,*1
14753 4381           53                         push	bx
14754 4382           50                         push	ax
14755 4383           8B86       F7D8            mov	ax,-$828[bp]
14756 4387           8B9E       F7DA            mov	bx,-$826[bp]
14757 438B           8DBE       F7D4            lea	di,-$82C[bp]
14758 438F           E8         BD57            call	lmulul
14759 4392           83C4                   08  add	sp,*8
14760 4395           53                         push	bx
14761 4396           50                         push	ax
14762                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
14763 4397           8A86       F81D            mov	al,-$7E3[bp]
14764 439B           30E4                       xor	ah,ah
14765 439D           31DB                       xor	bx,bx
14766                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14767 439F           53                         push	bx
14768 43A0           50                         push	ax
14769 43A1           31C0                       xor	ax,ax
14770 43A3           BB                   0100  mov	bx,#$100
14771 43A6           53                         push	bx
14772 43A7           50                         push	ax
14773 43A8           8B86       F7D4            mov	ax,-$82C[bp]
14774 43AC           8B9E       F7D6            mov	bx,-$82A[bp]
14775 43B0           8DBE       F7D0            lea	di,-$830[bp]
14776 43B4           E8         BD32            call	lmulul
14777 43B7           83C4                   08  add	sp,*8
14778                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14779 43BA           8DBE       F7D8            lea	di,-$828[bp]
14780 43BE           E8         BD02            call	laddul
14781 43C1           83C4                   04  add	sp,*4
14782                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14783 43C4           8DBE       F7DC            lea	di,-$824[bp]
14784 43C8           E8         BCF8            call	laddul
14785 43CB           83C4                   04  add	sp,*4
14786                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14787 43CE           8DBE       F7E0            lea	di,-$820[bp]
14788 43D2           E8         BCEE            call	laddul
14789 43D5           83C4                   04  add	sp,*4
14790                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14791 43D8           8986       F7EE            mov	-$812[bp],ax
14792 43DC           899E       F7F0            mov	-$810[bp],bx
14793                                           !BCC_EOS
14794                                           ! 2362   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
14795                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
14796 43E0           FFB6       F7F0            push	-$810[bp]
14797 43E4           FFB6       F7EE            push	-$812[bp]
14798                                           ! Debug: list * unsigned long = const $260 (used reg = )
14799 43E8           B8                   0260  mov	ax,#$260
14800 43EB           50                         push	ax
14801                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
14802 43EC           FF76         FE            push	-2[bp]
14803                                           ! Debug: func () void = write_dword+0 (used reg = )
14804 43EF           E8         BCA9            call	_write_dword
14805 43F2           83C4                   08  add	sp,*8
14806                                           !BCC_EOS
14807                                           ! 2363   memsetb(get_SS(),atacmd,0,12);
14808                                           ! Debug: list int = const $C (used reg = )
14809 43F5           B8                   000C  mov	ax,*$C
14810 43F8           50                         push	ax
14811                                           ! Debug: list int = const 0 (used reg = )
14812 43F9           31C0                       xor	ax,ax
14813 43FB           50                         push	ax
14814                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14815 43FC           8D5E         F2            lea	bx,-$E[bp]
14816 43FF           53                         push	bx
14817                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14818 4400           E8         C24E            call	_get_SS
14819                                           ! Debug: list unsigned short = ax+0 (used reg = )
14820 4403           50                         push	ax
14821                                           ! Debug: func () void = memsetb+0 (used reg = )
14822 4404           E8         BBF9            call	_memsetb
14823 4407           83C4                   08  add	sp,*8
14824                                           !BCC_EOS
14825                                           ! 2364   atacmd[0]=0x28;
14826                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14827 440A           B0                     28  mov	al,*$28
14828 440C           8846         F2            mov	-$E[bp],al
14829                                           !BCC_EOS
14830                                           ! 2365   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
14831                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14832 440F           8B86       F7EA            mov	ax,-$816[bp]
14833                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14834 4413           48                         dec	ax
14835 4414           D1E8                       shr	ax,*1
14836 4416           D1E8                       shr	ax,*1
14837                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14838                                           ! Debug: expression subtree swapping
14839                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
14840 4418           40                         inc	ax
14841 4419           30C0                       xor	al,al
14842                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
14843 441B           88E0                       mov	al,ah
14844 441D           30E4                       xor	ah,ah
14845                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14846 441F           8846         F9            mov	-7[bp],al
14847                                           !BCC_EOS
14848                                           ! 2366   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
14849                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14850 4422           8B86       F7EA            mov	ax,-$816[bp]
14851                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14852 4426           48                         dec	ax
14853 4427           D1E8                       shr	ax,*1
14854 4429           D1E8                       shr	ax,*1
14855                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14856                                           ! Debug: expression subtree swapping
14857                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
14858 442B           40                         inc	ax
14859                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
14860 442C           8846         FA            mov	-6[bp],al
14861                                           !BCC_EOS
14862                                           ! 2367   atacmd[2]=(lba & 0xff000000) >> 24;
14863                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14864                                           ! Debug: expression subtree swapping
14865 442F           31C0                       xor	ax,ax
14866 4431           BB                   FF00  mov	bx,#$FF00
14867 4434           8DBE       F7EE            lea	di,-$812[bp]
14868 4438           E8         BC80            call	landul
14869                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14870 443B           93                         xchg	bx,ax
14871 443C           88E0                       mov	al,ah
14872 443E           30E4                       xor	ah,ah
14873 4440           31DB                       xor	bx,bx
14874                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14875 4442           8846         F4            mov	-$C[bp],al
14876                                           !BCC_EOS
14877                                           ! 2368   atacmd[3]=(lba & 0x00ff0000) >> 16;
14878                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14879                                           ! Debug: expression subtree swapping
14880 4445           31C0                       xor	ax,ax
14881 4447           BB                   00FF  mov	bx,#$FF
14882 444A           8DBE       F7EE            lea	di,-$812[bp]
14883 444E           E8         BC6A            call	landul
14884                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14885 4451           93                         xchg	bx,ax
14886 4452           31DB                       xor	bx,bx
14887                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14888 4454           8846         F5            mov	-$B[bp],al
14889                                           !BCC_EOS
14890                                           ! 2369   atacmd[4]=(lba & 0x0000ff00) >> 8;
14891                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14892                                           ! Debug: expression subtree swapping
14893 4457           B8                   FF00  mov	ax,#$FF00
14894 445A           31DB                       xor	bx,bx
14895 445C           8DBE       F7EE            lea	di,-$812[bp]
14896 4460           E8         BC58            call	landul
14897                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14898 4463           88E0                       mov	al,ah
14899 4465           88DC                       mov	ah,bl
14900 4467           88FB                       mov	bl,bh
14901 4469           28FF                       sub	bh,bh
14902                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14903 446B           8846         F6            mov	-$A[bp],al
14904                                           !BCC_EOS
14905                                           ! 2370   atacmd[5]=(lba & 0x000000ff);
14906                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14907                                           ! Debug: expression subtree swapping
14908 446E           B8                   00FF  mov	ax,#$FF
14909 4471           31DB                       xor	bx,bx
14910 4473           8DBE       F7EE            lea	di,-$812[bp]
14911 4477           E8         BC41            call	landul
14912                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14913 447A           8846         F7            mov	-9[bp],al
14914                                           !BCC_EOS
14915                                           ! 2371   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
14916                                           ! Debug: list int = const 0 (used reg = )
14917 447D           31C0                       xor	ax,ax
14918 447F           50                         push	ax
14919                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
14920 4480           FFB6       F7EC            push	-$814[bp]
14921                                           ! Debug: list int = const 1 (used reg = )
14922 4484           B8                   0001  mov	ax,*1
14923 4487           50                         push	ax
14924                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
14925 4488           8B86       F7EA            mov	ax,-$816[bp]
14926 448C           31DB                       xor	bx,bx
14927                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
14928 448E           53                         push	bx
14929 448F           50                         push	ax
14930 4490           B8                   0200  mov	ax,#$200
14931 4493           31DB                       xor	bx,bx
14932 4495           53                         push	bx
14933 4496           50                         push	ax
14934 4497           8B86       F7DA            mov	ax,-$826[bp]
14935 449B           8B9E       F7DC            mov	bx,-$824[bp]
14936 449F           8DBE       F7D6            lea	di,-$82A[bp]
14937 44A3           E8         BC43            call	lmulul
14938 44A6           83C4                   08  add	sp,*8
14939                                           ! Debug: list unsigned long = bx+0 (used reg = )
14940 44A9           53                         push	bx
14941 44AA           50                         push	ax
14942                                           ! Debug: list int = const 0 (used reg = )
14943 44AB           31C0                       xor	ax,ax
14944 44AD           50                         push	ax
14945                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14946 44AE           8D5E         F2            lea	bx,-$E[bp]
14947 44B1           53                         push	bx
14948                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14949 44B2           E8         C19C            call	_get_SS
14950                                           ! Debug: list unsigned short = ax+0 (used reg = )
14951 44B5           50                         push	ax
14952                                           ! Debug: list int = const $C (used reg = )
14953 44B6           B8                   000C  mov	ax,*$C
14954 44B9           50                         push	ax
14955                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14956 44BA           8A86       F7E5            mov	al,-$81B[bp]
14957 44BE           30E4                       xor	ah,ah
14958 44C0           50                         push	ax
14959                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14960 44C1           E8         F123            call	_ata_cmd_packet
14961 44C4           83C4                   14  add	sp,*$14
14962                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14963 44C7           8986       F7E6            mov	-$81A[bp],ax
14964                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14965 44CB           85C0                       test	ax,ax
14966 44CD           74           07            je  	.332
14967                       000044CF            .333:
14968                                           ! 2372     return 12;
14969 44CF           B8                   000C  mov	ax,*$C
14970 44D2           89EC                       mov	sp,bp
14971 44D4           5D                         pop	bp
14972 44D5           C3                         ret
14973                                           !BCC_EOS
14974                                           ! 2373   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
14975                       000044D6            .332:
14976                                           ! Debug: list * unsigned char = const $25B (used reg = )
14977 44D6           B8                   025B  mov	ax,#$25B
14978 44D9           50                         push	ax
14979                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
14980 44DA           FF76         FE            push	-2[bp]
14981                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14982 44DD           E8         C118            call	_read_byte
14983 44E0           83C4                   04  add	sp,*4
14984 44E3           E9         0120            br 	.336
14985                                           ! 2374     case 0x01:
14986                                           ! 2375       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
14987                       000044E6            .337:
14988                                           ! Debug: list int = const $F (used reg = )
14989 44E6           B8                   000F  mov	ax,*$F
14990 44E9           50                         push	ax
14991                                           ! Debug: list * unsigned short = const $26E (used reg = )
14992 44EA           B8                   026E  mov	ax,#$26E
14993 44ED           50                         push	ax
14994                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14995 44EE           FF76         FE            push	-2[bp]
14996                                           ! Debug: func () void = write_word+0 (used reg = )
14997 44F1           E8         C142            call	_write_word
14998 44F4           83C4                   06  add	sp,*6
14999                                           !BCC_EOS
15000                                           ! 2376       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15001                                           ! Debug: list int = const $50 (used reg = )
15002 44F7           B8                   0050  mov	ax,*$50
15003 44FA           50                         push	ax
15004                                           ! Debug: list * unsigned short = const $26C (used reg = )
15005 44FB           B8                   026C  mov	ax,#$26C
15006 44FE           50                         push	ax
15007                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15008 44FF           FF76         FE            push	-2[bp]
15009                                           ! Debug: func () void = write_word+0 (used reg = )
15010 4502           E8         C131            call	_write_word
15011 4505           83C4                   06  add	sp,*6
15012                                           !BCC_EOS
15013                                           ! 2377       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15014                                           ! Debug: list int = const 2 (used reg = )
15015 4508           B8                   0002  mov	ax,*2
15016 450B           50                         push	ax
15017                                           ! Debug: list * unsigned short = const $26A (used reg = )
15018 450C           B8                   026A  mov	ax,#$26A
15019 450F           50                         push	ax
15020                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15021 4510           FF76         FE            push	-2[bp]
15022                                           ! Debug: func () void = write_word+0 (used reg = )
15023 4513           E8         C120            call	_write_word
15024 4516           83C4                   06  add	sp,*6
15025                                           !BCC_EOS
15026                                           ! 2378       break;
15027 4519           E9         0102            br 	.334
15028                                           !BCC_EOS
15029                                           ! 2379     case 0x02:
15030                                           ! 2380       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
15031                       0000451C            .338:
15032                                           ! Debug: list int = const $12 (used reg = )
15033 451C           B8                   0012  mov	ax,*$12
15034 451F           50                         push	ax
15035                                           ! Debug: list * unsigned short = const $26E (used reg = )
15036 4520           B8                   026E  mov	ax,#$26E
15037 4523           50                         push	ax
15038                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15039 4524           FF76         FE            push	-2[bp]
15040                                           ! Debug: func () void = write_word+0 (used reg = )
15041 4527           E8         C10C            call	_write_word
15042 452A           83C4                   06  add	sp,*6
15043                                           !BCC_EOS
15044                                           ! 2381       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15045                                           ! Debug: list int = const $50 (used reg = )
15046 452D           B8                   0050  mov	ax,*$50
15047 4530           50                         push	ax
15048                                           ! Debug: list * unsigned short = const $26C (used reg = )
15049 4531           B8                   026C  mov	ax,#$26C
15050 4534           50                         push	ax
15051                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15052 4535           FF76         FE            push	-2[bp]
15053                                           ! Debug: func () void = write_word+0 (used reg = )
15054 4538           E8         C0FB            call	_write_word
15055 453B           83C4                   06  add	sp,*6
15056                                           !BCC_EOS
15057                                           ! 2382       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15058                                           ! Debug: list int = const 2 (used reg = )
15059 453E           B8                   0002  mov	ax,*2
15060 4541           50                         push	ax
15061                                           ! Debug: list * unsigned short = const $26A (used reg = )
15062 4542           B8                   026A  mov	ax,#$26A
15063 4545           50                         push	ax
15064                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15065 4546           FF76         FE            push	-2[bp]
15066                                           ! Debug: func () void = write_word+0 (used reg = )
15067 4549           E8         C0EA            call	_write_word
15068 454C           83C4                   06  add	sp,*6
15069                                           !BCC_EOS
15070                                           ! 2383       break;
15071 454F           E9         00CC            br 	.334
15072                                           !BCC_EOS
15073                                           ! 2384     case 0x03:
15074                                           ! 2385       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
15075                       00004552            .339:
15076                                           ! Debug: list int = const $24 (used reg = )
15077 4552           B8                   0024  mov	ax,*$24
15078 4555           50                         push	ax
15079                                           ! Debug: list * unsigned short = const $26E (used reg = )
15080 4556           B8                   026E  mov	ax,#$26E
15081 4559           50                         push	ax
15082                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15083 455A           FF76         FE            push	-2[bp]
15084                                           ! Debug: func () void = write_word+0 (used reg = )
15085 455D           E8         C0D6            call	_write_word
15086 4560           83C4                   06  add	sp,*6
15087                                           !BCC_EOS
15088                                           ! 2386       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevi
15089                                           ! 2386 ce.cylinders,80);
15090                                           ! Debug: list int = const $50 (used reg = )
15091 4563           B8                   0050  mov	ax,*$50
15092 4566           50                         push	ax
15093                                           ! Debug: list * unsigned short = const $26C (used reg = )
15094 4567           B8                   026C  mov	ax,#$26C
15095 456A           50                         push	ax
15096                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15097 456B           FF76         FE            push	-2[bp]
15098                                           ! Debug: func () void = write_word+0 (used reg = )
15099 456E           E8         C0C5            call	_write_word
15100 4571           83C4                   06  add	sp,*6
15101                                           !BCC_EOS
15102                                           ! 2387       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15103                                           ! Debug: list int = const 2 (used reg = )
15104 4574           B8                   0002  mov	ax,*2
15105 4577           50                         push	ax
15106                                           ! Debug: list * unsigned short = const $26A (used reg = )
15107 4578           B8                   026A  mov	ax,#$26A
15108 457B           50                         push	ax
15109                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15110 457C           FF76         FE            push	-2[bp]
15111                                           ! Debug: func () void = write_word+0 (used reg = )
15112 457F           E8         C0B4            call	_write_word
15113 4582           83C4                   06  add	sp,*6
15114                                           !BCC_EOS
15115                                           ! 2388       break;
15116 4585           E9         0096            br 	.334
15117                                           !BCC_EOS
15118                                           ! 2389     case 0x04:
15119                                           ! 2390       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
15120                       00004588            .33A:
15121                                           ! Debug: list int = const $1C4 (used reg = )
15122 4588           B8                   01C4  mov	ax,#$1C4
15123 458B           50                         push	ax
15124                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15125 458C           FFB6       F7EC            push	-$814[bp]
15126                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15127 4590           E8         C065            call	_read_byte
15128 4593           83C4                   04  add	sp,*4
15129                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15130 4596           24                     3F  and	al,*$3F
15131                                           ! Debug: list unsigned char = al+0 (used reg = )
15132 4598           30E4                       xor	ah,ah
15133 459A           50                         push	ax
15134                                           ! Debug: list * unsigned short = const $26E (used reg = )
15135 459B           B8                   026E  mov	ax,#$26E
15136 459E           50                         push	ax
15137                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15138 459F           FF76         FE            push	-2[bp]
15139                                           ! Debug: func () void = write_word+0 (used reg = )
15140 45A2           E8         C091            call	_write_word
15141 45A5           83C4                   06  add	sp,*6
15142                                           !BCC_EOS
15143                                           ! 2391       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15144                                           ! 2392               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15145                                           ! Debug: list int = const $1C5 (used reg = )
15146 45A8           B8                   01C5  mov	ax,#$1C5
15147 45AB           50                         push	ax
15148                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15149 45AC           FFB6       F7EC            push	-$814[bp]
15150                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15151 45B0           E8         C045            call	_read_byte
15152 45B3           83C4                   04  add	sp,*4
15153 45B6           50                         push	ax
15154                                           ! Debug: list int = const $1C4 (used reg = )
15155 45B7           B8                   01C4  mov	ax,#$1C4
15156 45BA           50                         push	ax
15157                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15158 45BB           FFB6       F7EC            push	-$814[bp]
15159                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15160 45BF           E8         C036            call	_read_byte
15161 45C2           83C4                   04  add	sp,*4
15162                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15163 45C5           30E4                       xor	ah,ah
15164 45C7           D1E0                       shl	ax,*1
15165 45C9           D1E0                       shl	ax,*1
15166                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15167 45CB           0286       F7E2            add	al,0+..FFF9[bp]
15168 45CF           80D4                   00  adc	ah,*0
15169 45D2           44                         inc	sp
15170 45D3           44                         inc	sp
15171                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15172                                           ! Debug: list unsigned int = ax+1 (used reg = )
15173 45D4           40                         inc	ax
15174 45D5           50                         push	ax
15175                                           ! Debug: list * unsigned short = const $26C (used reg = )
15176 45D6           B8                   026C  mov	ax,#$26C
15177 45D9           50                         push	ax
15178                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15179 45DA           FF76         FE            push	-2[bp]
15180                                           ! Debug: func () void = write_word+0 (used reg = )
15181 45DD           E8         C056            call	_write_word
15182 45E0           83C4                   06  add	sp,*6
15183                                           !BCC_EOS
15184                                           ! 2393       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15185                                           ! Debug: list int = const $1C3 (used reg = )
15186 45E3           B8                   01C3  mov	ax,#$1C3
15187 45E6           50                         push	ax
15188                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15189 45E7           FFB6       F7EC            push	-$814[bp]
15190                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15191 45EB           E8         C00A            call	_read_byte
15192 45EE           83C4                   04  add	sp,*4
15193                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15194 45F1           30E4                       xor	ah,ah
15195                                           ! Debug: list unsigned int = ax+1 (used reg = )
15196 45F3           40                         inc	ax
15197 45F4           50                         push	ax
15198                                           ! Debug: list * unsigned short = const $26A (used reg = )
15199 45F5           B8                   026A  mov	ax,#$26A
15200 45F8           50                         push	ax
15201                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15202 45F9           FF76         FE            push	-2[bp]
15203                                           ! Debug: func () void = write_word+0 (used reg = )
15204 45FC           E8         C037            call	_write_word
15205 45FF           83C4                   06  add	sp,*6
15206                                           !BCC_EOS
15207                                           ! 2394       break;
15208 4602           EB           1A            jmp .334
15209                                           !BCC_EOS
15210                                           ! 2395    }
15211                                           ! 2396   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15212 4604           EB           18            jmp .334
15213                       00004606            .336:
15214 4606           2C                     01  sub	al,*1
15215 4608         0F84         FEDA            beq 	.337
15216 460C           2C                     01  sub	al,*1
15217 460E         0F84         FF0A            beq 	.338
15218 4612           2C                     01  sub	al,*1
15219 4614         0F84         FF3A            beq 	.339
15220 4618           2C                     01  sub	al,*1
15221 461A         0F84         FF6A            beq 	.33A
15222                       0000461E            .334:
15223                       FFFFF7E2            ..FFF9	=	-$81E
15224                                           ! Debug: list * unsigned char = const $25B (used reg = )
15225 461E           B8                   025B  mov	ax,#$25B
15226 4621           50                         push	ax
15227                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15228 4622           FF76         FE            push	-2[bp]
15229                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15230 4625           E8         BFD0            call	_read_byte
15231 4628           83C4                   04  add	sp,*4
15232                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15233 462B           84C0                       test	al,al
15234 462D           74           52            je  	.33B
15235                       0000462F            .33C:
15236                                           ! 2397     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15237                                           ! Debug: list * unsigned char = const $25C (used reg = )
15238 462F           B8                   025C  mov	ax,#$25C
15239 4632           50                         push	ax
15240                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15241 4633           FF76         FE            push	-2[bp]
15242                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15243 4636           E8         BFBF            call	_read_byte
15244 4639           83C4                   04  add	sp,*4
15245                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15246 463C           84C0                       test	al,al
15247 463E           75           23            jne 	.33D
15248                       00004640            .33E:
15249                                           ! 2398       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15250                                           ! Debug: list int = const $10 (used reg = )
15251 4640           B8                   0010  mov	ax,*$10
15252 4643           50                         push	ax
15253                                           ! Debug: list int = const $40 (used reg = )
15254 4644           B8                   0040  mov	ax,*$40
15255 4647           50                         push	ax
15256                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15257 4648           E8         BFAD            call	_read_byte
15258 464B           83C4                   04  add	sp,*4
15259                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15260 464E           0C                     41  or	al,*$41
15261                                           ! Debug: list unsigned char = al+0 (used reg = )
15262 4650           30E4                       xor	ah,ah
15263 4652           50                         push	ax
15264                                           ! Debug: list int = const $10 (used reg = )
15265 4653           B8                   0010  mov	ax,*$10
15266 4656           50                         push	ax
15267                                           ! Debug: list int = const $40 (used reg = )
15268 4657           B8                   0040  mov	ax,*$40
15269 465A           50                         push	ax
15270                                           ! Debug: func () void = write_byte+0 (used reg = )
15271 465B           E8         BFC0            call	_write_byte
15272 465E           83C4                   06  add	sp,*6
15273                                           !BCC_EOS
15274                                           ! 2399     else
15275                                           ! 2400       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15276 4661           EB           1E            jmp .33F
15277                       00004663            .33D:
15278                                           ! Debug: list * unsigned char = const $232 (used reg = )
15279 4663           B8                   0232  mov	ax,#$232
15280 4666           50                         push	ax
15281                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15282 4667           FF76         FE            push	-2[bp]
15283                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15284 466A           E8         BF8B            call	_read_byte
15285 466D           83C4                   04  add	sp,*4
15286                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15287 4670           30E4                       xor	ah,ah
15288                                           ! Debug: list unsigned int = ax+1 (used reg = )
15289 4672           40                         inc	ax
15290 4673           50                         push	ax
15291                                           ! Debug: list * unsigned char = const $232 (used reg = )
15292 4674           B8                   0232  mov	ax,#$232
15293 4677           50                         push	ax
15294                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15295 4678           FF76         FE            push	-2[bp]
15296                                           ! Debug: func () void = write_byte+0 (used reg = )
15297 467B           E8         BFA0            call	_write_byte
15298 467E           83C4                   06  add	sp,*6
15299                                           !BCC_EOS
15300                                           ! 2401   }
15301                       00004681            .33F:
15302                                           ! 2402   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15303                       00004681            .33B:
15304                                           ! Debug: list * unsigned char = const $25B (used reg = )
15305 4681           B8                   025B  mov	ax,#$25B
15306 4684           50                         push	ax
15307                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15308 4685           FF76         FE            push	-2[bp]
15309                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15310 4688           E8         BF6D            call	_read_byte
15311 468B           83C4                   04  add	sp,*4
15312                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15313 468E           84C0                       test	al,al
15314 4690           74           11            je  	.340
15315                       00004692            .341:
15316                                           ! 2403     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15317                                           ! Debug: list int = const 1 (used reg = )
15318 4692           B8                   0001  mov	ax,*1
15319 4695           50                         push	ax
15320                                           ! Debug: list * unsigned char = const $25A (used reg = )
15321 4696           B8                   025A  mov	ax,#$25A
15322 4699           50                         push	ax
15323                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15324 469A           FF76         FE            push	-2[bp]
15325                                           ! Debug: func () void = write_byte+0 (used reg = )
15326 469D           E8         BF7E            call	_write_byte
15327 46A0           83C4                   06  add	sp,*6
15328                                           !BCC_EOS
15329                                           ! 2404   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15330                       000046A3            .340:
15331                                           ! Debug: list * unsigned char = const $25C (used reg = )
15332 46A3           B8                   025C  mov	ax,#$25C
15333 46A6           50                         push	ax
15334                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15335 46A7           FF76         FE            push	-2[bp]
15336                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15337 46AA           E8         BF4B            call	_read_byte
15338 46AD           83C4                   04  add	sp,*4
15339                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15340 46B0           30E4                       xor	ah,ah
15341 46B2           B9                   0100  mov	cx,#$100
15342 46B5           F7E9                       imul	cx
15343                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15344                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15345 46B7           89EC                       mov	sp,bp
15346 46B9           5D                         pop	bp
15347 46BA           C3                         ret
15348                                           !BCC_EOS
15349                                           ! 2405 }
15350                                           ! 2406 void int14_function(regs, ds, iret_addr)
15351                                           ! Register BX used in function cdrom_boot
15352                                           ! 2407   pusha_regs_t regs;
15353                                           export	_int14_function
15354                       000046BB            _int14_function:
15355                                           !BCC_EOS
15356                                           ! 2408   Bit16u ds;
15357                                           !BCC_EOS
15358                                           ! 2409   iret_addr_t iret_addr;
15359                                           !BCC_EOS
15360                                           ! 2410 {
15361                                           ! 2411   Bit16u addr,timer,val16;
15362                                           !BCC_EOS
15363                                           ! 2412   Bit8u counter;
15364                                           !BCC_EOS
15365                                           ! 2413 #asm
15366 46BB           55                         push	bp
15367 46BC           89E5                       mov	bp,sp
15368 46BE           83C4                   F8  add	sp,*-8
15369                                           !BCC_EOS
15370                                           !BCC_ASM
15371                       0000001C            _int14_function.ds	set	$1C
15372                       00000014            .int14_function.ds	set	$14
15373                       00000001            _int14_function.counter	set	1
15374                       FFFFFFF9            .int14_function.counter	set	-7
15375                       00000004            _int14_function.timer	set	4
15376                       FFFFFFFC            .int14_function.timer	set	-4
15377                       0000001E            _int14_function.iret_addr	set	$1E
15378                       00000016            .int14_function.iret_addr	set	$16
15379                       00000006            _int14_function.addr	set	6
15380                       FFFFFFFE            .int14_function.addr	set	-2
15381                       00000002            _int14_function.val16	set	2
15382                       FFFFFFFA            .int14_function.val16	set	-6
15383                       0000000C            _int14_function.regs	set	$C
15384                       00000004            .int14_function.regs	set	4
15385 46C1           FB                           sti
15386                                           ! 2415 endasm
15387                                           !BCC_ENDASM
15388                                           !BCC_EOS
15389                                           ! 2416   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15390                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15391 46C2           8B46         0E            mov	ax,$E[bp]
15392 46C5           D1E0                       shl	ax,*1
15393                                           ! Debug: list unsigned int = ax+0 (used reg = )
15394 46C7           50                         push	ax
15395                                           ! Debug: list int = const $40 (used reg = )
15396 46C8           B8                   0040  mov	ax,*$40
15397 46CB           50                         push	ax
15398                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15399 46CC           E8         BF3C            call	_read_word
15400 46CF           83C4                   04  add	sp,*4
15401                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15402 46D2           8946         FE            mov	-2[bp],ax
15403                                           !BCC_EOS
15404                                           ! 2417   counter = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15405                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15406                                           ! Debug: expression subtree swapping
15407 46D5           8B46         0E            mov	ax,$E[bp]
15408                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15409 46D8           05                   007C  add	ax,*$7C
15410 46DB           50                         push	ax
15411                                           ! Debug: list int = const $40 (used reg = )
15412 46DC           B8                   0040  mov	ax,*$40
15413 46DF           50                         push	ax
15414                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15415 46E0           E8         BF15            call	_read_byte
15416 46E3           83C4                   04  add	sp,*4
15417                                           ! Debug: eq unsigned char = al+0 to unsigned char counter = [S+$A-9] (used reg = )
15418 46E6           8846         F9            mov	-7[bp],al
15419                                           !BCC_EOS
15420                                           ! 2418   if ((regs.u.r16.dx < 4) && (addr > 0)) {
15421                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15422 46E9           8B46         0E            mov	ax,$E[bp]
15423 46EC           3D                   0004  cmp	ax,*4
15424 46EF         0F83         0224            bhis	.342
15425                       000046F3            .344:
15426                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15427 46F3           8B46         FE            mov	ax,-2[bp]
15428 46F6           85C0                       test	ax,ax
15429 46F8         0F84         021B            beq 	.342
15430                       000046FC            .343:
15431                                           ! 2419     switch (regs.u.r8.ah) {
15432 46FC           8A46         13            mov	al,$13[bp]
15433 46FF           E9         01FB            br 	.347
15434                                           ! 2420       case 0:
15435                                           ! 2421         outb(addr+3, inb(addr+3) | 0x80);
15436                       00004702            .348:
15437                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15438 4702           8B46         FE            mov	ax,-2[bp]
15439                                           ! Debug: list unsigned int = ax+3 (used reg = )
15440 4705           05                   0003  add	ax,*3
15441 4708           50                         push	ax
15442                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15443 4709           E8         BE36            call	_inb
15444 470C           44                         inc	sp
15445 470D           44                         inc	sp
15446                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15447 470E           0C                     80  or	al,#$80
15448                                           ! Debug: list unsigned char = al+0 (used reg = )
15449 4710           30E4                       xor	ah,ah
15450 4712           50                         push	ax
15451                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15452 4713           8B46         FE            mov	ax,-2[bp]
15453                                           ! Debug: list unsigned int = ax+3 (used reg = )
15454 4716           05                   0003  add	ax,*3
15455 4719           50                         push	ax
15456                                           ! Debug: func () void = outb+0 (used reg = )
15457 471A           E8         BE3B            call	_outb
15458 471D           83C4                   04  add	sp,*4
15459                                           !BCC_EOS
15460                                           ! 2422         if (regs.u.r8.al & 0xE0 == 0) {
15461                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15462 4720           8A46         12            mov	al,$12[bp]
15463 4723           30C0                       xor	al,al
15464 4725           84C0                       test	al,al
15465 4727           74           1E            je  	.349
15466                       00004729            .34A:
15467                                           ! 2423           outb(addr, 0x17);
15468                                           ! Debug: list int = const $17 (used reg = )
15469 4729           B8                   0017  mov	ax,*$17
15470 472C           50                         push	ax
15471                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15472 472D           FF76         FE            push	-2[bp]
15473                                           ! Debug: func () void = outb+0 (used reg = )
15474 4730           E8         BE25            call	_outb
15475 4733           83C4                   04  add	sp,*4
15476                                           !BCC_EOS
15477                                           ! 2424           outb(addr+1, 0x04);
15478                                           ! Debug: list int = const 4 (used reg = )
15479 4736           B8                   0004  mov	ax,*4
15480 4739           50                         push	ax
15481                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15482 473A           8B46         FE            mov	ax,-2[bp]
15483                                           ! Debug: list unsigned int = ax+1 (used reg = )
15484 473D           40                         inc	ax
15485 473E           50                         push	ax
15486                                           ! Debug: func () void = outb+0 (used reg = )
15487 473F           E8         BE16            call	_outb
15488 4742           83C4                   04  add	sp,*4
15489                                           !BCC_EOS
15490                                           ! 2425         } else {
15491 4745           EB           39            jmp .34B
15492                       00004747            .349:
15493                                           ! 2426           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15494                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15495 4747           8A46         12            mov	al,$12[bp]
15496 474A           24                     E0  and	al,#$E0
15497                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15498 474C           30E4                       xor	ah,ah
15499 474E           B1                     05  mov	cl,*5
15500 4750           D3E8                       shr	ax,cl
15501                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15502 4752           89C3                       mov	bx,ax
15503 4754           B8                   0600  mov	ax,#$600
15504 4757           89D9                       mov	cx,bx
15505 4759           D3F8                       sar	ax,cl
15506                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15507 475B           8946         FA            mov	-6[bp],ax
15508                                           !BCC_EOS
15509                                           ! 2427           outb(addr, val16 & 0xFF);
15510                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15511 475E           8A46         FA            mov	al,-6[bp]
15512                                           ! Debug: list unsigned char = al+0 (used reg = )
15513 4761           30E4                       xor	ah,ah
15514 4763           50                         push	ax
15515                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15516 4764           FF76         FE            push	-2[bp]
15517                                           ! Debug: func () void = outb+0 (used reg = )
15518 4767           E8         BDEE            call	_outb
15519 476A           83C4                   04  add	sp,*4
15520                                           !BCC_EOS
15521                                           ! 2428           outb(addr+1, val16 >> 8);
15522                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15523 476D           8B46         FA            mov	ax,-6[bp]
15524 4770           88E0                       mov	al,ah
15525 4772           30E4                       xor	ah,ah
15526                                           ! Debug: list unsigned int = ax+0 (used reg = )
15527 4774           50                         push	ax
15528                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15529 4775           8B46         FE            mov	ax,-2[bp]
15530                                           ! Debug: list unsigned int = ax+1 (used reg = )
15531 4778           40                         inc	ax
15532 4779           50                         push	ax
15533                                           ! Debug: func () void = outb+0 (used reg = )
15534 477A           E8         BDDB            call	_outb
15535 477D           83C4                   04  add	sp,*4
15536                                           !BCC_EOS
15537                                           ! 2429         }
15538                                           ! 2430         outb(addr+3, regs.u.r8.al & 0x1F);
15539                       00004780            .34B:
15540                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15541 4780           8A46         12            mov	al,$12[bp]
15542 4783           24                     1F  and	al,*$1F
15543                                           ! Debug: list unsigned char = al+0 (used reg = )
15544 4785           30E4                       xor	ah,ah
15545 4787           50                         push	ax
15546                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15547 4788           8B46         FE            mov	ax,-2[bp]
15548                                           ! Debug: list unsigned int = ax+3 (used reg = )
15549 478B           05                   0003  add	ax,*3
15550 478E           50                         push	ax
15551                                           ! Debug: func () void = outb+0 (used reg = )
15552 478F           E8         BDC6            call	_outb
15553 4792           83C4                   04  add	sp,*4
15554                                           !BCC_EOS
15555                                           ! 2431         regs.u.r8.ah = inb(addr+5);
15556                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15557 4795           8B46         FE            mov	ax,-2[bp]
15558                                           ! Debug: list unsigned int = ax+5 (used reg = )
15559 4798           05                   0005  add	ax,*5
15560 479B           50                         push	ax
15561                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15562 479C           E8         BDA3            call	_inb
15563 479F           44                         inc	sp
15564 47A0           44                         inc	sp
15565                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15566 47A1           8846         13            mov	$13[bp],al
15567                                           !BCC_EOS
15568                                           ! 2432         regs.u.r8.al = inb(addr+6);
15569                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15570 47A4           8B46         FE            mov	ax,-2[bp]
15571                                           ! Debug: list unsigned int = ax+6 (used reg = )
15572 47A7           05                   0006  add	ax,*6
15573 47AA           50                         push	ax
15574                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15575 47AB           E8         BD94            call	_inb
15576 47AE           44                         inc	sp
15577 47AF           44                         inc	sp
15578                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15579 47B0           8846         12            mov	$12[bp],al
15580                                           !BCC_EOS
15581                                           ! 2433         iret_addr.flags.u.r8.flagsl &= 0xfe;
15582                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15583 47B3           8A46         1A            mov	al,$1A[bp]
15584 47B6           24                     FE  and	al,#$FE
15585 47B8           8846         1A            mov	$1A[bp],al
15586                                           !BCC_EOS
15587                                           ! 2434         break;
15588 47BB           E9         0157            br 	.345
15589                                           !BCC_EOS
15590                                           ! 2435       case 1:
15591                                           ! 2436         timer = read_word(0x0040, 0x006C);
15592                       000047BE            .34C:
15593                                           ! Debug: list int = const $6C (used reg = )
15594 47BE           B8                   006C  mov	ax,*$6C
15595 47C1           50                         push	ax
15596                                           ! Debug: list int = const $40 (used reg = )
15597 47C2           B8                   0040  mov	ax,*$40
15598 47C5           50                         push	ax
15599                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15600 47C6           E8         BE42            call	_read_word
15601 47C9           83C4                   04  add	sp,*4
15602                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15603 47CC           8946         FC            mov	-4[bp],ax
15604                                           !BCC_EOS
15605                                           ! 2437         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
15606 47CF           EB           26            jmp .34E
15607                       000047D1            .34F:
15608                                           ! 2438           val16 = read_word(0x0040, 0x006C);
15609                                           ! Debug: list int = const $6C (used reg = )
15610 47D1           B8                   006C  mov	ax,*$6C
15611 47D4           50                         push	ax
15612                                           ! Debug: list int = const $40 (used reg = )
15613 47D5           B8                   0040  mov	ax,*$40
15614 47D8           50                         push	ax
15615                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15616 47D9           E8         BE2F            call	_read_word
15617 47DC           83C4                   04  add	sp,*4
15618                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15619 47DF           8946         FA            mov	-6[bp],ax
15620                                           !BCC_EOS
15621                                           ! 2439         
15622                                           ! 2439   if (val16 != timer) {
15623                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15624 47E2           8B46         FA            mov	ax,-6[bp]
15625 47E5           3B46         FC            cmp	ax,-4[bp]
15626 47E8           74           0D            je  	.350
15627                       000047EA            .351:
15628                                           ! 2440             timer = val16;
15629                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15630 47EA           8B46         FA            mov	ax,-6[bp]
15631 47ED           8946         FC            mov	-4[bp],ax
15632                                           !BCC_EOS
15633                                           ! 2441             counter--;
15634                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
15635 47F0           8A46         F9            mov	al,-7[bp]
15636 47F3           48                         dec	ax
15637 47F4           8846         F9            mov	-7[bp],al
15638                                           !BCC_EOS
15639                                           ! 2442           }
15640                                           ! 2443         }
15641                       000047F7            .350:
15642                                           ! 2444         if (counter > 0) {
15643                       000047F7            .34E:
15644                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15645 47F7           8B46         FE            mov	ax,-2[bp]
15646                                           ! Debug: list unsigned int = ax+5 (used reg = )
15647 47FA           05                   0005  add	ax,*5
15648 47FD           50                         push	ax
15649                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15650 47FE           E8         BD41            call	_inb
15651 4801           44                         inc	sp
15652 4802           44                         inc	sp
15653                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15654 4803           24                     60  and	al,*$60
15655                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15656 4805           3C                     60  cmp	al,*$60
15657 4807           74           07            je  	.352
15658                       00004809            .353:
15659 4809           8A46         F9            mov	al,-7[bp]
15660 480C           84C0                       test	al,al
15661 480E           75           C1            jne	.34F
15662                       00004810            .352:
15663                       00004810            .34D:
15664                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
15665 4810           8A46         F9            mov	al,-7[bp]
15666 4813           84C0                       test	al,al
15667 4815           74           20            je  	.354
15668                       00004817            .355:
15669                                           ! 2445           outb(addr, regs.u.r8.al);
15670                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15671 4817           8A46         12            mov	al,$12[bp]
15672 481A           30E4                       xor	ah,ah
15673 481C           50                         push	ax
15674                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15675 481D           FF76         FE            push	-2[bp]
15676                                           ! Debug: func () void = outb+0 (used reg = )
15677 4820           E8         BD35            call	_outb
15678 4823           83C4                   04  add	sp,*4
15679                                           !BCC_EOS
15680                                           ! 2446           regs.u.r8.ah = inb(addr+5);
15681                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15682 4826           8B46         FE            mov	ax,-2[bp]
15683                                           ! Debug: list unsigned int = ax+5 (used reg = )
15684 4829           05                   0005  add	ax,*5
15685 482C           50                         push	ax
15686                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15687 482D           E8         BD12            call	_inb
15688 4830           44                         inc	sp
15689 4831           44                         inc	sp
15690                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15691 4832           8846         13            mov	$13[bp],al
15692                                           !BCC_EOS
15693                                           ! 2447         } else {
15694 4835           EB           05            jmp .356
15695                       00004837            .354:
15696                                           ! 2448           regs.u.r8.ah = 0x80;
15697                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15698 4837           B0                     80  mov	al,#$80
15699 4839           8846         13            mov	$13[bp],al
15700                                           !BCC_EOS
15701                                           ! 2449         }
15702                                           ! 2450         iret_addr.flags.u.r8.flagsl &= 0xfe;
15703                       0000483C            .356:
15704                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15705 483C           8A46         1A            mov	al,$1A[bp]
15706 483F           24                     FE  and	al,#$FE
15707 4841           8846         1A            mov	$1A[bp],al
15708                                           !BCC_EOS
15709                                           ! 2451         break;
15710 4844           E9         00CE            br 	.345
15711                                           !BCC_EOS
15712                                           ! 2452       case 2:
15713                                           ! 2453         timer = read_word(0x0040, 0x006C);
15714                       00004847            .357:
15715                                           ! Debug: list int = const $6C (used reg = )
15716 4847           B8                   006C  mov	ax,*$6C
15717 484A           50                         push	ax
15718                                           ! Debug: list int = const $40 (used reg = )
15719 484B           B8                   0040  mov	ax,*$40
15720 484E           50                         push	ax
15721                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15722 484F           E8         BDB9            call	_read_word
15723 4852           83C4                   04  add	sp,*4
15724                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15725 4855           8946         FC            mov	-4[bp],ax
15726                                           !BCC_EOS
15727                                           ! 2454         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
15728 4858           EB           26            jmp .359
15729                       0000485A            .35A:
15730                                           ! 2455           val16 = read_word(0x0040, 0x006C);
15731                                           ! Debug: list int = const $6C (used reg = )
15732 485A           B8                   006C  mov	ax,*$6C
15733 485D           50                         push	ax
15734                                           ! Debug: list int = const $40 (used reg = )
15735 485E           B8                   0040  mov	ax,*$40
15736 4861           50                         push	ax
15737                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15738 4862           E8         BDA6            call	_read_word
15739 4865           83C4                   04  add	sp,*4
15740                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15741 4868           8946         FA            mov	-6[bp],ax
15742                                           !BCC_EOS
15743                                           ! 2456           if (val16 != timer) {
15744                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15745 486B           8B46         FA            mov	ax,-6[bp]
15746 486E           3B46         FC            cmp	ax,-4[bp]
15747 4871           74           0D            je  	.35B
15748                       00004873            .35C:
15749                                           ! 2457             timer = val16;
15750                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15751 4873           8B46         FA            mov	ax,-6[bp]
15752 4876           8946         FC            mov	-4[bp],ax
15753                                           !BCC_EOS
15754                                           ! 2458             counter--;
15755                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
15756 4879           8A46         F9            mov	al,-7[bp]
15757 487C           48                         dec	ax
15758 487D           8846         F9            mov	-7[bp],al
15759                                           !BCC_EOS
15760                                           ! 2459           }
15761                                           ! 2460         }
15762                       00004880            .35B:
15763                                           ! 2461         if (counter > 0) {
15764                       00004880            .359:
15765                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15766 4880           8B46         FE            mov	ax,-2[bp]
15767                                           ! Debug: list unsigned int = ax+5 (used reg = )
15768 4883           05                   0005  add	ax,*5
15769 4886           50                         push	ax
15770                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15771 4887           E8         BCB8            call	_inb
15772 488A           44                         inc	sp
15773 488B           44                         inc	sp
15774                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
15775 488C           24                     01  and	al,*1
15776                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15777 488E           84C0                       test	al,al
15778 4890           75           07            jne 	.35D
15779                       00004892            .35E:
15780 4892           8A46         F9            mov	al,-7[bp]
15781 4895           84C0                       test	al,al
15782 4897           75           C1            jne	.35A
15783                       00004899            .35D:
15784                       00004899            .358:
15785                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
15786 4899           8A46         F9            mov	al,-7[bp]
15787 489C           84C0                       test	al,al
15788 489E           74           1C            je  	.35F
15789                       000048A0            .360:
15790                                           ! 2462           regs.u.r8.ah = inb(addr+5);
15791                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15792 48A0           8B46         FE            mov	ax,-2[bp]
15793                                           ! Debug: list unsigned int = ax+5 (used reg = )
15794 48A3           05                   0005  add	ax,*5
15795 48A6           50                         push	ax
15796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15797 48A7           E8         BC98            call	_inb
15798 48AA           44                         inc	sp
15799 48AB           44                         inc	sp
15800                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15801 48AC           8846         13            mov	$13[bp],al
15802                                           !BCC_EOS
15803                                           ! 2463           regs.u.r8.al = inb(addr);
15804                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
15805 48AF           FF76         FE            push	-2[bp]
15806                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15807 48B2           E8         BC8D            call	_inb
15808 48B5           44                         inc	sp
15809 48B6           44                         inc	sp
15810                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15811 48B7           8846         12            mov	$12[bp],al
15812                                           !BCC_EOS
15813                                           ! 2464         } else {
15814 48BA           EB           05            jmp .361
15815                       000048BC            .35F:
15816                                           ! 2465           regs.u.r8.ah = 0x80;
15817                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15818 48BC           B0                     80  mov	al,#$80
15819 48BE           8846         13            mov	$13[bp],al
15820                                           !BCC_EOS
15821                                           ! 2466         }
15822                                           ! 2467         iret_addr.flags.u.r8.flagsl &= 0xfe;
15823                       000048C1            .361:
15824                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15825 48C1           8A46         1A            mov	al,$1A[bp]
15826 48C4           24                     FE  and	al,#$FE
15827 48C6           8846         1A            mov	$1A[bp],al
15828                                           !BCC_EOS
15829                                           ! 2468         break;
15830 48C9           EB           4A            jmp .345
15831                                           !BCC_EOS
15832                                           ! 2469       case 3:
15833                                           ! 2470         regs.u.r8.ah = inb(addr+5);
15834                       000048CB            .362:
15835                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15836 48CB           8B46         FE            mov	ax,-2[bp]
15837                                           ! Debug: list unsigned int = ax+5 (used reg = )
15838 48CE           05                   0005  add	ax,*5
15839 48D1           50                         push	ax
15840                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15841 48D2           E8         BC6D            call	_inb
15842 48D5           44                         inc	sp
15843 48D6           44                         inc	sp
15844                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15845 48D7           8846         13            mov	$13[bp],al
15846                                           !BCC_EOS
15847                                           ! 2471         regs.u.r8.al = inb(addr+6);
15848                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15849 48DA           8B46         FE            mov	ax,-2[bp]
15850                                           ! Debug: list unsigned int = ax+6 (used reg = )
15851 48DD           05                   0006  add	ax,*6
15852 48E0           50                         push	ax
15853                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15854 48E1           E8         BC5E            call	_inb
15855 48E4           44                         inc	sp
15856 48E5           44                         inc	sp
15857                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15858 48E6           8846         12            mov	$12[bp],al
15859                                           !BCC_EOS
15860                                           ! 2472         iret_addr.flags.u.r8.flagsl &= 0xfe;
15861                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15862 48E9           8A46         1A            mov	al,$1A[bp]
15863 48EC           24                     FE  and	al,#$FE
15864 48EE           8846         1A            mov	$1A[bp],al
15865                                           !BCC_EOS
15866                                           ! 2473         break;
15867 48F1           EB           22            jmp .345
15868                                           !BCC_EOS
15869                                           ! 2474       default:
15870                                           ! 2475         iret_addr.flags.u.r8.flagsl |= 0x01;
15871                       000048F3            .363:
15872                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15873 48F3           8A46         1A            mov	al,$1A[bp]
15874 48F6           0C                     01  or	al,*1
15875 48F8           8846         1A            mov	$1A[bp],al
15876                                           !BCC_EOS
15877                                           ! 2476       }
15878                                           ! 2477   } else {
15879 48FB           EB           18            jmp .345
15880                       000048FD            .347:
15881 48FD           2C                     00  sub	al,*0
15882 48FF         0F84         FDFF            beq 	.348
15883 4903           2C                     01  sub	al,*1
15884 4905         0F84         FEB5            beq 	.34C
15885 4909           2C                     01  sub	al,*1
15886 490B         0F84         FF38            beq 	.357
15887 490F           2C                     01  sub	al,*1
15888 4911           74           B8            je 	.362
15889 4913           EB           DE            jmp	.363
15890                       00004915            .345:
15891                       FFFFFFF6            ..FFF8	=	-$A
15892 4915           EB           08            jmp .364
15893                       00004917            .342:
15894                                           ! 2478     iret_addr.flags.u.r8.flagsl |= 0x01;
15895                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15896 4917           8A46         1A            mov	al,$1A[bp]
15897 491A           0C                     01  or	al,*1
15898 491C           8846         1A            mov	$1A[bp],al
15899                                           !BCC_EOS
15900                                           ! 2479   }
15901                                           ! 2480 }
15902                       0000491F            .364:
15903 491F           89EC                       mov	sp,bp
15904 4921           5D                         pop	bp
15905 4922           C3                         ret
15906                                           ! 2481   void
15907                                           ! Register BX used in function int14_function
15908                                           ! 2482 int15_function(regs, ES, DS, FLAGS)
15909                                           ! 2483   pusha_regs_t regs;
15910                                           export	_int15_function
15911                       00004923            _int15_function:
15912                                           !BCC_EOS
15913                                           ! 2484   Bit16u ES, DS, FLAGS;
15914                                           !BCC_EOS
15915                                           ! 2485 {
15916                                           ! 2486   Bit16u ebda_seg=read_word(0x0040,0x000E);
15917 4923           55                         push	bp
15918 4924           89E5                       mov	bp,sp
15919 4926           4C                         dec	sp
15920 4927           4C                         dec	sp
15921                                           ! Debug: list int = const $E (used reg = )
15922 4928           B8                   000E  mov	ax,*$E
15923 492B           50                         push	ax
15924                                           ! Debug: list int = const $40 (used reg = )
15925 492C           B8                   0040  mov	ax,*$40
15926 492F           50                         push	ax
15927                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15928 4930           E8         BCD8            call	_read_word
15929 4933           83C4                   04  add	sp,*4
15930                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15931 4936           8946         FE            mov	-2[bp],ax
15932                                           !BCC_EOS
15933                                           ! 2487   bx_bool prev_a20_enable;
15934                                           !BCC_EOS
15935                                           ! 2488   Bit16u base15_00;
15936                                           !BCC_EOS
15937                                           ! 2489   Bit8u base23_16;
15938                                           !BCC_EOS
15939                                           ! 2490   Bit16u ss;
15940                                           !BCC_EOS
15941                                           ! 2491   Bit16u BX,CX,DX;
15942                                           !BCC_EOS
15943                                           ! 2492   Bit16u bRegister;
15944                                           !BCC_EOS
15945                                           ! 2493   Bit8u irqDisable;
15946                                           !BCC_EOS
15947                                           ! 2494 ;
15948 4939           83C4                   EE  add	sp,*-$12
15949                                           !BCC_EOS
15950                                           ! 2495   switch (regs.u.r8.ah) {
15951 493C           8A46         13            mov	al,$13[bp]
15952 493F           E9         059B            br 	.367
15953                                           ! 2496     case 0x24:
15954                                           ! 2497       switch (regs.u.r8.al) {
15955                       00004942            .368:
15956 4942           8A46         12            mov	al,$12[bp]
15957 4945           E9         0089            br 	.36B
15958                                           ! 2498         case 0x00:
15959                                           ! 2499           set_enable_a20(0);
15960                       00004948            .36C:
15961                                           ! Debug: list int = const 0 (used reg = )
15962 4948           31C0                       xor	ax,ax
15963 494A           50                         push	ax
15964                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15965 494B           E8         CEAB            call	_set_enable_a20
15966 494E           44                         inc	sp
15967 494F           44                         inc	sp
15968                                           !BCC_EOS
15969                                           ! 2500           FLAGS &= 0xfffe;
15970                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15971 4950           8B46         18            mov	ax,$18[bp]
15972 4953           24                     FE  and	al,#$FE
15973 4955           8946         18            mov	$18[bp],ax
15974                                           !BCC_EOS
15975                                           ! 2501           regs.u.r8.ah = 0;
15976                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15977 4958           30C0                       xor	al,al
15978 495A           8846         13            mov	$13[bp],al
15979                                           !BCC_EOS
15980                                           ! 2502           break;
15981 495D           E9         0087            br 	.369
15982                                           !BCC_EOS
15983                                           ! 2503         case 0x01:
15984                                           ! 2504           set_enable_a20(1);
15985                       00004960            .36D:
15986                                           ! Debug: list int = const 1 (used reg = )
15987 4960           B8                   0001  mov	ax,*1
15988 4963           50                         push	ax
15989                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15990 4964           E8         CE92            call	_set_enable_a20
15991 4967           44                         inc	sp
15992 4968           44                         inc	sp
15993                                           !BCC_EOS
15994                                           ! 2505           FLAGS &= 0xfffe;
15995                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15996 4969           8B46         18            mov	ax,$18[bp]
15997 496C           24                     FE  and	al,#$FE
15998 496E           8946         18            mov	$18[bp],ax
15999                                           !BCC_EOS
16000                                           ! 2506           regs.u.r8.ah = 0;
16001                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16002 4971           30C0                       xor	al,al
16003 4973           8846         13            mov	$13[bp],al
16004                                           !BCC_EOS
16005                                           ! 2507           break;
16006 4976           EB           6F            jmp .369
16007                                           !BCC_EOS
16008                                           ! 2508         case 0x02:
16009                                           ! 2509           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
16010                       00004978            .36E:
16011                                           ! Debug: list int = const $92 (used reg = )
16012 4978           B8                   0092  mov	ax,#$92
16013 497B           50                         push	ax
16014                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16015 497C           E8         BBC3            call	_inb
16016 497F           44                         inc	sp
16017 4980           44                         inc	sp
16018                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
16019 4981           30E4                       xor	ah,ah
16020 4983           D1E8                       shr	ax,*1
16021                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
16022 4985           24                     01  and	al,*1
16023                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
16024 4987           8846         12            mov	$12[bp],al
16025                                           !BCC_EOS
16026                                           ! 2510           FLAGS &= 0xfffe;
16027                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16028 498A           8B46         18            mov	ax,$18[bp]
16029 498D           24                     FE  and	al,#$FE
16030 498F           8946         18            mov	$18[bp],ax
16031                                           !BCC_EOS
16032                                           ! 2511           regs.u.r8.ah = 0;
16033                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16034 4992           30C0                       xor	al,al
16035 4994           8846         13            mov	$13[bp],al
16036                                           !BCC_EOS
16037                                           ! 2512           break;
16038 4997           EB           4E            jmp .369
16039                                           !BCC_EOS
16040                                           ! 2513         case 0x03:
16041                                           ! 2514           FLAGS &= 0xfffe;
16042                       00004999            .36F:
16043                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16044 4999           8B46         18            mov	ax,$18[bp]
16045 499C           24                     FE  and	al,#$FE
16046 499E           8946         18            mov	$18[bp],ax
16047                                           !BCC_EOS
16048                                           ! 2515           regs.u.r8.ah = 0;
16049                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16050 49A1           30C0                       xor	al,al
16051 49A3           8846         13            mov	$13[bp],al
16052                                           !BCC_EOS
16053                                           ! 2516           regs.u.r16.bx = 3;
16054                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
16055 49A6           B8                   0003  mov	ax,*3
16056 49A9           8946         0C            mov	$C[bp],ax
16057                                           !BCC_EOS
16058                                           ! 2517           break;
16059 49AC           EB           39            jmp .369
16060                                           !BCC_EOS
16061                                           ! 2518         default:
16062                                           ! 2519           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.
16063                       000049AE            .370:
16064                                           ! 2519 al);
16065                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
16066 49AE           8A46         12            mov	al,$12[bp]
16067 49B1           30E4                       xor	ah,ah
16068 49B3           50                         push	ax
16069                                           ! Debug: list * char = .371+0 (used reg = )
16070 49B4           BB                   D575  mov	bx,#.371
16071 49B7           53                         push	bx
16072                                           ! Debug: list int = const 4 (used reg = )
16073 49B8           B8                   0004  mov	ax,*4
16074 49BB           50                         push	ax
16075                                           ! Debug: func () void = bios_printf+0 (used reg = )
16076 49BC           E8         BFE8            call	_bios_printf
16077 49BF           83C4                   06  add	sp,*6
16078                                           !BCC_EOS
16079                                           ! 2520           FLAGS |= 0x0001;
16080                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16081 49C2           8B46         18            mov	ax,$18[bp]
16082 49C5           0C                     01  or	al,*1
16083 49C7           8946         18            mov	$18[bp],ax
16084                                           !BCC_EOS
16085                                           ! 2521           regs.u.r8.ah = 0x86;
16086                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16087 49CA           B0                     86  mov	al,#$86
16088 49CC           8846         13            mov	$13[bp],al
16089                                           !BCC_EOS
16090                                           ! 2522       }
16091                                           ! 2523       break;
16092 49CF           EB           16            jmp .369
16093                       000049D1            .36B:
16094 49D1           2C                     00  sub	al,*0
16095 49D3         0F84         FF71            beq 	.36C
16096 49D7           2C                     01  sub	al,*1
16097 49D9         0F84         FF83            beq 	.36D
16098 49DD           2C                     01  sub	al,*1
16099 49DF           74           97            je 	.36E
16100 49E1           2C                     01  sub	al,*1
16101 49E3           74           B4            je 	.36F
16102 49E5           EB           C7            jmp	.370
16103                       000049E7            .369:
16104 49E7           E9         0557            br 	.365
16105                                           !BCC_EOS
16106                                           ! 2524     case 0x41:
16107                                           ! 2525       FLAGS |= 0x0001;
16108                       000049EA            .372:
16109                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16110 49EA           8B46         18            mov	ax,$18[bp]
16111 49ED           0C                     01  or	al,*1
16112 49EF           8946         18            mov	$18[bp],ax
16113                                           !BCC_EOS
16114                                           ! 2526       regs.u.r8.ah = 0x86;
16115                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16116 49F2           B0                     86  mov	al,#$86
16117 49F4           8846         13            mov	$13[bp],al
16118                                           !BCC_EOS
16119                                           ! 2527       break;
16120 49F7           E9         0547            br 	.365
16121                                           !BCC_EOS
16122                                           ! 2528     case 0x4f:
16123                                           ! 2529       FLAGS |= 0x0001;
16124                       000049FA            .373:
16125                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16126 49FA           8B46         18            mov	ax,$18[bp]
16127 49FD           0C                     01  or	al,*1
16128 49FF           8946         18            mov	$18[bp],ax
16129                                           !BCC_EOS
16130                                           ! 2530       break;
16131 4A02           E9         053C            br 	.365
16132                                           !BCC_EOS
16133                                           ! 2531     case 0x52:
16134                                           ! 2532       FLAGS &= 0xfffe;
16135                       00004A05            .374:
16136                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16137 4A05           8B46         18            mov	ax,$18[bp]
16138 4A08           24                     FE  and	al,#$FE
16139 4A0A           8946         18            mov	$18[bp],ax
16140                                           !BCC_EOS
16141                                           ! 2533       regs.u.r8.ah = 0;
16142                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16143 4A0D           30C0                       xor	al,al
16144 4A0F           8846         13            mov	$13[bp],al
16145                                           !BCC_EOS
16146                                           ! 2534       break;
16147 4A12           E9         052C            br 	.365
16148                                           !BCC_EOS
16149                                           ! 2535     case 0x83: {
16150                       00004A15            .375:
16151                                           ! 2536       if( regs.u.r8.al == 0 ) {
16152                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
16153 4A15           8A46         12            mov	al,$12[bp]
16154 4A18           84C0                       test	al,al
16155 4A1A         0F85         00C1            bne 	.376
16156                       00004A1E            .377:
16157                                           ! 2537         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16158                                           ! Debug: list int = const $A0 (used reg = )
16159 4A1E           B8                   00A0  mov	ax,#$A0
16160 4A21           50                         push	ax
16161                                           ! Debug: list int = const $40 (used reg = )
16162 4A22           B8                   0040  mov	ax,*$40
16163 4A25           50                         push	ax
16164                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16165 4A26           E8         BBCF            call	_read_byte
16166 4A29           83C4                   04  add	sp,*4
16167                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16168 4A2C           24                     01  and	al,*1
16169                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16170 4A2E           84C0                       test	al,al
16171 4A30         0F85         009C            bne 	.378
16172                       00004A34            .379:
16173                                           ! 2538           write_byte( 0x40, 0xA0, 1 );
16174                                           ! Debug: list int = const 1 (used reg = )
16175 4A34           B8                   0001  mov	ax,*1
16176 4A37           50                         push	ax
16177                                           ! Debug: list int = const $A0 (used reg = )
16178 4A38           B8                   00A0  mov	ax,#$A0
16179 4A3B           50                         push	ax
16180                                           ! Debug: list int = const $40 (used reg = )
16181 4A3C           B8                   0040  mov	ax,*$40
16182 4A3F           50                         push	ax
16183                                           ! Debug: func () void = write_byte+0 (used reg = )
16184 4A40           E8         BBDB            call	_write_byte
16185 4A43           83C4                   06  add	sp,*6
16186                                           !BCC_EOS
16187                                           ! 2539           write_word( 0x40, 0x98, ES );
16188                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
16189 4A46           FF76         14            push	$14[bp]
16190                                           ! Debug: list int = const $98 (used reg = )
16191 4A49           B8                   0098  mov	ax,#$98
16192 4A4C           50                         push	ax
16193                                           ! Debug: list int = const $40 (used reg = )
16194 4A4D           B8                   0040  mov	ax,*$40
16195 4A50           50                         push	ax
16196                                           ! Debug: func () void = write_word+0 (used reg = )
16197 4A51           E8         BBE2            call	_write_word
16198 4A54           83C4                   06  add	sp,*6
16199                                           !BCC_EOS
16200                                           ! 2540           write_word( 0x40, 0x9A, regs.u.r16.bx );
16201                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
16202 4A57           FF76         0C            push	$C[bp]
16203                                           ! Debug: list int = const $9A (used reg = )
16204 4A5A           B8                   009A  mov	ax,#$9A
16205 4A5D           50                         push	ax
16206                                           ! Debug: list int = const $40 (used reg = )
16207 4A5E           B8                   0040  mov	ax,*$40
16208 4A61           50                         push	ax
16209                                           ! Debug: func () void = write_word+0 (used reg = )
16210 4A62           E8         BBD1            call	_write_word
16211 4A65           83C4                   06  add	sp,*6
16212                                           !BCC_EOS
16213                                           ! 2541           write_word( 0x40, 0x9C, regs.u.r16.dx );
16214                                           ! Debug: list unsigned short regs = [S+$16+$C] (used reg = )
16215 4A68           FF76         0E            push	$E[bp]
16216                                           ! Debug: list int = const $9C (used reg = )
16217 4A6B           B8                   009C  mov	ax,#$9C
16218 4A6E           50                         push	ax
16219                                           ! Debug: list int = const $40 (used reg = )
16220 4A6F           B8                   0040  mov	ax,*$40
16221 4A72           50                         push	ax
16222                                           ! Debug: func () void = write_word+0 (used reg = )
16223 4A73           E8         BBC0            call	_write_word
16224 4A76           83C4                   06  add	sp,*6
16225                                           !BCC_EOS
16226                                           ! 2542           write_word( 0x40, 0x9E, regs.u.r16.cx );
16227                                           ! Debug: list unsigned short regs = [S+$16+$E] (used reg = )
16228 4A79           FF76         10            push	$10[bp]
16229                                           ! Debug: list int = const $9E (used reg = )
16230 4A7C           B8                   009E  mov	ax,#$9E
16231 4A7F           50                         push	ax
16232                                           ! Debug: list int = const $40 (used reg = )
16233 4A80           B8                   0040  mov	ax,*$40
16234 4A83           50                         push	ax
16235                                           ! Debug: func () void = write_word+0 (used reg = )
16236 4A84           E8         BBAF            call	_write_word
16237 4A87           83C4                   06  add	sp,*6
16238                                           !BCC_EOS
16239                                           ! 2543           FLAGS &= 0xfffe;
16240                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16241 4A8A           8B46         18            mov	ax,$18[bp]
16242 4A8D           24                     FE  and	al,#$FE
16243 4A8F           8946         18            mov	$18[bp],ax
16244                                           !BCC_EOS
16245                                           ! 2544           irqDisable = inb( 0xA1 );
16246                                           ! Debug: list int = const $A1 (used reg = )
16247 4A92           B8                   00A1  mov	ax,#$A1
16248 4A95           50                         push	ax
16249                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16250 4A96           E8         BAA9            call	_inb
16251 4A99           44                         inc	sp
16252 4A9A           44                         inc	sp
16253                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
16254 4A9B           8846         ED            mov	-$13[bp],al
16255                                           !BCC_EOS
16256                                           ! 2545           outb( 0xA1, irqDisable & 0xFE );
16257                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
16258 4A9E           8A46         ED            mov	al,-$13[bp]
16259 4AA1           24                     FE  and	al,#$FE
16260                                           ! Debug: list unsigned char = al+0 (used reg = )
16261 4AA3           30E4                       xor	ah,ah
16262 4AA5           50                         push	ax
16263                                           ! Debug: list int = const $A1 (used reg = )
16264 4AA6           B8                   00A1  mov	ax,#$A1
16265 4AA9           50                         push	ax
16266                                           ! Debug: func () void = outb+0 (used reg = )
16267 4AAA           E8         BAAB            call	_outb
16268 4AAD           83C4                   04  add	sp,*4
16269                                           !BCC_EOS
16270                                           ! 2546           bRegister = inb_cmos( 0xB );
16271                                           ! Debug: list int = const $B (used reg = )
16272 4AB0           B8                   000B  mov	ax,*$B
16273 4AB3           50                         push	ax
16274                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16275 4AB4           E8         BAD0            call	_inb_cmos
16276 4AB7           44                         inc	sp
16277 4AB8           44                         inc	sp
16278                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
16279 4AB9           30E4                       xor	ah,ah
16280 4ABB           8946         EE            mov	-$12[bp],ax
16281                                           !BCC_EOS
16282                                           ! 2547           outb_cmos( 0xB, bRegister | 0x40 );
16283                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
16284 4ABE           8B46         EE            mov	ax,-$12[bp]
16285 4AC1           0C                     40  or	al,*$40
16286                                           ! Debug: list unsigned int = ax+0 (used reg = )
16287 4AC3           50                         push	ax
16288                                           ! Debug: list int = const $B (used reg = )
16289 4AC4           B8                   000B  mov	ax,*$B
16290 4AC7           50                         push	ax
16291                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16292 4AC8           E8         BAAD            call	_outb_cmos
16293 4ACB           83C4                   04  add	sp,*4
16294                                           !BCC_EOS
16295                                           ! 2548         } else {
16296 4ACE           EB           0D            jmp .37A
16297                       00004AD0            .378:
16298                                           ! 2549           ;
16299                                           !BCC_EOS
16300                                           ! 2550           FLAGS |= 0x0001;
16301                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16302 4AD0           8B46         18            mov	ax,$18[bp]
16303 4AD3           0C                     01  or	al,*1
16304 4AD5           8946         18            mov	$18[bp],ax
16305                                           !BCC_EOS
16306                                           ! 2551           regs.u.r8.ah = 0x86;
16307                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16308 4AD8           B0                     86  mov	al,#$86
16309 4ADA           8846         13            mov	$13[bp],al
16310                                           !BCC_EOS
16311                                           ! 2552         }
16312                                           ! 2553       } else if( regs.u.r8.al == 1 ) {
16313                       00004ADD            .37A:
16314 4ADD           EB           54            jmp .37B
16315                       00004ADF            .376:
16316                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
16317 4ADF           8A46         12            mov	al,$12[bp]
16318 4AE2           3C                     01  cmp	al,*1
16319 4AE4           75           39            jne 	.37C
16320                       00004AE6            .37D:
16321                                           ! 2554         write_byte( 0x40, 0xA0, 0 );
16322                                           ! Debug: list int = const 0 (used reg = )
16323 4AE6           31C0                       xor	ax,ax
16324 4AE8           50                         push	ax
16325                                           ! Debug: list int = const $A0 (used reg = )
16326 4AE9           B8                   00A0  mov	ax,#$A0
16327 4AEC           50                         push	ax
16328                                           ! Debug: list int = const $40 (used reg = )
16329 4AED           B8                   0040  mov	ax,*$40
16330 4AF0           50                         push	ax
16331                                           ! Debug: func () void = write_byte+0 (used reg = )
16332 4AF1           E8         BB2A            call	_write_byte
16333 4AF4           83C4                   06  add	sp,*6
16334                                           !BCC_EOS
16335                                           ! 2555         FLAGS &= 0xfffe;
16336                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16337 4AF7           8B46         18            mov	ax,$18[bp]
16338 4AFA           24                     FE  and	al,#$FE
16339 4AFC           8946         18            mov	$18[bp],ax
16340                                           !BCC_EOS
16341                                           ! 2556         bRegister = inb_cmos( 0xB );
16342                                           ! Debug: list int = const $B (used reg = )
16343 4AFF           B8                   000B  mov	ax,*$B
16344 4B02           50                         push	ax
16345                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16346 4B03           E8         BA81            call	_inb_cmos
16347 4B06           44                         inc	sp
16348 4B07           44                         inc	sp
16349                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
16350 4B08           30E4                       xor	ah,ah
16351 4B0A           8946         EE            mov	-$12[bp],ax
16352                                           !BCC_EOS
16353                                           ! 2557         outb_cmos( 0xB, bRegister & ~0x40 );
16354                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
16355 4B0D           8B46         EE            mov	ax,-$12[bp]
16356 4B10           24                     BF  and	al,#$BF
16357                                           ! Debug: list unsigned int = ax+0 (used reg = )
16358 4B12           50                         push	ax
16359                                           ! Debug: list int = const $B (used reg = )
16360 4B13           B8                   000B  mov	ax,*$B
16361 4B16           50                         push	ax
16362                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16363 4B17           E8         BA5E            call	_outb_cmos
16364 4B1A           83C4                   04  add	sp,*4
16365                                           !BCC_EOS
16366                                           ! 2558       } else {
16367 4B1D           EB           14            jmp .37E
16368                       00004B1F            .37C:
16369                                           ! 2559         ;
16370                                           !BCC_EOS
16371                                           ! 2560         FLAGS |= 0x0001;
16372                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16373 4B1F           8B46         18            mov	ax,$18[bp]
16374 4B22           0C                     01  or	al,*1
16375 4B24           8946         18            mov	$18[bp],ax
16376                                           !BCC_EOS
16377                                           ! 2561         regs.u.r8.ah = 0x86;
16378                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16379 4B27           B0                     86  mov	al,#$86
16380 4B29           8846         13            mov	$13[bp],al
16381                                           !BCC_EOS
16382                                           ! 2562         regs.u.r8.al--;
16383                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
16384 4B2C           8A46         12            mov	al,$12[bp]
16385 4B2F           48                         dec	ax
16386 4B30           8846         12            mov	$12[bp],al
16387                                           !BCC_EOS
16388                                           ! 2563       }
16389                                           ! 2564       break;
16390                       00004B33            .37E:
16391                       00004B33            .37B:
16392 4B33           E9         040B            br 	.365
16393                                           !BCC_EOS
16394                                           ! 2565     }
16395                                           ! 2566     case 0x87:
16396                                           ! 2567 #asm
16397                       00004B36            .37F:
16398                                           !BCC_EOS
16399                                           !BCC_ASM
16400                       00000006            _int15_function.CX	set	6
16401                       FFFFFFF2            .int15_function.CX	set	-$E
16402                       0000002C            _int15_function.FLAGS	set	$2C
16403                       00000018            .int15_function.FLAGS	set	$18
16404                       00000001            _int15_function.irqDisable	set	1
16405                       FFFFFFED            .int15_function.irqDisable	set	-$13
16406                       0000002A            _int15_function.DS	set	$2A
16407                       00000016            .int15_function.DS	set	$16
16408                       00000004            _int15_function.DX	set	4
16409                       FFFFFFF0            .int15_function.DX	set	-$10
16410                       0000000D            _int15_function.base23_16	set	$D
16411                       FFFFFFF9            .int15_function.base23_16	set	-7
16412                       00000002            _int15_function.bRegister	set	2
16413                       FFFFFFEE            .int15_function.bRegister	set	-$12
16414                       00000028            _int15_function.ES	set	$28
16415                       00000014            .int15_function.ES	set	$14
16416                       00000012            _int15_function.ebda_seg	set	$12
16417                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16418                       0000000E            _int15_function.base15_00	set	$E
16419                       FFFFFFFA            .int15_function.base15_00	set	-6
16420                       0000000A            _int15_function.ss	set	$A
16421                       FFFFFFF6            .int15_function.ss	set	-$A
16422                       00000008            _int15_function.BX	set	8
16423                       FFFFFFF4            .int15_function.BX	set	-$C
16424                       00000018            _int15_function.regs	set	$18
16425                       00000004            .int15_function.regs	set	4
16426                       00000010            _int15_function.prev_a20_enable	set	$10
16427                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16428 4B36           FA                           cli
16429                                           ! 2569 endasm
16430                                           !BCC_ENDASM
16431                                           !BCC_EOS
16432                                           ! 2570       prev_a20_enable = set_enable_a20(1);
16433                                           ! Debug: list int = const 1 (used reg = )
16434 4B37           B8                   0001  mov	ax,*1
16435 4B3A           50                         push	ax
16436                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16437 4B3B           E8         CCBB            call	_set_enable_a20
16438 4B3E           44                         inc	sp
16439 4B3F           44                         inc	sp
16440                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
16441 4B40           8946         FC            mov	-4[bp],ax
16442                                           !BCC_EOS
16443                                           ! 2571       base15_00 = (ES << 4) + regs.u.r16.si;
16444                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
16445 4B43           8B46         14            mov	ax,$14[bp]
16446 4B46           B1                     04  mov	cl,*4
16447 4B48           D3E0                       shl	ax,cl
16448                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
16449 4B4A           0346         06            add	ax,6[bp]
16450                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16451 4B4D           8946         FA            mov	-6[bp],ax
16452                                           !BCC_EOS
16453                                           ! 2572       base23_16 = ES >> 12;
16454                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
16455 4B50           8B46         14            mov	ax,$14[bp]
16456 4B53           88E0                       mov	al,ah
16457 4B55           30E4                       xor	ah,ah
16458 4B57           B1                     04  mov	cl,*4
16459 4B59           D3E8                       shr	ax,cl
16460                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
16461 4B5B           8846         F9            mov	-7[bp],al
16462                                           !BCC_EOS
16463                                           ! 2573       if (base15_00 < (ES<<4))
16464                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
16465 4B5E           8B46         14            mov	ax,$14[bp]
16466 4B61           B1                     04  mov	cl,*4
16467 4B63           D3E0                       shl	ax,cl
16468                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16469 4B65           3B46         FA            cmp	ax,-6[bp]
16470 4B68           76           07            jbe 	.380
16471                       00004B6A            .381:
16472                                           ! 2574         base23_16++;
16473                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
16474 4B6A           8A46         F9            mov	al,-7[bp]
16475 4B6D           40                         inc	ax
16476 4B6E           8846         F9            mov	-7[bp],al
16477                                           !BCC_EOS
16478                                           ! 2575       write_word(ES, regs.u.r16.si+0x08+0, 47);
16479                       00004B71            .380:
16480                                           ! Debug: list int = const $2F (used reg = )
16481 4B71           B8                   002F  mov	ax,*$2F
16482 4B74           50                         push	ax
16483                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16484 4B75           8B46         06            mov	ax,6[bp]
16485                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16486                                           ! Debug: list unsigned int = ax+8 (used reg = )
16487 4B78           05                   0008  add	ax,*8
16488 4B7B           50                         push	ax
16489                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16490 4B7C           FF76         14            push	$14[bp]
16491                                           ! Debug: func () void = write_word+0 (used reg = )
16492 4B7F           E8         BAB4            call	_write_word
16493 4B82           83C4                   06  add	sp,*6
16494                                           !BCC_EOS
16495                                           ! 2576       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16496                                           ! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
16497 4B85           FF76         FA            push	-6[bp]
16498                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16499 4B88           8B46         06            mov	ax,6[bp]
16500                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16501                                           ! Debug: list unsigned int = ax+$A (used reg = )
16502 4B8B           05                   000A  add	ax,*$A
16503 4B8E           50                         push	ax
16504                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16505 4B8F           FF76         14            push	$14[bp]
16506                                           ! Debug: func () void = write_word+0 (used reg = )
16507 4B92           E8         BAA1            call	_write_word
16508 4B95           83C4                   06  add	sp,*6
16509                                           !BCC_EOS
16510                                           ! 2577       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16511                                           ! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
16512 4B98           8A46         F9            mov	al,-7[bp]
16513 4B9B           30E4                       xor	ah,ah
16514 4B9D           50                         push	ax
16515                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16516 4B9E           8B46         06            mov	ax,6[bp]
16517                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16518                                           ! Debug: list unsigned int = ax+$C (used reg = )
16519 4BA1           05                   000C  add	ax,*$C
16520 4BA4           50                         push	ax
16521                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16522 4BA5           FF76         14            push	$14[bp]
16523                                           ! Debug: func () void = write_byte+0 (used reg = )
16524 4BA8           E8         BA73            call	_write_byte
16525 4BAB           83C4                   06  add	sp,*6
16526                                           !BCC_EOS
16527                                           ! 2578       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16528                                           ! Debug: list int = const $93 (used reg = )
16529 4BAE           B8                   0093  mov	ax,#$93
16530 4BB1           50                         push	ax
16531                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16532 4BB2           8B46         06            mov	ax,6[bp]
16533                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16534                                           ! Debug: list unsigned int = ax+$D (used reg = )
16535 4BB5           05                   000D  add	ax,*$D
16536 4BB8           50                         push	ax
16537                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16538 4BB9           FF76         14            push	$14[bp]
16539                                           ! Debug: func () void = write_byte+0 (used reg = )
16540 4BBC           E8         BA5F            call	_write_byte
16541 4BBF           83C4                   06  add	sp,*6
16542                                           !BCC_EOS
16543                                           ! 2579       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16544                                           ! Debug: list int = const 0 (used reg = )
16545 4BC2           31C0                       xor	ax,ax
16546 4BC4           50                         push	ax
16547                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16548 4BC5           8B46         06            mov	ax,6[bp]
16549                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16550                                           ! Debug: list unsigned int = ax+$E (used reg = )
16551 4BC8           05                   000E  add	ax,*$E
16552 4BCB           50                         push	ax
16553                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16554 4BCC           FF76         14            push	$14[bp]
16555                                           ! Debug: func () void = write_word+0 (used reg = )
16556 4BCF           E8         BA64            call	_write_word
16557 4BD2           83C4                   06  add	sp,*6
16558                                           !BCC_EOS
16559                                           ! 2580       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16560                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16561 4BD5           B8                   FFFF  mov	ax,#$FFFF
16562 4BD8           50                         push	ax
16563                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16564 4BD9           8B46         06            mov	ax,6[bp]
16565                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16566                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16567 4BDC           05                   0020  add	ax,*$20
16568 4BDF           50                         push	ax
16569                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16570 4BE0           FF76         14            push	$14[bp]
16571                                           ! Debug: func () void = write_word+0 (used reg = )
16572 4BE3           E8         BA50            call	_write_word
16573 4BE6           83C4                   06  add	sp,*6
16574                                           !BCC_EOS
16575                                           ! 2581       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16576                                           ! Debug: list int = const 0 (used reg = )
16577 4BE9           31C0                       xor	ax,ax
16578 4BEB           50                         push	ax
16579                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16580 4BEC           8B46         06            mov	ax,6[bp]
16581                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16582                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16583 4BEF           05                   0022  add	ax,*$22
16584 4BF2           50                         push	ax
16585                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16586 4BF3           FF76         14            push	$14[bp]
16587                                           ! Debug: func () void = write_word+0 (used reg = )
16588 4BF6           E8         BA3D            call	_write_word
16589 4BF9           83C4                   06  add	sp,*6
16590                                           !BCC_EOS
16591                                           ! 2582       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16592                                           ! Debug: list int = const $F (used reg = )
16593 4BFC           B8                   000F  mov	ax,*$F
16594 4BFF           50                         push	ax
16595                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16596 4C00           8B46         06            mov	ax,6[bp]
16597                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16598                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16599 4C03           05                   0024  add	ax,*$24
16600 4C06           50                         push	ax
16601                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16602 4C07           FF76         14            push	$14[bp]
16603                                           ! Debug: func () void = write_byte+0 (used reg = )
16604 4C0A           E8         BA11            call	_write_byte
16605 4C0D           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 2583       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16608                                           ! Debug: list int = const $9B (used reg = )
16609 4C10           B8                   009B  mov	ax,#$9B
16610 4C13           50                         push	ax
16611                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16612 4C14           8B46         06            mov	ax,6[bp]
16613                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16614                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16615 4C17           05                   0025  add	ax,*$25
16616 4C1A           50                         push	ax
16617                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16618 4C1B           FF76         14            push	$14[bp]
16619                                           ! Debug: func () void = write_byte+0 (used reg = )
16620 4C1E           E8         B9FD            call	_write_byte
16621 4C21           83C4                   06  add	sp,*6
16622                                           !BCC_EOS
16623                                           ! 2584       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
16624                                           ! Debug: list int = const 0 (used reg = )
16625 4C24           31C0                       xor	ax,ax
16626 4C26           50                         push	ax
16627                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16628 4C27           8B46         06            mov	ax,6[bp]
16629                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16630                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16631 4C2A           05                   0026  add	ax,*$26
16632 4C2D           50                         push	ax
16633                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16634 4C2E           FF76         14            push	$14[bp]
16635                                           ! Debug: func () void = write_word+0 (used reg = )
16636 4C31           E8         BA02            call	_write_word
16637 4C34           83C4                   06  add	sp,*6
16638                                           !BCC_EOS
16639                                           ! 2585       ss = get_SS();
16640                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16641 4C37           E8         BA17            call	_get_SS
16642                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
16643 4C3A           8946         F6            mov	-$A[bp],ax
16644                                           !BCC_EOS
16645                                           ! 2586       base15_00 = ss << 4;
16646                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
16647 4C3D           8B46         F6            mov	ax,-$A[bp]
16648 4C40           B1                     04  mov	cl,*4
16649 4C42           D3E0                       shl	ax,cl
16650                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16651 4C44           8946         FA            mov	-6[bp],ax
16652                                           !BCC_EOS
16653                                           ! 2587       base23_16 = ss >> 12;
16654                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
16655 4C47           8B46         F6            mov	ax,-$A[bp]
16656 4C4A           88E0                       mov	al,ah
16657 4C4C           30E4                       xor	ah,ah
16658 4C4E           B1                     04  mov	cl,*4
16659 4C50           D3E8                       shr	ax,cl
16660                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
16661 4C52           8846         F9            mov	-7[bp],al
16662                                           !BCC_EOS
16663                                           ! 2588       write_word(ES, regs.u.r
16664                                           ! 2588 16.si+0x28+0, 0xffff);
16665                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16666 4C55           B8                   FFFF  mov	ax,#$FFFF
16667 4C58           50                         push	ax
16668                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16669 4C59           8B46         06            mov	ax,6[bp]
16670                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16671                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16672 4C5C           05                   0028  add	ax,*$28
16673 4C5F           50                         push	ax
16674                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16675 4C60           FF76         14            push	$14[bp]
16676                                           ! Debug: func () void = write_word+0 (used reg = )
16677 4C63           E8         B9D0            call	_write_word
16678 4C66           83C4                   06  add	sp,*6
16679                                           !BCC_EOS
16680                                           ! 2589       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16681                                           ! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
16682 4C69           FF76         FA            push	-6[bp]
16683                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16684 4C6C           8B46         06            mov	ax,6[bp]
16685                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16686                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16687 4C6F           05                   002A  add	ax,*$2A
16688 4C72           50                         push	ax
16689                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16690 4C73           FF76         14            push	$14[bp]
16691                                           ! Debug: func () void = write_word+0 (used reg = )
16692 4C76           E8         B9BD            call	_write_word
16693 4C79           83C4                   06  add	sp,*6
16694                                           !BCC_EOS
16695                                           ! 2590       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16696                                           ! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
16697 4C7C           8A46         F9            mov	al,-7[bp]
16698 4C7F           30E4                       xor	ah,ah
16699 4C81           50                         push	ax
16700                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16701 4C82           8B46         06            mov	ax,6[bp]
16702                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16703                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16704 4C85           05                   002C  add	ax,*$2C
16705 4C88           50                         push	ax
16706                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16707 4C89           FF76         14            push	$14[bp]
16708                                           ! Debug: func () void = write_byte+0 (used reg = )
16709 4C8C           E8         B98F            call	_write_byte
16710 4C8F           83C4                   06  add	sp,*6
16711                                           !BCC_EOS
16712                                           ! 2591       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
16713                                           ! Debug: list int = const $93 (used reg = )
16714 4C92           B8                   0093  mov	ax,#$93
16715 4C95           50                         push	ax
16716                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16717 4C96           8B46         06            mov	ax,6[bp]
16718                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
16719                                           ! Debug: list unsigned int = ax+$2D (used reg = )
16720 4C99           05                   002D  add	ax,*$2D
16721 4C9C           50                         push	ax
16722                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16723 4C9D           FF76         14            push	$14[bp]
16724                                           ! Debug: func () void = write_byte+0 (used reg = )
16725 4CA0           E8         B97B            call	_write_byte
16726 4CA3           83C4                   06  add	sp,*6
16727                                           !BCC_EOS
16728                                           ! 2592       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
16729                                           ! Debug: list int = const 0 (used reg = )
16730 4CA6           31C0                       xor	ax,ax
16731 4CA8           50                         push	ax
16732                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16733 4CA9           8B46         06            mov	ax,6[bp]
16734                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
16735                                           ! Debug: list unsigned int = ax+$2E (used reg = )
16736 4CAC           05                   002E  add	ax,*$2E
16737 4CAF           50                         push	ax
16738                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16739 4CB0           FF76         14            push	$14[bp]
16740                                           ! Debug: func () void = write_word+0 (used reg = )
16741 4CB3           E8         B980            call	_write_word
16742 4CB6           83C4                   06  add	sp,*6
16743                                           !BCC_EOS
16744                                           ! 2593       CX = regs.u.r16.cx;
16745                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
16746 4CB9           8B46         10            mov	ax,$10[bp]
16747 4CBC           8946         F2            mov	-$E[bp],ax
16748                                           !BCC_EOS
16749                                           ! 2594 #asm
16750                                           !BCC_EOS
16751                                           !BCC_ASM
16752                       00000006            _int15_function.CX	set	6
16753                       FFFFFFF2            .int15_function.CX	set	-$E
16754                       0000002C            _int15_function.FLAGS	set	$2C
16755                       00000018            .int15_function.FLAGS	set	$18
16756                       00000001            _int15_function.irqDisable	set	1
16757                       FFFFFFED            .int15_function.irqDisable	set	-$13
16758                       0000002A            _int15_function.DS	set	$2A
16759                       00000016            .int15_function.DS	set	$16
16760                       00000004            _int15_function.DX	set	4
16761                       FFFFFFF0            .int15_function.DX	set	-$10
16762                       0000000D            _int15_function.base23_16	set	$D
16763                       FFFFFFF9            .int15_function.base23_16	set	-7
16764                       00000002            _int15_function.bRegister	set	2
16765                       FFFFFFEE            .int15_function.bRegister	set	-$12
16766                       00000028            _int15_function.ES	set	$28
16767                       00000014            .int15_function.ES	set	$14
16768                       00000012            _int15_function.ebda_seg	set	$12
16769                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16770                       0000000E            _int15_function.base15_00	set	$E
16771                       FFFFFFFA            .int15_function.base15_00	set	-6
16772                       0000000A            _int15_function.ss	set	$A
16773                       FFFFFFF6            .int15_function.ss	set	-$A
16774                       00000008            _int15_function.BX	set	8
16775                       FFFFFFF4            .int15_function.BX	set	-$C
16776                       00000018            _int15_function.regs	set	$18
16777                       00000004            .int15_function.regs	set	4
16778                       00000010            _int15_function.prev_a20_enable	set	$10
16779                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16780 4CBF           89E3                             mov bx, sp
16781 4CC1           36                               SEG SS
16782 4CC2           8B4F         06                    mov cx, _int15_function.CX [bx]
16783 4CC5     66    50                               push eax
16784 4CC7     66    31C0                             xor eax, eax
16785 4CCA           8ED8                             mov ds, ax
16786 4CCC           8C16       0469                  mov 0x0469, ss
16787 4CD0           8926       0467                  mov 0x0467, sp
16788 4CD4           26                               SEG ES
16789 4CD5         0F0154         08                    lgdt [si + 0x08]
16790 4CD9           2E                               SEG CS
16791 4CDA         0F011E       F88C                    lidt [pmode_IDT_info]
16792                                                 ;; perhaps do something with IDT here
16793                                                 ;; set PE bit in CR0
16794 4CDF         0F20C0                             mov eax, cr0
16795 4CE2           0C                     01        or al, #0x01
16796 4CE4         0F22C0                             mov cr0, eax
16797                                                 ;; far jump to flush CPU queue after transition to protected mode
16798                                                 JMP_AP(0x0020, protected_mode)
 +a   4CE7                        EA              db 0xea
 +a   4CE8                      4CEC              dw  protected_mode
 +a   4CEA                      0020              dw 0x0020
16799                       00004CEC            protected_mode:
16800                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
16801 4CEC           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
16802 4CEF           8ED0                             mov ss, ax
16803 4CF1           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
16804 4CF4           8ED8                             mov ds, ax
16805 4CF6           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
16806 4CF9           8EC0                             mov es, ax
16807 4CFB           31F6                             xor si, si
16808 4CFD           31FF                             xor di, di
16809 4CFF           FC                               cld
16810 4D00           F3                               rep
16811 4D01           A5                                 movsw ;; move CX words from DS:SI to ES:DI
16812                                                 ;; make sure DS and ES limits are 64KB
16813 4D02           B8                   0028        mov ax, #0x28
16814 4D05           8ED8                             mov ds, ax
16815 4D07           8EC0                             mov es, ax
16816                                                 ;; reset PG bit in CR0 ???
16817 4D09         0F20C0                             mov eax, cr0
16818 4D0C           24                     FE        and al, #0xFE
16819 4D0E         0F22C0                             mov cr0, eax
16820                                                 ;; far jump to flush CPU queue after transition to real mode
16821                                                 JMP_AP(0xf000, real_mode)
 +a   4D11                        EA              db 0xea
 +a   4D12                      4D16              dw  real_mode
 +a   4D14                      F000              dw 0xf000
16822                       00004D16            real_mode:
16823                                                 ;; restore IDT to normal real-mode defaults
16824 4D16           2E                               SEG CS
16825 4D17         0F011E       F891                    lidt [rmode_IDT_info]
16826 4D1C           31C0                             xor ax, ax
16827 4D1E           8ED8                             mov ds, ax
16828 4D20           8E16       0469                  mov ss, 0x0469
16829 4D24           8B26       0467                  mov sp, 0x0467
16830 4D28     66    58                               pop eax
16831                                           ! 2646 endasm
16832                                           !BCC_ENDASM
16833                                           !BCC_EOS
16834                                           ! 2647       set_enable_a20(prev_a20_enable);
16835                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
16836 4D2A           FF76         FC            push	-4[bp]
16837                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16838 4D2D           E8         CAC9            call	_set_enable_a20
16839 4D30           44                         inc	sp
16840 4D31           44                         inc	sp
16841                                           !BCC_EOS
16842                                           ! 2648 #asm
16843                                           !BCC_EOS
16844                                           !BCC_ASM
16845                       00000006            _int15_function.CX	set	6
16846                       FFFFFFF2            .int15_function.CX	set	-$E
16847                       0000002C            _int15_function.FLAGS	set	$2C
16848                       00000018            .int15_function.FLAGS	set	$18
16849                       00000001            _int15_function.irqDisable	set	1
16850                       FFFFFFED            .int15_function.irqDisable	set	-$13
16851                       0000002A            _int15_function.DS	set	$2A
16852                       00000016            .int15_function.DS	set	$16
16853                       00000004            _int15_function.DX	set	4
16854                       FFFFFFF0            .int15_function.DX	set	-$10
16855                       0000000D            _int15_function.base23_16	set	$D
16856                       FFFFFFF9            .int15_function.base23_16	set	-7
16857                       00000002            _int15_function.bRegister	set	2
16858                       FFFFFFEE            .int15_function.bRegister	set	-$12
16859                       00000028            _int15_function.ES	set	$28
16860                       00000014            .int15_function.ES	set	$14
16861                       00000012            _int15_function.ebda_seg	set	$12
16862                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16863                       0000000E            _int15_function.base15_00	set	$E
16864                       FFFFFFFA            .int15_function.base15_00	set	-6
16865                       0000000A            _int15_function.ss	set	$A
16866                       FFFFFFF6            .int15_function.ss	set	-$A
16867                       00000008            _int15_function.BX	set	8
16868                       FFFFFFF4            .int15_function.BX	set	-$C
16869                       00000018            _int15_function.regs	set	$18
16870                       00000004            .int15_function.regs	set	4
16871                       00000010            _int15_function.prev_a20_enable	set	$10
16872                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16873 4D32           FB                           sti
16874                                           ! 2650 endasm
16875                                           !BCC_ENDASM
16876                                           !BCC_EOS
16877                                           ! 2651       regs.u.r8.ah = 0;
16878                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16879 4D33           30C0                       xor	al,al
16880 4D35           8846         13            mov	$13[bp],al
16881                                           !BCC_EOS
16882                                           ! 2652       FLAGS &= 0xfffe;
16883                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16884 4D38           8B46         18            mov	ax,$18[bp]
16885 4D3B           24                     FE  and	al,#$FE
16886 4D3D           8946         18            mov	$18[bp],ax
16887                                           !BCC_EOS
16888                                           ! 2653       break;
16889 4D40           E9         01FE            br 	.365
16890                                           !BCC_EOS
16891                                           ! 2654     case 0x88:
16892                                           ! 2655       regs.u.r8.al = inb_cmos(0x30);
16893                       00004D43            .382:
16894                                           ! Debug: list int = const $30 (used reg = )
16895 4D43           B8                   0030  mov	ax,*$30
16896 4D46           50                         push	ax
16897                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16898 4D47           E8         B83D            call	_inb_cmos
16899 4D4A           44                         inc	sp
16900 4D4B           44                         inc	sp
16901                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
16902 4D4C           8846         12            mov	$12[bp],al
16903                                           !BCC_EOS
16904                                           ! 2656       regs.u.r8.ah = inb_cmos(0x31);
16905                                           ! Debug: list int = const $31 (used reg = )
16906 4D4F           B8                   0031  mov	ax,*$31
16907 4D52           50                         push	ax
16908                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16909 4D53           E8         B831            call	_inb_cmos
16910 4D56           44                         inc	sp
16911 4D57           44                         inc	sp
16912                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
16913 4D58           8846         13            mov	$13[bp],al
16914                                           !BCC_EOS
16915                                           ! 2657       if(regs.u.r16.ax > 0xffc0)
16916                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
16917 4D5B           8B46         12            mov	ax,$12[bp]
16918 4D5E           3D                   FFC0  cmp	ax,#$FFC0
16919 4D61           76           06            jbe 	.383
16920                       00004D63            .384:
16921                                           ! 2658         regs.u.r16.ax = 0xffc0;
16922                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
16923 4D63           B8                   FFC0  mov	ax,#$FFC0
16924 4D66           8946         12            mov	$12[bp],ax
16925                                           !BCC_EOS
16926                                           ! 2659       FLAGS &= 0xfffe;
16927                       00004D69            .383:
16928                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16929 4D69           8B46         18            mov	ax,$18[bp]
16930 4D6C           24                     FE  and	al,#$FE
16931 4D6E           8946         18            mov	$18[bp],ax
16932                                           !BCC_EOS
16933                                           ! 2660       break;
16934 4D71           E9         01CD            br 	.365
16935                                           !BCC_EOS
16936                                           ! 2661   case 0x89:
16937                                           ! 2662 #asm
16938                       00004D74            .385:
16939                                           !BCC_EOS
16940                                           !BCC_ASM
16941                       00000006            _int15_function.CX	set	6
16942                       FFFFFFF2            .int15_function.CX	set	-$E
16943                       0000002C            _int15_function.FLAGS	set	$2C
16944                       00000018            .int15_function.FLAGS	set	$18
16945                       00000001            _int15_function.irqDisable	set	1
16946                       FFFFFFED            .int15_function.irqDisable	set	-$13
16947                       0000002A            _int15_function.DS	set	$2A
16948                       00000016            .int15_function.DS	set	$16
16949                       00000004            _int15_function.DX	set	4
16950                       FFFFFFF0            .int15_function.DX	set	-$10
16951                       0000000D            _int15_function.base23_16	set	$D
16952                       FFFFFFF9            .int15_function.base23_16	set	-7
16953                       00000002            _int15_function.bRegister	set	2
16954                       FFFFFFEE            .int15_function.bRegister	set	-$12
16955                       00000028            _int15_function.ES	set	$28
16956                       00000014            .int15_function.ES	set	$14
16957                       00000012            _int15_function.ebda_seg	set	$12
16958                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16959                       0000000E            _int15_function.base15_00	set	$E
16960                       FFFFFFFA            .int15_function.base15_00	set	-6
16961                       0000000A            _int15_function.ss	set	$A
16962                       FFFFFFF6            .int15_function.ss	set	-$A
16963                       00000008            _int15_function.BX	set	8
16964                       FFFFFFF4            .int15_function.BX	set	-$C
16965                       00000018            _int15_function.regs	set	$18
16966                       00000004            .int15_function.regs	set	4
16967                       00000010            _int15_function.prev_a20_enable	set	$10
16968                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16969 4D74           FA                           cli
16970                                           ! 2664 endasm
16971                                           !BCC_ENDASM
16972                                           !BCC_EOS
16973                                           ! 2665       set_en
16974                                           ! 2665 able_a20(1);
16975                                           ! Debug: list int = const 1 (used reg = )
16976 4D75           B8                   0001  mov	ax,*1
16977 4D78           50                         push	ax
16978                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16979 4D79           E8         CA7D            call	_set_enable_a20
16980 4D7C           44                         inc	sp
16981 4D7D           44                         inc	sp
16982                                           !BCC_EOS
16983                                           ! 2666       write_word(ES, regs.u.r16.si+0x38+0, 0xffff);
16984                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16985 4D7E           B8                   FFFF  mov	ax,#$FFFF
16986 4D81           50                         push	ax
16987                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
16988 4D82           8B46         06            mov	ax,6[bp]
16989                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
16990                                           ! Debug: list unsigned int = ax+$38 (used reg = )
16991 4D85           05                   0038  add	ax,*$38
16992 4D88           50                         push	ax
16993                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16994 4D89           FF76         14            push	$14[bp]
16995                                           ! Debug: func () void = write_word+0 (used reg = )
16996 4D8C           E8         B8A7            call	_write_word
16997 4D8F           83C4                   06  add	sp,*6
16998                                           !BCC_EOS
16999                                           ! 2667       write_word(ES, regs.u.r16.si+0x38+2, 0x0000);
17000                                           ! Debug: list int = const 0 (used reg = )
17001 4D92           31C0                       xor	ax,ax
17002 4D94           50                         push	ax
17003                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17004 4D95           8B46         06            mov	ax,6[bp]
17005                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
17006                                           ! Debug: list unsigned int = ax+$3A (used reg = )
17007 4D98           05                   003A  add	ax,*$3A
17008 4D9B           50                         push	ax
17009                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17010 4D9C           FF76         14            push	$14[bp]
17011                                           ! Debug: func () void = write_word+0 (used reg = )
17012 4D9F           E8         B894            call	_write_word
17013 4DA2           83C4                   06  add	sp,*6
17014                                           !BCC_EOS
17015                                           ! 2668       write_byte(ES, regs.u.r16.si+0x38+4, 0x000f);
17016                                           ! Debug: list int = const $F (used reg = )
17017 4DA5           B8                   000F  mov	ax,*$F
17018 4DA8           50                         push	ax
17019                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17020 4DA9           8B46         06            mov	ax,6[bp]
17021                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
17022                                           ! Debug: list unsigned int = ax+$3C (used reg = )
17023 4DAC           05                   003C  add	ax,*$3C
17024 4DAF           50                         push	ax
17025                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17026 4DB0           FF76         14            push	$14[bp]
17027                                           ! Debug: func () void = write_byte+0 (used reg = )
17028 4DB3           E8         B868            call	_write_byte
17029 4DB6           83C4                   06  add	sp,*6
17030                                           !BCC_EOS
17031                                           ! 2669       write_byte(ES, regs.u.r16.si+0x38+5, 0x9b);
17032                                           ! Debug: list int = const $9B (used reg = )
17033 4DB9           B8                   009B  mov	ax,#$9B
17034 4DBC           50                         push	ax
17035                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17036 4DBD           8B46         06            mov	ax,6[bp]
17037                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
17038                                           ! Debug: list unsigned int = ax+$3D (used reg = )
17039 4DC0           05                   003D  add	ax,*$3D
17040 4DC3           50                         push	ax
17041                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17042 4DC4           FF76         14            push	$14[bp]
17043                                           ! Debug: func () void = write_byte+0 (used reg = )
17044 4DC7           E8         B854            call	_write_byte
17045 4DCA           83C4                   06  add	sp,*6
17046                                           !BCC_EOS
17047                                           ! 2670       write_word(ES, regs.u.r16.si+0x38+6, 0x0000);
17048                                           ! Debug: list int = const 0 (used reg = )
17049 4DCD           31C0                       xor	ax,ax
17050 4DCF           50                         push	ax
17051                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17052 4DD0           8B46         06            mov	ax,6[bp]
17053                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
17054                                           ! Debug: list unsigned int = ax+$3E (used reg = )
17055 4DD3           05                   003E  add	ax,*$3E
17056 4DD6           50                         push	ax
17057                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17058 4DD7           FF76         14            push	$14[bp]
17059                                           ! Debug: func () void = write_word+0 (used reg = )
17060 4DDA           E8         B859            call	_write_word
17061 4DDD           83C4                   06  add	sp,*6
17062                                           !BCC_EOS
17063                                           ! 2671       BX = regs.u.r16.bx;
17064                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
17065 4DE0           8B46         0C            mov	ax,$C[bp]
17066 4DE3           8946         F4            mov	-$C[bp],ax
17067                                           !BCC_EOS
17068                                           ! 2672 #asm
17069                                           !BCC_EOS
17070                                           !BCC_ASM
17071                       00000006            _int15_function.CX	set	6
17072                       FFFFFFF2            .int15_function.CX	set	-$E
17073                       0000002C            _int15_function.FLAGS	set	$2C
17074                       00000018            .int15_function.FLAGS	set	$18
17075                       00000001            _int15_function.irqDisable	set	1
17076                       FFFFFFED            .int15_function.irqDisable	set	-$13
17077                       0000002A            _int15_function.DS	set	$2A
17078                       00000016            .int15_function.DS	set	$16
17079                       00000004            _int15_function.DX	set	4
17080                       FFFFFFF0            .int15_function.DX	set	-$10
17081                       0000000D            _int15_function.base23_16	set	$D
17082                       FFFFFFF9            .int15_function.base23_16	set	-7
17083                       00000002            _int15_function.bRegister	set	2
17084                       FFFFFFEE            .int15_function.bRegister	set	-$12
17085                       00000028            _int15_function.ES	set	$28
17086                       00000014            .int15_function.ES	set	$14
17087                       00000012            _int15_function.ebda_seg	set	$12
17088                       FFFFFFFE            .int15_function.ebda_seg	set	-2
17089                       0000000E            _int15_function.base15_00	set	$E
17090                       FFFFFFFA            .int15_function.base15_00	set	-6
17091                       0000000A            _int15_function.ss	set	$A
17092                       FFFFFFF6            .int15_function.ss	set	-$A
17093                       00000008            _int15_function.BX	set	8
17094                       FFFFFFF4            .int15_function.BX	set	-$C
17095                       00000018            _int15_function.regs	set	$18
17096                       00000004            .int15_function.regs	set	4
17097                       00000010            _int15_function.prev_a20_enable	set	$10
17098                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
17099 4DE6           89E3                             mov bx, sp
17100 4DE8           36                               SEG SS
17101 4DE9           8B5F         08                    mov bx, _int15_function.BX [bx]
17102 4DEC           B0                     11        mov al, #0x11 ; send initialisation commands
17103 4DEE           E6                     20        out 0x20, al
17104 4DF0           E6                     A0        out 0xa0, al
17105 4DF2           88F8                             mov al, bh
17106 4DF4           E6                     21        out 0x21, al
17107 4DF6           88D8                             mov al, bl
17108 4DF8           E6                     A1        out 0xa1, al
17109 4DFA           B0                     04        mov al, #0x04
17110 4DFC           E6                     21        out 0x21, al
17111 4DFE           B0                     02        mov al, #0x02
17112 4E00           E6                     A1        out 0xa1, al
17113 4E02           B0                     01        mov al, #0x01
17114 4E04           E6                     21        out 0x21, al
17115 4E06           E6                     A1        out 0xa1, al
17116 4E08           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
17117 4E0A           E6                     21        out 0x21, al
17118 4E0C           E6                     A1        out 0xa1, al
17119 4E0E           26                               SEG ES
17120 4E0F         0F0154         08                    lgdt [si + 0x08]
17121 4E13           26                               SEG ES
17122 4E14         0F015C         10                    lidt [si + 0x10]
17123 4E18         0F20C0                             mov eax, cr0
17124 4E1B           0C                     01        or al, #0x01
17125 4E1D         0F22C0                             mov cr0, eax
17126                                                 JMP_AP(0x0038, protmode_switch)
 +a   4E20                        EA              db 0xea
 +a   4E21                      4E25              dw  protmode_switch
 +a   4E23                      0038              dw 0x0038
17127                       00004E25            protmode_switch:
17128                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
17129 4E25           B8                   0028        mov ax, #0x28
17130 4E28           8ED0                             mov ss, ax
17131 4E2A           B8                   0018        mov ax, #0x18
17132 4E2D           8ED8                             mov ds, ax
17133 4E2F           B8                   0020        mov ax, #0x20
17134 4E32           8EC0                             mov es, ax
17135 4E34           89EC                             mov sp,bp
17136 4E36           83C4                   04        add sp,#4 ; skip return address
17137 4E39           61                               popa ; restore regs
17138 4E3A           58                               pop ax ; skip saved es
17139 4E3B           58                               pop ax ; skip saved ds
17140 4E3C           58                               pop ax ; skip saved flags
17141 4E3D           59                               pop cx ; get return offset
17142 4E3E           58                               pop ax ; skip return segment
17143 4E3F           58                               pop ax ; skip flags
17144 4E40           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
17145 4E43           50                               push ax
17146 4E44           51                               push cx ; re-create modified ret address on stack
17147 4E45           CB                               retf
17148                                           ! 2722 endasm
17149                                           !BCC_ENDASM
17150                                           !BCC_EOS
17151                                           ! 2723       break;
17152 4E46           E9         00F8            br 	.365
17153                                           !BCC_EOS
17154                                           ! 2724     case 0x90:
17155                                           ! 2725       break;
17156                       00004E49            .386:
17157 4E49           E9         00F5            br 	.365
17158                                           !BCC_EOS
17159                                           ! 2726     case 0x91:
17160                                           ! 2727       break;
17161                       00004E4C            .387:
17162 4E4C           E9         00F2            br 	.365
17163                                           !BCC_EOS
17164                                           ! 2728     case 0xbf:
17165                                           ! 2729       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
17166                       00004E4F            .388:
17167                                           ! Debug: list * char = .389+0 (used reg = )
17168 4E4F           BB                   D546  mov	bx,#.389
17169 4E52           53                         push	bx
17170                                           ! Debug: list int = const 4 (used reg = )
17171 4E53           B8                   0004  mov	ax,*4
17172 4E56           50                         push	ax
17173                                           ! Debug: func () void = bios_printf+0 (used reg = )
17174 4E57           E8         BB4D            call	_bios_printf
17175 4E5A           83C4                   04  add	sp,*4
17176                                           !BCC_EOS
17177                                           ! 2730       FLAGS |= 0x0001;
17178                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17179 4E5D           8B46         18            mov	ax,$18[bp]
17180 4E60           0C                     01  or	al,*1
17181 4E62           8946         18            mov	$18[bp],ax
17182                                           !BCC_EOS
17183                                           ! 2731       regs.u.r8.ah = 0x86;
17184                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17185 4E65           B0                     86  mov	al,#$86
17186 4E67           8846         13            mov	$13[bp],al
17187                                           !BCC_EOS
17188                                           ! 2732       break;
17189 4E6A           E9         00D4            br 	.365
17190                                           !BCC_EOS
17191                                           ! 2733     case 0xC0:
17192                                           ! 2734       FLAGS &= 0xfffe;
17193                       00004E6D            .38A:
17194                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
17195 4E6D           8B46         18            mov	ax,$18[bp]
17196 4E70           24                     FE  and	al,#$FE
17197 4E72           8946         18            mov	$18[bp],ax
17198                                           !BCC_EOS
17199                                           ! 2735       regs.u.r8.ah = 0;
17200                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
17201 4E75           30C0                       xor	al,al
17202 4E77           8846         13            mov	$13[bp],al
17203                                           !BCC_EOS
17204                                           ! 2736       regs.u.r16.bx = 0xe6f5;
17205                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
17206 4E7A           B8                   E6F5  mov	ax,#$E6F5
17207 4E7D           8946         0C            mov	$C[bp],ax
17208                                           !BCC_EOS
17209                                           ! 2737       ES = 0xF000;
17210                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
17211 4E80           B8                   F000  mov	ax,#$F000
17212 4E83           8946         14            mov	$14[bp],ax
17213                                           !BCC_EOS
17214                                           ! 2738       break;
17215 4E86           E9         00B8            br 	.365
17216                                           !BCC_EOS
17217                                           ! 2739     case 0xc1:
17218                                           ! 2740       ES = ebda_seg;
17219                       00004E89            .38B:
17220                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
17221 4E89           8B46         FE            mov	ax,-2[bp]
17222 4E8C           8946         14            mov	$14[bp],ax
17223                                           !BCC_EOS
17224                                           ! 2741       FLAGS &= 0xfffe;
17225                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
17226 4E8F           8B46         18            mov	ax,$18[bp]
17227 4E92           24                     FE  and	al,#$FE
17228 4E94           8946         18            mov	$18[bp],ax
17229                                           !BCC_EOS
17230                                           ! 2742       break;
17231 4E97           E9         00A7            br 	.365
17232                                           !BCC_EOS
17233                                           ! 2743     case 0xd8:
17234                                           ! 2744       bios_printf(8, "EISA BIOS not present\n");
17235                       00004E9A            .38C:
17236                                           ! Debug: list * char = .38D+0 (used reg = )
17237 4E9A           BB                   D52F  mov	bx,#.38D
17238 4E9D           53                         push	bx
17239                                           ! Debug: list int = const 8 (used reg = )
17240 4E9E           B8                   0008  mov	ax,*8
17241 4EA1           50                         push	ax
17242                                           ! Debug: func () void = bios_printf+0 (used reg = )
17243 4EA2           E8         BB02            call	_bios_printf
17244 4EA5           83C4                   04  add	sp,*4
17245                                           !BCC_EOS
17246                                           ! 2745       FLAGS |= 0x0001;
17247                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17248 4EA8           8B46         18            mov	ax,$18[bp]
17249 4EAB           0C                     01  or	al,*1
17250 4EAD           8946         18            mov	$18[bp],ax
17251                                           !BCC_EOS
17252                                           ! 2746       re
17253                                           ! 2746 gs.u.r8.ah = 0x86;
17254                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17255 4EB0           B0                     86  mov	al,#$86
17256 4EB2           8846         13            mov	$13[bp],al
17257                                           !BCC_EOS
17258                                           ! 2747       break;
17259 4EB5           E9         0089            br 	.365
17260                                           !BCC_EOS
17261                                           ! 2748     default:
17262                                           ! 2749       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17263                       00004EB8            .38E:
17264                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
17265 4EB8           FF76         0C            push	$C[bp]
17266                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
17267 4EBB           FF76         12            push	$12[bp]
17268                                           ! Debug: list * char = .38F+0 (used reg = )
17269 4EBE           BB                   D4F5  mov	bx,#.38F
17270 4EC1           53                         push	bx
17271                                           ! Debug: list int = const 4 (used reg = )
17272 4EC2           B8                   0004  mov	ax,*4
17273 4EC5           50                         push	ax
17274                                           ! Debug: func () void = bios_printf+0 (used reg = )
17275 4EC6           E8         BADE            call	_bios_printf
17276 4EC9           83C4                   08  add	sp,*8
17277                                           !BCC_EOS
17278                                           ! 2750       FLAGS |= 0x0001;
17279                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17280 4ECC           8B46         18            mov	ax,$18[bp]
17281 4ECF           0C                     01  or	al,*1
17282 4ED1           8946         18            mov	$18[bp],ax
17283                                           !BCC_EOS
17284                                           ! 2751       regs.u.r8.ah = 0x86;
17285                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17286 4ED4           B0                     86  mov	al,#$86
17287 4ED6           8846         13            mov	$13[bp],al
17288                                           !BCC_EOS
17289                                           ! 2752       break;
17290 4ED9           EB           66            jmp .365
17291                                           !BCC_EOS
17292                                           ! 2753     }
17293                                           ! 2754 }
17294 4EDB           EB           64            jmp .365
17295                       00004EDD            .367:
17296 4EDD           2C                     24  sub	al,*$24
17297 4EDF         0F84         FA5F            beq 	.368
17298 4EE3           2C                     1D  sub	al,*$1D
17299 4EE5         0F84         FB01            beq 	.372
17300 4EE9           2C                     0E  sub	al,*$E
17301 4EEB         0F84         FB0B            beq 	.373
17302 4EEF           2C                     03  sub	al,*3
17303 4EF1         0F84         FB10            beq 	.374
17304 4EF5           2C                     31  sub	al,*$31
17305 4EF7           72           BF            jb 	.38E
17306 4EF9           3C                     0E  cmp	al,*$E
17307 4EFB           77           29            ja  	.390
17308 4EFD           30E4                       xor	ah,ah
17309 4EFF           D1E0                       shl	ax,*1
17310 4F01           89C3                       mov	bx,ax
17311 4F03           2E                         seg	cs
17312 4F04           FFA7       4F08            br	.391[bx]
17313                       00004F08            .391:
17314 4F08                      4A15            .word	.375
17315 4F0A                      4EB8            .word	.38E
17316 4F0C                      4EB8            .word	.38E
17317 4F0E                      4EB8            .word	.38E
17318 4F10                      4B36            .word	.37F
17319 4F12                      4D43            .word	.382
17320 4F14                      4D74            .word	.385
17321 4F16                      4EB8            .word	.38E
17322 4F18                      4EB8            .word	.38E
17323 4F1A                      4EB8            .word	.38E
17324 4F1C                      4EB8            .word	.38E
17325 4F1E                      4EB8            .word	.38E
17326 4F20                      4EB8            .word	.38E
17327 4F22                      4E49            .word	.386
17328 4F24                      4E4C            .word	.387
17329                       00004F26            .390:
17330 4F26           2C                     3C  sub	al,*$3C
17331 4F28         0F84         FF23            beq 	.388
17332 4F2C           2C                     01  sub	al,*1
17333 4F2E         0F84         FF3B            beq 	.38A
17334 4F32           2C                     01  sub	al,*1
17335 4F34         0F84         FF51            beq 	.38B
17336 4F38           2C                     17  sub	al,*$17
17337 4F3A         0F84         FF5C            beq 	.38C
17338 4F3E           E9         FF77            br 	.38E
17339                       00004F41            .365:
17340                       FFFFFFEA            ..FFF7	=	-$16
17341 4F41           89EC                       mov	sp,bp
17342 4F43           5D                         pop	bp
17343 4F44           C3                         ret
17344                                           ! 2755   void
17345                                           ! Register BX used in function int15_function
17346                                           ! 2756 int15_function_mouse(regs, ES, DS, FLAGS)
17347                                           ! 2757   pusha_regs_t regs;
17348                                           export	_int15_function_mouse
17349                       00004F45            _int15_function_mouse:
17350                                           !BCC_EOS
17351                                           ! 2758   Bit16u ES, DS, FLAGS;
17352                                           !BCC_EOS
17353                                           ! 2759 {
17354                                           ! 2760   Bit16u ebda_seg=read_word(0x0040,0x000E);
17355 4F45           55                         push	bp
17356 4F46           89E5                       mov	bp,sp
17357 4F48           4C                         dec	sp
17358 4F49           4C                         dec	sp
17359                                           ! Debug: list int = const $E (used reg = )
17360 4F4A           B8                   000E  mov	ax,*$E
17361 4F4D           50                         push	ax
17362                                           ! Debug: list int = const $40 (used reg = )
17363 4F4E           B8                   0040  mov	ax,*$40
17364 4F51           50                         push	ax
17365                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17366 4F52           E8         B6B6            call	_read_word
17367 4F55           83C4                   04  add	sp,*4
17368                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
17369 4F58           8946         FE            mov	-2[bp],ax
17370                                           !BCC_EOS
17371                                           ! 2761   Bit8u mouse_flags_1, mouse_flags_2;
17372                                           !BCC_EOS
17373                                           ! 2762   Bit16u mouse_driver_seg;
17374                                           !BCC_EOS
17375                                           ! 2763   Bit16u mouse_driver_offset;
17376                                           !BCC_EOS
17377                                           ! 2764   Bit8u comm_byte, prev_command_byte;
17378                                           !BCC_EOS
17379                                           ! 2765   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
17380                                           !BCC_EOS
17381                                           ! 2766 ;
17382 4F5B           83C4                   F4  add	sp,*-$C
17383                                           !BCC_EOS
17384                                           ! 2767   switch (regs.u.r8.ah) {
17385 4F5E           8A46         13            mov	al,$13[bp]
17386 4F61           E9         0652            br 	.394
17387                                           ! 2768     case 0xC2:
17388                                           ! 2769       switch (regs.u.r8.al) {
17389                       00004F64            .395:
17390 4F64           8A46         12            mov	al,$12[bp]
17391 4F67           E9         0600            br 	.398
17392                                           ! 2770         case 0:
17393                                           ! 2771 ;
17394                       00004F6A            .399:
17395                                           !BCC_EOS
17396                                           ! 2772           switch (regs.u.r8.bh) {
17397 4F6A           8A46         0D            mov	al,$D[bp]
17398 4F6D           E9         00E9            br 	.39C
17399                                           ! 2773             case 0:
17400                                           ! 2774 ;
17401                       00004F70            .39D:
17402                                           !BCC_EOS
17403                                           ! 2775               inhibit_mouse_int_and_events();
17404                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17405 4F70           E8         118F            call	_inhibit_mouse_int_and_events
17406                                           !BCC_EOS
17407                                           ! 2776               ret = send_to_mouse_ctrl(0xF5);
17408                                           ! Debug: list int = const $F5 (used reg = )
17409 4F73           B8                   00F5  mov	ax,#$F5
17410 4F76           50                         push	ax
17411                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17412 4F77           E8         12D9            call	_send_to_mouse_ctrl
17413 4F7A           44                         inc	sp
17414 4F7B           44                         inc	sp
17415                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17416 4F7C           8846         F5            mov	-$B[bp],al
17417                                           !BCC_EOS
17418                                           ! 2777               if (ret == 0) {
17419                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17420 4F7F           8A46         F5            mov	al,-$B[bp]
17421 4F82           84C0                       test	al,al
17422 4F84           75           2B            jne 	.39E
17423                       00004F86            .39F:
17424                                           ! 2778                 ret = get_mouse_data(&mouse_data1);
17425                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17426 4F86           8D5E         F4            lea	bx,-$C[bp]
17427 4F89           53                         push	bx
17428                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17429 4F8A           E8         1310            call	_get_mouse_data
17430 4F8D           44                         inc	sp
17431 4F8E           44                         inc	sp
17432                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17433 4F8F           8846         F5            mov	-$B[bp],al
17434                                           !BCC_EOS
17435                                           ! 2779                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17436                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17437 4F92           8A46         F5            mov	al,-$B[bp]
17438 4F95           84C0                       test	al,al
17439 4F97           74           07            je  	.3A1
17440                       00004F99            .3A2:
17441                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17442 4F99           8A46         F4            mov	al,-$C[bp]
17443 4F9C           3C                     FA  cmp	al,#$FA
17444 4F9E           75           11            jne 	.3A0
17445                       00004FA0            .3A1:
17446                                           ! 2780                   FLAGS &= 0xfffe;
17447                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17448 4FA0           8B46         18            mov	ax,$18[bp]
17449 4FA3           24                     FE  and	al,#$FE
17450 4FA5           8946         18            mov	$18[bp],ax
17451                                           !BCC_EOS
17452                                           ! 2781                   regs.u.r8.ah = 0;
17453                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17454 4FA8           30C0                       xor	al,al
17455 4FAA           8846         13            mov	$13[bp],al
17456                                           !BCC_EOS
17457                                           ! 2782                   return;
17458 4FAD           89EC                       mov	sp,bp
17459 4FAF           5D                         pop	bp
17460 4FB0           C3                         ret
17461                                           !BCC_EOS
17462                                           ! 2783                 }
17463                                           ! 2784               }
17464                       00004FB1            .3A0:
17465                                           ! 2785               FLAGS |= 0x0001;
17466                       00004FB1            .39E:
17467                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17468 4FB1           8B46         18            mov	ax,$18[bp]
17469 4FB4           0C                     01  or	al,*1
17470 4FB6           8946         18            mov	$18[bp],ax
17471                                           !BCC_EOS
17472                                           ! 2786               regs.u.r8.ah = ret;
17473                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17474 4FB9           8A46         F5            mov	al,-$B[bp]
17475 4FBC           8846         13            mov	$13[bp],al
17476                                           !BCC_EOS
17477                                           ! 2787               return;
17478 4FBF           89EC                       mov	sp,bp
17479 4FC1           5D                         pop	bp
17480 4FC2           C3                         ret
17481                                           !BCC_EOS
17482                                           ! 2788               break;
17483 4FC3           E9         00A1            br 	.39A
17484                                           !BCC_EOS
17485                                           ! 2789             case 1:
17486                                           ! 2790 ;
17487                       00004FC6            .3A3:
17488                                           !BCC_EOS
17489                                           ! 2791               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17490                                           ! Debug: list int = const $27 (used reg = )
17491 4FC6           B8                   0027  mov	ax,*$27
17492 4FC9           50                         push	ax
17493                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17494 4FCA           FF76         FE            push	-2[bp]
17495                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17496 4FCD           E8         B628            call	_read_byte
17497 4FD0           83C4                   04  add	sp,*4
17498                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17499 4FD3           8846         FC            mov	-4[bp],al
17500                                           !BCC_EOS
17501                                           ! 2792               if ( (mouse_flags_2 & 0x80) == 0 ) {
17502                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17503 4FD6           8A46         FC            mov	al,-4[bp]
17504 4FD9           24                     80  and	al,#$80
17505                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17506 4FDB           84C0                       test	al,al
17507 4FDD           75           11            jne 	.3A4
17508                       00004FDF            .3A5:
17509                                           ! 2793                 ;
17510                                           !BCC_EOS
17511                                           ! 2794                 FLAGS |= 0x0001;
17512                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17513 4FDF           8B46         18            mov	ax,$18[bp]
17514 4FE2           0C                     01  or	al,*1
17515 4FE4           8946         18            mov	$18[bp],ax
17516                                           !BCC_EOS
17517                                           ! 2795                 regs.u.r8.ah = 5;
17518                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17519 4FE7           B0                     05  mov	al,*5
17520 4FE9           8846         13            mov	$13[bp],al
17521                                           !BCC_EOS
17522                                           ! 2796                 return;
17523 4FEC           89EC                       mov	sp,bp
17524 4FEE           5D                         pop	bp
17525 4FEF           C3                         ret
17526                                           !BCC_EOS
17527                                           ! 2797               }
17528                                           ! 2798               inhibit_mouse_int_and_events();
17529                       00004FF0            .3A4:
17530                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17531 4FF0           E8         110F            call	_inhibit_mouse_int_and_events
17532                                           !BCC_EOS
17533                                           ! 2799               ret = send_to_mouse_ctrl(0xF4);
17534                                           ! Debug: list int = const $F4 (used reg = )
17535 4FF3           B8                   00F4  mov	ax,#$F4
17536 4FF6           50                         push	ax
17537                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17538 4FF7           E8         1259            call	_send_to_mouse_ctrl
17539 4FFA           44                         inc	sp
17540 4FFB           44                         inc	sp
17541                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17542 4FFC           8846         F5            mov	-$B[bp],al
17543                                           !BCC_EOS
17544                                           ! 2800               if (ret == 0) {
17545                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17546 4FFF           8A46         F5            mov	al,-$B[bp]
17547 5002           84C0                       test	al,al
17548 5004           75           2E            jne 	.3A6
17549                       00005006            .3A7:
17550                                           ! 2801                 ret = get_mouse_data(&mouse_data1);
17551                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17552 5006           8D5E         F4            lea	bx,-$C[bp]
17553 5009           53                         push	bx
17554                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17555 500A           E8         1290            call	_get_mouse_data
17556 500D           44                         inc	sp
17557 500E           44                         inc	sp
17558                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17559 500F           8846         F5            mov	-$B[bp],al
17560                                           !BCC_EOS
17561                                           ! 2802                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
17562                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17563 5012           8A46         F5            mov	al,-$B[bp]
17564 5015           84C0                       test	al,al
17565 5017           75           1B            jne 	.3A8
17566                       00005019            .3AA:
17567                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17568 5019           8A46         F4            mov	al,-$C[bp]
17569 501C           3C                     FA  cmp	al,#$FA
17570 501E           75           14            jne 	.3A8
17571                       00005020            .3A9:
17572                                           ! 2803                   enable_mouse_int_and_events();
17573                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17574 5020           E8         118C            call	_enable_mouse_int_and_events
17575                                           !BCC_EOS
17576                                           ! 2804                   FLAGS &= 0xfffe;
17577                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17578 5023           8B46         18            mov	ax,$18[bp]
17579 5026           24                     FE  and	al,#$FE
17580 5028           8946         18            mov	$18[bp],ax
17581                                           !BCC_EOS
17582                                           ! 2805                   regs.u.r8.ah = 0;
17583                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17584 502B           30C0                       xor	al,al
17585 502D           8846         13            mov	$13[bp],al
17586                                           !BCC_EOS
17587                                           ! 2806                   return;
17588 5030           89EC                       mov	sp,bp
17589 5032           5D                         pop	bp
17590 5033           C3                         ret
17591                                           !BCC_EOS
17592                                           ! 2807                 }
17593                                           ! 2808               }
17594                       00005034            .3A8:
17595                                           ! 2809               FLAGS |= 0x0001;
17596                       00005034            .3A6:
17597                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17598 5034           8B46         18            mov	ax,$18[bp]
17599 5037           0C                     01  or	al,*1
17600 5039           8946         18            mov	$18[bp],ax
17601                                           !BCC_EOS
17602                                           ! 2810               regs.u.r8.ah = ret;
17603                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17604 503C           8A46         F5            mov	al,-$B[bp]
17605 503F           8846         13            mov	$13[bp],al
17606                                           !BCC_EOS
17607                                           ! 2811               return;
17608 5042           89EC                       mov	sp,bp
17609 5044           5D                         pop	bp
17610 5045           C3                         ret
17611                                           !BCC_EOS
17612                                           ! 2812             default:
17613                                           ! 2813               ;
17614                       00005046            .3AB:
17615                                           !BCC_EOS
17616                                           ! 2814               FLAGS |= 0x0001;
17617                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17618 5046           8B46         18            mov	ax,$18[bp]
17619 5049           0C                     01  or	al,*1
17620 504B           8946         18            mov	$18[bp],ax
17621                                           !BCC_EOS
17622                                           ! 2815               regs.u.r8
17623                                           ! 2815 .ah = 1;
17624                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17625 504E           B0                     01  mov	al,*1
17626 5050           8846         13            mov	$13[bp],al
17627                                           !BCC_EOS
17628                                           ! 2816               return;
17629 5053           89EC                       mov	sp,bp
17630 5055           5D                         pop	bp
17631 5056           C3                         ret
17632                                           !BCC_EOS
17633                                           ! 2817           }
17634                                           ! 2818           break;
17635 5057           EB           0E            jmp .39A
17636                       00005059            .39C:
17637 5059           2C                     00  sub	al,*0
17638 505B         0F84         FF11            beq 	.39D
17639 505F           2C                     01  sub	al,*1
17640 5061         0F84         FF61            beq 	.3A3
17641 5065           EB           DF            jmp	.3AB
17642                       00005067            .39A:
17643 5067           E9         0525            br 	.396
17644                                           !BCC_EOS
17645                                           ! 2819         case 1:
17646                                           ! 2820         case 5:
17647                       0000506A            .3AC:
17648                                           ! 2821 ;
17649                       0000506A            .3AD:
17650                                           !BCC_EOS
17651                                           ! 2822           if (regs.u.r8.al == 5) {
17652                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17653 506A           8A46         12            mov	al,$12[bp]
17654 506D           3C                     05  cmp	al,*5
17655 506F         0F85         005E            bne 	.3AE
17656                       00005073            .3AF:
17657                                           ! 2823             if (regs.u.r8.bh != 3) {
17658                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17659 5073           8A46         0D            mov	al,$D[bp]
17660 5076           3C                     03  cmp	al,*3
17661 5078           74           11            je  	.3B0
17662                       0000507A            .3B1:
17663                                           ! 2824               FLAGS |= 0x0001;
17664                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17665 507A           8B46         18            mov	ax,$18[bp]
17666 507D           0C                     01  or	al,*1
17667 507F           8946         18            mov	$18[bp],ax
17668                                           !BCC_EOS
17669                                           ! 2825               regs.u.r8.ah = 0x02;
17670                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17671 5082           B0                     02  mov	al,*2
17672 5084           8846         13            mov	$13[bp],al
17673                                           !BCC_EOS
17674                                           ! 2826               return;
17675 5087           89EC                       mov	sp,bp
17676 5089           5D                         pop	bp
17677 508A           C3                         ret
17678                                           !BCC_EOS
17679                                           ! 2827             }
17680                                           ! 2828             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17681                       0000508B            .3B0:
17682                                           ! Debug: list int = const $27 (used reg = )
17683 508B           B8                   0027  mov	ax,*$27
17684 508E           50                         push	ax
17685                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17686 508F           FF76         FE            push	-2[bp]
17687                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17688 5092           E8         B563            call	_read_byte
17689 5095           83C4                   04  add	sp,*4
17690                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17691 5098           8846         FC            mov	-4[bp],al
17692                                           !BCC_EOS
17693                                           ! 2829             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17694                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17695 509B           8A46         FC            mov	al,-4[bp]
17696 509E           30C0                       xor	al,al
17697                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17698 50A0           0A46         0D            or	al,$D[bp]
17699                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17700 50A3           8846         FC            mov	-4[bp],al
17701                                           !BCC_EOS
17702                                           ! 2830             mouse_flags_1 = 0x00;
17703                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17704 50A6           30C0                       xor	al,al
17705 50A8           8846         FD            mov	-3[bp],al
17706                                           !BCC_EOS
17707                                           ! 2831             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17708                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17709 50AB           8A46         FD            mov	al,-3[bp]
17710 50AE           30E4                       xor	ah,ah
17711 50B0           50                         push	ax
17712                                           ! Debug: list int = const $26 (used reg = )
17713 50B1           B8                   0026  mov	ax,*$26
17714 50B4           50                         push	ax
17715                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17716 50B5           FF76         FE            push	-2[bp]
17717                                           ! Debug: func () void = write_byte+0 (used reg = )
17718 50B8           E8         B563            call	_write_byte
17719 50BB           83C4                   06  add	sp,*6
17720                                           !BCC_EOS
17721                                           ! 2832             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17722                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17723 50BE           8A46         FC            mov	al,-4[bp]
17724 50C1           30E4                       xor	ah,ah
17725 50C3           50                         push	ax
17726                                           ! Debug: list int = const $27 (used reg = )
17727 50C4           B8                   0027  mov	ax,*$27
17728 50C7           50                         push	ax
17729                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17730 50C8           FF76         FE            push	-2[bp]
17731                                           ! Debug: func () void = write_byte+0 (used reg = )
17732 50CB           E8         B550            call	_write_byte
17733 50CE           83C4                   06  add	sp,*6
17734                                           !BCC_EOS
17735                                           ! 2833           }
17736                                           ! 2834           inhibit_mouse_int_and_events();
17737                       000050D1            .3AE:
17738                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17739 50D1           E8         102E            call	_inhibit_mouse_int_and_events
17740                                           !BCC_EOS
17741                                           ! 2835           ret = send_to_mouse_ctrl(0xFF);
17742                                           ! Debug: list int = const $FF (used reg = )
17743 50D4           B8                   00FF  mov	ax,#$FF
17744 50D7           50                         push	ax
17745                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17746 50D8           E8         1178            call	_send_to_mouse_ctrl
17747 50DB           44                         inc	sp
17748 50DC           44                         inc	sp
17749                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17750 50DD           8846         F5            mov	-$B[bp],al
17751                                           !BCC_EOS
17752                                           ! 2836           if (ret == 0) {
17753                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17754 50E0           8A46         F5            mov	al,-$B[bp]
17755 50E3           84C0                       test	al,al
17756 50E5         0F85         0087            bne 	.3B2
17757                       000050E9            .3B3:
17758                                           ! 2837             ret = get_mouse_data(&mouse_data3);
17759                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17760 50E9           8D5E         F2            lea	bx,-$E[bp]
17761 50EC           53                         push	bx
17762                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17763 50ED           E8         11AD            call	_get_mouse_data
17764 50F0           44                         inc	sp
17765 50F1           44                         inc	sp
17766                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17767 50F2           8846         F5            mov	-$B[bp],al
17768                                           !BCC_EOS
17769                                           ! 2838             if (mouse_data3 == 0xfe) {
17770                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17771 50F5           8A46         F2            mov	al,-$E[bp]
17772 50F8           3C                     FE  cmp	al,#$FE
17773 50FA           75           0C            jne 	.3B4
17774                       000050FC            .3B5:
17775                                           ! 2839               FLAGS |= 0x0001;
17776                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17777 50FC           8B46         18            mov	ax,$18[bp]
17778 50FF           0C                     01  or	al,*1
17779 5101           8946         18            mov	$18[bp],ax
17780                                           !BCC_EOS
17781                                           ! 2840               return;
17782 5104           89EC                       mov	sp,bp
17783 5106           5D                         pop	bp
17784 5107           C3                         ret
17785                                           !BCC_EOS
17786                                           ! 2841             }
17787                                           ! 2842             if (mouse_data3 != 0xfa)
17788                       00005108            .3B4:
17789                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17790 5108           8A46         F2            mov	al,-$E[bp]
17791 510B           3C                     FA  cmp	al,#$FA
17792 510D           74           14            je  	.3B6
17793                       0000510F            .3B7:
17794                                           ! 2843               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17795                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17796 510F           8A46         F2            mov	al,-$E[bp]
17797 5112           30E4                       xor	ah,ah
17798 5114           50                         push	ax
17799                                           ! Debug: list * char = .3B8+0 (used reg = )
17800 5115           BB                   D4CA  mov	bx,#.3B8
17801 5118           53                         push	bx
17802                                           ! Debug: list int = const 7 (used reg = )
17803 5119           B8                   0007  mov	ax,*7
17804 511C           50                         push	ax
17805                                           ! Debug: func () void = bios_printf+0 (used reg = )
17806 511D           E8         B887            call	_bios_printf
17807 5120           83C4                   06  add	sp,*6
17808                                           !BCC_EOS
17809                                           ! 2844             if ( ret == 0 ) {
17810                       00005123            .3B6:
17811                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17812 5123           8A46         F5            mov	al,-$B[bp]
17813 5126           84C0                       test	al,al
17814 5128           75           46            jne 	.3B9
17815                       0000512A            .3BA:
17816                                           ! 2845               ret = get_mouse_data(&mouse_data1);
17817                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17818 512A           8D5E         F4            lea	bx,-$C[bp]
17819 512D           53                         push	bx
17820                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17821 512E           E8         116C            call	_get_mouse_data
17822 5131           44                         inc	sp
17823 5132           44                         inc	sp
17824                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17825 5133           8846         F5            mov	-$B[bp],al
17826                                           !BCC_EOS
17827                                           ! 2846               if ( ret == 0 ) {
17828                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17829 5136           8A46         F5            mov	al,-$B[bp]
17830 5139           84C0                       test	al,al
17831 513B           75           33            jne 	.3BB
17832                       0000513D            .3BC:
17833                                           ! 2847                 ret = get_mouse_data(&mouse_data2);
17834                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17835 513D           8D5E         F3            lea	bx,-$D[bp]
17836 5140           53                         push	bx
17837                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17838 5141           E8         1159            call	_get_mouse_data
17839 5144           44                         inc	sp
17840 5145           44                         inc	sp
17841                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17842 5146           8846         F5            mov	-$B[bp],al
17843                                           !BCC_EOS
17844                                           ! 2848                 if ( ret == 0 ) {
17845                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17846 5149           8A46         F5            mov	al,-$B[bp]
17847 514C           84C0                       test	al,al
17848 514E           75           20            jne 	.3BD
17849                       00005150            .3BE:
17850                                           ! 2849                   enable_mouse_int_and_events();
17851                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17852 5150           E8         105C            call	_enable_mouse_int_and_events
17853                                           !BCC_EOS
17854                                           ! 2850                   FLAGS &= 0xfffe;
17855                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17856 5153           8B46         18            mov	ax,$18[bp]
17857 5156           24                     FE  and	al,#$FE
17858 5158           8946         18            mov	$18[bp],ax
17859                                           !BCC_EOS
17860                                           ! 2851                   regs.u.r8.ah = 0;
17861                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17862 515B           30C0                       xor	al,al
17863 515D           8846         13            mov	$13[bp],al
17864                                           !BCC_EOS
17865                                           ! 2852                   regs.u.r8.bl = mouse_data1;
17866                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17867 5160           8A46         F4            mov	al,-$C[bp]
17868 5163           8846         0C            mov	$C[bp],al
17869                                           !BCC_EOS
17870                                           ! 2853                   regs.u.r8.bh = mouse_data2;
17871                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17872 5166           8A46         F3            mov	al,-$D[bp]
17873 5169           8846         0D            mov	$D[bp],al
17874                                           !BCC_EOS
17875                                           ! 2854                   return;
17876 516C           89EC                       mov	sp,bp
17877 516E           5D                         pop	bp
17878 516F           C3                         ret
17879                                           !BCC_EOS
17880                                           ! 2855                 }
17881                                           ! 2856               }
17882                       00005170            .3BD:
17883                                           ! 2857             }
17884                       00005170            .3BB:
17885                                           ! 2858           }
17886                       00005170            .3B9:
17887                                           ! 2859           FLAGS |= 0x0001;
17888                       00005170            .3B2:
17889                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17890 5170           8B46         18            mov	ax,$18[bp]
17891 5173           0C                     01  or	al,*1
17892 5175           8946         18            mov	$18[bp],ax
17893                                           !BCC_EOS
17894                                           ! 2860           regs.u.r8.ah = ret;
17895                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17896 5178           8A46         F5            mov	al,-$B[bp]
17897 517B           8846         13            mov	$13[bp],al
17898                                           !BCC_EOS
17899                                           ! 2861           return;
17900 517E           89EC                       mov	sp,bp
17901 5180           5D                         pop	bp
17902 5181           C3                         ret
17903                                           !BCC_EOS
17904                                           ! 2862         case 2:
17905                                           ! 2863 ;
17906                       00005182            .3BF:
17907                                           !BCC_EOS
17908                                           ! 2864           switch (regs.u.r8.bh) {
17909 5182           8A46         0D            mov	al,$D[bp]
17910 5185           EB           38            jmp .3C2
17911                                           ! 2865             case 0: mouse_data1 = 10; break;
17912                       00005187            .3C3:
17913                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17914 5187           B0                     0A  mov	al,*$A
17915 5189           8846         F4            mov	-$C[bp],al
17916                                           !BCC_EOS
17917 518C           EB           54            jmp .3C0
17918                                           !BCC_EOS
17919                                           ! 2866             case 1: mouse_data1 = 20; break;
17920                       0000518E            .3C4:
17921                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17922 518E           B0                     14  mov	al,*$14
17923 5190           8846         F4            mov	-$C[bp],al
17924                                           !BCC_EOS
17925 5193           EB           4D            jmp .3C0
17926                                           !BCC_EOS
17927                                           ! 2867             case 2: mouse_data1 = 40; break;
17928                       00005195            .3C5:
17929                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17930 5195           B0                     28  mov	al,*$28
17931 5197           8846         F4            mov	-$C[bp],al
17932                                           !BCC_EOS
17933 519A           EB           46            jmp .3C0
17934                                           !BCC_EOS
17935                                           ! 2868             case 3: mouse_data1 = 60; break;
17936                       0000519C            .3C6:
17937                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17938 519C           B0                     3C  mov	al,*$3C
17939 519E           8846         F4            mov	-$C[bp],al
17940                                           !BCC_EOS
17941 51A1           EB           3F            jmp .3C0
17942                                           !BCC_EOS
17943                                           ! 2869             case 4: mouse_data1 = 80; break;
17944                       000051A3            .3C7:
17945                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17946 51A3           B0                     50  mov	al,*$50
17947 51A5           8846         F4            mov	-$C[bp],al
17948                                           !BCC_EOS
17949 51A8           EB           38            jmp .3C0
17950                                           !BCC_EOS
17951                                           ! 2870             case 5: mouse_data1 = 100; break;
17952                       000051AA            .3C8:
17953                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17954 51AA           B0                     64  mov	al,*$64
17955 51AC           8846         F4            mov	-$C[bp],al
17956                                           !BCC_EOS
17957 51AF           EB           31            jmp .3C0
17958                                           !BCC_EOS
17959                                           ! 2871             case 6: mouse_data1 = 200; break;
17960                       000051B1            .3C9:
17961                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17962 51B1           B0                     C8  mov	al,#$C8
17963 51B3           8846         F4            mov	-$C[bp],al
17964                                           !BCC_EOS
17965 51B6           EB           2A            jmp .3C0
17966                                           !BCC_EOS
17967                                           ! 2872             default: mouse_data1 = 0;
17968                       000051B8            .3CA:
17969                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17970 51B8           30C0                       xor	al,al
17971 51BA           8846         F4            mov	-$C[bp],al
17972                                           !BCC_EOS
17973                                           ! 2873           }
17974                                           ! 2874           if (mouse_data1 > 0) {
17975 51BD           EB           23            jmp .3C0
17976                       000051BF            .3C2:
17977 51BF           2C                     00  sub	al,*0
17978 51C1           72           F5            jb 	.3CA
17979 51C3           3C                     06  cmp	al,*6
17980 51C5           77           19            ja  	.3CB
17981 51C7           30E4                       xor	ah,ah
17982 51C9           D1E0                       shl	ax,*1
17983 51CB           89C3                       mov	bx,ax
17984 51CD           2E                         seg	cs
17985 51CE           FFA7       51D2            br	.3CC[bx]
17986                       000051D2            .3CC:
17987 51D2                      5187            .word	.3C3
17988 51D4                      518E            .word	.3C4
17989 51D6                      5195            .word	.3C5
17990 51D8                      519C            .word	.3C6
17991 51DA                      51A3            .word	.3C7
17992 51DC                      51AA            .word	.3C8
17993 51DE                      51B1            .word	.3C9
17994                       000051E0            .3CB:
17995 51E0           EB           D6            jmp	.3CA
17996                       000051E2            .3C0:
17997                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17998 51E2           8A46         F4            mov	al,-$C[bp]
17999 51E5           84C0                       test	al,al
18000 51E7           74           57            je  	.3CD
18001                       000051E9            .3CE:
18002                                           ! 2875             ret = send_to_mouse_ctrl(0xF3);
18003                                           ! Debug: list int = const $F3 (used reg = )
18004 51E9           B8                   00F3  mov	ax,#$F3
18005 51EC           50                         push	ax
18006                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18007 51ED           E8         1063            call	_send_to_mouse_ctrl
18008 51F0           44                         inc	sp
18009 51F1           44                         inc	sp
18010                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18011 51F2           8846         F5            mov	-$B[bp],al
18012                                           !BCC_EOS
18013                                           ! 2876             if (re
18014                                           ! 2876 t == 0) {
18015                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18016 51F5           8A46         F5            mov	al,-$B[bp]
18017 51F8           84C0                       test	al,al
18018 51FA           75           35            jne 	.3CF
18019                       000051FC            .3D0:
18020                                           ! 2877               ret = get_mouse_data(&mouse_data2);
18021                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18022 51FC           8D5E         F3            lea	bx,-$D[bp]
18023 51FF           53                         push	bx
18024                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18025 5200           E8         109A            call	_get_mouse_data
18026 5203           44                         inc	sp
18027 5204           44                         inc	sp
18028                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18029 5205           8846         F5            mov	-$B[bp],al
18030                                           !BCC_EOS
18031                                           ! 2878               ret = send_to_mouse_ctrl(mouse_data1);
18032                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18033 5208           8A46         F4            mov	al,-$C[bp]
18034 520B           30E4                       xor	ah,ah
18035 520D           50                         push	ax
18036                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18037 520E           E8         1042            call	_send_to_mouse_ctrl
18038 5211           44                         inc	sp
18039 5212           44                         inc	sp
18040                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18041 5213           8846         F5            mov	-$B[bp],al
18042                                           !BCC_EOS
18043                                           ! 2879               ret = get_mouse_data(&mouse_data2);
18044                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18045 5216           8D5E         F3            lea	bx,-$D[bp]
18046 5219           53                         push	bx
18047                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18048 521A           E8         1080            call	_get_mouse_data
18049 521D           44                         inc	sp
18050 521E           44                         inc	sp
18051                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18052 521F           8846         F5            mov	-$B[bp],al
18053                                           !BCC_EOS
18054                                           ! 2880               FLAGS &= 0xfffe;
18055                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18056 5222           8B46         18            mov	ax,$18[bp]
18057 5225           24                     FE  and	al,#$FE
18058 5227           8946         18            mov	$18[bp],ax
18059                                           !BCC_EOS
18060                                           ! 2881               regs.u.r8.ah = 0;
18061                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18062 522A           30C0                       xor	al,al
18063 522C           8846         13            mov	$13[bp],al
18064                                           !BCC_EOS
18065                                           ! 2882             } else {
18066 522F           EB           0D            jmp .3D1
18067                       00005231            .3CF:
18068                                           ! 2883               FLAGS |= 0x0001;
18069                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18070 5231           8B46         18            mov	ax,$18[bp]
18071 5234           0C                     01  or	al,*1
18072 5236           8946         18            mov	$18[bp],ax
18073                                           !BCC_EOS
18074                                           ! 2884               regs.u.r8.ah = 0x86;
18075                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18076 5239           B0                     86  mov	al,#$86
18077 523B           8846         13            mov	$13[bp],al
18078                                           !BCC_EOS
18079                                           ! 2885             }
18080                                           ! 2886           } else {
18081                       0000523E            .3D1:
18082 523E           EB           0D            jmp .3D2
18083                       00005240            .3CD:
18084                                           ! 2887             FLAGS |= 0x0001;
18085                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18086 5240           8B46         18            mov	ax,$18[bp]
18087 5243           0C                     01  or	al,*1
18088 5245           8946         18            mov	$18[bp],ax
18089                                           !BCC_EOS
18090                                           ! 2888             regs.u.r8.ah = 0x86;
18091                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18092 5248           B0                     86  mov	al,#$86
18093 524A           8846         13            mov	$13[bp],al
18094                                           !BCC_EOS
18095                                           ! 2889           }
18096                                           ! 2890           break;
18097                       0000524D            .3D2:
18098 524D           E9         033F            br 	.396
18099                                           !BCC_EOS
18100                                           ! 2891         case 3:
18101                                           ! 2892 ;
18102                       00005250            .3D3:
18103                                           !BCC_EOS
18104                                           ! 2893           comm_byte = inhibit_mouse_int_and_events();
18105                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18106 5250           E8         0EAF            call	_inhibit_mouse_int_and_events
18107                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18108 5253           8846         F7            mov	-9[bp],al
18109                                           !BCC_EOS
18110                                           ! 2894           if (regs.u.r8.bh < 4) {
18111                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
18112 5256           8A46         0D            mov	al,$D[bp]
18113 5259           3C                     04  cmp	al,*4
18114 525B         0F83         008D            bhis	.3D4
18115                       0000525F            .3D5:
18116                                           ! 2895             ret = send_to_mouse_ctrl(0xE8);
18117                                           ! Debug: list int = const $E8 (used reg = )
18118 525F           B8                   00E8  mov	ax,#$E8
18119 5262           50                         push	ax
18120                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18121 5263           E8         0FED            call	_send_to_mouse_ctrl
18122 5266           44                         inc	sp
18123 5267           44                         inc	sp
18124                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18125 5268           8846         F5            mov	-$B[bp],al
18126                                           !BCC_EOS
18127                                           ! 2896             if (ret == 0) {
18128                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18129 526B           8A46         F5            mov	al,-$B[bp]
18130 526E           84C0                       test	al,al
18131 5270           75           6B            jne 	.3D6
18132                       00005272            .3D7:
18133                                           ! 2897               ret = get_mouse_data(&mouse_data1);
18134                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18135 5272           8D5E         F4            lea	bx,-$C[bp]
18136 5275           53                         push	bx
18137                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18138 5276           E8         1024            call	_get_mouse_data
18139 5279           44                         inc	sp
18140 527A           44                         inc	sp
18141                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18142 527B           8846         F5            mov	-$B[bp],al
18143                                           !BCC_EOS
18144                                           ! 2898               if (mouse_data1 != 0xfa)
18145                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18146 527E           8A46         F4            mov	al,-$C[bp]
18147 5281           3C                     FA  cmp	al,#$FA
18148 5283           74           14            je  	.3D8
18149                       00005285            .3D9:
18150                                           ! 2899                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18151                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18152 5285           8A46         F4            mov	al,-$C[bp]
18153 5288           30E4                       xor	ah,ah
18154 528A           50                         push	ax
18155                                           ! Debug: list * char = .3DA+0 (used reg = )
18156 528B           BB                   D49E  mov	bx,#.3DA
18157 528E           53                         push	bx
18158                                           ! Debug: list int = const 7 (used reg = )
18159 528F           B8                   0007  mov	ax,*7
18160 5292           50                         push	ax
18161                                           ! Debug: func () void = bios_printf+0 (used reg = )
18162 5293           E8         B711            call	_bios_printf
18163 5296           83C4                   06  add	sp,*6
18164                                           !BCC_EOS
18165                                           ! 2900               ret = send_to_mouse_ctrl(regs.u.r8.bh);
18166                       00005299            .3D8:
18167                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18168 5299           8A46         0D            mov	al,$D[bp]
18169 529C           30E4                       xor	ah,ah
18170 529E           50                         push	ax
18171                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18172 529F           E8         0FB1            call	_send_to_mouse_ctrl
18173 52A2           44                         inc	sp
18174 52A3           44                         inc	sp
18175                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18176 52A4           8846         F5            mov	-$B[bp],al
18177                                           !BCC_EOS
18178                                           ! 2901               ret = get_mouse_data(&mouse_data1);
18179                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18180 52A7           8D5E         F4            lea	bx,-$C[bp]
18181 52AA           53                         push	bx
18182                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18183 52AB           E8         0FEF            call	_get_mouse_data
18184 52AE           44                         inc	sp
18185 52AF           44                         inc	sp
18186                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18187 52B0           8846         F5            mov	-$B[bp],al
18188                                           !BCC_EOS
18189                                           ! 2902               if (mouse_data1 != 0xfa)
18190                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18191 52B3           8A46         F4            mov	al,-$C[bp]
18192 52B6           3C                     FA  cmp	al,#$FA
18193 52B8           74           14            je  	.3DB
18194                       000052BA            .3DC:
18195                                           ! 2903                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18196                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18197 52BA           8A46         F4            mov	al,-$C[bp]
18198 52BD           30E4                       xor	ah,ah
18199 52BF           50                         push	ax
18200                                           ! Debug: list * char = .3DD+0 (used reg = )
18201 52C0           BB                   D472  mov	bx,#.3DD
18202 52C3           53                         push	bx
18203                                           ! Debug: list int = const 7 (used reg = )
18204 52C4           B8                   0007  mov	ax,*7
18205 52C7           50                         push	ax
18206                                           ! Debug: func () void = bios_printf+0 (used reg = )
18207 52C8           E8         B6DC            call	_bios_printf
18208 52CB           83C4                   06  add	sp,*6
18209                                           !BCC_EOS
18210                                           ! 2904               FLAGS &= 0xfffe;
18211                       000052CE            .3DB:
18212                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18213 52CE           8B46         18            mov	ax,$18[bp]
18214 52D1           24                     FE  and	al,#$FE
18215 52D3           8946         18            mov	$18[bp],ax
18216                                           !BCC_EOS
18217                                           ! 2905               regs.u.r8.ah = 0;
18218                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18219 52D6           30C0                       xor	al,al
18220 52D8           8846         13            mov	$13[bp],al
18221                                           !BCC_EOS
18222                                           ! 2906             } else {
18223 52DB           EB           0D            jmp .3DE
18224                       000052DD            .3D6:
18225                                           ! 2907               FLAGS |= 0x0001;
18226                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18227 52DD           8B46         18            mov	ax,$18[bp]
18228 52E0           0C                     01  or	al,*1
18229 52E2           8946         18            mov	$18[bp],ax
18230                                           !BCC_EOS
18231                                           ! 2908               regs.u.r8.ah = 0x86;
18232                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18233 52E5           B0                     86  mov	al,#$86
18234 52E7           8846         13            mov	$13[bp],al
18235                                           !BCC_EOS
18236                                           ! 2909             }
18237                                           ! 2910           } else {
18238                       000052EA            .3DE:
18239 52EA           EB           0D            jmp .3DF
18240                       000052EC            .3D4:
18241                                           ! 2911             FLAGS |= 0x0001;
18242                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18243 52EC           8B46         18            mov	ax,$18[bp]
18244 52EF           0C                     01  or	al,*1
18245 52F1           8946         18            mov	$18[bp],ax
18246                                           !BCC_EOS
18247                                           ! 2912             regs.u.r8.ah = 0x86;
18248                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18249 52F4           B0                     86  mov	al,#$86
18250 52F6           8846         13            mov	$13[bp],al
18251                                           !BCC_EOS
18252                                           ! 2913           }
18253                                           ! 2914           set_kbd_command_byte(comm_byte);
18254                       000052F9            .3DF:
18255                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18256 52F9           8A46         F7            mov	al,-9[bp]
18257 52FC           30E4                       xor	ah,ah
18258 52FE           50                         push	ax
18259                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18260 52FF           E8         0FDC            call	_set_kbd_command_byte
18261 5302           44                         inc	sp
18262 5303           44                         inc	sp
18263                                           !BCC_EOS
18264                                           ! 2915           break;
18265 5304           E9         0288            br 	.396
18266                                           !BCC_EOS
18267                                           ! 2916         case 4:
18268                                           ! 2917 ;
18269                       00005307            .3E0:
18270                                           !BCC_EOS
18271                                           ! 2918           inhibit_mouse_int_and_events();
18272                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18273 5307           E8         0DF8            call	_inhibit_mouse_int_and_events
18274                                           !BCC_EOS
18275                                           ! 2919           ret = send_to_mouse_ctrl(0xF2);
18276                                           ! Debug: list int = const $F2 (used reg = )
18277 530A           B8                   00F2  mov	ax,#$F2
18278 530D           50                         push	ax
18279                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18280 530E           E8         0F42            call	_send_to_mouse_ctrl
18281 5311           44                         inc	sp
18282 5312           44                         inc	sp
18283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18284 5313           8846         F5            mov	-$B[bp],al
18285                                           !BCC_EOS
18286                                           ! 2920           if (ret == 0) {
18287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18288 5316           8A46         F5            mov	al,-$B[bp]
18289 5319           84C0                       test	al,al
18290 531B           75           2D            jne 	.3E1
18291                       0000531D            .3E2:
18292                                           ! 2921             ret = get_mouse_data(&mouse_data1);
18293                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18294 531D           8D5E         F4            lea	bx,-$C[bp]
18295 5320           53                         push	bx
18296                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18297 5321           E8         0F79            call	_get_mouse_data
18298 5324           44                         inc	sp
18299 5325           44                         inc	sp
18300                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18301 5326           8846         F5            mov	-$B[bp],al
18302                                           !BCC_EOS
18303                                           ! 2922             ret = get_mouse_data(&mouse_data2);
18304                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18305 5329           8D5E         F3            lea	bx,-$D[bp]
18306 532C           53                         push	bx
18307                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18308 532D           E8         0F6D            call	_get_mouse_data
18309 5330           44                         inc	sp
18310 5331           44                         inc	sp
18311                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18312 5332           8846         F5            mov	-$B[bp],al
18313                                           !BCC_EOS
18314                                           ! 2923             FLAGS &= 0xfffe;
18315                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18316 5335           8B46         18            mov	ax,$18[bp]
18317 5338           24                     FE  and	al,#$FE
18318 533A           8946         18            mov	$18[bp],ax
18319                                           !BCC_EOS
18320                                           ! 2924             regs.u.r8.ah = 0;
18321                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18322 533D           30C0                       xor	al,al
18323 533F           8846         13            mov	$13[bp],al
18324                                           !BCC_EOS
18325                                           ! 2925             regs.u.r8.bh = mouse_data2;
18326                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
18327 5342           8A46         F3            mov	al,-$D[bp]
18328 5345           8846         0D            mov	$D[bp],al
18329                                           !BCC_EOS
18330                                           ! 2926           } else {
18331 5348           EB           0D            jmp .3E3
18332                       0000534A            .3E1:
18333                                           ! 2927             FLAGS |= 0x0001;
18334                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18335 534A           8B46         18            mov	ax,$18[bp]
18336 534D           0C                     01  or	al,*1
18337 534F           8946         18            mov	$18[bp],ax
18338                                           !BCC_EOS
18339                                           ! 2928             regs.u.r8.ah = 0x86;
18340                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18341 5352           B0                     86  mov	al,#$86
18342 5354           8846         13            mov	$13[bp],al
18343                                           !BCC_EOS
18344                                           ! 2929           }
18345                                           ! 2930           break;
18346                       00005357            .3E3:
18347 5357           E9         0235            br 	.396
18348                                           !BCC_EOS
18349                                           ! 2931         case 6:
18350                                           ! 2932 ;
18351                       0000535A            .3E4:
18352                                           !BCC_EOS
18353                                           ! 2933           switch (regs.u.r8.bh) {
18354 535A           8A46         0D            mov	al,$D[bp]
18355 535D           E9         015A            br 	.3E7
18356                                           ! 2934             case 0:
18357                                           ! 2935               comm_byte = inhibit_mouse_int_and_events();
18358                       00005360            .3E8:
18359                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18360 5360           E8         0D9F            call	_inhibit_mouse_int_and_events
18361                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18362 5363           8846         F7            mov	-9[bp],al
18363                                           !BCC_EOS
18364                                           ! 2936               ret = send_to_mouse_ctrl(0xE9);
18365                                           ! Debug: list int = const $E9 (used reg = )
18366 5366           B8                   00E9  mov	ax,#$E9
18367 5369           50                         push	ax
18368                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18369 536A           E8         0EE6            call	_send_to_mouse_ctrl
18370 536D           44                         inc	sp
18371 536E           44                         inc	sp
18372                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18373 536F           8846         F5            mov	-$B[bp],al
18374                                           !BCC_EOS
18375                                           ! 2937               if (ret == 0) {
18376                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18377 5372           8A46         F5            mov	al,-$B[bp]
18378 5375           84C0                       test	al,al
18379 5377         0F85         0095            bne 	.3E9
18380                       0000537B            .3EA:
18381                                           ! 2938                 ret
18382                                           ! 2938  = get_mouse_data(&mouse_data1);
18383                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18384 537B           8D5E         F4            lea	bx,-$C[bp]
18385 537E           53                         push	bx
18386                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18387 537F           E8         0F1B            call	_get_mouse_data
18388 5382           44                         inc	sp
18389 5383           44                         inc	sp
18390                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18391 5384           8846         F5            mov	-$B[bp],al
18392                                           !BCC_EOS
18393                                           ! 2939                 if (mouse_data1 != 0xfa)
18394                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18395 5387           8A46         F4            mov	al,-$C[bp]
18396 538A           3C                     FA  cmp	al,#$FA
18397 538C           74           14            je  	.3EB
18398                       0000538E            .3EC:
18399                                           ! 2940                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18400                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18401 538E           8A46         F4            mov	al,-$C[bp]
18402 5391           30E4                       xor	ah,ah
18403 5393           50                         push	ax
18404                                           ! Debug: list * char = .3ED+0 (used reg = )
18405 5394           BB                   D446  mov	bx,#.3ED
18406 5397           53                         push	bx
18407                                           ! Debug: list int = const 7 (used reg = )
18408 5398           B8                   0007  mov	ax,*7
18409 539B           50                         push	ax
18410                                           ! Debug: func () void = bios_printf+0 (used reg = )
18411 539C           E8         B608            call	_bios_printf
18412 539F           83C4                   06  add	sp,*6
18413                                           !BCC_EOS
18414                                           ! 2941                 if (ret == 0) {
18415                       000053A2            .3EB:
18416                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18417 53A2           8A46         F5            mov	al,-$B[bp]
18418 53A5           84C0                       test	al,al
18419 53A7           75           67            jne 	.3EE
18420                       000053A9            .3EF:
18421                                           ! 2942                   ret = get_mouse_data(&mouse_data1);
18422                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18423 53A9           8D5E         F4            lea	bx,-$C[bp]
18424 53AC           53                         push	bx
18425                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18426 53AD           E8         0EED            call	_get_mouse_data
18427 53B0           44                         inc	sp
18428 53B1           44                         inc	sp
18429                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18430 53B2           8846         F5            mov	-$B[bp],al
18431                                           !BCC_EOS
18432                                           ! 2943                   if (ret == 0) {
18433                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18434 53B5           8A46         F5            mov	al,-$B[bp]
18435 53B8           84C0                       test	al,al
18436 53BA           75           54            jne 	.3F0
18437                       000053BC            .3F1:
18438                                           ! 2944                     ret = get_mouse_data(&mouse_data2);
18439                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18440 53BC           8D5E         F3            lea	bx,-$D[bp]
18441 53BF           53                         push	bx
18442                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18443 53C0           E8         0EDA            call	_get_mouse_data
18444 53C3           44                         inc	sp
18445 53C4           44                         inc	sp
18446                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18447 53C5           8846         F5            mov	-$B[bp],al
18448                                           !BCC_EOS
18449                                           ! 2945                     if (ret == 0) {
18450                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18451 53C8           8A46         F5            mov	al,-$B[bp]
18452 53CB           84C0                       test	al,al
18453 53CD           75           41            jne 	.3F2
18454                       000053CF            .3F3:
18455                                           ! 2946                       ret = get_mouse_data(&mouse_data3);
18456                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18457 53CF           8D5E         F2            lea	bx,-$E[bp]
18458 53D2           53                         push	bx
18459                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18460 53D3           E8         0EC7            call	_get_mouse_data
18461 53D6           44                         inc	sp
18462 53D7           44                         inc	sp
18463                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18464 53D8           8846         F5            mov	-$B[bp],al
18465                                           !BCC_EOS
18466                                           ! 2947                       if (ret == 0) {
18467                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18468 53DB           8A46         F5            mov	al,-$B[bp]
18469 53DE           84C0                       test	al,al
18470 53E0           75           2E            jne 	.3F4
18471                       000053E2            .3F5:
18472                                           ! 2948                         FLAGS &= 0xfffe;
18473                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18474 53E2           8B46         18            mov	ax,$18[bp]
18475 53E5           24                     FE  and	al,#$FE
18476 53E7           8946         18            mov	$18[bp],ax
18477                                           !BCC_EOS
18478                                           ! 2949                         regs.u.r8.ah = 0;
18479                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18480 53EA           30C0                       xor	al,al
18481 53EC           8846         13            mov	$13[bp],al
18482                                           !BCC_EOS
18483                                           ! 2950                         regs.u.r8.bl = mouse_data1;
18484                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18485 53EF           8A46         F4            mov	al,-$C[bp]
18486 53F2           8846         0C            mov	$C[bp],al
18487                                           !BCC_EOS
18488                                           ! 2951                         regs.u.r8.cl = mouse_data2;
18489                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18490 53F5           8A46         F3            mov	al,-$D[bp]
18491 53F8           8846         10            mov	$10[bp],al
18492                                           !BCC_EOS
18493                                           ! 2952                         regs.u.r8.dl = mouse_data3;
18494                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18495 53FB           8A46         F2            mov	al,-$E[bp]
18496 53FE           8846         0E            mov	$E[bp],al
18497                                           !BCC_EOS
18498                                           ! 2953                         set_kbd_command_byte(comm_byte);
18499                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18500 5401           8A46         F7            mov	al,-9[bp]
18501 5404           30E4                       xor	ah,ah
18502 5406           50                         push	ax
18503                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18504 5407           E8         0ED4            call	_set_kbd_command_byte
18505 540A           44                         inc	sp
18506 540B           44                         inc	sp
18507                                           !BCC_EOS
18508                                           ! 2954                         return;
18509 540C           89EC                       mov	sp,bp
18510 540E           5D                         pop	bp
18511 540F           C3                         ret
18512                                           !BCC_EOS
18513                                           ! 2955                       }
18514                                           ! 2956                     }
18515                       00005410            .3F4:
18516                                           ! 2957                   }
18517                       00005410            .3F2:
18518                                           ! 2958                 }
18519                       00005410            .3F0:
18520                                           ! 2959               }
18521                       00005410            .3EE:
18522                                           ! 2960               FLAGS |= 0x0001;
18523                       00005410            .3E9:
18524                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18525 5410           8B46         18            mov	ax,$18[bp]
18526 5413           0C                     01  or	al,*1
18527 5415           8946         18            mov	$18[bp],ax
18528                                           !BCC_EOS
18529                                           ! 2961               regs.u.r8.ah = ret;
18530                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18531 5418           8A46         F5            mov	al,-$B[bp]
18532 541B           8846         13            mov	$13[bp],al
18533                                           !BCC_EOS
18534                                           ! 2962               set_kbd_command_byte(comm_byte);
18535                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18536 541E           8A46         F7            mov	al,-9[bp]
18537 5421           30E4                       xor	ah,ah
18538 5423           50                         push	ax
18539                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18540 5424           E8         0EB7            call	_set_kbd_command_byte
18541 5427           44                         inc	sp
18542 5428           44                         inc	sp
18543                                           !BCC_EOS
18544                                           ! 2963               return;
18545 5429           89EC                       mov	sp,bp
18546 542B           5D                         pop	bp
18547 542C           C3                         ret
18548                                           !BCC_EOS
18549                                           ! 2964             case 1:
18550                                           ! 2965             case 2:
18551                       0000542D            .3F6:
18552                                           ! 2966               comm_byte = inhibit_mouse_int_and_events();
18553                       0000542D            .3F7:
18554                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18555 542D           E8         0CD2            call	_inhibit_mouse_int_and_events
18556                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18557 5430           8846         F7            mov	-9[bp],al
18558                                           !BCC_EOS
18559                                           ! 2967               if (regs.u.r8.bh == 1) {
18560                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18561 5433           8A46         0D            mov	al,$D[bp]
18562 5436           3C                     01  cmp	al,*1
18563 5438           75           0E            jne 	.3F8
18564                       0000543A            .3F9:
18565                                           ! 2968                 ret = send_to_mouse_ctrl(0xE6);
18566                                           ! Debug: list int = const $E6 (used reg = )
18567 543A           B8                   00E6  mov	ax,#$E6
18568 543D           50                         push	ax
18569                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18570 543E           E8         0E12            call	_send_to_mouse_ctrl
18571 5441           44                         inc	sp
18572 5442           44                         inc	sp
18573                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18574 5443           8846         F5            mov	-$B[bp],al
18575                                           !BCC_EOS
18576                                           ! 2969               } else {
18577 5446           EB           0C            jmp .3FA
18578                       00005448            .3F8:
18579                                           ! 2970                 ret = send_to_mouse_ctrl(0xE7);
18580                                           ! Debug: list int = const $E7 (used reg = )
18581 5448           B8                   00E7  mov	ax,#$E7
18582 544B           50                         push	ax
18583                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18584 544C           E8         0E04            call	_send_to_mouse_ctrl
18585 544F           44                         inc	sp
18586 5450           44                         inc	sp
18587                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18588 5451           8846         F5            mov	-$B[bp],al
18589                                           !BCC_EOS
18590                                           ! 2971               }
18591                                           ! 2972               if (ret == 0) {
18592                       00005454            .3FA:
18593                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18594 5454           8A46         F5            mov	al,-$B[bp]
18595 5457           84C0                       test	al,al
18596 5459           75           19            jne 	.3FB
18597                       0000545B            .3FC:
18598                                           ! 2973                 get_mouse_data(&mouse_data1);
18599                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18600 545B           8D5E         F4            lea	bx,-$C[bp]
18601 545E           53                         push	bx
18602                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18603 545F           E8         0E3B            call	_get_mouse_data
18604 5462           44                         inc	sp
18605 5463           44                         inc	sp
18606                                           !BCC_EOS
18607                                           ! 2974                 ret = (mouse_data1 != 0xFA);
18608                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18609 5464           8A46         F4            mov	al,-$C[bp]
18610 5467           3C                     FA  cmp	al,#$FA
18611 5469           74           04            je 	.3FD
18612 546B           B0                     01  mov	al,*1
18613 546D           EB           02            jmp	.3FE
18614                       0000546F            .3FD:
18615 546F           30C0                       xor	al,al
18616                       00005471            .3FE:
18617                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18618 5471           8846         F5            mov	-$B[bp],al
18619                                           !BCC_EOS
18620                                           ! 2975               }
18621                                           ! 2976               if (ret == 0) {
18622                       00005474            .3FB:
18623                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18624 5474           8A46         F5            mov	al,-$B[bp]
18625 5477           84C0                       test	al,al
18626 5479           75           0F            jne 	.3FF
18627                       0000547B            .400:
18628                                           ! 2977                 FLAGS &= 0xfffe;
18629                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18630 547B           8B46         18            mov	ax,$18[bp]
18631 547E           24                     FE  and	al,#$FE
18632 5480           8946         18            mov	$18[bp],ax
18633                                           !BCC_EOS
18634                                           ! 2978                 regs.u.r8.ah = 0;
18635                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18636 5483           30C0                       xor	al,al
18637 5485           8846         13            mov	$13[bp],al
18638                                           !BCC_EOS
18639                                           ! 2979               } else {
18640 5488           EB           0D            jmp .401
18641                       0000548A            .3FF:
18642                                           ! 2980                 FLAGS |= 0x0001;
18643                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18644 548A           8B46         18            mov	ax,$18[bp]
18645 548D           0C                     01  or	al,*1
18646 548F           8946         18            mov	$18[bp],ax
18647                                           !BCC_EOS
18648                                           ! 2981                 regs.u.r8.ah = 0x86;
18649                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18650 5492           B0                     86  mov	al,#$86
18651 5494           8846         13            mov	$13[bp],al
18652                                           !BCC_EOS
18653                                           ! 2982               }
18654                                           ! 2983               set_kbd_command_byte(comm_byte);
18655                       00005497            .401:
18656                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18657 5497           8A46         F7            mov	al,-9[bp]
18658 549A           30E4                       xor	ah,ah
18659 549C           50                         push	ax
18660                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18661 549D           E8         0E3E            call	_set_kbd_command_byte
18662 54A0           44                         inc	sp
18663 54A1           44                         inc	sp
18664                                           !BCC_EOS
18665                                           ! 2984               break;
18666 54A2           EB           2A            jmp .3E5
18667                                           !BCC_EOS
18668                                           ! 2985             default:
18669                                           ! 2986               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18670                       000054A4            .402:
18671                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18672 54A4           8A46         0D            mov	al,$D[bp]
18673 54A7           30E4                       xor	ah,ah
18674 54A9           50                         push	ax
18675                                           ! Debug: list * char = .403+0 (used reg = )
18676 54AA           BB                   D42C  mov	bx,#.403
18677 54AD           53                         push	bx
18678                                           ! Debug: list int = const 7 (used reg = )
18679 54AE           B8                   0007  mov	ax,*7
18680 54B1           50                         push	ax
18681                                           ! Debug: func () void = bios_printf+0 (used reg = )
18682 54B2           E8         B4F2            call	_bios_printf
18683 54B5           83C4                   06  add	sp,*6
18684                                           !BCC_EOS
18685                                           ! 2987           }
18686                                           ! 2988           break;
18687 54B8           EB           14            jmp .3E5
18688                       000054BA            .3E7:
18689 54BA           2C                     00  sub	al,*0
18690 54BC         0F84         FEA0            beq 	.3E8
18691 54C0           2C                     01  sub	al,*1
18692 54C2         0F84         FF67            beq 	.3F6
18693 54C6           2C                     01  sub	al,*1
18694 54C8         0F84         FF61            beq 	.3F7
18695 54CC           EB           D6            jmp	.402
18696                       000054CE            .3E5:
18697 54CE           E9         00BE            br 	.396
18698                                           !BCC_EOS
18699                                           ! 2989         case 7:
18700                                           ! 2990 ;
18701                       000054D1            .404:
18702                                           !BCC_EOS
18703                                           ! 2991           mouse_driver_seg = ES;
18704                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18705 54D1           8B46         14            mov	ax,$14[bp]
18706 54D4           8946         FA            mov	-6[bp],ax
18707                                           !BCC_EOS
18708                                           ! 2992           mouse_driver_offset = regs.u.r16.bx;
18709                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18710 54D7           8B46         0C            mov	ax,$C[bp]
18711 54DA           8946         F8            mov	-8[bp],ax
18712                                           !BCC_EOS
18713                                           ! 2993           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18714                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18715 54DD           FF76         F8            push	-8[bp]
18716                                           ! Debug: list int = const $22 (used reg = )
18717 54E0           B8                   0022  mov	ax,*$22
18718 54E3           50                         push	ax
18719                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18720 54E4           FF76         FE            push	-2[bp]
18721                                           ! Debug: func () void = write_word+0 (used reg = )
18722 54E7           E8         B14C            call	_write_word
18723 54EA           83C4                   06  add	sp,*6
18724                                           !BCC_EOS
18725                                           ! 2994   
18726                                           ! 2994         write_word(ebda_seg, 0x0024, mouse_driver_seg);
18727                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18728 54ED           FF76         FA            push	-6[bp]
18729                                           ! Debug: list int = const $24 (used reg = )
18730 54F0           B8                   0024  mov	ax,*$24
18731 54F3           50                         push	ax
18732                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18733 54F4           FF76         FE            push	-2[bp]
18734                                           ! Debug: func () void = write_word+0 (used reg = )
18735 54F7           E8         B13C            call	_write_word
18736 54FA           83C4                   06  add	sp,*6
18737                                           !BCC_EOS
18738                                           ! 2995           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18739                                           ! Debug: list int = const $27 (used reg = )
18740 54FD           B8                   0027  mov	ax,*$27
18741 5500           50                         push	ax
18742                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18743 5501           FF76         FE            push	-2[bp]
18744                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18745 5504           E8         B0F1            call	_read_byte
18746 5507           83C4                   04  add	sp,*4
18747                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18748 550A           8846         FC            mov	-4[bp],al
18749                                           !BCC_EOS
18750                                           ! 2996           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18751                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18752 550D           8B46         F8            mov	ax,-8[bp]
18753 5510           85C0                       test	ax,ax
18754 5512           75           1D            jne 	.405
18755                       00005514            .407:
18756                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18757 5514           8B46         FA            mov	ax,-6[bp]
18758 5517           85C0                       test	ax,ax
18759 5519           75           16            jne 	.405
18760                       0000551B            .406:
18761                                           ! 2997             if ( (mouse_flags_2 & 0x80) != 0 ) {
18762                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18763 551B           8A46         FC            mov	al,-4[bp]
18764 551E           24                     80  and	al,#$80
18765                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18766 5520           84C0                       test	al,al
18767 5522           74           0B            je  	.408
18768                       00005524            .409:
18769                                           ! 2998               mouse_flags_2 &= ~0x80;
18770                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18771 5524           8A46         FC            mov	al,-4[bp]
18772 5527           24                     7F  and	al,*$7F
18773 5529           8846         FC            mov	-4[bp],al
18774                                           !BCC_EOS
18775                                           ! 2999               inhibit_mouse_int_and_events();
18776                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18777 552C           E8         0BD3            call	_inhibit_mouse_int_and_events
18778                                           !BCC_EOS
18779                                           ! 3000             }
18780                                           ! 3001           }
18781                       0000552F            .408:
18782                                           ! 3002           else {
18783 552F           EB           08            jmp .40A
18784                       00005531            .405:
18785                                           ! 3003             mouse_flags_2 |= 0x80;
18786                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18787 5531           8A46         FC            mov	al,-4[bp]
18788 5534           0C                     80  or	al,#$80
18789 5536           8846         FC            mov	-4[bp],al
18790                                           !BCC_EOS
18791                                           ! 3004           }
18792                                           ! 3005           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18793                       00005539            .40A:
18794                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18795 5539           8A46         FC            mov	al,-4[bp]
18796 553C           30E4                       xor	ah,ah
18797 553E           50                         push	ax
18798                                           ! Debug: list int = const $27 (used reg = )
18799 553F           B8                   0027  mov	ax,*$27
18800 5542           50                         push	ax
18801                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18802 5543           FF76         FE            push	-2[bp]
18803                                           ! Debug: func () void = write_byte+0 (used reg = )
18804 5546           E8         B0D5            call	_write_byte
18805 5549           83C4                   06  add	sp,*6
18806                                           !BCC_EOS
18807                                           ! 3006           FLAGS &= 0xfffe;
18808                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18809 554C           8B46         18            mov	ax,$18[bp]
18810 554F           24                     FE  and	al,#$FE
18811 5551           8946         18            mov	$18[bp],ax
18812                                           !BCC_EOS
18813                                           ! 3007           regs.u.r8.ah = 0;
18814                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18815 5554           30C0                       xor	al,al
18816 5556           8846         13            mov	$13[bp],al
18817                                           !BCC_EOS
18818                                           ! 3008           break;
18819 5559           EB           34            jmp .396
18820                                           !BCC_EOS
18821                                           ! 3009         default:
18822                                           ! 3010 ;
18823                       0000555B            .40B:
18824                                           !BCC_EOS
18825                                           ! 3011           regs.u.r8.ah = 1;
18826                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18827 555B           B0                     01  mov	al,*1
18828 555D           8846         13            mov	$13[bp],al
18829                                           !BCC_EOS
18830                                           ! 3012           FLAGS |= 0x0001;
18831                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18832 5560           8B46         18            mov	ax,$18[bp]
18833 5563           0C                     01  or	al,*1
18834 5565           8946         18            mov	$18[bp],ax
18835                                           !BCC_EOS
18836                                           ! 3013       }
18837                                           ! 3014       break;
18838 5568           EB           25            jmp .396
18839                       0000556A            .398:
18840 556A           2C                     00  sub	al,*0
18841 556C           72           ED            jb 	.40B
18842 556E           3C                     07  cmp	al,*7
18843 5570           77           1B            ja  	.40C
18844 5572           30E4                       xor	ah,ah
18845 5574           D1E0                       shl	ax,*1
18846 5576           89C3                       mov	bx,ax
18847 5578           2E                         seg	cs
18848 5579           FFA7       557D            br	.40D[bx]
18849                       0000557D            .40D:
18850 557D                      4F6A            .word	.399
18851 557F                      506A            .word	.3AC
18852 5581                      5182            .word	.3BF
18853 5583                      5250            .word	.3D3
18854 5585                      5307            .word	.3E0
18855 5587                      506A            .word	.3AD
18856 5589                      535A            .word	.3E4
18857 558B                      54D1            .word	.404
18858                       0000558D            .40C:
18859 558D           EB           CC            jmp	.40B
18860                       0000558F            .396:
18861 558F           EB           2D            jmp .392
18862                                           !BCC_EOS
18863                                           ! 3015     default:
18864                                           ! 3016       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
18865                       00005591            .40E:
18866                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
18867 5591           FF76         0C            push	$C[bp]
18868                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
18869 5594           FF76         12            push	$12[bp]
18870                                           ! Debug: list * char = .40F+0 (used reg = )
18871 5597           BB                   D3F2  mov	bx,#.40F
18872 559A           53                         push	bx
18873                                           ! Debug: list int = const 4 (used reg = )
18874 559B           B8                   0004  mov	ax,*4
18875 559E           50                         push	ax
18876                                           ! Debug: func () void = bios_printf+0 (used reg = )
18877 559F           E8         B405            call	_bios_printf
18878 55A2           83C4                   08  add	sp,*8
18879                                           !BCC_EOS
18880                                           ! 3017       FLAGS |= 0x0001;
18881                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18882 55A5           8B46         18            mov	ax,$18[bp]
18883 55A8           0C                     01  or	al,*1
18884 55AA           8946         18            mov	$18[bp],ax
18885                                           !BCC_EOS
18886                                           ! 3018       regs.u.r8.ah = 0x86;
18887                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18888 55AD           B0                     86  mov	al,#$86
18889 55AF           8846         13            mov	$13[bp],al
18890                                           !BCC_EOS
18891                                           ! 3019       break;
18892 55B2           EB           0A            jmp .392
18893                                           !BCC_EOS
18894                                           ! 3020   }
18895                                           ! 3021 }
18896 55B4           EB           08            jmp .392
18897                       000055B6            .394:
18898 55B6           2C                     C2  sub	al,#$C2
18899 55B8         0F84         F9A8            beq 	.395
18900 55BC           EB           D3            jmp	.40E
18901                       000055BE            .392:
18902                       FFFFFFF0            ..FFF6	=	-$10
18903 55BE           89EC                       mov	sp,bp
18904 55C0           5D                         pop	bp
18905 55C1           C3                         ret
18906                                           ! 3022 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
18907                                           ! Register BX used in function int15_function_mouse
18908                                           ! 3023      Bit16u ES;
18909                                           export	_set_e820_range
18910                       000055C2            _set_e820_range:
18911                                           !BCC_EOS
18912                                           ! 3024      Bit16u DI;
18913                                           !BCC_EOS
18914                                           ! 3025      Bit32u start;
18915                                           !BCC_EOS
18916                                           ! 3026      Bit32u end;
18917                                           !BCC_EOS
18918                                           ! 3027      Bit8u extra_start;
18919                                           !BCC_EOS
18920                                           ! 3028      Bit8u extra_end;
18921                                           !BCC_EOS
18922                                           ! 3029      Bit16u type;
18923                                           !BCC_EOS
18924                                           ! 3030 {
18925                                           ! 3031     write_word(ES, DI, start);
18926 55C2           55                         push	bp
18927 55C3           89E5                       mov	bp,sp
18928                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18929 55C5           FF76         0A            push	$A[bp]
18930 55C8           FF76         08            push	8[bp]
18931                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18932 55CB           FF76         06            push	6[bp]
18933                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18934 55CE           FF76         04            push	4[bp]
18935                                           ! Debug: func () void = write_word+0 (used reg = )
18936 55D1           E8         B062            call	_write_word
18937 55D4           89EC                       mov	sp,bp
18938                                           !BCC_EOS
18939                                           ! 3032     write_word(ES, DI+2, start >> 16);
18940                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18941 55D6           8B46         08            mov	ax,8[bp]
18942 55D9           8B5E         0A            mov	bx,$A[bp]
18943 55DC           93                         xchg	bx,ax
18944 55DD           31DB                       xor	bx,bx
18945                                           ! Debug: list unsigned long = bx+0 (used reg = )
18946 55DF           53                         push	bx
18947 55E0           50                         push	ax
18948                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18949 55E1           8B46         06            mov	ax,6[bp]
18950                                           ! Debug: list unsigned int = ax+2 (used reg = )
18951 55E4           40                         inc	ax
18952 55E5           40                         inc	ax
18953 55E6           50                         push	ax
18954                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18955 55E7           FF76         04            push	4[bp]
18956                                           ! Debug: func () void = write_word+0 (used reg = )
18957 55EA           E8         B049            call	_write_word
18958 55ED           89EC                       mov	sp,bp
18959                                           !BCC_EOS
18960                                           ! 3033     write_word(ES, DI+4, extra_start);
18961                                           ! Debug: list unsigned char extra_start = [S+2+$E] (used reg = )
18962 55EF           8A46         10            mov	al,$10[bp]
18963 55F2           30E4                       xor	ah,ah
18964 55F4           50                         push	ax
18965                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
18966 55F5           8B46         06            mov	ax,6[bp]
18967                                           ! Debug: list unsigned int = ax+4 (used reg = )
18968 55F8           05                   0004  add	ax,*4
18969 55FB           50                         push	ax
18970                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18971 55FC           FF76         04            push	4[bp]
18972                                           ! Debug: func () void = write_word+0 (used reg = )
18973 55FF           E8         B034            call	_write_word
18974 5602           89EC                       mov	sp,bp
18975                                           !BCC_EOS
18976                                           ! 3034     write_word(ES, DI+6, 0x00);
18977                                           ! Debug: list int = const 0 (used reg = )
18978 5604           31C0                       xor	ax,ax
18979 5606           50                         push	ax
18980                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
18981 5607           8B46         06            mov	ax,6[bp]
18982                                           ! Debug: list unsigned int = ax+6 (used reg = )
18983 560A           05                   0006  add	ax,*6
18984 560D           50                         push	ax
18985                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18986 560E           FF76         04            push	4[bp]
18987                                           ! Debug: func () void = write_word+0 (used reg = )
18988 5611           E8         B022            call	_write_word
18989 5614           89EC                       mov	sp,bp
18990                                           !BCC_EOS
18991                                           ! 3035     end -= start;
18992                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
18993 5616           8B46         0C            mov	ax,$C[bp]
18994 5619           8B5E         0E            mov	bx,$E[bp]
18995 561C           8D7E         08            lea	di,8[bp]
18996 561F           E8         AABF            call	lsubul
18997 5622           8946         0C            mov	$C[bp],ax
18998 5625           895E         0E            mov	$E[bp],bx
18999                                           !BCC_EOS
19000                                           ! 3036     extra_end -= extra_start;
19001                                           ! Debug: subab unsigned char extra_start = [S+2+$E] to unsigned char extra_end = [S+2+$10] (used reg = )
19002 5628           8A46         12            mov	al,$12[bp]
19003 562B           30E4                       xor	ah,ah
19004 562D           2A46         10            sub	al,$10[bp]
19005 5630           80DC                   00  sbb	ah,*0
19006 5633           8846         12            mov	$12[bp],al
19007                                           !BCC_EOS
19008                                           ! 3037     write_word(ES, DI+8, end);
19009                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
19010 5636           FF76         0E            push	$E[bp]
19011 5639           FF76         0C            push	$C[bp]
19012                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
19013 563C           8B46         06            mov	ax,6[bp]
19014                                           ! Debug: list unsigned int = ax+8 (used reg = )
19015 563F           05                   0008  add	ax,*8
19016 5642           50                         push	ax
19017                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19018 5643           FF76         04            push	4[bp]
19019                                           ! Debug: func () void = write_word+0 (used reg = )
19020 5646           E8         AFED            call	_write_word
19021 5649           89EC                       mov	sp,bp
19022                                           !BCC_EOS
19023                                           ! 3038     write_word(ES, DI+10, end >> 16);
19024                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
19025 564B           8B46         0C            mov	ax,$C[bp]
19026 564E           8B5E         0E            mov	bx,$E[bp]
19027 5651           93                         xchg	bx,ax
19028 5652           31DB                       xor	bx,bx
19029                                           ! Debug: list unsigned long = bx+0 (used reg = )
19030 5654           53                         push	bx
19031 5655           50                         push	ax
19032                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
19033 5656           8B46         06            mov	ax,6[bp]
19034                                           ! Debug: list unsigned int = ax+$A (used reg = )
19035 5659           05                   000A  add	ax,*$A
19036 565C           50                         push	ax
19037                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19038 565D           FF76         04            push	4[bp]
19039                                           ! Debug: func () void = write_word+0 (used reg = )
19040 5660           E8         AFD3            call	_write_word
19041 5663           89EC                       mov	sp,bp
19042                                           !BCC_EOS
19043                                           ! 3039     write_word(ES, DI+12, extra_end);
19044                                           ! Debug: list unsigned char extra_end = [S+2+$10] (used reg = )
19045 5665           8A46         12            mov	al,$12[bp]
19046 5668           30E4                       xor	ah,ah
19047 566A           50                         push	ax
19048                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
19049 566B           8B46         06            mov	ax,6[bp]
19050                                           ! Debug: list unsigned int = ax+$C (used reg = )
19051 566E           05                   000C  add	ax,*$C
19052 5671           50                         push	ax
19053                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19054 5672           FF76         04            push	4[bp]
19055                                           ! Debug: func () void = write_word+0 (used reg = )
19056 5675           E8         AFBE            call	_write_word
19057 5678           89EC                       mov	sp,bp
19058                                           !BCC_EOS
19059                                           ! 3040     write_word(ES, DI+14, 0x0000);
19060                                           ! Debug: list int = const 0 (used reg = )
19061 567A           31C0                       xor	ax,ax
19062 567C           50                         push	ax
19063                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
19064 567D           8B46         06            mov	ax,6[bp]
19065                                           ! Debug: list unsigned int = ax+$E (used reg = )
19066 5680           05                   000E  add	ax,*$E
19067 5683           50                         push	ax
19068                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19069 5684           FF76         04            push	4[bp]
19070                                           ! Debug: func () void = write_word+0 (used reg = )
19071 5687           E8         AFAC            call	_write_word
19072 568A           89EC                       mov	sp,bp
19073                                           !BCC_EOS
19074                                           ! 3041     write_word(ES, DI+16, type);
19075                                           ! Debug: list unsigned short type = [S+2+$12] (used reg = )
19076 568C           FF76         14            push	$14[bp]
19077                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
19078 568F           8B46         06            mov	ax,6[bp]
19079                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19080 5692           05                   0010  add	ax,*$10
19081 5695           50                         push	ax
19082                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19083 5696           FF76         04            push	4[bp]
19084                                           ! Debug: func () void = write_word+0 (used reg = )
19085 5699           E8         AF9A            call	_write_word
19086 569C           89EC                       mov	sp,bp
19087                                           !BCC_EOS
19088                                           ! 3042     write_word(ES, DI+18, 0x0);
19089                                           ! Debug: list int = const 0 (used reg = )
19090 569E           31C0                       xor	ax,ax
19091 56A0           50                         push	ax
19092                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
19093 56A1           8B46         06            mov	ax,6[bp]
19094                                           ! Debug: list unsigned int = ax+$12 (used reg = )
19095 56A4           05                   0012  add	ax,*$12
19096 56A7           50                         push	ax
19097                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19098 56A8           FF76         04            push	4[bp]
19099                                           ! Debug: func () void = write_word+0 (used reg = )
19100 56AB           E8         AF88            call	_write_word
19101 56AE           89EC                       mov	sp,bp
19102                                           !BCC_EOS
19103                                           ! 3043 }
19104 56B0           5D                         pop	bp
19105 56B1           C3                         ret
19106                                           ! 3044   void
19107                                           ! Register BX used in function set_e820_range
19108                                           ! 3045 int15_function32(regs, ES, DS, FLAGS)
19109                                           ! 3046   pushad_regs_t regs;
19110                                           export	_int15_function32
19111                       000056B2            _int15_function32:
19112                                           !BCC_EOS
19113                                           ! 3047   Bit16u ES, DS, FLAGS;
19114                                           !BCC_EOS
19115                                           ! 3048 {
19116                                           ! 3049   Bit32u extended_memory_size=0;
19117 56B2           55                         push	bp
19118 56B3           89E5                       mov	bp,sp
19119 56B5           83C4                   FC  add	sp,*-4
19120                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
19121 56B8           31C0                       xor	ax,ax
19122 56BA           31DB                       xor	bx,bx
19123 56BC           8946         FC            mov	-4[bp],ax
19124 56BF           895E         FE            mov	-2[bp],bx
19125                                           !BCC_EOS
19126                                           ! 3050   Bit32u extra_lowbits_memory_size=0;
19127 56C2           83C4                   FC  add	sp,*-4
19128                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
19129 56C5           31C0                       xor	ax,ax
19130 56C7           31DB                       xor	bx,bx
19131 56C9           8946         F8            mov	-8[bp],ax
19132 56CC           895E         FA            mov	-6[bp],bx
19133                                           !BCC_EOS
19134                                           ! 3051   Bit16u CX,DX;
19135                                           !BCC_EOS
19136                                           ! 3052   Bit8u extra_highbits_memory_size=0;
19137 56CF           83C4                   FB  add	sp,*-5
19138                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
19139 56D2           30C0                       xor	al,al
19140 56D4           8846         F3            mov	-$D[bp],al
19141                                           !BCC_EOS
19142                                           ! 3053 ;
19143 56D7           4C                         dec	sp
19144                                           !BCC_EOS
19145                                           ! 3054   switch (regs.u.r8.ah) {
19146 56D8           8A46         21            mov	al,$21[bp]
19147 56DB           E9         04CF            br 	.412
19148                                           ! 3055     case 0x86:
19149                                           ! 3056       CX = regs.u.r16.cx;
19150                       000056DE            .413:
19151                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
19152 56DE           8B46         1C            mov	ax,$1C[bp]
19153 56E1           8946         F6            mov	-$A[bp],ax
19154                                           !BCC_EOS
19155                                           ! 3057       DX = regs.u.r16.dx;
19156                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
19157 56E4           8B46         18            mov	ax,$18[bp]
19158 56E7           8946         F4            mov	-$C[bp],ax
19159                                           !BCC_EOS
19160                                           ! 3058 #asm
19161                                           !BCC_EOS
19162                                           !BCC_ASM
19163                       00000004            _int15_function32.CX	set	4
19164                       FFFFFFF6            .int15_function32.CX	set	-$A
19165                       00000001            _int15_function32.extra_highbits_memory_size	set	1
19166                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
19167                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
19168                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
19169                       0000000A            _int15_function32.extended_memory_size	set	$A
19170                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
19171                       00000036            _int15_function32.FLAGS	set	$36
19172                       00000028            .int15_function32.FLAGS	set	$28
19173                       00000034            _int15_function32.DS	set	$34
19174                       00000026            .int15_function32.DS	set	$26
19175                       00000002            _int15_function32.DX	set	2
19176                       FFFFFFF4            .int15_function32.DX	set	-$C
19177                       00000032            _int15_function32.ES	set	$32
19178                       00000024            .int15_function32.ES	set	$24
19179                       00000012            _int15_function32.regs	set	$12
19180                       00000004            .int15_function32.regs	set	4
19181 56EA           FB                               sti
19182                                                 ;; Get the count in eax
19183 56EB           89E3                             mov bx, sp
19184 56ED           36                               SEG SS
19185 56EE           8B47         04                    mov ax, _int15_function32.CX [bx]
19186 56F1     66    C1E0                   10        shl eax, #16
19187 56F5           36                               SEG SS
19188 56F6           8B47         02                    mov ax, _int15_function32.DX [bx]
19189                                                 ;; convert to numbers of 15usec ticks
19190 56F9     66    BB               0000000F        mov ebx, #15
19191 56FF     66    31D2                             xor edx, edx
19192 5702     66    F7F3                             div eax, ebx
19193 5705     66    89C1                             mov ecx, eax
19194                                                 ;; wait for ecx number of refresh requests
19195 5708           E4                     61        in al, #0x61
19196 570A           24                     10        and al,#0x10
19197 570C           88C4                             mov ah, al
19198 570E     66    09C9                             or ecx, ecx
19199 5711           74           0E                  je int1586_tick_end
19200                       00005713            int1586_tick:
19201 5713           E4                     61        in al, #0x61
19202 5715           24                     10        and al,#0x10
19203 5717           38E0                             cmp al, ah
19204 5719           74           F8                  je int1586_tick
19205 571B           88C4                             mov ah, al
19206 571D     66    49                               dec ecx
19207 571F           75           F2                  jnz int1586_tick
19208                       00005721            int1586_tick_end:
19209                                           ! 3087 endasm
19210                                           !BCC_ENDASM
19211                                           !BCC_EOS
19212                                           ! 3088       break;
19213 5721           E9         0497            br 	.410
19214                                           !BCC_EOS
19215                                           ! 3089     case 0xe8:
19216                                           ! 3090         switch(regs.u.r8.al) {
19217                       00005724            .414:
19218 5724           8A46         20            mov	al,$20[bp]
19219 5727           E9         0450            br 	.417
19220                                           ! 3091          case 0x20:
19221                                           ! 3092             if(regs.u.r32.edx == 0x534D4150)
19222                       0000572A            .418:
19223                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
19224                                           ! Debug: expression subtree swapping
19225 572A           B8                   4150  mov	ax,#$4150
19226 572D           BB                   534D  mov	bx,#$534D
19227 5730           53                         push	bx
19228 5731           50                         push	ax
19229 5732           8B46         18            mov	ax,$18[bp]
19230 5735           8B5E         1A            mov	bx,$1A[bp]
19231 5738           8D7E         EE            lea	di,-2+..FFF5[bp]
19232 573B           E8         A98D            call	lcmpul
19233 573E           8D66         F2            lea	sp,2+..FFF5[bp]
19234 5741         0F85         03D1            bne 	.419
19235                       00005745            .41A:
19236                                           ! 3093             {
19237                                           ! 3094                 extended_memory_size = inb_cmos(0x35);
19238                                           ! Debug: list int = const $35 (used reg = )
19239 5745           B8                   0035  mov	ax,*$35
19240 5748           50                         push	ax
19241                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19242 5749           E8         AE3B            call	_inb_cmos
19243 574C           44                         inc	sp
19244 574D           44                         inc	sp
19245                                           ! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19246 574E           30E4                       xor	ah,ah
19247 5750           31DB                       xor	bx,bx
19248 5752           8946         FC            mov	-4[bp],ax
19249 5755           895E         FE            mov	-2[bp],bx
19250                                           !BCC_EOS
19251                                           ! 3095                 extended_memory_size <<= 8;
19252                                           ! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19253 5758           8B46         FC            mov	ax,-4[bp]
19254 575B           8B5E         FE            mov	bx,-2[bp]
19255 575E           88DF                       mov	bh,bl
19256 5760           88E3                       mov	bl,ah
19257 5762           88C4                       mov	ah,al
19258 5764           30C0                       xor	al,al
19259 5766           8946         FC            mov	-4[bp],ax
19260 5769           895E         FE            mov	-2[bp],bx
19261                                           !BCC_EOS
19262                                           ! 3096                 extended_memory_size |= inb_cmos(0x34);
19263                                           ! Debug: list int = const $34 (used reg = )
19264 576C           B8                   0034  mov	ax,*$34
19265 576F           50                         push	ax
19266                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19267 5770           E8         AE14            call	_inb_cmos
19268 5773           44                         inc	sp
19269 5774           44                         inc	sp
19270                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19271 5775           30E4                       xor	ah,ah
19272 5777           31DB                       xor	bx,bx
19273                                           ! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19274 5779           53                         push	bx
19275 577A           50                         push	ax
19276 577B           8B46         FC            mov	ax,-4[bp]
19277 577E           8B5E         FE            mov	bx,-2[bp]
19278 5781           8D7E         EE            lea	di,-2+..FFF5[bp]
19279 5784           E8         A980            call	lorul
19280 5787           8946         FC            mov	-4[bp],ax
19281 578A           895E         FE            mov	-2[bp],bx
19282 578D           83C4                   04  add	sp,*4
19283                                           !BCC_EOS
19284                                           ! 3097                 extended_memory_size *= 64;
19285                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19286 5790           B8                   0040  mov	ax,*$40
19287 5793           31DB                       xor	bx,bx
19288 5795           53                         push	bx
19289 5796           50                         push	ax
19290 5797           8B46         FC            mov	ax,-4[bp]
19291 579A           8B5E         FE            mov	bx,-2[bp]
19292 579D           8D7E         EE            lea	di,-2+..FFF5[bp]
19293 57A0           E8         A946            call	lmulul
19294 57A3           8946         FC            mov	-4[bp],ax
19295 57A6           895E         FE            mov	-2[bp],bx
19296 57A9           83C4                   04  add	sp,*4
19297                                           !BCC_EOS
19298                                           ! 3098                 if(extended_memory_size > 0x3bc000) {
19299                                           ! Debug: gt long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19300 57AC           B8                   C000  mov	ax,#$C000
19301 57AF           BB                   003B  mov	bx,*$3B
19302 57B2           8D7E         FC            lea	di,-4[bp]
19303 57B5           E8         A913            call	lcmpul
19304 57B8           73           0C            jae 	.41B
19305                       000057BA            .41C:
19306                                           ! 3099                     extended_memory_size = 0x3bc000;
19307                                           ! Debug: eq long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19308 57BA           B8                   C000  mov	ax,#$C000
19309 57BD           BB                   003B  mov	bx,*$3B
19310 57C0           8946         FC            mov	-4[bp],ax
19311 57C3           895E         FE            mov	-2[bp],bx
19312                                           !BCC_EOS
19313                                           ! 3100                 }
19314                                           ! 3101                 extended_memory_size *= 1024;
19315                       000057C6            .41B:
19316                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19317 57C6           B8                   0400  mov	ax,#$400
19318 57C9           31DB                       xor	bx,bx
19319 57CB           53                         push	bx
19320 57CC           50                         push	ax
19321 57CD           8B46         FC            mov	ax,-4[bp]
19322 57D0           8B5E         FE            mov	bx,-2[bp]
19323 57D3           8D7E         EE            lea	di,-2+..FFF5[bp]
19324 57D6           E8         A910            call	lmulul
19325 57D9           8946         FC            mov	-4[bp],ax
19326 57DC           895E         FE            mov	-2[bp],bx
19327 57DF           83C4                   04  add	sp,*4
19328                                           !BCC_EOS
19329                                           ! 3102                 extended_memory_size += (16L * 1024 * 1024);
19330                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19331 57E2           31C0                       xor	ax,ax
19332 57E4           BB                   0100  mov	bx,#$100
19333 57E7           53                         push	bx
19334 57E8           50                         push	ax
19335 57E9           8B46         FC            mov	ax,-4[bp]
19336 57EC           8B5E         FE            mov	bx,-2[bp]
19337 57EF           8D7E         EE            lea	di,-2+..FFF5[bp]
19338 57F2           E8         A8CE            call	laddul
19339 57F5           8946         FC            mov	-4[bp],ax
19340 57F8           895E         FE            mov	-2[bp],bx
19341 57FB           83C4                   04  add	sp,*4
19342                                           !BCC_EOS
19343                                           ! 3103                 if(extended_memory_size <= (16L * 1024 * 1024)) {
19344                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19345 57FE           31C0                       xor	ax,ax
19346 5800           BB                   0100  mov	bx,#$100
19347 5803           8D7E         FC            lea	di,-4[bp]
19348 5806           E8         A8C2            call	lcmpul
19349 5809         0F82         0083            blo 	.41D
19350                       0000580D            .41E:
19351                                           ! 3104                     extended_memory_size = inb_cmos(0x31);
19352                                           ! Debug: list int = const $31 (used reg = )
19353 580D           B8                   0031  mov	ax,*$31
19354 5810           50                         push	ax
19355                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19356 5811           E8         AD73            call	_inb_cmos
19357 5814           44                         inc	sp
19358 5815           44                         inc	sp
19359                                           ! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19360 5816           30E4                       xor	ah,ah
19361 5818           31DB                       xor	bx,bx
19362 581A           8946         FC            mov	-4[bp],ax
19363 581D           895E         FE            mov	-2[bp],bx
19364                                           !BCC_EOS
19365                                           ! 3105                     extended_memory_size <<= 8;
19366                                           ! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19367 5820           8B46         FC            mov	ax,-4[bp]
19368 5823           8B5E         FE            mov	bx,-2[bp]
19369 5826           88DF                       mov	bh,bl
19370 5828           88E3                       mov	bl,ah
19371 582A           88C4                       mov	ah,al
19372 582C           30C0                       xor	al,al
19373 582E           8946         FC            mov	-4[bp],ax
19374 5831           895E         FE            mov	-2[bp],bx
19375                                           !BCC_EOS
19376                                           ! 3106                     extended_memory_size |= inb_cmos(0x30);
19377                                           ! Debug: list int = const $30 (used reg = )
19378 5834           B8                   0030  mov	ax,*$30
19379 5837           50                         push	ax
19380                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19381 5838           E8         AD4C            call	_inb_cmos
19382 583B           44                         inc	sp
19383 583C           44                         inc	sp
19384                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19385 583D           30E4                       xor	ah,ah
19386 583F           31DB                       xor	bx,bx
19387                                           ! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19388 5841           53                         push	bx
19389 5842           50                         push	ax
19390 5843           8B46         FC            mov	ax,-4[bp]
19391 5846           8B5E         FE            mov	bx,-2[bp]
19392 5849           8D7E         EE            lea	di,-2+..FFF5[bp]
19393 584C           E8         A8B8            call	lorul
19394 584F           8946         FC            mov	-4[bp],ax
19395 5852           895E         FE            mov	-2[bp],bx
19396 5855           83C4                   04  add	sp,*4
19397                                           !BCC_EOS
19398                                           ! 3107                     extended_memory_size *= 1024;
19399                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19400 5858           B8                   0400  mov	ax,#$400
19401 585B           31DB                       xor	bx,bx
19402 585D           53                         push	bx
19403 585E           50                         push	ax
19404 585F           8B46         FC            mov	ax,-4[bp]
19405 5862           8B5E         FE            mov	bx,-2[bp]
19406 5865           8D7E         EE            lea	di,-2+..FFF5[bp]
19407 5868           E8         A87E            call	lmulul
19408 586B           8946         FC            mov	-4[bp],ax
19409 586E           895E         FE            mov	-2[bp],bx
19410 5871           83C4                   04  add	sp,*4
19411                                           !BCC_EOS
19412                                           ! 3108                     extended_memory_size += (1L * 1024 * 1024);
19413                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19414 5874           31C0                       xor	ax,ax
19415 5876           BB                   0010  mov	bx,*$10
19416 5879           53                         push	bx
19417 587A           50                         push	ax
19418 587B           8B46         FC            mov	ax,-4[bp]
19419 587E           8B5E         FE            mov	bx,-2[bp]
19420 5881           8D7E         EE            lea	di,-2+..FFF5[bp]
19421 5884           E8         A83C            call	laddul
19422 5887           8946         FC            mov	-4[bp],ax
19423 588A           895E         FE            mov	-2[bp],bx
19424 588D           83C4                   04  add	sp,*4
19425                                           !BCC_EOS
19426                                           ! 3109                 }
19427                                           ! 3110                 extra_lowbits_memory_size = inb_cmos(0x5c);
19428                       00005890            .41D:
19429                                           ! Debug: list int = const $5C (used reg = )
19430 5890           B8                   005C  mov	ax,*$5C
19431 5893           50                         push	ax
19432                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19433 5894           E8         ACF0            call	_inb_cmos
19434 5897           44                         inc	sp
19435 5898           44                         inc	sp
19436                                           ! Debug: eq unsigned char = al+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19437 5899           30E4                       xor	ah,ah
19438 589B           31DB                       xor	bx,bx
19439 589D           8946         F8            mov	-8[bp],ax
19440 58A0           895E         FA            mov	-6[bp],bx
19441                                           !BCC_EOS
19442                                           ! 3111                 extra_lowbits_memory_size <<= 8;
19443                                           ! Debug: slab int = const 8 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19444 58A3           8B46         F8            mov	ax,-8[bp]
19445 58A6           8B5E         FA            mov	bx,-6[bp]
19446 58A9           88DF                       mov	bh,bl
19447 58AB           88E3                       mov	bl,ah
19448 58AD           88C4                       mov	ah,al
19449 58AF           30C0                       xor	al,al
19450 58B1           8946         F8            mov	-8[bp],ax
19451 58B4           895E         FA            mov	-6[bp],bx
19452                                           !BCC_EOS
19453                                           ! 3112                 extra_lowbits_memory_size |= inb_cmos(0x5b);
19454                                           ! Debug: list int = const $5B (used reg = )
19455 58B7           B8                   005B  mov	ax,*$5B
19456 58BA           50                         push	ax
19457                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19458 58BB           E8         ACC9            call	_inb_cmos
19459 58BE           44                         inc	sp
19460 58BF           44                         inc	sp
19461                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19462 58C0           30E4                       xor	ah,ah
19463 58C2           31DB                       xor	bx,bx
19464                                           ! Debug: orab unsigned long = bx+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19465 58C4           53                         push	bx
19466 58C5           50                         push	ax
19467 58C6           8B46         F8            mov	ax,-8[bp]
19468 58C9           8B5E         FA            mov	bx,-6[bp]
19469 58CC           8D7E         EE            lea	di,-2+..FFF5[bp]
19470 58CF           E8         A835            call	lorul
19471 58D2           8946         F8            mov	-8[bp],ax
19472 58D5           895E         FA            mov	-6[bp],bx
19473 58D8           83C4                   04  add	sp,*4
19474                                           !BCC_EOS
19475                                           ! 3113                 extra_lowbits_memory_size *= 64;
19476                                           ! Debug: mulab unsigned long = const $40 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19477 58DB           B8                   0040  mov	ax,*$40
19478 58DE           31DB                       xor	bx,bx
19479 58E0           53                         push	bx
19480 58E1           50                         push	ax
19481 58E2           8B46         F8            mov	ax,-8[bp]
19482 58E5           8B5E         FA            mov	bx,-6[bp]
19483 58E8           8D7E         EE            lea	di,-2+..FFF5[bp]
19484 58EB           E8         A7FB            call	lmulul
19485 58EE           8946         F8            mov	-8[bp],ax
19486 58F1           895E         FA            mov	-6[bp],bx
19487 58F4           83C4                   04  add	sp,*4
19488                                           !BCC_EOS
19489                                           ! 3114                 extra_lowbits_memory_size *= 1024;
19490                                           ! Debug: mulab unsigned long = const $400 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19491 58F7           B8                   0400  mov	ax,#$400
19492 58FA           31DB                       xor	bx,bx
19493 58FC           53                         push	bx
19494 58FD           50                         push	ax
19495 58FE           8B46         F8            mov	ax,-8[bp]
19496 5901           8B5E         FA            mov	bx,-6[bp]
19497 5904           8D7E         EE            lea	di,-2+..FFF5[bp]
19498 5907           E8         A7DF            call	lmulul
19499 590A           8946         F8            mov	-8[bp],ax
19500 590D           895E         FA            mov	-6[bp],bx
19501 5910           83C4                   04  add	sp,*4
19502                                           !BCC_EOS
19503                                           ! 3115                 extra_highbits_memory_size = inb_cmos(0x5d);
19504                                           ! Debug: list int = const $5D (used reg = )
19505 5913           B8                   005D  mov	ax,*$5D
19506 5916           50                         push	ax
19507                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19508 5917           E8         AC6D            call	_inb_cmos
19509 591A           44                         inc	sp
19510 591B           44                         inc	sp
19511                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
19512 591C           8846         F3            mov	-$D[bp],al
19513                                           !BCC_EOS
19514                                           ! 3116                 switch(regs.u.r16.bx)
19515 591F           8B46         14            mov	ax,$14[bp]
19516                                           ! 3117                 {
19517 5922           E9         01AD            br 	.421
19518                                           ! 3118                     case 0:
19519                                           ! 3119                         set_e820_range(ES, regs.u.r16.di,
19520                       00005925            .422:
19521                                           ! 3120                                        0x0000000L, 0x0009f000L, 0, 0, 1);
19522                                           ! Debug: list int = const 1 (used reg = )
19523 5925           B8                   0001  mov	ax,*1
19524 5928           50                         push	ax
19525                                           ! Debug: list int = const 0 (used reg = )
19526 5929           31C0                       xor	ax,ax
19527 592B           50                         push	ax
19528                                           ! Debug: list int = const 0 (used reg = )
19529 592C           31C0                       xor	ax,ax
19530 592E           50                         push	ax
19531                                           ! Debug: list long = const $9F000 (used reg = )
19532 592F           B8                   F000  mov	ax,#$F000
19533 5932           BB                   0009  mov	bx,*9
19534 5935           53                         push	bx
19535 5936           50                         push	ax
19536                                           ! Debug: list long = const 0 (used reg = )
19537 5937           31C0                       xor	ax,ax
19538 5939           31DB                       xor	bx,bx
19539 593B           53                         push	bx
19540 593C           50                         push	ax
19541                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19542 593D           FF76         04            push	4[bp]
19543                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19544 5940           FF76         24            push	$24[bp]
19545                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19546 5943           E8         FC7C            call	_set_e820_range
19547 5946           83C4                   12  add	sp,*$12
19548                                           !BCC_EOS
19549                                           ! 3121                         regs.u.r32.ebx = 1;
19550                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
19551 5949           B8                   0001  mov	ax,*1
19552 594C           31DB                       xor	bx,bx
19553 594E           8946         14            mov	$14[bp],ax
19554 5951           895E         16            mov	$16[bp],bx
19555                                           !BCC_EOS
19556                                           ! 3122                         break;
19557 5954           E9         019E            br 	.41F
19558                                           !BCC_EOS
19559                                           ! 3123                     case 1:
19560                                           ! 3124                         set_e820_range(ES, regs.u.r16.di,
19561                       00005957            .423:
19562                                           ! 3125                                        0x0009f000L, 0x000a0000L, 0, 
19563                                           ! 3125 0, 2);
19564                                           ! Debug: list int = const 2 (used reg = )
19565 5957           B8                   0002  mov	ax,*2
19566 595A           50                         push	ax
19567                                           ! Debug: list int = const 0 (used reg = )
19568 595B           31C0                       xor	ax,ax
19569 595D           50                         push	ax
19570                                           ! Debug: list int = const 0 (used reg = )
19571 595E           31C0                       xor	ax,ax
19572 5960           50                         push	ax
19573                                           ! Debug: list long = const $A0000 (used reg = )
19574 5961           31C0                       xor	ax,ax
19575 5963           BB                   000A  mov	bx,*$A
19576 5966           53                         push	bx
19577 5967           50                         push	ax
19578                                           ! Debug: list long = const $9F000 (used reg = )
19579 5968           B8                   F000  mov	ax,#$F000
19580 596B           BB                   0009  mov	bx,*9
19581 596E           53                         push	bx
19582 596F           50                         push	ax
19583                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19584 5970           FF76         04            push	4[bp]
19585                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19586 5973           FF76         24            push	$24[bp]
19587                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19588 5976           E8         FC49            call	_set_e820_range
19589 5979           83C4                   12  add	sp,*$12
19590                                           !BCC_EOS
19591                                           ! 3126                         regs.u.r32.ebx = 2;
19592                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
19593 597C           B8                   0002  mov	ax,*2
19594 597F           31DB                       xor	bx,bx
19595 5981           8946         14            mov	$14[bp],ax
19596 5984           895E         16            mov	$16[bp],bx
19597                                           !BCC_EOS
19598                                           ! 3127                         break;
19599 5987           E9         016B            br 	.41F
19600                                           !BCC_EOS
19601                                           ! 3128                     case 2:
19602                                           ! 3129                         set_e820_range(ES, regs.u.r16.di,
19603                       0000598A            .424:
19604                                           ! 3130                                        0x000e8000L, 0x00100000L, 0, 0, 2);
19605                                           ! Debug: list int = const 2 (used reg = )
19606 598A           B8                   0002  mov	ax,*2
19607 598D           50                         push	ax
19608                                           ! Debug: list int = const 0 (used reg = )
19609 598E           31C0                       xor	ax,ax
19610 5990           50                         push	ax
19611                                           ! Debug: list int = const 0 (used reg = )
19612 5991           31C0                       xor	ax,ax
19613 5993           50                         push	ax
19614                                           ! Debug: list long = const $100000 (used reg = )
19615 5994           31C0                       xor	ax,ax
19616 5996           BB                   0010  mov	bx,*$10
19617 5999           53                         push	bx
19618 599A           50                         push	ax
19619                                           ! Debug: list long = const $E8000 (used reg = )
19620 599B           B8                   8000  mov	ax,#$8000
19621 599E           BB                   000E  mov	bx,*$E
19622 59A1           53                         push	bx
19623 59A2           50                         push	ax
19624                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19625 59A3           FF76         04            push	4[bp]
19626                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19627 59A6           FF76         24            push	$24[bp]
19628                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19629 59A9           E8         FC16            call	_set_e820_range
19630 59AC           83C4                   12  add	sp,*$12
19631                                           !BCC_EOS
19632                                           ! 3131                         regs.u.r32.ebx = 3;
19633                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
19634 59AF           B8                   0003  mov	ax,*3
19635 59B2           31DB                       xor	bx,bx
19636 59B4           8946         14            mov	$14[bp],ax
19637 59B7           895E         16            mov	$16[bp],bx
19638                                           !BCC_EOS
19639                                           ! 3132                         break;
19640 59BA           E9         0138            br 	.41F
19641                                           !BCC_EOS
19642                                           ! 3133                     case 3:
19643                                           ! 3134                         set_e820_range(ES, regs.u.r16.di,
19644                       000059BD            .425:
19645                                           ! 3135                                        0x00100000L,
19646                                           ! 3136                                        extended_memory_size - 0x00010000L, 0, 0, 1);
19647                                           ! Debug: list int = const 1 (used reg = )
19648 59BD           B8                   0001  mov	ax,*1
19649 59C0           50                         push	ax
19650                                           ! Debug: list int = const 0 (used reg = )
19651 59C1           31C0                       xor	ax,ax
19652 59C3           50                         push	ax
19653                                           ! Debug: list int = const 0 (used reg = )
19654 59C4           31C0                       xor	ax,ax
19655 59C6           50                         push	ax
19656                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
19657 59C7           31C0                       xor	ax,ax
19658 59C9           BB                   0001  mov	bx,*1
19659 59CC           53                         push	bx
19660 59CD           50                         push	ax
19661 59CE           8B46         FC            mov	ax,-4[bp]
19662 59D1           8B5E         FE            mov	bx,-2[bp]
19663 59D4           8D7E         E8            lea	di,-8+..FFF5[bp]
19664 59D7           E8         A707            call	lsubul
19665 59DA           83C4                   04  add	sp,*4
19666                                           ! Debug: list unsigned long = bx+0 (used reg = )
19667 59DD           53                         push	bx
19668 59DE           50                         push	ax
19669                                           ! Debug: list long = const $100000 (used reg = )
19670 59DF           31C0                       xor	ax,ax
19671 59E1           BB                   0010  mov	bx,*$10
19672 59E4           53                         push	bx
19673 59E5           50                         push	ax
19674                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19675 59E6           FF76         04            push	4[bp]
19676                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19677 59E9           FF76         24            push	$24[bp]
19678                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19679 59EC           E8         FBD3            call	_set_e820_range
19680 59EF           83C4                   12  add	sp,*$12
19681                                           !BCC_EOS
19682                                           ! 3137                         regs.u.r32.ebx = 4;
19683                                           ! Debug: eq int = const 4 to unsigned long regs = [S+$10+$12] (used reg = )
19684 59F2           B8                   0004  mov	ax,*4
19685 59F5           31DB                       xor	bx,bx
19686 59F7           8946         14            mov	$14[bp],ax
19687 59FA           895E         16            mov	$16[bp],bx
19688                                           !BCC_EOS
19689                                           ! 3138                         break;
19690 59FD           E9         00F5            br 	.41F
19691                                           !BCC_EOS
19692                                           ! 3139                     case 4:
19693                                           ! 3140                         set_e820_range(ES, regs.u.r16.di,
19694                       00005A00            .426:
19695                                           ! 3141                                        extended_memory_size - 0x00010000L,
19696                                           ! 3142                                        extended_memory_size, 0, 0, 3);
19697                                           ! Debug: list int = const 3 (used reg = )
19698 5A00           B8                   0003  mov	ax,*3
19699 5A03           50                         push	ax
19700                                           ! Debug: list int = const 0 (used reg = )
19701 5A04           31C0                       xor	ax,ax
19702 5A06           50                         push	ax
19703                                           ! Debug: list int = const 0 (used reg = )
19704 5A07           31C0                       xor	ax,ax
19705 5A09           50                         push	ax
19706                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
19707 5A0A           FF76         FE            push	-2[bp]
19708 5A0D           FF76         FC            push	-4[bp]
19709                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
19710 5A10           31C0                       xor	ax,ax
19711 5A12           BB                   0001  mov	bx,*1
19712 5A15           53                         push	bx
19713 5A16           50                         push	ax
19714 5A17           8B46         FC            mov	ax,-4[bp]
19715 5A1A           8B5E         FE            mov	bx,-2[bp]
19716 5A1D           8D7E         E4            lea	di,-$C+..FFF5[bp]
19717 5A20           E8         A6BE            call	lsubul
19718 5A23           83C4                   04  add	sp,*4
19719                                           ! Debug: list unsigned long = bx+0 (used reg = )
19720 5A26           53                         push	bx
19721 5A27           50                         push	ax
19722                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19723 5A28           FF76         04            push	4[bp]
19724                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19725 5A2B           FF76         24            push	$24[bp]
19726                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19727 5A2E           E8         FB91            call	_set_e820_range
19728 5A31           83C4                   12  add	sp,*$12
19729                                           !BCC_EOS
19730                                           ! 3143                         regs.u.r32.ebx = 5;
19731                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
19732 5A34           B8                   0005  mov	ax,*5
19733 5A37           31DB                       xor	bx,bx
19734 5A39           8946         14            mov	$14[bp],ax
19735 5A3C           895E         16            mov	$16[bp],bx
19736                                           !BCC_EOS
19737                                           ! 3144                         break;
19738 5A3F           E9         00B3            br 	.41F
19739                                           !BCC_EOS
19740                                           ! 3145                     case 5:
19741                                           ! 3146                         set_e820_range(ES, regs.u.r16.di,
19742                       00005A42            .427:
19743                                           ! 3147                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
19744                                           ! Debug: list int = const 2 (used reg = )
19745 5A42           B8                   0002  mov	ax,*2
19746 5A45           50                         push	ax
19747                                           ! Debug: list int = const 0 (used reg = )
19748 5A46           31C0                       xor	ax,ax
19749 5A48           50                         push	ax
19750                                           ! Debug: list int = const 0 (used reg = )
19751 5A49           31C0                       xor	ax,ax
19752 5A4B           50                         push	ax
19753                                           ! Debug: list long = const 0 (used reg = )
19754 5A4C           31C0                       xor	ax,ax
19755 5A4E           31DB                       xor	bx,bx
19756 5A50           53                         push	bx
19757 5A51           50                         push	ax
19758                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
19759 5A52           31C0                       xor	ax,ax
19760 5A54           BB                   FFFC  mov	bx,#$FFFC
19761 5A57           53                         push	bx
19762 5A58           50                         push	ax
19763                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19764 5A59           FF76         04            push	4[bp]
19765                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19766 5A5C           FF76         24            push	$24[bp]
19767                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19768 5A5F           E8         FB60            call	_set_e820_range
19769 5A62           83C4                   12  add	sp,*$12
19770                                           !BCC_EOS
19771                                           ! 3148                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
19772                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
19773 5A65           8A46         F3            mov	al,-$D[bp]
19774 5A68           30E4                       xor	ah,ah
19775 5A6A           31DB                       xor	bx,bx
19776 5A6C           E8         A6A5            call	ltstl
19777 5A6F           75           0B            jne 	.429
19778                       00005A71            .42A:
19779 5A71           8B46         F8            mov	ax,-8[bp]
19780 5A74           8B5E         FA            mov	bx,-6[bp]
19781 5A77           E8         A69A            call	ltstl
19782 5A7A           74           0D            je  	.428
19783                       00005A7C            .429:
19784                                           ! 3149                             regs.u.r32.ebx = 6;
19785                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
19786 5A7C           B8                   0006  mov	ax,*6
19787 5A7F           31DB                       xor	bx,bx
19788 5A81           8946         14            mov	$14[bp],ax
19789 5A84           895E         16            mov	$16[bp],bx
19790                                           !BCC_EOS
19791                                           ! 3150                         else
19792                                           ! 3151                             regs.u.r32.ebx = 0;
19793 5A87           EB           0A            jmp .42B
19794                       00005A89            .428:
19795                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
19796 5A89           31C0                       xor	ax,ax
19797 5A8B           31DB                       xor	bx,bx
19798 5A8D           8946         14            mov	$14[bp],ax
19799 5A90           895E         16            mov	$16[bp],bx
19800                                           !BCC_EOS
19801                                           ! 3152                         break;
19802                       00005A93            .42B:
19803 5A93           EB           60            jmp .41F
19804                                           !BCC_EOS
19805                                           ! 3153                     case 6:
19806                                           ! 3154                         set_e820_range(ES, regs.u.r16.di, 0x00000000L,
19807                       00005A95            .42C:
19808                                           ! 3155                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
19809                                           ! 3156                                        + 1, 1);
19810                                           ! Debug: list int = const 1 (used reg = )
19811 5A95           B8                   0001  mov	ax,*1
19812 5A98           50                         push	ax
19813                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
19814 5A99           8A46         F3            mov	al,-$D[bp]
19815 5A9C           30E4                       xor	ah,ah
19816                                           ! Debug: list unsigned int = ax+1 (used reg = )
19817 5A9E           40                         inc	ax
19818 5A9F           50                         push	ax
19819                                           ! Debug: list int = const 1 (used reg = )
19820 5AA0           B8                   0001  mov	ax,*1
19821 5AA3           50                         push	ax
19822                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
19823 5AA4           FF76         FA            push	-6[bp]
19824 5AA7           FF76         F8            push	-8[bp]
19825                                           ! Debug: list long = const 0 (used reg = )
19826 5AAA           31C0                       xor	ax,ax
19827 5AAC           31DB                       xor	bx,bx
19828 5AAE           53                         push	bx
19829 5AAF           50                         push	ax
19830                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19831 5AB0           FF76         04            push	4[bp]
19832                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19833 5AB3           FF76         24            push	$24[bp]
19834                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19835 5AB6           E8         FB09            call	_set_e820_range
19836 5AB9           83C4                   12  add	sp,*$12
19837                                           !BCC_EOS
19838                                           ! 3157                         regs.u.r32.ebx = 0;
19839                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
19840 5ABC           31C0                       xor	ax,ax
19841 5ABE           31DB                       xor	bx,bx
19842 5AC0           8946         14            mov	$14[bp],ax
19843 5AC3           895E         16            mov	$16[bp],bx
19844                                           !BCC_EOS
19845                                           ! 3158                         break;
19846 5AC6           EB           2D            jmp .41F
19847                                           !BCC_EOS
19848                                           ! 3159                     default:
19849                                           ! 3160                         goto int15_unimplemented;
19850                       00005AC8            .42D:
19851 5AC8           83C4                   00  add	sp,#..FFF4-..FFF5
19852 5ACB           E9         00BA            br 	.FFF4
19853                                           !BCC_EOS
19854                                           ! 3161                         break;
19855 5ACE           EB           25            jmp .41F
19856                                           !BCC_EOS
19857                                           ! 3162                 }
19858                                           ! 3163                 regs.u.r32.eax = 0x534D4150;
19859 5AD0           EB           23            jmp .41F
19860                       00005AD2            .421:
19861 5AD2           2D                   0000  sub	ax,*0
19862 5AD5           7C           F1            jl 	.42D
19863 5AD7           3D                   0006  cmp	ax,*6
19864 5ADA           77           17            ja  	.42E
19865 5ADC           D1E0                       shl	ax,*1
19866 5ADE           89C3                       mov	bx,ax
19867 5AE0           2E                         seg	cs
19868 5AE1           FFA7       5AE5            br	.42F[bx]
19869                       00005AE5            .42F:
19870 5AE5                      5925            .word	.422
19871 5AE7                      5957            .word	.423
19872 5AE9                      598A            .word	.424
19873 5AEB                      59BD            .word	.425
19874 5AED                      5A00            .word	.426
19875 5AEF                      5A42            .word	.427
19876 5AF1                      5A95            .word	.42C
19877                       00005AF3            .42E:
19878 5AF3           EB           D3            jmp	.42D
19879                       00005AF5            .41F:
19880                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
19881 5AF5           B8                   4150  mov	ax,#$4150
19882 5AF8           BB                   534D  mov	bx,#$534D
19883 5AFB           8946         20            mov	$20[bp],ax
19884 5AFE           895E         22            mov	$22[bp],bx
19885                                           !BCC_EOS
19886                                           ! 3164                 regs.u.r32.ecx = 0x14;
19887                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
19888 5B01           B8                   0014  mov	ax,*$14
19889 5B04           31DB                       xor	bx,bx
19890 5B06           8946         1C            mov	$1C[bp],ax
19891 5B09           895E         1E            mov	$1E[bp],bx
19892                                           !BCC_EOS
19893                                           ! 3165                 FLAGS &= 0xfffe;
19894                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
19895 5B0C           8B46         28            mov	ax,$28[bp]
19896 5B0F           24                     FE  and	al,#$FE
19897 5B11           8946         28            mov	$28[bp],ax
19898                                           !BCC_EOS
19899                                           ! 3166             } else {
19900 5B14           EB           05            jmp .430
19901                       00005B16            .419:
19902                                           ! 3167               goto int15_unimplemented;
19903 5B16           83C4                   00  add	sp,#..FFF4-..FFF5
19904 5B19           EB           6D            jmp .FFF4
19905                                           !BCC_EOS
19906                                           ! 3168             }
19907                                           ! 3169             break;
19908                       00005B1B            .430:
19909 5B1B           EB           69            jmp .415
19910                                           !BCC_EOS
19911                                           ! 3170         case 0x01:
19912                                           ! 3171           FLAGS &= 0xfffe;
19913                       00005B1D            .431:
19914                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
19915 5B1D           8B46         28            mov	ax,$28[bp]
19916 5B20           24                     FE  and	al,#$FE
19917 5B22           8946         28            mov	$28[bp],ax
19918                                           !BCC_EOS
19919                                           ! 3172           regs.u.r8.cl = inb_cm
19920                                           ! 3172 os(0x30);
19921                                           ! Debug: list int = const $30 (used reg = )
19922 5B25           B8                   0030  mov	ax,*$30
19923 5B28           50                         push	ax
19924                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19925 5B29           E8         AA5B            call	_inb_cmos
19926 5B2C           44                         inc	sp
19927 5B2D           44                         inc	sp
19928                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
19929 5B2E           8846         1C            mov	$1C[bp],al
19930                                           !BCC_EOS
19931                                           ! 3173           regs.u.r8.ch = inb_cmos(0x31);
19932                                           ! Debug: list int = const $31 (used reg = )
19933 5B31           B8                   0031  mov	ax,*$31
19934 5B34           50                         push	ax
19935                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19936 5B35           E8         AA4F            call	_inb_cmos
19937 5B38           44                         inc	sp
19938 5B39           44                         inc	sp
19939                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
19940 5B3A           8846         1D            mov	$1D[bp],al
19941                                           !BCC_EOS
19942                                           ! 3174           if(regs.u.r16.cx > 0x3c00)
19943                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
19944 5B3D           8B46         1C            mov	ax,$1C[bp]
19945 5B40           3D                   3C00  cmp	ax,#$3C00
19946 5B43         0F86         0006            blos	.432
19947                       00005B47            .433:
19948                                           ! 3175           {
19949                                           ! 3176             regs.u.r16.cx = 0x3c00;
19950                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
19951 5B47           B8                   3C00  mov	ax,#$3C00
19952 5B4A           8946         1C            mov	$1C[bp],ax
19953                                           !BCC_EOS
19954                                           ! 3177           }
19955                                           ! 3178           regs.u.r8.dl = inb_cmos(0x34);
19956                       00005B4D            .432:
19957                                           ! Debug: list int = const $34 (used reg = )
19958 5B4D           B8                   0034  mov	ax,*$34
19959 5B50           50                         push	ax
19960                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19961 5B51           E8         AA33            call	_inb_cmos
19962 5B54           44                         inc	sp
19963 5B55           44                         inc	sp
19964                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
19965 5B56           8846         18            mov	$18[bp],al
19966                                           !BCC_EOS
19967                                           ! 3179           regs.u.r8.dh = inb_cmos(0x35);
19968                                           ! Debug: list int = const $35 (used reg = )
19969 5B59           B8                   0035  mov	ax,*$35
19970 5B5C           50                         push	ax
19971                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19972 5B5D           E8         AA27            call	_inb_cmos
19973 5B60           44                         inc	sp
19974 5B61           44                         inc	sp
19975                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
19976 5B62           8846         19            mov	$19[bp],al
19977                                           !BCC_EOS
19978                                           ! 3180           regs.u.r16.ax = regs.u.r16.cx;
19979                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
19980 5B65           8B46         1C            mov	ax,$1C[bp]
19981 5B68           8946         20            mov	$20[bp],ax
19982                                           !BCC_EOS
19983                                           ! 3181           regs.u.r16.bx = regs.u.r16.dx;
19984                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
19985 5B6B           8B46         18            mov	ax,$18[bp]
19986 5B6E           8946         14            mov	$14[bp],ax
19987                                           !BCC_EOS
19988                                           ! 3182           break;
19989 5B71           EB           13            jmp .415
19990                                           !BCC_EOS
19991                                           ! 3183         default:
19992                                           ! 3184           goto int15_unimplemented;
19993                       00005B73            .434:
19994 5B73           83C4                   00  add	sp,#..FFF4-..FFF5
19995 5B76           EB           10            jmp .FFF4
19996                                           !BCC_EOS
19997                                           ! 3185        }
19998                                           ! 3186        break;
19999 5B78           EB           0C            jmp .415
20000                       00005B7A            .417:
20001 5B7A           2C                     01  sub	al,*1
20002 5B7C           74           9F            je 	.431
20003 5B7E           2C                     1F  sub	al,*$1F
20004 5B80         0F84         FBA6            beq 	.418
20005 5B84           EB           ED            jmp	.434
20006                       00005B86            .415:
20007 5B86           EB           33            jmp .410
20008                                           !BCC_EOS
20009                                           ! 3187     int15_unimplemented:
20010                       00005B88            .FFF4:
20011                                           ! 3188     default:
20012                                           ! 3189       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
20013                       00005B88            .435:
20014                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
20015 5B88           FF76         14            push	$14[bp]
20016                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
20017 5B8B           FF76         20            push	$20[bp]
20018                                           ! Debug: list * char = .436+0 (used reg = )
20019 5B8E           BB                   D3B8  mov	bx,#.436
20020 5B91           53                         push	bx
20021                                           ! Debug: list int = const 4 (used reg = )
20022 5B92           B8                   0004  mov	ax,*4
20023 5B95           50                         push	ax
20024                                           ! Debug: func () void = bios_printf+0 (used reg = )
20025 5B96           E8         AE0E            call	_bios_printf
20026 5B99           83C4                   08  add	sp,*8
20027                                           !BCC_EOS
20028                                           ! 3190       FLAGS |= 0x0001;
20029                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
20030 5B9C           8B46         28            mov	ax,$28[bp]
20031 5B9F           0C                     01  or	al,*1
20032 5BA1           8946         28            mov	$28[bp],ax
20033                                           !BCC_EOS
20034                                           ! 3191       regs.u.r8.ah = 0x86;
20035                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
20036 5BA4           B0                     86  mov	al,#$86
20037 5BA6           8846         21            mov	$21[bp],al
20038                                           !BCC_EOS
20039                                           ! 3192       break;
20040 5BA9           EB           10            jmp .410
20041                                           !BCC_EOS
20042                                           ! 3193     }
20043                                           ! 3194 }
20044 5BAB           EB           0E            jmp .410
20045                       00005BAD            .412:
20046 5BAD           2C                     86  sub	al,#$86
20047 5BAF         0F84         FB2B            beq 	.413
20048 5BB3           2C                     62  sub	al,*$62
20049 5BB5         0F84         FB6B            beq 	.414
20050 5BB9           EB           CD            jmp	.435
20051                       00005BBB            .410:
20052                       FFFFFFF0            ..FFF5	=	-$10
20053                       FFFFFFF0            ..FFF4	=	-$10
20054 5BBB           89EC                       mov	sp,bp
20055 5BBD           5D                         pop	bp
20056 5BBE           C3                         ret
20057                                           ! 3195   void
20058                                           ! Register BX used in function int15_function32
20059                                           ! 3196 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
20060                                           ! 3197   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
20061                                           export	_int16_function
20062                       00005BBF            _int16_function:
20063                                           !BCC_EOS
20064                                           ! 3198 {
20065                                           ! 3199   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
20066                                           !BCC_EOS
20067                                           ! 3200   Bit16u kbd_code, max;
20068                                           !BCC_EOS
20069                                           ! 3201   ;
20070 5BBF           55                         push	bp
20071 5BC0           89E5                       mov	bp,sp
20072 5BC2           83C4                   F6  add	sp,*-$A
20073                                           !BCC_EOS
20074                                           ! 3202   shift_flags = read_byte(0x0040, 0x17);
20075                                           ! Debug: list int = const $17 (used reg = )
20076 5BC5           B8                   0017  mov	ax,*$17
20077 5BC8           50                         push	ax
20078                                           ! Debug: list int = const $40 (used reg = )
20079 5BC9           B8                   0040  mov	ax,*$40
20080 5BCC           50                         push	ax
20081                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20082 5BCD           E8         AA28            call	_read_byte
20083 5BD0           83C4                   04  add	sp,*4
20084                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20085 5BD3           8846         FD            mov	-3[bp],al
20086                                           !BCC_EOS
20087                                           ! 3203   led_flags = read_byte(0x0040, 0x97);
20088                                           ! Debug: list int = const $97 (used reg = )
20089 5BD6           B8                   0097  mov	ax,#$97
20090 5BD9           50                         push	ax
20091                                           ! Debug: list int = const $40 (used reg = )
20092 5BDA           B8                   0040  mov	ax,*$40
20093 5BDD           50                         push	ax
20094                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20095 5BDE           E8         AA17            call	_read_byte
20096 5BE1           83C4                   04  add	sp,*4
20097                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
20098 5BE4           8846         FC            mov	-4[bp],al
20099                                           !BCC_EOS
20100                                           ! 3204   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
20101                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
20102 5BE7           8A46         FC            mov	al,-4[bp]
20103 5BEA           24                     07  and	al,*7
20104 5BEC           50                         push	ax
20105                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
20106 5BED           8A46         FD            mov	al,-3[bp]
20107 5BF0           30E4                       xor	ah,ah
20108 5BF2           B1                     04  mov	cl,*4
20109 5BF4           D3E8                       shr	ax,cl
20110                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
20111 5BF6           24                     07  and	al,*7
20112                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20113 5BF8           3246         F4            xor	al,-$C[bp]
20114 5BFB           44                         inc	sp
20115 5BFC           44                         inc	sp
20116                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
20117 5BFD           84C0                       test	al,al
20118 5BFF         0F84         00A3            beq 	.437
20119                       00005C03            .438:
20120                                           ! 3205 #asm
20121                                           !BCC_EOS
20122                                           !BCC_ASM
20123                       00000012            _int16_function.BP	set	$12
20124                       00000008            .int16_function.BP	set	8
20125                       00000005            _int16_function.count	set	5
20126                       FFFFFFFB            .int16_function.count	set	-5
20127                       0000001A            _int16_function.CX	set	$1A
20128                       00000010            .int16_function.CX	set	$10
20129                       00000008            _int16_function.ascii_code	set	8
20130                       FFFFFFFE            .int16_function.ascii_code	set	-2
20131                       0000000E            _int16_function.DI	set	$E
20132                       00000004            .int16_function.DI	set	4
20133                       0000001E            _int16_function.FLAGS	set	$1E
20134                       00000014            .int16_function.FLAGS	set	$14
20135                       00000002            _int16_function.kbd_code	set	2
20136                       FFFFFFF8            .int16_function.kbd_code	set	-8
20137                       00000009            _int16_function.scan_code	set	9
20138                       FFFFFFFF            .int16_function.scan_code	set	-1
20139                       00000018            _int16_function.DX	set	$18
20140                       0000000E            .int16_function.DX	set	$E
20141                       00000006            _int16_function.led_flags	set	6
20142                       FFFFFFFC            .int16_function.led_flags	set	-4
20143                       00000010            _int16_function.SI	set	$10
20144                       00000006            .int16_function.SI	set	6
20145                       0000001C            _int16_function.AX	set	$1C
20146                       00000012            .int16_function.AX	set	$12
20147                       00000014            _int16_function.SP	set	$14
20148                       0000000A            .int16_function.SP	set	$A
20149                       00000016            _int16_function.BX	set	$16
20150                       0000000C            .int16_function.BX	set	$C
20151                       00000007            _int16_function.shift_flags	set	7
20152                       FFFFFFFD            .int16_function.shift_flags	set	-3
20153                       00000000            _int16_function.max	set	0
20154                       FFFFFFF6            .int16_function.max	set	-$A
20155 5C03           FA                             cli
20156                                           ! 3207 endasm
20157                                           !BCC_ENDASM
20158                                           !BCC_EOS
20159                                           ! 3208     outb(0x60, 0xed);
20160                                           ! Debug: list int = const $ED (used reg = )
20161 5C04           B8                   00ED  mov	ax,#$ED
20162 5C07           50                         push	ax
20163                                           ! Debug: list int = const $60 (used reg = )
20164 5C08           B8                   0060  mov	ax,*$60
20165 5C0B           50                         push	ax
20166                                           ! Debug: func () void = outb+0 (used reg = )
20167 5C0C           E8         A949            call	_outb
20168 5C0F           83C4                   04  add	sp,*4
20169                                           !BCC_EOS
20170                                           ! 3209     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
20171 5C12           EB           0E            jmp .43A
20172                       00005C14            .43B:
20173                                           ! Debug: list int = const $21 (used reg = )
20174 5C14           B8                   0021  mov	ax,*$21
20175 5C17           50                         push	ax
20176                                           ! Debug: list int = const $80 (used reg = )
20177 5C18           B8                   0080  mov	ax,#$80
20178 5C1B           50                         push	ax
20179                                           ! Debug: func () void = outb+0 (used reg = )
20180 5C1C           E8         A939            call	_outb
20181 5C1F           83C4                   04  add	sp,*4
20182                                           !BCC_EOS
20183                                           ! 3210     if ((inb(0x60) == 0xfa)) {
20184                       00005C22            .43A:
20185                                           ! Debug: list int = const $64 (used reg = )
20186 5C22           B8                   0064  mov	ax,*$64
20187 5C25           50                         push	ax
20188                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20189 5C26           E8         A919            call	_inb
20190 5C29           44                         inc	sp
20191 5C2A           44                         inc	sp
20192                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20193 5C2B           24                     01  and	al,*1
20194                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20195 5C2D           84C0                       test	al,al
20196 5C2F           74           E3            je 	.43B
20197                       00005C31            .43C:
20198                       00005C31            .439:
20199                                           ! Debug: list int = const $60 (used reg = )
20200 5C31           B8                   0060  mov	ax,*$60
20201 5C34           50                         push	ax
20202                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20203 5C35           E8         A90A            call	_inb
20204 5C38           44                         inc	sp
20205 5C39           44                         inc	sp
20206                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20207 5C3A           3C                     FA  cmp	al,#$FA
20208 5C3C           75           67            jne 	.43D
20209                       00005C3E            .43E:
20210                                           ! 3211       led_flags &= 0xf8;
20211                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
20212 5C3E           8A46         FC            mov	al,-4[bp]
20213 5C41           24                     F8  and	al,#$F8
20214 5C43           8846         FC            mov	-4[bp],al
20215                                           !BCC_EOS
20216                                           ! 3212       led_flags |= ((shift_flags >> 4) & 0x07);
20217                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
20218 5C46           8A46         FD            mov	al,-3[bp]
20219 5C49           30E4                       xor	ah,ah
20220 5C4B           B1                     04  mov	cl,*4
20221 5C4D           D3E8                       shr	ax,cl
20222                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
20223 5C4F           24                     07  and	al,*7
20224                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
20225 5C51           0A46         FC            or	al,-4[bp]
20226 5C54           8846         FC            mov	-4[bp],al
20227                                           !BCC_EOS
20228                                           ! 3213       outb(0x60, led_flags & 0x07);
20229                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
20230 5C57           8A46         FC            mov	al,-4[bp]
20231 5C5A           24                     07  and	al,*7
20232                                           ! Debug: list unsigned char = al+0 (used reg = )
20233 5C5C           30E4                       xor	ah,ah
20234 5C5E           50                         push	ax
20235                                           ! Debug: list int = const $60 (used reg = )
20236 5C5F           B8                   0060  mov	ax,*$60
20237 5C62           50                         push	ax
20238                                           ! Debug: func () void = outb+0 (used reg = )
20239 5C63           E8         A8F2            call	_outb
20240 5C66           83C4                   04  add	sp,*4
20241                                           !BCC_EOS
20242                                           ! 3214       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
20243 5C69           EB           0E            jmp .440
20244                       00005C6B            .441:
20245                                           ! Debug: list int = const $21 (used reg = )
20246 5C6B           B8                   0021  mov	ax,*$21
20247 5C6E           50                         push	ax
20248                                           ! Debug: list int = const $80 (used reg = )
20249 5C6F           B8                   0080  mov	ax,#$80
20250 5C72           50                         push	ax
20251                                           ! Debug: func () void = outb+0 (used reg = )
20252 5C73           E8         A8E2            call	_outb
20253 5C76           83C4                   04  add	sp,*4
20254                                           !BCC_EOS
20255                                           ! 3215       inb(0x60);
20256                       00005C79            .440:
20257                                           ! Debug: list int = const $64 (used reg = )
20258 5C79           B8                   0064  mov	ax,*$64
20259 5C7C           50                         push	ax
20260                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20261 5C7D           E8         A8C2            call	_inb
20262 5C80           44                         inc	sp
20263 5C81           44                         inc	sp
20264                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20265 5C82           24                     01  and	al,*1
20266                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20267 5C84           84C0                       test	al,al
20268 5C86           74           E3            je 	.441
20269                       00005C88            .442:
20270                       00005C88            .43F:
20271                                           ! Debug: list int = const $60 (used reg = )
20272 5C88           B8                   0060  mov	ax,*$60
20273 5C8B           50                         push	ax
20274                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20275 5C8C           E8         A8B3            call	_inb
20276 5C8F           44                         inc	sp
20277 5C90           44                         inc	sp
20278                                           !BCC_EOS
20279                                           ! 3216       write_byte(0x0040, 0x97, led_flags);
20280                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
20281 5C91           8A46         FC            mov	al,-4[bp]
20282 5C94           30E4                       xor	ah,ah
20283 5C96           50                         push	ax
20284                                           ! Debug: list int = const $97 (used reg = )
20285 5C97           B8                   0097  mov	ax,#$97
20286 5C9A           50                         push	ax
20287                                           ! Debug: list int = const $40 (used reg = )
20288 5C9B           B8                   0040  mov	ax,*$40
20289 5C9E           50                         push	ax
20290                                           ! Debug: func () void = write_byte+0 (used reg = )
20291 5C9F           E8         A97C            call	_write_byte
20292 5CA2           83C4                   06  add	sp,*6
20293                                           !BCC_EOS
20294                                           ! 3217     }
20295                                           ! 3218 #asm
20296                       00005CA5            .43D:
20297                                           !BCC_EOS
20298                                           !BCC_ASM
20299                       00000012            _int16_function.BP	set	$12
20300                       00000008            .int16_function.BP	set	8
20301                       00000005            _int16_function.count	set	5
20302                       FFFFFFFB            .int16_function.count	set	-5
20303                       0000001A            _int16_function.CX	set	$1A
20304                       00000010            .int16_function.CX	set	$10
20305                       00000008            _int16_function.ascii_code	set	8
20306                       FFFFFFFE            .int16_function.ascii_code	set	-2
20307                       0000000E            _int16_function.DI	set	$E
20308                       00000004            .int16_function.DI	set	4
20309                       0000001E            _int16_function.FLAGS	set	$1E
20310                       00000014            .int16_function.FLAGS	set	$14
20311                       00000002            _int16_function.kbd_code	set	2
20312                       FFFFFFF8            .int16_function.kbd_code	set	-8
20313                       00000009            _int16_function.scan_code	set	9
20314                       FFFFFFFF            .int16_function.scan_code	set	-1
20315                       00000018            _int16_function.DX	set	$18
20316                       0000000E            .int16_function.DX	set	$E
20317                       00000006            _int16_function.led_flags	set	6
20318                       FFFFFFFC            .int16_function.led_flags	set	-4
20319                       00000010            _int16_function.SI	set	$10
20320                       00000006            .int16_function.SI	set	6
20321                       0000001C            _int16_function.AX	set	$1C
20322                       00000012            .int16_function.AX	set	$12
20323                       00000014            _int16_function.SP	set	$14
20324                       0000000A            .int16_function.SP	set	$A
20325                       00000016            _int16_function.BX	set	$16
20326                       0000000C            .int16_function.BX	set	$C
20327                       00000007            _int16_function.shift_flags	set	7
20328                       FFFFFFFD            .int16_function.shift_flags	set	-3
20329                       00000000            _int16_function.max	set	0
20330                       FFFFFFF6            .int16_function.max	set	-$A
20331 5CA5           FB                             sti
20332                                           ! 3220 endasm
20333                                           !BCC_ENDASM
20334                                           !BCC_EOS
20335                                           ! 3221   }
20336                                           ! 3222   switch (( AX >> 8 )) {
20337                       00005CA6            .437:
20338                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
20339 5CA6           8B46         12            mov	ax,$12[bp]
20340 5CA9           88E0                       mov	al,ah
20341 5CAB           30E4                       xor	ah,ah
20342 5CAD           E9         0303            br 	.445
20343                                           ! 3223     case 0x00:
20344                                           ! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20345                       00005CB0            .446:
20346                                           ! Debug: list int = const 1 (used reg = )
20347 5CB0           B8                   0001  mov	ax,*1
20348 5CB3           50                         push	ax
20349                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20350 5CB4           8D5E         FE            lea	bx,-2[bp]
20351 5CB7           53                         push	bx
20352                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20353 5CB8           8D5E         FF            lea	bx,-1[bp]
20354 5CBB           53                         push	bx
20355                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20356 5CBC           E8         0342            call	_dequeue_key
20357 5CBF           83C4                   06  add	sp,*6
20358 5CC2           85C0                       test	ax,ax
20359 5CC4           75           0E            jne 	.447
20360                       00005CC6            .448:
20361                                           ! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20362                                           ! Debug: list * char = .449+0 (used reg = )
20363 5CC6           BB                   D394  mov	bx,#.449
20364 5CC9           53                         push	bx
20365                                           ! Debug: list int = const 7 (used reg = )
20366 5CCA           B8                   0007  mov	ax,*7
20367 5CCD           50                         push	ax
20368                                           ! Debug: func () void = bios_printf+0 (used reg = )
20369 5CCE           E8         ACD6            call	_bios_printf
20370 5CD1           83C4                   04  add	sp,*4
20371                                           !BCC_EOS
20372                                           ! 3226       }
20373                                           ! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20374                       00005CD4            .447:
20375                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20376 5CD4           8A46         FF            mov	al,-1[bp]
20377 5CD7           84C0                       test	al,al
20378 5CD9           74           0E            je  	.44A
20379                       00005CDB            .44C:
20380                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20381 5CDB           8A46         FE            mov	al,-2[bp]
20382 5CDE           3C                     F0  cmp	al,#$F0
20383 5CE0           75           07            jne 	.44A
20384                       00005CE2            .44B:
20385                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20386 5CE2           30C0                       xor	al,al
20387 5CE4           8846         FE            mov	-2[bp],al
20388                                           !BCC_EOS
20389                                           ! 3228       else if (ascii_code == 0xE0) ascii_code = 0;
20390 5CE7           EB           0C            jmp .44D
20391                       00005CE9            .44A:
20392                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20393 5CE9           8A46         FE            mov	al,-2[bp]
20394 5CEC           3C                     E0  cmp	al,#$E0
20395 5CEE           75           05            jne 	.44E
20396                       00005CF0            .44F:
20397                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20398 5CF0           30C0                       xor	al,al
20399 5CF2           8846         FE            mov	-2[bp],al
20400                                           !BCC_EOS
20401                                           ! 3229       AX = (scan_code << 8) | ascii_code;
20402                       00005CF5            .44E:
20403                       00005CF5            .44D:
20404                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20405 5CF5           8A46         FF            mov	al,-1[bp]
20406 5CF8           30E4                       xor	ah,ah
20407 5CFA           88C4                       mov	ah,al
20408 5CFC           30C0                       xor	al,al
20409                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20410 5CFE           0A46         FE            or	al,-2[bp]
20411                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20412 5D01           8946         12            mov	$12[bp],ax
20413                                           !BCC_EOS
20414                                           ! 3230       break;
20415 5D04           E9         02F6            br 	.443
20416                                           !BCC_EOS
20417                                           ! 3231     case 0x01:
20418                                           ! 3232       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20419                       00005D07            .450:
20420                                           ! Debug: list int = const 0 (used reg = )
20421 5D07           31C0                       xor	ax,ax
20422 5D09           50                         push	ax
20423                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20424 5D0A           8D5E         FE            lea	bx,-2[bp]
20425 5D0D           53                         push	bx
20426                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20427 5D0E           8D5E         FF            lea	bx,-1[bp]
20428 5D11           53                         push	bx
20429                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20430 5D12           E8         02EC            call	_dequeue_key
20431 5D15           83C4                   06  add	sp,*6
20432 5D18           85C0                       test	ax,ax
20433 5D1A           75           0C            jne 	.451
20434                       00005D1C            .452:
20435                                           ! 3233         FLAGS |= 0x0040;
20436                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20437 5D1C           8B46         14            mov	ax,$14[bp]
20438 5D1F           0C                     40  or	al,*$40
20439 5D21           8946         14            mov	$14[bp],ax
20440                                           !BCC_EOS
20441                                           ! 3234         return;
20442 5D24           89EC                       mov	sp,bp
20443 5D26           5D                         pop	bp
20444 5D27           C3                         ret
20445                                           !BCC_EOS
20446                                           ! 3235       }
20447                                           ! 3236       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20448                       00005D28            .451:
20449                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20450 5D28           8A46         FF            mov	al,-1[bp]
20451 5D2B           84C0                       test	al,al
20452 5D2D           74           0E            je  	.453
20453                       00005D2F            .455:
20454                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20455 5D2F           8A46         FE            mov	al,-2[bp]
20456 5D32           3C                     F0  cmp	al,#$F0
20457 5D34           75           07            jne 	.453
20458                       00005D36            .454:
20459                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20460 5D36           30C0                       xor	al,al
20461 5D38           8846         FE            mov	-2[bp],al
20462                                           !BCC_EOS
20463                                           ! 3237       else if (ascii_code == 0xE0) ascii_code = 0;
20464 5D3B           EB           0C            jmp .456
20465                       00005D3D            .453:
20466                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20467 5D3D           8A46         FE            mov	al,-2[bp]
20468 5D40           3C                     E0  cmp	al,#$E0
20469 5D42           75           05            jne 	.457
20470                       00005D44            .458:
20471                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20472 5D44           30C0                       xor	al,al
20473 5D46           8846         FE            mov	-2[bp],al
20474                                           !BCC_EOS
20475                                           ! 3238       AX = (scan_code << 8) | ascii_code;
20476                       00005D49            .457:
20477                       00005D49            .456:
20478                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20479 5D49           8A46         FF            mov	al,-1[bp]
20480 5D4C           30E4                       xor	ah,ah
20481 5D4E           88C4                       mov	ah,al
20482 5D50           30C0                       xor	al,al
20483                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20484 5D52           0A46         FE            or	al,-2[bp]
20485                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20486 5D55           8946         12            mov	$12[bp],ax
20487                                           !BCC_EOS
20488                                           ! 3239       FLAGS &= 0xffbf;
20489                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20490 5D58           8B46         14            mov	ax,$14[bp]
20491 5D5B           24                     BF  and	al,#$BF
20492 5D5D           8946         14            mov	$14[bp],ax
20493                                           !BCC_EOS
20494                                           ! 3240       break;
20495 5D60           E9         029A            br 	.443
20496                                           !BCC_EOS
20497                                           ! 3241     case 
20498                                           ! 3241 0x02:
20499                                           ! 3242       shift_flags = read_byte(0x0040, 0x17);
20500                       00005D63            .459:
20501                                           ! Debug: list int = const $17 (used reg = )
20502 5D63           B8                   0017  mov	ax,*$17
20503 5D66           50                         push	ax
20504                                           ! Debug: list int = const $40 (used reg = )
20505 5D67           B8                   0040  mov	ax,*$40
20506 5D6A           50                         push	ax
20507                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20508 5D6B           E8         A88A            call	_read_byte
20509 5D6E           83C4                   04  add	sp,*4
20510                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20511 5D71           8846         FD            mov	-3[bp],al
20512                                           !BCC_EOS
20513                                           ! 3243       AX = ((AX & 0xff00) | (shift_flags));
20514                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20515 5D74           8B46         12            mov	ax,$12[bp]
20516 5D77           30C0                       xor	al,al
20517                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20518 5D79           0A46         FD            or	al,-3[bp]
20519                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20520 5D7C           8946         12            mov	$12[bp],ax
20521                                           !BCC_EOS
20522                                           ! 3244       break;
20523 5D7F           E9         027B            br 	.443
20524                                           !BCC_EOS
20525                                           ! 3245     case 0x05:
20526                                           ! 3246       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
20527                       00005D82            .45A:
20528                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
20529 5D82           8A46         10            mov	al,$10[bp]
20530                                           ! Debug: list unsigned char = al+0 (used reg = )
20531 5D85           30E4                       xor	ah,ah
20532 5D87           50                         push	ax
20533                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
20534 5D88           8B46         10            mov	ax,$10[bp]
20535 5D8B           88E0                       mov	al,ah
20536 5D8D           30E4                       xor	ah,ah
20537                                           ! Debug: list unsigned int = ax+0 (used reg = )
20538 5D8F           50                         push	ax
20539                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20540 5D90           E8         0C0A            call	_enqueue_key
20541 5D93           83C4                   04  add	sp,*4
20542 5D96           85C0                       test	ax,ax
20543 5D98           75           0C            jne 	.45B
20544                       00005D9A            .45C:
20545                                           ! 3247         AX = ((AX & 0xff00) | (1));
20546                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20547 5D9A           8B46         12            mov	ax,$12[bp]
20548 5D9D           30C0                       xor	al,al
20549                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
20550 5D9F           0C                     01  or	al,*1
20551                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20552 5DA1           8946         12            mov	$12[bp],ax
20553                                           !BCC_EOS
20554                                           ! 3248       }
20555                                           ! 3249       else {
20556 5DA4           EB           0A            jmp .45D
20557                       00005DA6            .45B:
20558                                           ! 3250         AX = ((AX & 0xff00) | (0));
20559                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20560 5DA6           8B46         12            mov	ax,$12[bp]
20561 5DA9           30C0                       xor	al,al
20562                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
20563 5DAB           0C                     00  or	al,*0
20564                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20565 5DAD           8946         12            mov	$12[bp],ax
20566                                           !BCC_EOS
20567                                           ! 3251       }
20568                                           ! 3252       break;
20569                       00005DB0            .45D:
20570 5DB0           E9         024A            br 	.443
20571                                           !BCC_EOS
20572                                           ! 3253     case 0x09:
20573                                           ! 3254       AX = ((AX & 0xff00) | (0x30));
20574                       00005DB3            .45E:
20575                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20576 5DB3           8B46         12            mov	ax,$12[bp]
20577 5DB6           30C0                       xor	al,al
20578                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
20579 5DB8           0C                     30  or	al,*$30
20580                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20581 5DBA           8946         12            mov	$12[bp],ax
20582                                           !BCC_EOS
20583                                           ! 3255       break;
20584 5DBD           E9         023D            br 	.443
20585                                           !BCC_EOS
20586                                           ! 3256     case 0x0A:
20587                                           ! 3257       count = 2;
20588                       00005DC0            .45F:
20589                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
20590 5DC0           B0                     02  mov	al,*2
20591 5DC2           8846         FB            mov	-5[bp],al
20592                                           !BCC_EOS
20593                                           ! 3258       kbd_code = 0x0;
20594                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20595 5DC5           31C0                       xor	ax,ax
20596 5DC7           8946         F8            mov	-8[bp],ax
20597                                           !BCC_EOS
20598                                           ! 3259       outb(0x60, 0xf2);
20599                                           ! Debug: list int = const $F2 (used reg = )
20600 5DCA           B8                   00F2  mov	ax,#$F2
20601 5DCD           50                         push	ax
20602                                           ! Debug: list int = const $60 (used reg = )
20603 5DCE           B8                   0060  mov	ax,*$60
20604 5DD1           50                         push	ax
20605                                           ! Debug: func () void = outb+0 (used reg = )
20606 5DD2           E8         A783            call	_outb
20607 5DD5           83C4                   04  add	sp,*4
20608                                           !BCC_EOS
20609                                           ! 3260       max=0xffff;
20610                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20611 5DD8           B8                   FFFF  mov	ax,#$FFFF
20612 5DDB           8946         F6            mov	-$A[bp],ax
20613                                           !BCC_EOS
20614                                           ! 3261       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20615 5DDE           EB           0D            jmp .461
20616                       00005DE0            .462:
20617                                           ! Debug: list int = const 0 (used reg = )
20618 5DE0           31C0                       xor	ax,ax
20619 5DE2           50                         push	ax
20620                                           ! Debug: list int = const $80 (used reg = )
20621 5DE3           B8                   0080  mov	ax,#$80
20622 5DE6           50                         push	ax
20623                                           ! Debug: func () void = outb+0 (used reg = )
20624 5DE7           E8         A76E            call	_outb
20625 5DEA           83C4                   04  add	sp,*4
20626                                           !BCC_EOS
20627                                           ! 3262       if (max>0x0) {
20628                       00005DED            .461:
20629                                           ! Debug: list int = const $64 (used reg = )
20630 5DED           B8                   0064  mov	ax,*$64
20631 5DF0           50                         push	ax
20632                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20633 5DF1           E8         A74E            call	_inb
20634 5DF4           44                         inc	sp
20635 5DF5           44                         inc	sp
20636                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20637 5DF6           24                     01  and	al,*1
20638                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20639 5DF8           84C0                       test	al,al
20640 5DFA           75           0B            jne 	.463
20641                       00005DFC            .464:
20642                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20643 5DFC           8B46         F6            mov	ax,-$A[bp]
20644 5DFF           48                         dec	ax
20645 5E00           8946         F6            mov	-$A[bp],ax
20646                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20647 5E03           85C0                       test	ax,ax
20648 5E05           75           D9            jne	.462
20649                       00005E07            .463:
20650                       00005E07            .460:
20651                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20652 5E07           8B46         F6            mov	ax,-$A[bp]
20653 5E0A           85C0                       test	ax,ax
20654 5E0C           74           6D            je  	.465
20655                       00005E0E            .466:
20656                                           ! 3263         if ((inb(0x60) == 0xfa)) {
20657                                           ! Debug: list int = const $60 (used reg = )
20658 5E0E           B8                   0060  mov	ax,*$60
20659 5E11           50                         push	ax
20660                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20661 5E12           E8         A72D            call	_inb
20662 5E15           44                         inc	sp
20663 5E16           44                         inc	sp
20664                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20665 5E17           3C                     FA  cmp	al,#$FA
20666 5E19           75           60            jne 	.467
20667                       00005E1B            .468:
20668                                           ! 3264           do {
20669                       00005E1B            .46B:
20670                                           ! 3265             max=0xffff;
20671                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20672 5E1B           B8                   FFFF  mov	ax,#$FFFF
20673 5E1E           8946         F6            mov	-$A[bp],ax
20674                                           !BCC_EOS
20675                                           ! 3266             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20676 5E21           EB           0D            jmp .46D
20677                       00005E23            .46E:
20678                                           ! Debug: list int = const 0 (used reg = )
20679 5E23           31C0                       xor	ax,ax
20680 5E25           50                         push	ax
20681                                           ! Debug: list int = const $80 (used reg = )
20682 5E26           B8                   0080  mov	ax,#$80
20683 5E29           50                         push	ax
20684                                           ! Debug: func () void = outb+0 (used reg = )
20685 5E2A           E8         A72B            call	_outb
20686 5E2D           83C4                   04  add	sp,*4
20687                                           !BCC_EOS
20688                                           ! 3267             if (max>0x0) {
20689                       00005E30            .46D:
20690                                           ! Debug: list int = const $64 (used reg = )
20691 5E30           B8                   0064  mov	ax,*$64
20692 5E33           50                         push	ax
20693                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20694 5E34           E8         A70B            call	_inb
20695 5E37           44                         inc	sp
20696 5E38           44                         inc	sp
20697                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20698 5E39           24                     01  and	al,*1
20699                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20700 5E3B           84C0                       test	al,al
20701 5E3D           75           0B            jne 	.46F
20702                       00005E3F            .470:
20703                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20704 5E3F           8B46         F6            mov	ax,-$A[bp]
20705 5E42           48                         dec	ax
20706 5E43           8946         F6            mov	-$A[bp],ax
20707                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20708 5E46           85C0                       test	ax,ax
20709 5E48           75           D9            jne	.46E
20710                       00005E4A            .46F:
20711                       00005E4A            .46C:
20712                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20713 5E4A           8B46         F6            mov	ax,-$A[bp]
20714 5E4D           85C0                       test	ax,ax
20715 5E4F           74           1F            je  	.471
20716                       00005E51            .472:
20717                                           ! 3268               kbd_code >>= 8;
20718                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20719 5E51           8B46         F8            mov	ax,-8[bp]
20720 5E54           88E0                       mov	al,ah
20721 5E56           30E4                       xor	ah,ah
20722 5E58           8946         F8            mov	-8[bp],ax
20723                                           !BCC_EOS
20724                                           ! 3269               kbd_code |= (inb(0x60) << 8);
20725                                           ! Debug: list int = const $60 (used reg = )
20726 5E5B           B8                   0060  mov	ax,*$60
20727 5E5E           50                         push	ax
20728                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20729 5E5F           E8         A6E0            call	_inb
20730 5E62           44                         inc	sp
20731 5E63           44                         inc	sp
20732                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20733 5E64           30E4                       xor	ah,ah
20734 5E66           88C4                       mov	ah,al
20735 5E68           30C0                       xor	al,al
20736                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20737 5E6A           0B46         F8            or	ax,-8[bp]
20738 5E6D           8946         F8            mov	-8[bp],ax
20739                                           !BCC_EOS
20740                                           ! 3270             }
20741                                           ! 3271           } while (--count>0);
20742                       00005E70            .471:
20743                       00005E70            .46A:
20744                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20745 5E70           8A46         FB            mov	al,-5[bp]
20746 5E73           48                         dec	ax
20747 5E74           8846         FB            mov	-5[bp],al
20748                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20749 5E77           84C0                       test	al,al
20750 5E79           75           A0            jne	.46B
20751                       00005E7B            .473:
20752                                           !BCC_EOS
20753                                           ! 3272         }
20754                       00005E7B            .469:
20755                                           ! 3273       }
20756                       00005E7B            .467:
20757                                           ! 3274       BX=kbd_code;
20758                       00005E7B            .465:
20759                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20760 5E7B           8B46         F8            mov	ax,-8[bp]
20761 5E7E           8946         0C            mov	$C[bp],ax
20762                                           !BCC_EOS
20763                                           ! 3275       break;
20764 5E81           E9         0179            br 	.443
20765                                           !BCC_EOS
20766                                           ! 3276     case 0x10:
20767                                           ! 3277       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20768                       00005E84            .474:
20769                                           ! Debug: list int = const 1 (used reg = )
20770 5E84           B8                   0001  mov	ax,*1
20771 5E87           50                         push	ax
20772                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20773 5E88           8D5E         FE            lea	bx,-2[bp]
20774 5E8B           53                         push	bx
20775                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20776 5E8C           8D5E         FF            lea	bx,-1[bp]
20777 5E8F           53                         push	bx
20778                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20779 5E90           E8         016E            call	_dequeue_key
20780 5E93           83C4                   06  add	sp,*6
20781 5E96           85C0                       test	ax,ax
20782 5E98           75           0E            jne 	.475
20783                       00005E9A            .476:
20784                                           ! 3278         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20785                                           ! Debug: list * char = .477+0 (used reg = )
20786 5E9A           BB                   D370  mov	bx,#.477
20787 5E9D           53                         push	bx
20788                                           ! Debug: list int = const 7 (used reg = )
20789 5E9E           B8                   0007  mov	ax,*7
20790 5EA1           50                         push	ax
20791                                           ! Debug: func () void = bios_printf+0 (used reg = )
20792 5EA2           E8         AB02            call	_bios_printf
20793 5EA5           83C4                   04  add	sp,*4
20794                                           !BCC_EOS
20795                                           ! 3279       }
20796                                           ! 3280       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20797                       00005EA8            .475:
20798                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20799 5EA8           8A46         FF            mov	al,-1[bp]
20800 5EAB           84C0                       test	al,al
20801 5EAD           74           0C            je  	.478
20802                       00005EAF            .47A:
20803                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20804 5EAF           8A46         FE            mov	al,-2[bp]
20805 5EB2           3C                     F0  cmp	al,#$F0
20806 5EB4           75           05            jne 	.478
20807                       00005EB6            .479:
20808                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20809 5EB6           30C0                       xor	al,al
20810 5EB8           8846         FE            mov	-2[bp],al
20811                                           !BCC_EOS
20812                                           ! 3281       AX = (scan_code << 8) | ascii_code;
20813                       00005EBB            .478:
20814                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20815 5EBB           8A46         FF            mov	al,-1[bp]
20816 5EBE           30E4                       xor	ah,ah
20817 5EC0           88C4                       mov	ah,al
20818 5EC2           30C0                       xor	al,al
20819                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20820 5EC4           0A46         FE            or	al,-2[bp]
20821                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20822 5EC7           8946         12            mov	$12[bp],ax
20823                                           !BCC_EOS
20824                                           ! 3282       break;
20825 5ECA           E9         0130            br 	.443
20826                                           !BCC_EOS
20827                                           ! 3283     case 0x11:
20828                                           ! 3284       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20829                       00005ECD            .47B:
20830                                           ! Debug: list int = const 0 (used reg = )
20831 5ECD           31C0                       xor	ax,ax
20832 5ECF           50                         push	ax
20833                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20834 5ED0           8D5E         FE            lea	bx,-2[bp]
20835 5ED3           53                         push	bx
20836                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20837 5ED4           8D5E         FF            lea	bx,-1[bp]
20838 5ED7           53                         push	bx
20839                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20840 5ED8           E8         0126            call	_dequeue_key
20841 5EDB           83C4                   06  add	sp,*6
20842 5EDE           85C0                       test	ax,ax
20843 5EE0           75           0C            jne 	.47C
20844                       00005EE2            .47D:
20845                                           ! 3285         FLAGS |= 0x0040;
20846                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20847 5EE2           8B46         14            mov	ax,$14[bp]
20848 5EE5           0C                     40  or	al,*$40
20849 5EE7           8946         14            mov	$14[bp],ax
20850                                           !BCC_EOS
20851                                           ! 3286         return;
20852 5EEA           89EC                       mov	sp,bp
20853 5EEC           5D                         pop	bp
20854 5EED           C3                         ret
20855                                           !BCC_EOS
20856                                           ! 3287       }
20857                                           ! 3288       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20858                       00005EEE            .47C:
20859                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20860 5EEE           8A46         FF            mov	al,-1[bp]
20861 5EF1           84C0                       test	al,al
20862 5EF3           74           0C            je  	.47E
20863                       00005EF5            .480:
20864                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20865 5EF5           8A46         FE            mov	al,-2[bp]
20866 5EF8           3C                     F0  cmp	al,#$F0
20867 5EFA           75           05            jne 	.47E
20868                       00005EFC            .47F:
20869                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20870 5EFC           30C0                       xor	al,al
20871 5EFE           8846         FE            mov	-2[bp],al
20872                                           !BCC_EOS
20873                                           ! 3289       AX = (scan_code << 8) | ascii_code;
20874                       00005F01            .47E:
20875                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20876 5F01           8A46         FF            mov	al,-1[bp]
20877 5F04           30E4                       xor	ah,ah
20878 5F06           88C4                       mov	ah,al
20879 5F08           30C0                       xor	al,al
20880                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20881 5F0A           0A46         FE            or	al,-2[bp]
20882                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20883 5F0D           8946         12            mov	$12[bp],ax
20884                                           !BCC_EOS
20885                                           ! 3290       FLAGS &= 0xffbf;
20886                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20887 5F10           8B46         14            mov	ax,$14[bp]
20888 5F13           24                     BF  and	al,#$BF
20889 5F15           8946         14            mov	$14[bp],ax
20890                                           !BCC_EOS
20891                                           ! 3291       break;
20892 5F18           E9         00E2            br 	.443
20893                                           !BCC_EOS
20894                                           ! 3292     case 0x12:
20895                                           ! 3293       shift_flags = read_byte(0x0040, 0x17);
20896                       00005F1B            .481:
20897                                           ! Debug: list int = const $17 (used reg = )
20898 5F1B           B8                   0017  mov	ax,*$17
20899 5F1E           50                         push	ax
20900                                           ! Debug: list int = const $40 (used reg = )
20901 5F1F           B8                   0040  mov	ax,*$40
20902 5F22           50                         push	ax
20903                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20904 5F23           E8         A6D2            call	_read_byte
20905 5F26           83C4                   04  add	sp,*4
20906                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20907 5F29           8846         FD            mov	-3[bp],al
20908                                           !BCC_EOS
20909                                           ! 3294       AX = ((AX & 0xff00) | (shift_flags));
20910                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20911 5F2C           8B46         12            mov	ax,$12[bp]
20912 5F2F           30C0                       xor	al,al
20913                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20914 5F31           0A46         FD            or	al,-3[bp]
20915                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20916 5F34           8946         12            mov	$12[bp],ax
20917                                           !BCC_EOS
20918                                           ! 3295       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20919                                           ! Debug: list int = const $18 (used reg = )
20920 5F37           B8                   0018  mov	ax,*$18
20921 5F3A           50                         push	ax
20922                                           ! Debug: list int = const $40 (used reg = )
20923 5F3B           B8                   0040  mov	ax,*$40
20924 5F3E           50                         push	ax
20925                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20926 5F3F           E8         A6B6            call	_read_byte
20927 5F42           83C4                   04  add	sp,*4
20928                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20929 5F45           24                     73  and	al,*$73
20930                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20931 5F47           8846         FD            mov	-3[bp],al
20932                                           !BCC_EOS
20933                                           ! 3296       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20934                                           ! Debug: list int = const $96 (used reg = )
20935 5F4A           B8                   0096  mov	ax,#$96
20936 5F4D           50                         push	ax
20937                                           ! Debug: list int = const $40 (used reg = )
20938 5F4E           B8                   0040  mov	ax,*$40
20939 5F51           50                         push	ax
20940                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20941 5F52           E8         A6A3            call	_read_byte
20942 5F55           83C4                   04  add	sp,*4
20943                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20944 5F58           24                     0C  and	al,*$C
20945                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20946 5F5A           0A46         FD            or	al,-3[bp]
20947 5F5D           8846         FD            mov	-3[bp],al
20948                                           !BCC_EOS
20949                                           ! 3297       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20950                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20951 5F60           8A46         FD            mov	al,-3[bp]
20952 5F63           30E4                       xor	ah,ah
20953 5F65           88C4                       mov	ah,al
20954 5F67           30C0                       xor	al,al
20955 5F69           50                         push	ax
20956                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20957 5F6A           8A46         12            mov	al,$12[bp]
20958                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20959 5F6D           30E4                       xor	ah,ah
20960 5F6F           0B46         F4            or	ax,0+..FFF3[bp]
20961 5F72           44                         inc	sp
20962 5F73           44                         inc	sp
20963                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20964 5F74           8946         12            mov	$12[bp],ax
20965                                           !BCC_EOS
20966                                           ! 3298       ;
20967                                           !BCC_EOS
20968                                           ! 3299       break;
20969 5F77           E9         0083            br 	.443
20970                                           !BCC_EOS
20971                                           ! 3300     case 0x92:
20972                                           ! 3301       AX = ((AX & 0x00ff) | ((0x80) << 8));
20973                       00005F7A            .482:
20974                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20975 5F7A           8A46         12            mov	al,$12[bp]
20976                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20977 5F7D           30E4                       xor	ah,ah
20978 5F7F           0D                   8000  or	ax,#-$8000
20979                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20980 5F82           8946         12            mov	$12[bp],ax
20981                                           !BCC_EOS
20982                                           ! 3302       break;
20983 5F85           EB           76            jmp .443
20984                                           !BCC_EOS
20985                                           ! 3303     case 0xA2:
20986                                           ! 3304       break;
20987                       00005F87            .483:
20988 5F87           EB           74            jmp .443
20989                                           !BCC_EOS
20990                                           ! 3305     case 0x6F:
20991                                           ! 3306       if (( AX & 0x00ff ) == 0x08)
20992                       00005F89            .484:
20993                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20994 5F89           8A46         12            mov	al,$12[bp]
20995                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20996 5F8C           3C                     08  cmp	al,*8
20997 5F8E           75           0B            jne 	.485
20998                       00005F90            .486:
20999                                           ! 3307         AX = ((AX & 0x00ff) | ((0x02) << 8));
21000                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
21001 5F90           8A46         12            mov	al,$12[bp]
21002                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
21003 5F93           30E4                       xor	ah,ah
21004 5F95           0D                   0200  or	ax,#$200
21005                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
21006 5F98           8946         12            mov	$12[bp],ax
21007                                           !BCC_EOS
21008                                           ! 3308     default:
21009                       00005F9B            .485:
21010                                           ! 3309       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
21011                       00005F9B            .487:
21012                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
21013 5F9B           8B46         12            mov	ax,$12[bp]
21014 5F9E           88E0                       mov	al,ah
21015 5FA0           30E4                       xor	ah,ah
21016                                           ! Debug: list unsigned int = ax+0 (used reg = )
21017 5FA2           50                         push	ax
21018                                           ! Debug: list * char = .488+0 (used reg = )
21019 5FA3           BB                   D348  mov	bx,#.488
21020 5FA6           53                         push	bx
21021                                           ! Debug: list int = const 4 (used reg = )
21022 5FA7           B8                   0004  mov	ax,*4
21023 5FAA           50                         push	ax
21024                                           ! Debug: func () void = bios_printf+0 (used reg = )
21025 5FAB           E8         A9F9            call	_bios_printf
21026 5FAE           83C4                   06  add	sp,*6
21027                                           !BCC_EOS
21028                                           ! 3310   }
21029                                           ! 3311 }
21030 5FB1           EB           4A            jmp .443
21031                       00005FB3            .445:
21032 5FB3           2D                   0000  sub	ax,*0
21033 5FB6           7C           E3            jl 	.487
21034 5FB8           3D                   0012  cmp	ax,*$12
21035 5FBB           77           2F            ja  	.489
21036 5FBD           D1E0                       shl	ax,*1
21037 5FBF           89C3                       mov	bx,ax
21038 5FC1           2E                         seg	cs
21039 5FC2           FFA7       5FC6            br	.48A[bx]
21040                       00005FC6            .48A:
21041 5FC6                      5CB0            .word	.446
21042 5FC8                      5D07            .word	.450
21043 5FCA                      5D63            .word	.459
21044 5FCC                      5F9B            .word	.487
21045 5FCE                      5F9B            .word	.487
21046 5FD0                      5D82            .word	.45A
21047 5FD2                      5F9B            .word	.487
21048 5FD4                      5F9B            .word	.487
21049 5FD6                      5F9B            .word	.487
21050 5FD8                      5DB3            .word	.45E
21051 5FDA                      5DC0            .word	.45F
21052 5FDC                      5F9B            .word	.487
21053 5FDE                      5F9B            .word	.487
21054 5FE0                      5F9B            .word	.487
21055 5FE2                      5F9B            .word	.487
21056 5FE4                      5F9B            .word	.487
21057 5FE6                      5E84            .word	.474
21058 5FE8                      5ECD            .word	.47B
21059 5FEA                      5F1B            .word	.481
21060                       00005FEC            .489:
21061 5FEC           2D                   006F  sub	ax,*$6F
21062 5FEF           74           98            je 	.484
21063 5FF1           2D                   0023  sub	ax,*$23
21064 5FF4           74           84            je 	.482
21065 5FF6           2D                   0010  sub	ax,*$10
21066 5FF9           74           8C            je 	.483
21067 5FFB           EB           9E            jmp	.487
21068                       00005FFD            .443:
21069                       FFFFFFF4            ..FFF3	=	-$C
21070 5FFD           89EC                       mov	sp,bp
21071 5FFF           5D                         pop	bp
21072 6000           C3                         ret
21073                                           ! 3312   unsigned int
21074                                           ! Register BX used in function int16_function
21075                                           ! 3313 dequeue_key(scan_code, asci
21076                                           ! 3313 i_code, incr)
21077                                           ! 3314   Bit8u *scan_code;
21078                                           export	_dequeue_key
21079                       00006001            _dequeue_key:
21080                                           !BCC_EOS
21081                                           ! 3315   Bit8u *ascii_code;
21082                                           !BCC_EOS
21083                                           ! 3316   unsigned int incr;
21084                                           !BCC_EOS
21085                                           ! 3317 {
21086                                           ! 3318   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
21087                                           !BCC_EOS
21088                                           ! 3319   Bit16u ss;
21089                                           !BCC_EOS
21090                                           ! 3320   Bit8u acode, scode;
21091                                           !BCC_EOS
21092                                           ! 3321   buffer_start = read_word(0x0040, 0x0080);
21093 6001           55                         push	bp
21094 6002           89E5                       mov	bp,sp
21095 6004           83C4                   F4  add	sp,*-$C
21096                                           ! Debug: list int = const $80 (used reg = )
21097 6007           B8                   0080  mov	ax,#$80
21098 600A           50                         push	ax
21099                                           ! Debug: list int = const $40 (used reg = )
21100 600B           B8                   0040  mov	ax,*$40
21101 600E           50                         push	ax
21102                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21103 600F           E8         A5F9            call	_read_word
21104 6012           83C4                   04  add	sp,*4
21105                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
21106 6015           8946         FE            mov	-2[bp],ax
21107                                           !BCC_EOS
21108                                           ! 3322   buffer_end = read_word(0x0040, 0x0082);
21109                                           ! Debug: list int = const $82 (used reg = )
21110 6018           B8                   0082  mov	ax,#$82
21111 601B           50                         push	ax
21112                                           ! Debug: list int = const $40 (used reg = )
21113 601C           B8                   0040  mov	ax,*$40
21114 601F           50                         push	ax
21115                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21116 6020           E8         A5E8            call	_read_word
21117 6023           83C4                   04  add	sp,*4
21118                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
21119 6026           8946         FC            mov	-4[bp],ax
21120                                           !BCC_EOS
21121                                           ! 3323   buffer_head = read_word(0x0040, 0x001a);
21122                                           ! Debug: list int = const $1A (used reg = )
21123 6029           B8                   001A  mov	ax,*$1A
21124 602C           50                         push	ax
21125                                           ! Debug: list int = const $40 (used reg = )
21126 602D           B8                   0040  mov	ax,*$40
21127 6030           50                         push	ax
21128                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21129 6031           E8         A5D7            call	_read_word
21130 6034           83C4                   04  add	sp,*4
21131                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
21132 6037           8946         FA            mov	-6[bp],ax
21133                                           !BCC_EOS
21134                                           ! 3324   buffer_tail = read_word(0x0040, 0x001c);
21135                                           ! Debug: list int = const $1C (used reg = )
21136 603A           B8                   001C  mov	ax,*$1C
21137 603D           50                         push	ax
21138                                           ! Debug: list int = const $40 (used reg = )
21139 603E           B8                   0040  mov	ax,*$40
21140 6041           50                         push	ax
21141                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21142 6042           E8         A5C6            call	_read_word
21143 6045           83C4                   04  add	sp,*4
21144                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
21145 6048           8946         F8            mov	-8[bp],ax
21146                                           !BCC_EOS
21147                                           ! 3325   if (buffer_head != buffer_tail) {
21148                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
21149 604B           8B46         FA            mov	ax,-6[bp]
21150 604E           3B46         F8            cmp	ax,-8[bp]
21151 6051         0F84         0083            beq 	.48B
21152                       00006055            .48C:
21153                                           ! 3326     ss = get_SS();
21154                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21155 6055           E8         A5F9            call	_get_SS
21156                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
21157 6058           8946         F6            mov	-$A[bp],ax
21158                                           !BCC_EOS
21159                                           ! 3327     acode = read_byte(0x0040, buffer_head);
21160                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
21161 605B           FF76         FA            push	-6[bp]
21162                                           ! Debug: list int = const $40 (used reg = )
21163 605E           B8                   0040  mov	ax,*$40
21164 6061           50                         push	ax
21165                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21166 6062           E8         A593            call	_read_byte
21167 6065           83C4                   04  add	sp,*4
21168                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
21169 6068           8846         F5            mov	-$B[bp],al
21170                                           !BCC_EOS
21171                                           ! 3328     scode = read_byte(0x0040, buffer_head+1);
21172                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
21173 606B           8B46         FA            mov	ax,-6[bp]
21174                                           ! Debug: list unsigned int = ax+1 (used reg = )
21175 606E           40                         inc	ax
21176 606F           50                         push	ax
21177                                           ! Debug: list int = const $40 (used reg = )
21178 6070           B8                   0040  mov	ax,*$40
21179 6073           50                         push	ax
21180                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21181 6074           E8         A581            call	_read_byte
21182 6077           83C4                   04  add	sp,*4
21183                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
21184 607A           8846         F4            mov	-$C[bp],al
21185                                           !BCC_EOS
21186                                           ! 3329     write_byte(ss, ascii_code, acode);
21187                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
21188 607D           8A46         F5            mov	al,-$B[bp]
21189 6080           30E4                       xor	ah,ah
21190 6082           50                         push	ax
21191                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
21192 6083           FF76         06            push	6[bp]
21193                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
21194 6086           FF76         F6            push	-$A[bp]
21195                                           ! Debug: func () void = write_byte+0 (used reg = )
21196 6089           E8         A592            call	_write_byte
21197 608C           83C4                   06  add	sp,*6
21198                                           !BCC_EOS
21199                                           ! 3330     write_byte(ss, scan_code, scode);
21200                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
21201 608F           8A46         F4            mov	al,-$C[bp]
21202 6092           30E4                       xor	ah,ah
21203 6094           50                         push	ax
21204                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
21205 6095           FF76         04            push	4[bp]
21206                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
21207 6098           FF76         F6            push	-$A[bp]
21208                                           ! Debug: func () void = write_byte+0 (used reg = )
21209 609B           E8         A580            call	_write_byte
21210 609E           83C4                   06  add	sp,*6
21211                                           !BCC_EOS
21212                                           ! 3331     if (incr) {
21213 60A1           8B46         08            mov	ax,8[bp]
21214 60A4           85C0                       test	ax,ax
21215 60A6           74           27            je  	.48D
21216                       000060A8            .48E:
21217                                           ! 3332       buffer_head += 2;
21218                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
21219 60A8           8B46         FA            mov	ax,-6[bp]
21220 60AB           40                         inc	ax
21221 60AC           40                         inc	ax
21222 60AD           8946         FA            mov	-6[bp],ax
21223                                           !BCC_EOS
21224                                           ! 3333       if (buffer_head >= buffer_end)
21225                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
21226 60B0           8B46         FA            mov	ax,-6[bp]
21227 60B3           3B46         FC            cmp	ax,-4[bp]
21228 60B6           72           06            jb  	.48F
21229                       000060B8            .490:
21230                                           ! 3334         buffer_head = buffer_start;
21231                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
21232 60B8           8B46         FE            mov	ax,-2[bp]
21233 60BB           8946         FA            mov	-6[bp],ax
21234                                           !BCC_EOS
21235                                           ! 3335       write_word(0x0040, 0x001a, buffer_head);
21236                       000060BE            .48F:
21237                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
21238 60BE           FF76         FA            push	-6[bp]
21239                                           ! Debug: list int = const $1A (used reg = )
21240 60C1           B8                   001A  mov	ax,*$1A
21241 60C4           50                         push	ax
21242                                           ! Debug: list int = const $40 (used reg = )
21243 60C5           B8                   0040  mov	ax,*$40
21244 60C8           50                         push	ax
21245                                           ! Debug: func () void = write_word+0 (used reg = )
21246 60C9           E8         A56A            call	_write_word
21247 60CC           83C4                   06  add	sp,*6
21248                                           !BCC_EOS
21249                                           ! 3336     }
21250                                           ! 3337     return(1);
21251                       000060CF            .48D:
21252 60CF           B8                   0001  mov	ax,*1
21253 60D2           89EC                       mov	sp,bp
21254 60D4           5D                         pop	bp
21255 60D5           C3                         ret
21256                                           !BCC_EOS
21257                                           ! 3338   }
21258                                           ! 3339   else {
21259 60D6           EB           06            jmp .491
21260                       000060D8            .48B:
21261                                           ! 3340     return(0);
21262 60D8           31C0                       xor	ax,ax
21263 60DA           89EC                       mov	sp,bp
21264 60DC           5D                         pop	bp
21265 60DD           C3                         ret
21266                                           !BCC_EOS
21267                                           ! 3341   }
21268                                           ! 3342 }
21269                       000060DE            .491:
21270 60DE           89EC                       mov	sp,bp
21271 60E0           5D                         pop	bp
21272 60E1           C3                         ret
21273                                           ! 3343 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
21274                                           
21275                       000060E2            _panic_msg_keyb_buffer_full:
21276                       000060E2            .492:
21277 60E2                        25            .ascii	"%s: keyboard input buffer full"
21278 6100                        0A            .byte	$A
21279 6101                        00            .byte	0
21280                                           !BCC_EOS
21281                                           ! 3344   Bit8u
21282                                           ! 3345 inhibit_mouse_int_and_events()
21283                                           ! 3346 {
21284                                           
21285                                           export	_inhibit_mouse_int_and_events
21286                       00006102            _inhibit_mouse_int_and_events:
21287                                           ! 3347   Bit8u command_byte, prev_command_byte;
21288                                           !BCC_EOS
21289                                           ! 3348   if ( inb(0x64) & 0x02 )
21290 6102           55                         push	bp
21291 6103           89E5                       mov	bp,sp
21292 6105           4C                         dec	sp
21293 6106           4C                         dec	sp
21294                                           ! Debug: list int = const $64 (used reg = )
21295 6107           B8                   0064  mov	ax,*$64
21296 610A           50                         push	ax
21297                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21298 610B           E8         A434            call	_inb
21299 610E           44                         inc	sp
21300 610F           44                         inc	sp
21301                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21302 6110           24                     02  and	al,*2
21303 6112           84C0                       test	al,al
21304 6114           74           12            je  	.493
21305                       00006116            .494:
21306                                           ! 3349     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21307                                           ! Debug: list * char = .495+0 (used reg = )
21308 6116           BB                   D33D  mov	bx,#.495
21309 6119           53                         push	bx
21310                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21311 611A           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21312 611D           53                         push	bx
21313                                           ! Debug: list int = const 7 (used reg = )
21314 611E           B8                   0007  mov	ax,*7
21315 6121           50                         push	ax
21316                                           ! Debug: func () void = bios_printf+0 (used reg = )
21317 6122           E8         A882            call	_bios_printf
21318 6125           83C4                   06  add	sp,*6
21319                                           !BCC_EOS
21320                                           ! 3350   outb(0x64, 0x20);
21321                       00006128            .493:
21322                                           ! Debug: list int = const $20 (used reg = )
21323 6128           B8                   0020  mov	ax,*$20
21324 612B           50                         push	ax
21325                                           ! Debug: list int = const $64 (used reg = )
21326 612C           B8                   0064  mov	ax,*$64
21327 612F           50                         push	ax
21328                                           ! Debug: func () void = outb+0 (used reg = )
21329 6130           E8         A425            call	_outb
21330 6133           83C4                   04  add	sp,*4
21331                                           !BCC_EOS
21332                                           ! 3351   while ( (inb(0x64) & 0x01) != 0x01 );
21333 6136           EB           00            jmp .497
21334                       00006138            .498:
21335                                           !BCC_EOS
21336                                           ! 3352   prev_command_byte = inb(0x60);
21337                       00006138            .497:
21338                                           ! Debug: list int = const $64 (used reg = )
21339 6138           B8                   0064  mov	ax,*$64
21340 613B           50                         push	ax
21341                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21342 613C           E8         A403            call	_inb
21343 613F           44                         inc	sp
21344 6140           44                         inc	sp
21345                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21346 6141           24                     01  and	al,*1
21347                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21348 6143           3C                     01  cmp	al,*1
21349 6145           75           F1            jne	.498
21350                       00006147            .499:
21351                       00006147            .496:
21352                                           ! Debug: list int = const $60 (used reg = )
21353 6147           B8                   0060  mov	ax,*$60
21354 614A           50                         push	ax
21355                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21356 614B           E8         A3F4            call	_inb
21357 614E           44                         inc	sp
21358 614F           44                         inc	sp
21359                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
21360 6150           8846         FE            mov	-2[bp],al
21361                                           !BCC_EOS
21362                                           ! 3353   command_byte = prev_command_byte;
21363                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
21364 6153           8A46         FE            mov	al,-2[bp]
21365 6156           8846         FF            mov	-1[bp],al
21366                                           !BCC_EOS
21367                                           ! 3354   if ( inb(0x64) & 0x02 )
21368                                           ! Debug: list int = const $64 (used reg = )
21369 6159           B8                   0064  mov	ax,*$64
21370 615C           50                         push	ax
21371                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21372 615D           E8         A3E2            call	_inb
21373 6160           44                         inc	sp
21374 6161           44                         inc	sp
21375                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21376 6162           24                     02  and	al,*2
21377 6164           84C0                       test	al,al
21378 6166           74           12            je  	.49A
21379                       00006168            .49B:
21380                                           ! 3355     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21381                                           ! Debug: list * char = .49C+0 (used reg = )
21382 6168           BB                   D332  mov	bx,#.49C
21383 616B           53                         push	bx
21384                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21385 616C           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21386 616F           53                         push	bx
21387                                           ! Debug: list int = const 7 (used reg = )
21388 6170           B8                   0007  mov	ax,*7
21389 6173           50                         push	ax
21390                                           ! Debug: func () void = bios_printf+0 (used reg = )
21391 6174           E8         A830            call	_bios_printf
21392 6177           83C4                   06  add	sp,*6
21393                                           !BCC_EOS
21394                                           ! 3356   command_byte &= 0xfd;
21395                       0000617A            .49A:
21396                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
21397 617A           8A46         FF            mov	al,-1[bp]
21398 617D           24                     FD  and	al,#$FD
21399 617F           8846         FF            mov	-1[bp],al
21400                                           !BCC_EOS
21401                                           ! 3357   command_byte |= 0x20;
21402                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
21403 6182           8A46         FF            mov	al,-1[bp]
21404 6185           0C                     20  or	al,*$20
21405 6187           8846         FF            mov	-1[bp],al
21406                                           !BCC_EOS
21407                                           ! 3358   outb(0x64, 0x60);
21408                                           ! Debug: list int = const $60 (used reg = )
21409 618A           B8                   0060  mov	ax,*$60
21410 618D           50                         push	ax
21411                                           ! Debug: list int = const $64 (used reg = )
21412 618E           B8                   0064  mov	ax,*$64
21413 6191           50                         push	ax
21414                                           ! Debug: func () void = outb+0 (used reg = )
21415 6192           E8         A3C3            call	_outb
21416 6195           83C4                   04  add	sp,*4
21417                                           !BCC_EOS
21418                                           ! 3359   outb(0x60, command_byte);
21419                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21420 6198           8A46         FF            mov	al,-1[bp]
21421 619B           30E4                       xor	ah,ah
21422 619D           50                         push	ax
21423                                           ! Debug: list int = const $60 (used reg = )
21424 619E           B8                   0060  mov	ax,*$60
21425 61A1           50                         push	ax
21426                                           ! Debug: func () void = outb+0 (used reg = )
21427 61A2           E8         A3B3            call	_outb
21428 61A5           83C4                   04  add	sp,*4
21429                                           !BCC_EOS
21430                                           ! 3360   return(prev_command_byte);
21431 61A8           8A46         FE            mov	al,-2[bp]
21432 61AB           89EC                       mov	sp,bp
21433 61AD           5D                         pop	bp
21434 61AE           C3                         ret
21435                                           !BCC_EOS
21436                                           ! 3361 }
21437                                           ! 3362   void
21438                                           ! Register BX used in function inhibit_mouse_int_and_events
21439                                           ! 3363 enable_mouse_int_and_events()
21440                                           ! 3364 {
21441                                           export	_enable_mouse_int_and_events
21442                       000061AF            _enable_mouse_int_and_events:
21443                                           ! 3365   Bit8u command_byte;
21444                                           !BCC_EOS
21445                                           ! 3366   if ( inb(0x64) & 0x02 )
21446 61AF           55                         push	bp
21447 61B0           89E5                       mov	bp,sp
21448 61B2           4C                         dec	sp
21449 61B3           4C                         dec	sp
21450                                           ! Debug: list int = const $64 (used reg = )
21451 61B4           B8                   0064  mov	ax,*$64
21452 61B7           50                         push	ax
21453                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21454 61B8           E8         A387            call	_inb
21455 61BB           44                         inc	sp
21456 61BC           44                         inc	sp
21457                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21458 61BD           24                     02  and	al,*2
21459 61BF           84C0                       test	al,al
21460 61C1           74           12            je  	.49D
21461                       000061C3            .49E:
21462                                           ! 3367     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21463                                           ! Debug: list * char = .49F+0 (used reg = )
21464 61C3           BB                   D328  mov	bx,#.49F
21465 61C6           53                         push	bx
21466                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21467 61C7           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21468 61CA           53                         push	bx
21469                                           ! Debug: list int = const 7 (used reg = )
21470 61CB           B8                   0007  mov	ax,*7
21471 61CE           50                         push	ax
21472                                           ! Debug: func () void = bios_printf+0 (used reg = )
21473 61CF           E8         A7D5            call	_bios_printf
21474 61D2           83C4                   06  add	sp,*6
21475                                           !BCC_EOS
21476                                           ! 3368   outb(0x64, 0x20);
21477                       000061D5            .49D:
21478                                           ! Debug: list int = const $20 (used reg = )
21479 61D5           B8                   0020  mov	ax,*$20
21480 61D8           50                         push	ax
21481                                           ! Debug: list int = const $64 (used reg = )
21482 61D9           B8                   0064  mov	ax,*$64
21483 61DC           50                         push	ax
21484                                           ! Debug: func () void = outb+0 (used reg = )
21485 61DD           E8         A378            call	_outb
21486 61E0           83C4                   04  add	sp,*4
21487                                           !BCC_EOS
21488                                           ! 3369   while ( (inb(0x64) & 0x01) != 0x01 );
21489 61E3           EB           00            jmp .4A1
21490                       000061E5            .4A2:
21491                                           !BCC_EOS
21492                                           ! 3370   command_byte = inb(0x60);
21493                       000061E5            .4A1:
21494                                           ! Debug: list int = const $64 (used reg = )
21495 61E5           B8                   0064  mov	ax,*$64
21496 61E8           50                         push	ax
21497                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21498 61E9           E8         A356            call	_inb
21499 61EC           44                         inc	sp
21500 61ED           44                         inc	sp
21501                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21502 61EE           24                     01  and	al,*1
21503                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21504 61F0           3C                     01  cmp	al,*1
21505 61F2           75           F1            jne	.4A2
21506                       000061F4            .4A3:
21507                       000061F4            .4A0:
21508                                           ! Debug: list int = const $60 (used reg = )
21509 61F4           B8                   0060  mov	ax,*$60
21510 61F7           50                         push	ax
21511                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21512 61F8           E8         A347            call	_inb
21513 61FB           44                         inc	sp
21514 61FC           44                         inc	sp
21515                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
21516 61FD           8846         FF            mov	-1[bp],al
21517                                           !BCC_EOS
21518                                           ! 3371   if ( inb(0x64) & 0x02 )
21519                                           ! Debug: list int = const $64 (used reg = )
21520 6200           B8                   0064  mov	ax,*$64
21521 6203           50                         push	ax
21522                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21523 6204           E8         A33B            call	_inb
21524 6207           44                         inc	sp
21525 6208           44                         inc	sp
21526                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21527 6209           24                     02  and	al,*2
21528 620B           84C0                       test	al,al
21529 620D           74           12            je  	.4A4
21530                       0000620F            .4A5:
21531                                           ! 3372     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21532                                           ! Debug: list * char = .4A6+0 (used reg = )
21533 620F           BB                   D31E  mov	bx,#.4A6
21534 6212           53                         push	bx
21535                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21536 6213           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21537 6216           53                         push	bx
21538                                           ! Debug: list int = const 7 (used reg = )
21539 6217           B8                   0007  mov	ax,*7
21540 621A           50                         push	ax
21541                                           ! Debug: func () void = bios_printf+0 (used reg = )
21542 621B           E8         A789            call	_bios_printf
21543 621E           83C4                   06  add	sp,*6
21544                                           !BCC_EOS
21545                                           ! 3373   command_byte |= 0x02;
21546                       00006221            .4A4:
21547                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
21548 6221           8A46         FF            mov	al,-1[bp]
21549 6224           0C                     02  or	al,*2
21550 6226           8846         FF            mov	-1[bp],al
21551                                           !BCC_EOS
21552                                           ! 3374   command_byte &= 0xdf;
21553                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
21554 6229           8A46         FF            mov	al,-1[bp]
21555 622C           24                     DF  and	al,#$DF
21556 622E           8846         FF            mov	-1[bp],al
21557                                           !BCC_EOS
21558                                           ! 3375   outb(0x64, 0x60);
21559                                           ! Debug: list int = const $60 (used reg = )
21560 6231           B8                   0060  mov	ax,*$60
21561 6234           50                         push	ax
21562                                           ! Debug: list int = const $64 (used reg = )
21563 6235           B8                   0064  mov	ax,*$64
21564 6238           50                         push	ax
21565                                           ! Debug: func () void = outb+0 (used reg = )
21566 6239           E8         A31C            call	_outb
21567 623C           83C4                   04  add	sp,*4
21568                                           !BCC_EOS
21569                                           ! 3376   outb(0x60, command_byte);
21570                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21571 623F           8A46         FF            mov	al,-1[bp]
21572 6242           30E4                       xor	ah,ah
21573 6244           50                         push	ax
21574                                           ! Debug: list int = const $60 (used reg = )
21575 6245           B8                   0060  mov	ax,*$60
21576 6248           50                         push	ax
21577                                           ! Debug: func () void = outb+0 (used reg = )
21578 6249           E8         A30C            call	_outb
21579 624C           83C4                   04  add	sp,*4
21580                                           !BCC_EOS
21581                                           ! 3377 }
21582 624F           89EC                       mov	sp,bp
21583 6251           5D                         pop	bp
21584 6252           C3                         ret
21585                                           ! 3378   Bit8u
21586                                           ! Register BX used in function enable_mouse_int_and_events
21587                                           ! 3379 send_to_mouse_ctrl(sendbyte)
21588                                           ! 3380   Bit8u sendbyte;
21589                                           export	_send_to_mouse_ctrl
21590                       00006253            _send_to_mouse_ctrl:
21591                                           !BCC_EOS
21592                                           ! 3381 {
21593                                           ! 3382   Bit8u response;
21594                                           !BCC_EOS
21595                                           ! 3383   if ( inb(0x64) & 0x02 )
21596 6253           55                         push	bp
21597 6254           89E5                       mov	bp,sp
21598 6256           4C                         dec	sp
21599 6257           4C                         dec	sp
21600                                           ! Debug: list int = const $64 (used reg = )
21601 6258           B8                   0064  mov	ax,*$64
21602 625B           50                         push	ax
21603                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21604 625C           E8         A2E3            call	_inb
21605 625F           44                         inc	sp
21606 6260           44                         inc	sp
21607                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21608 6261           24                     02  and	al,*2
21609 6263           84C0                       test	al,al
21610 6265           74           12            je  	.4A7
21611                       00006267            .4A8:
21612                                           ! 3384     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
21613                                           ! Debug: list * char = .4A9+0 (used reg = )
21614 6267           BB                   D314  mov	bx,#.4A9
21615 626A           53                         push	bx
21616                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21617 626B           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21618 626E           53                         push	bx
21619                                           ! Debug: list int = const 7 (used reg = )
21620 626F           B8                   0007  mov	ax,*7
21621 6272           50                         push	ax
21622                                           ! Debug: func () void = bios_printf+0 (used reg = )
21623 6273           E8         A731            call	_bios_printf
21624 6276           83C4                   06  add	sp,*6
21625                                           !BCC_EOS
21626                                           ! 3385   outb(0x64, 0xD4);
21627                       00006279            .4A7:
21628                                           ! Debug: list int = const $D4 (used reg = )
21629 6279           B8                   00D4  mov	ax,#$D4
21630 627C           50                         push	ax
21631                                           ! Debug: list int = const $64 (used reg = )
21632 627D           B8                   0064  mov	ax,*$64
21633 6280           50                         push	ax
21634                                           ! Debug: func () void = outb+0 (used reg = )
21635 6281           E8         A2D4            call	_outb
21636 6284           83C4                   04  add	sp,*4
21637                                           !BCC_EOS
21638                                           ! 3386   outb(0x60, sendbyte);
21639                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
21640 6287           8A46         04            mov	al,4[bp]
21641 628A           30E4                       xor	ah,ah
21642 628C           50                         push	ax
21643                                           ! Debug: list int = const $60 (used reg = )
21644 628D           B8                   0060  mov	ax,*$60
21645 6290           50                         push	ax
21646                                           ! Debug: func () void = outb+0 (used reg = )
21647 6291           E8         A2C4            call	_outb
21648 6294           83C4                   04  add	sp,*4
21649                                           !BCC_EOS
21650                                           ! 3387 
21651                                           ! 3387   return(0);
21652 6297           30C0                       xor	al,al
21653 6299           89EC                       mov	sp,bp
21654 629B           5D                         pop	bp
21655 629C           C3                         ret
21656                                           !BCC_EOS
21657                                           ! 3388 }
21658                                           ! 3389   Bit8u
21659                                           ! Register BX used in function send_to_mouse_ctrl
21660                                           ! 3390 get_mouse_data(data)
21661                                           ! 3391   Bit8u *data;
21662                                           export	_get_mouse_data
21663                       0000629D            _get_mouse_data:
21664                                           !BCC_EOS
21665                                           ! 3392 {
21666                                           ! 3393   Bit8u response;
21667                                           !BCC_EOS
21668                                           ! 3394   Bit16u ss;
21669                                           !BCC_EOS
21670                                           ! 3395   while ((inb(0x64) & 0x21) != 0x21) { }
21671 629D           55                         push	bp
21672 629E           89E5                       mov	bp,sp
21673 62A0           83C4                   FC  add	sp,*-4
21674 62A3           EB           00            jmp .4AB
21675                       000062A5            .4AC:
21676                                           ! 3396   response = inb(0x60);
21677                       000062A5            .4AB:
21678                                           ! Debug: list int = const $64 (used reg = )
21679 62A5           B8                   0064  mov	ax,*$64
21680 62A8           50                         push	ax
21681                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21682 62A9           E8         A296            call	_inb
21683 62AC           44                         inc	sp
21684 62AD           44                         inc	sp
21685                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
21686 62AE           24                     21  and	al,*$21
21687                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
21688 62B0           3C                     21  cmp	al,*$21
21689 62B2           75           F1            jne	.4AC
21690                       000062B4            .4AD:
21691                       000062B4            .4AA:
21692                                           ! Debug: list int = const $60 (used reg = )
21693 62B4           B8                   0060  mov	ax,*$60
21694 62B7           50                         push	ax
21695                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21696 62B8           E8         A287            call	_inb
21697 62BB           44                         inc	sp
21698 62BC           44                         inc	sp
21699                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21700 62BD           8846         FF            mov	-1[bp],al
21701                                           !BCC_EOS
21702                                           ! 3397   ss = get_SS();
21703                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21704 62C0           E8         A38E            call	_get_SS
21705                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21706 62C3           8946         FC            mov	-4[bp],ax
21707                                           !BCC_EOS
21708                                           ! 3398   write_byte(ss, data, response);
21709                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21710 62C6           8A46         FF            mov	al,-1[bp]
21711 62C9           30E4                       xor	ah,ah
21712 62CB           50                         push	ax
21713                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21714 62CC           FF76         04            push	4[bp]
21715                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21716 62CF           FF76         FC            push	-4[bp]
21717                                           ! Debug: func () void = write_byte+0 (used reg = )
21718 62D2           E8         A349            call	_write_byte
21719 62D5           83C4                   06  add	sp,*6
21720                                           !BCC_EOS
21721                                           ! 3399   return(0);
21722 62D8           30C0                       xor	al,al
21723 62DA           89EC                       mov	sp,bp
21724 62DC           5D                         pop	bp
21725 62DD           C3                         ret
21726                                           !BCC_EOS
21727                                           ! 3400 }
21728                                           ! 3401   void
21729                                           ! 3402 set_kbd_command_byte(command_byte)
21730                                           ! 3403   Bit8u command_byte;
21731                                           export	_set_kbd_command_byte
21732                       000062DE            _set_kbd_command_byte:
21733                                           !BCC_EOS
21734                                           ! 3404 {
21735                                           ! 3405   if ( inb(0x64) & 0x02 )
21736 62DE           55                         push	bp
21737 62DF           89E5                       mov	bp,sp
21738                                           ! Debug: list int = const $64 (used reg = )
21739 62E1           B8                   0064  mov	ax,*$64
21740 62E4           50                         push	ax
21741                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21742 62E5           E8         A25A            call	_inb
21743 62E8           89EC                       mov	sp,bp
21744                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21745 62EA           24                     02  and	al,*2
21746 62EC           84C0                       test	al,al
21747 62EE           74           11            je  	.4AE
21748                       000062F0            .4AF:
21749                                           ! 3406     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21750                                           ! Debug: list * char = .4B0+0 (used reg = )
21751 62F0           BB                   D309  mov	bx,#.4B0
21752 62F3           53                         push	bx
21753                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21754 62F4           BB                   60E2  mov	bx,#_panic_msg_keyb_buffer_full
21755 62F7           53                         push	bx
21756                                           ! Debug: list int = const 7 (used reg = )
21757 62F8           B8                   0007  mov	ax,*7
21758 62FB           50                         push	ax
21759                                           ! Debug: func () void = bios_printf+0 (used reg = )
21760 62FC           E8         A6A8            call	_bios_printf
21761 62FF           89EC                       mov	sp,bp
21762                                           !BCC_EOS
21763                                           ! 3407   outb(0x64, 0xD4);
21764                       00006301            .4AE:
21765                                           ! Debug: list int = const $D4 (used reg = )
21766 6301           B8                   00D4  mov	ax,#$D4
21767 6304           50                         push	ax
21768                                           ! Debug: list int = const $64 (used reg = )
21769 6305           B8                   0064  mov	ax,*$64
21770 6308           50                         push	ax
21771                                           ! Debug: func () void = outb+0 (used reg = )
21772 6309           E8         A24C            call	_outb
21773 630C           89EC                       mov	sp,bp
21774                                           !BCC_EOS
21775                                           ! 3408   outb(0x64, 0x60);
21776                                           ! Debug: list int = const $60 (used reg = )
21777 630E           B8                   0060  mov	ax,*$60
21778 6311           50                         push	ax
21779                                           ! Debug: list int = const $64 (used reg = )
21780 6312           B8                   0064  mov	ax,*$64
21781 6315           50                         push	ax
21782                                           ! Debug: func () void = outb+0 (used reg = )
21783 6316           E8         A23F            call	_outb
21784 6319           89EC                       mov	sp,bp
21785                                           !BCC_EOS
21786                                           ! 3409   outb(0x60, command_byte);
21787                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21788 631B           8A46         04            mov	al,4[bp]
21789 631E           30E4                       xor	ah,ah
21790 6320           50                         push	ax
21791                                           ! Debug: list int = const $60 (used reg = )
21792 6321           B8                   0060  mov	ax,*$60
21793 6324           50                         push	ax
21794                                           ! Debug: func () void = outb+0 (used reg = )
21795 6325           E8         A230            call	_outb
21796 6328           89EC                       mov	sp,bp
21797                                           !BCC_EOS
21798                                           ! 3410 }
21799 632A           5D                         pop	bp
21800 632B           C3                         ret
21801                                           ! 3411   void
21802                                           ! Register BX used in function set_kbd_command_byte
21803                                           ! 3412 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21804                                           ! 3413   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21805                                           export	_int09_function
21806                       0000632C            _int09_function:
21807                                           !BCC_EOS
21808                                           ! 3414 {
21809                                           ! 3415   Bit8u scancode, asciicode, shift_flags;
21810                                           !BCC_EOS
21811                                           ! 3416   Bit8u mf2_flags, mf2_state;
21812                                           !BCC_EOS
21813                                           ! 3417   scancode = ( AX & 0x00ff );
21814 632C           55                         push	bp
21815 632D           89E5                       mov	bp,sp
21816 632F           83C4                   FA  add	sp,*-6
21817                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21818 6332           8A46         12            mov	al,$12[bp]
21819                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21820 6335           8846         FF            mov	-1[bp],al
21821                                           !BCC_EOS
21822                                           ! 3418   if (scancode == 0) {
21823                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21824 6338           8A46         FF            mov	al,-1[bp]
21825 633B           84C0                       test	al,al
21826 633D           75           12            jne 	.4B1
21827                       0000633F            .4B2:
21828                                           ! 3419     bios_printf(4, "KBD: int09 handler: AL=0\n");
21829                                           ! Debug: list * char = .4B3+0 (used reg = )
21830 633F           BB                   D2EF  mov	bx,#.4B3
21831 6342           53                         push	bx
21832                                           ! Debug: list int = const 4 (used reg = )
21833 6343           B8                   0004  mov	ax,*4
21834 6346           50                         push	ax
21835                                           ! Debug: func () void = bios_printf+0 (used reg = )
21836 6347           E8         A65D            call	_bios_printf
21837 634A           83C4                   04  add	sp,*4
21838                                           !BCC_EOS
21839                                           ! 3420     return;
21840 634D           89EC                       mov	sp,bp
21841 634F           5D                         pop	bp
21842 6350           C3                         ret
21843                                           !BCC_EOS
21844                                           ! 3421   }
21845                                           ! 3422   shift_flags = read_byte(0x0040, 0x17);
21846                       00006351            .4B1:
21847                                           ! Debug: list int = const $17 (used reg = )
21848 6351           B8                   0017  mov	ax,*$17
21849 6354           50                         push	ax
21850                                           ! Debug: list int = const $40 (used reg = )
21851 6355           B8                   0040  mov	ax,*$40
21852 6358           50                         push	ax
21853                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21854 6359           E8         A29C            call	_read_byte
21855 635C           83C4                   04  add	sp,*4
21856                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21857 635F           8846         FD            mov	-3[bp],al
21858                                           !BCC_EOS
21859                                           ! 3423   mf2_flags = read_byte(0x0040, 0x18);
21860                                           ! Debug: list int = const $18 (used reg = )
21861 6362           B8                   0018  mov	ax,*$18
21862 6365           50                         push	ax
21863                                           ! Debug: list int = const $40 (used reg = )
21864 6366           B8                   0040  mov	ax,*$40
21865 6369           50                         push	ax
21866                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21867 636A           E8         A28B            call	_read_byte
21868 636D           83C4                   04  add	sp,*4
21869                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21870 6370           8846         FC            mov	-4[bp],al
21871                                           !BCC_EOS
21872                                           ! 3424   mf2_state = read_byte(0x0040, 0x96);
21873                                           ! Debug: list int = const $96 (used reg = )
21874 6373           B8                   0096  mov	ax,#$96
21875 6376           50                         push	ax
21876                                           ! Debug: list int = const $40 (used reg = )
21877 6377           B8                   0040  mov	ax,*$40
21878 637A           50                         push	ax
21879                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21880 637B           E8         A27A            call	_read_byte
21881 637E           83C4                   04  add	sp,*4
21882                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21883 6381           8846         FB            mov	-5[bp],al
21884                                           !BCC_EOS
21885                                           ! 3425   asciicode = 0;
21886                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21887 6384           30C0                       xor	al,al
21888 6386           8846         FE            mov	-2[bp],al
21889                                           !BCC_EOS
21890                                           ! 3426   switch (scancode) {
21891 6389           8A46         FF            mov	al,-1[bp]
21892 638C           E9         0586            br 	.4B6
21893                                           ! 3427     case 0x3a:
21894                                           ! 3428       shift_flags ^= 0x40;
21895                       0000638F            .4B7:
21896                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21897 638F           8A46         FD            mov	al,-3[bp]
21898 6392           34                     40  xor	al,*$40
21899 6394           8846         FD            mov	-3[bp],al
21900                                           !BCC_EOS
21901                                           ! 3429       write_byte(0x0040, 0x17, shift_flags);
21902                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21903 6397           8A46         FD            mov	al,-3[bp]
21904 639A           30E4                       xor	ah,ah
21905 639C           50                         push	ax
21906                                           ! Debug: list int = const $17 (used reg = )
21907 639D           B8                   0017  mov	ax,*$17
21908 63A0           50                         push	ax
21909                                           ! Debug: list int = const $40 (used reg = )
21910 63A1           B8                   0040  mov	ax,*$40
21911 63A4           50                         push	ax
21912                                           ! Debug: func () void = write_byte+0 (used reg = )
21913 63A5           E8         A276            call	_write_byte
21914 63A8           83C4                   06  add	sp,*6
21915                                           !BCC_EOS
21916                                           ! 3430       mf2_flags |= 0x40;
21917                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21918 63AB           8A46         FC            mov	al,-4[bp]
21919 63AE           0C                     40  or	al,*$40
21920 63B0           8846         FC            mov	-4[bp],al
21921                                           !BCC_EOS
21922                                           ! 3431       write_byte(0x0040, 0x18, mf2_flags);
21923                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21924 63B3           8A46         FC            mov	al,-4[bp]
21925 63B6           30E4                       xor	ah,ah
21926 63B8           50                         push	ax
21927                                           ! Debug: list int = const $18 (used reg = )
21928 63B9           B8                   0018  mov	ax,*$18
21929 63BC           50                         push	ax
21930                                           ! Debug: list int = const $40 (used reg = )
21931 63BD           B8                   0040  mov	ax,*$40
21932 63C0           50                         push	ax
21933                                           ! Debug: func () void = write_byte+0 (used reg = )
21934 63C1           E8         A25A            call	_write_byte
21935 63C4           83C4                   06  add	sp,*6
21936                                           !BCC_EOS
21937                                           ! 3432       break;
21938 63C7           E9         05A2            br 	.4B4
21939                                           !BCC_EOS
21940                                           ! 3433     case 0xba:
21941                                           ! 3434       mf2_flags &= ~0x40;
21942                       000063CA            .4B8:
21943                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21944 63CA           8A46         FC            mov	al,-4[bp]
21945 63CD           24                     BF  and	al,#$BF
21946 63CF           8846         FC            mov	-4[bp],al
21947                                           !BCC_EOS
21948                                           ! 3435       write_byte(0x0040, 0x18, mf2_flags);
21949                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21950 63D2           8A46         FC            mov	al,-4[bp]
21951 63D5           30E4                       xor	ah,ah
21952 63D7           50                         push	ax
21953                                           ! Debug: list int = const $18 (used reg = )
21954 63D8           B8                   0018  mov	ax,*$18
21955 63DB           50                         push	ax
21956                                           ! Debug: list int = const $40 (used reg = )
21957 63DC           B8                   0040  mov	ax,*$40
21958 63DF           50                         push	ax
21959                                           ! Debug: func () void = write_byte+0 (used reg = )
21960 63E0           E8         A23B            call	_write_byte
21961 63E3           83C4                   06  add	sp,*6
21962                                           !BCC_EOS
21963                                           ! 3436       break;
21964 63E6           E9         0583            br 	.4B4
21965                                           !BCC_EOS
21966                                           ! 3437     case 0x2a:
21967                                           ! 3438       shift_flags |= 0x02;
21968                       000063E9            .4B9:
21969                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21970 63E9           8A46         FD            mov	al,-3[bp]
21971 63EC           0C                     02  or	al,*2
21972 63EE           8846         FD            mov	-3[bp],al
21973                                           !BCC_EOS
21974                                           ! 3439       write_byte(0x0040, 0x17, shift_flags);
21975                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21976 63F1           8A46         FD            mov	al,-3[bp]
21977 63F4           30E4                       xor	ah,ah
21978 63F6           50                         push	ax
21979                                           ! Debug: list int = const $17 (used reg = )
21980 63F7           B8                   0017  mov	ax,*$17
21981 63FA           50                         push	ax
21982                                           ! Debug: list int = const $40 (used reg = )
21983 63FB           B8                   0040  mov	ax,*$40
21984 63FE           50                         push	ax
21985                                           ! Debug: func () void = write_byte+0 (used reg = )
21986 63FF           E8         A21C            call	_write_byte
21987 6402           83C4                   06  add	sp,*6
21988                                           !BCC_EOS
21989                                           ! 3440       break;
21990 6405           E9         0564            br 	.4B4
21991                                           !BCC_EOS
21992                                           ! 3441     case 0xaa:
21993                                           ! 3442       shift_flags &= ~0x02;
21994                       00006408            .4BA:
21995                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21996 6408           8A46         FD            mov	al,-3[bp]
21997 640B           24                     FD  and	al,#$FD
21998 640D           8846         FD            mov	-3[bp],al
21999                                           !BCC_EOS
22000                                           ! 3443       write_byte(0x0040, 0x17, shift_flags);
22001                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22002 6410           8A46         FD            mov	al,-3[bp]
22003 6413           30E4                       xor	ah,ah
22004 6415           50                         push	ax
22005                                           ! Debug: list int = const $17 (used reg = )
22006 6416           B8                   0017  mov	ax,*$17
22007 6419           50                         push	ax
22008                                           ! Debug: list int = const $40 (used reg = )
22009 641A           B8                   0040  mov	ax,*$40
22010 641D           50                         push	ax
22011                                           ! Debug: func () void = write_byte+0 (used reg = )
22012 641E           E8         A1FD            call	_write_byte
22013 6421           83C4                   06  add	sp,*6
22014                                           !BCC_EOS
22015                                           ! 3444       break;
22016 6424           E9         0545            br 	.4B4
22017                                           !BCC_EOS
22018                                           ! 3445     case 0x36:
22019                                           ! 3446       shift_flags |= 0x01;
22020                       00006427            .4BB:
22021                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
22022 6427           8A46         FD            mov	al,-3[bp]
22023 642A           0C                     01  or	al,*1
22024 642C           8846         FD            mov	-3[bp],al
22025                                           !BCC_EOS
22026                                           ! 3447       write_byte(0x0040, 0x17, shift_flags);
22027                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22028 642F           8A46         FD            mov	al,-3[bp]
22029 6432           30E4                       xor	ah,ah
22030 6434           50                         push	ax
22031                                           ! Debug: list int = const $17 (used reg = )
22032 6435           B8                   0017  mov	ax,*$17
22033 6438           50                         push	ax
22034                                           ! Debug: list int = const $40 (used reg = )
22035 6439           B8                   0040  mov	ax,*$40
22036 643C           50                         push	ax
22037                                           ! Debug: func () void = write_byte+0 (used reg = )
22038 643D           E8         A1DE            call	_write_byte
22039 6440           83C4                   06  add	sp,*6
22040                                           !BCC_EOS
22041                                           ! 3448       break;
22042 6443           E9         0526            br 	.4B4
22043                                           !BCC_EOS
22044                                           ! 3449     case 0xb6:
22045                                           ! 3450       shift_flags &= ~0x01;
22046                       00006446            .4BC:
22047                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
22048 6446           8A46         FD            mov	al,-3[bp]
22049 6449           24                     FE  and	al,#$FE
22050 644B           8846         FD            mov	-3[bp],al
22051                                           !BCC_EOS
22052                                           ! 3451       write_byte(0x0040, 0x17, shift_flags);
22053                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22054 644E           8A46         FD            mov	al,-3[bp]
22055 6451           30E4                       xor	ah,ah
22056 6453           50                         push	ax
22057                                           ! Debug: list int = const $17 (used reg = )
22058 6454           B8                   0017  mov	ax,*$17
22059 6457           50                         push	ax
22060                                           ! Debug: list int = const $40 (used reg = )
22061 6458           B8                   0040  mov	ax,*$40
22062 645B           50                         push	ax
22063                                           ! Debug: func () void = write_byte+0 (used reg = )
22064 645C           E8         A1BF            call	_write_byte
22065 645F           83C4                   06  add	sp,*6
22066                                           !BCC_EOS
22067                                           ! 3452       break;
22068 6462           E9         0507            br 	.4B4
22069                                           !BCC_EOS
22070                                           ! 3453     case 0x1d:
22071                                           ! 3454       if ((mf2_state & 0x01) == 0) {
22072                       00006465            .4BD:
22073                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
22074 6465           8A46         FB            mov	al,-5[bp]
22075 6468           24                     01  and	al,*1
22076                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22077 646A           84C0                       test	al,al
22078 646C           75           5F            jne 	.4BE
22079                       0000646E            .4BF:
22080                                           ! 3455         shift_flags |= 0x04;
22081                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22082 646E           8A46         FD            mov	al,-3[bp]
22083 6471           0C                     04  or	al,*4
22084 6473           8846         FD            mov	-3[bp],al
22085                                           !BCC_EOS
22086                                           ! 3456         write_byte(0x0040, 0x17, shift_flags);
22087                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22088 6476           8A46         FD            mov	al,-3[bp]
22089 6479           30E4                       xor	ah,ah
22090 647B           50                         push	ax
22091                                           ! Debug: list int = const $17 (used reg = )
22092 647C           B8                   0017  mov	ax,*$17
22093 647F           50                         push	ax
22094                                           ! Debug: list int = const $40 (used reg = )
22095 6480           B8                   0040  mov	ax,*$40
22096 6483           50                         push	ax
22097                                           ! Debug: func () void = write_byte+0 (used reg = )
22098 6484           E8         A197            call	_write_byte
22099 6487           83C4                   06  add	sp,*6
22100                                           !BCC_EOS
22101                                           ! 3457         if (mf2_state & 0x02) {
22102                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22103 648A           8A46         FB            mov	al,-5[bp]
22104 648D           24                     02  and	al,*2
22105 648F           84C0                       test	al,al
22106 6491           74           1E            je  	.4C0
22107                       00006493            .4C1:
22108                                           ! 3458           mf2_state |= 0x04;
22109                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
22110 6493           8A46         FB            mov	al,-5[bp]
22111 6496           0C                     04  or	al,*4
22112 6498           8846         FB            mov	-5[bp],al
22113                                           !BCC_EOS
22114                                           ! 3459           write_byte(0x0040, 0x96, mf2_state);
22115                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22116 649B           8A46         FB            mov	al,-5[bp]
22117 649E           30E4                       xor	ah,ah
22118 64A0           50                         push	ax
22119                                           ! Debug: list int = const $96 (used reg = )
22120 64A1           B8                   0096  mov	ax,#$96
22121 64A4           50                         push	ax
22122                                           ! Debug: list int = const $40 (used reg = )
22123 64A5           B8                   0040  mov	ax,*$40
22124 64A8           50                         push	ax
22125                                           ! Debug: func () void = write_byte+0 (used reg = )
22126 64A9           E8         A172            call	_write_byte
22127 64AC           83C4                   06  add	sp,*6
22128                                           !BCC_EOS
22129                                           ! 3460         } else {
22130 64AF           EB           1C            jmp .4C2
22131                       000064B1            .4C0:
22132                                           ! 3461           mf2_flags |= 0x01;
22133                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
22134 64B1           8A46         FC            mov	al,-4[bp]
22135 64B4           0C                     01  or	al,*1
22136 64B6           8846         FC            mov	-4[bp],al
22137                                           !BCC_EOS
22138                                           ! 3462           write_byte(0x0040, 0x18, mf2_flags);
22139                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22140 64B9           8A46         FC            mov	al,-4[bp]
22141 64BC           30E4                       xor	ah,ah
22142 64BE           50                         push	ax
22143                                           ! Debug: list int = const $18 (used reg = )
22144 64BF           B8                   0018  mov	ax,*$18
22145 64C2           50                         push	ax
22146                                           ! Debug: list int = const $40 (used reg = )
22147 64C3           B8                   0040  mov	ax,*$40
22148 64C6           50                         push	ax
22149                                           ! Debug: func () void = write_byte+0 (used reg = )
22150 64C7           E8         A154            call	_write_byte
22151 64CA           83C4                   06  add	sp,*6
22152                                           !BCC_EOS
22153                                           ! 3463         }
22154                                           ! 3464       }
22155                       000064CD            .4C2:
22156                                           ! 3465       break;
22157                       000064CD            .4BE:
22158 64CD           E9         049C            br 	.4B4
22159                                           !BCC_EOS
22160                                           ! 3466     case 0x9d:
22161                                           ! 3467       if ((mf2_state & 0x01) == 0) {
22162                       000064D0            .4C3:
22163                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
22164 64D0           8A46         FB            mov	al,-5[bp]
22165 64D3           24                     01  and	al,*1
22166                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22167 64D5           84C0                       test	al,al
22168 64D7           75           5F            jne 	.4C4
22169                       000064D9            .4C5:
22170                                           ! 3468         shift_flags &= ~0x04;
22171                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
22172 64D9           8A46         FD            mov	al,-3[bp]
22173 64DC           24                     FB  and	al,#$FB
22174 64DE           8846         FD            mov	-3[bp],al
22175                                           !BCC_EOS
22176                                           ! 3469         write_byte(0x0040, 0x17, shif
22177                                           ! 3469 t_flags);
22178                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22179 64E1           8A46         FD            mov	al,-3[bp]
22180 64E4           30E4                       xor	ah,ah
22181 64E6           50                         push	ax
22182                                           ! Debug: list int = const $17 (used reg = )
22183 64E7           B8                   0017  mov	ax,*$17
22184 64EA           50                         push	ax
22185                                           ! Debug: list int = const $40 (used reg = )
22186 64EB           B8                   0040  mov	ax,*$40
22187 64EE           50                         push	ax
22188                                           ! Debug: func () void = write_byte+0 (used reg = )
22189 64EF           E8         A12C            call	_write_byte
22190 64F2           83C4                   06  add	sp,*6
22191                                           !BCC_EOS
22192                                           ! 3470         if (mf2_state & 0x02) {
22193                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22194 64F5           8A46         FB            mov	al,-5[bp]
22195 64F8           24                     02  and	al,*2
22196 64FA           84C0                       test	al,al
22197 64FC           74           1E            je  	.4C6
22198                       000064FE            .4C7:
22199                                           ! 3471           mf2_state &= ~0x04;
22200                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
22201 64FE           8A46         FB            mov	al,-5[bp]
22202 6501           24                     FB  and	al,#$FB
22203 6503           8846         FB            mov	-5[bp],al
22204                                           !BCC_EOS
22205                                           ! 3472           write_byte(0x0040, 0x96, mf2_state);
22206                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22207 6506           8A46         FB            mov	al,-5[bp]
22208 6509           30E4                       xor	ah,ah
22209 650B           50                         push	ax
22210                                           ! Debug: list int = const $96 (used reg = )
22211 650C           B8                   0096  mov	ax,#$96
22212 650F           50                         push	ax
22213                                           ! Debug: list int = const $40 (used reg = )
22214 6510           B8                   0040  mov	ax,*$40
22215 6513           50                         push	ax
22216                                           ! Debug: func () void = write_byte+0 (used reg = )
22217 6514           E8         A107            call	_write_byte
22218 6517           83C4                   06  add	sp,*6
22219                                           !BCC_EOS
22220                                           ! 3473         } else {
22221 651A           EB           1C            jmp .4C8
22222                       0000651C            .4C6:
22223                                           ! 3474           mf2_flags &= ~0x01;
22224                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22225 651C           8A46         FC            mov	al,-4[bp]
22226 651F           24                     FE  and	al,#$FE
22227 6521           8846         FC            mov	-4[bp],al
22228                                           !BCC_EOS
22229                                           ! 3475           write_byte(0x0040, 0x18, mf2_flags);
22230                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22231 6524           8A46         FC            mov	al,-4[bp]
22232 6527           30E4                       xor	ah,ah
22233 6529           50                         push	ax
22234                                           ! Debug: list int = const $18 (used reg = )
22235 652A           B8                   0018  mov	ax,*$18
22236 652D           50                         push	ax
22237                                           ! Debug: list int = const $40 (used reg = )
22238 652E           B8                   0040  mov	ax,*$40
22239 6531           50                         push	ax
22240                                           ! Debug: func () void = write_byte+0 (used reg = )
22241 6532           E8         A0E9            call	_write_byte
22242 6535           83C4                   06  add	sp,*6
22243                                           !BCC_EOS
22244                                           ! 3476         }
22245                                           ! 3477       }
22246                       00006538            .4C8:
22247                                           ! 3478       break;
22248                       00006538            .4C4:
22249 6538           E9         0431            br 	.4B4
22250                                           !BCC_EOS
22251                                           ! 3479     case 0x38:
22252                                           ! 3480       shift_flags |= 0x08;
22253                       0000653B            .4C9:
22254                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22255 653B           8A46         FD            mov	al,-3[bp]
22256 653E           0C                     08  or	al,*8
22257 6540           8846         FD            mov	-3[bp],al
22258                                           !BCC_EOS
22259                                           ! 3481       write_byte(0x0040, 0x17, shift_flags);
22260                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22261 6543           8A46         FD            mov	al,-3[bp]
22262 6546           30E4                       xor	ah,ah
22263 6548           50                         push	ax
22264                                           ! Debug: list int = const $17 (used reg = )
22265 6549           B8                   0017  mov	ax,*$17
22266 654C           50                         push	ax
22267                                           ! Debug: list int = const $40 (used reg = )
22268 654D           B8                   0040  mov	ax,*$40
22269 6550           50                         push	ax
22270                                           ! Debug: func () void = write_byte+0 (used reg = )
22271 6551           E8         A0CA            call	_write_byte
22272 6554           83C4                   06  add	sp,*6
22273                                           !BCC_EOS
22274                                           ! 3482       if (mf2_state & 0x02) {
22275                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22276 6557           8A46         FB            mov	al,-5[bp]
22277 655A           24                     02  and	al,*2
22278 655C           84C0                       test	al,al
22279 655E           74           1E            je  	.4CA
22280                       00006560            .4CB:
22281                                           ! 3483         mf2_state |= 0x08;
22282                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
22283 6560           8A46         FB            mov	al,-5[bp]
22284 6563           0C                     08  or	al,*8
22285 6565           8846         FB            mov	-5[bp],al
22286                                           !BCC_EOS
22287                                           ! 3484         write_byte(0x0040, 0x96, mf2_state);
22288                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22289 6568           8A46         FB            mov	al,-5[bp]
22290 656B           30E4                       xor	ah,ah
22291 656D           50                         push	ax
22292                                           ! Debug: list int = const $96 (used reg = )
22293 656E           B8                   0096  mov	ax,#$96
22294 6571           50                         push	ax
22295                                           ! Debug: list int = const $40 (used reg = )
22296 6572           B8                   0040  mov	ax,*$40
22297 6575           50                         push	ax
22298                                           ! Debug: func () void = write_byte+0 (used reg = )
22299 6576           E8         A0A5            call	_write_byte
22300 6579           83C4                   06  add	sp,*6
22301                                           !BCC_EOS
22302                                           ! 3485       } else {
22303 657C           EB           1C            jmp .4CC
22304                       0000657E            .4CA:
22305                                           ! 3486         mf2_flags |= 0x02;
22306                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22307 657E           8A46         FC            mov	al,-4[bp]
22308 6581           0C                     02  or	al,*2
22309 6583           8846         FC            mov	-4[bp],al
22310                                           !BCC_EOS
22311                                           ! 3487         write_byte(0x0040, 0x18, mf2_flags);
22312                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22313 6586           8A46         FC            mov	al,-4[bp]
22314 6589           30E4                       xor	ah,ah
22315 658B           50                         push	ax
22316                                           ! Debug: list int = const $18 (used reg = )
22317 658C           B8                   0018  mov	ax,*$18
22318 658F           50                         push	ax
22319                                           ! Debug: list int = const $40 (used reg = )
22320 6590           B8                   0040  mov	ax,*$40
22321 6593           50                         push	ax
22322                                           ! Debug: func () void = write_byte+0 (used reg = )
22323 6594           E8         A087            call	_write_byte
22324 6597           83C4                   06  add	sp,*6
22325                                           !BCC_EOS
22326                                           ! 3488       }
22327                                           ! 3489       break;
22328                       0000659A            .4CC:
22329 659A           E9         03CF            br 	.4B4
22330                                           !BCC_EOS
22331                                           ! 3490     case 0xb8:
22332                                           ! 3491       shift_flags &= ~0x08;
22333                       0000659D            .4CD:
22334                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
22335 659D           8A46         FD            mov	al,-3[bp]
22336 65A0           24                     F7  and	al,#$F7
22337 65A2           8846         FD            mov	-3[bp],al
22338                                           !BCC_EOS
22339                                           ! 3492       write_byte(0x0040, 0x17, shift_flags);
22340                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22341 65A5           8A46         FD            mov	al,-3[bp]
22342 65A8           30E4                       xor	ah,ah
22343 65AA           50                         push	ax
22344                                           ! Debug: list int = const $17 (used reg = )
22345 65AB           B8                   0017  mov	ax,*$17
22346 65AE           50                         push	ax
22347                                           ! Debug: list int = const $40 (used reg = )
22348 65AF           B8                   0040  mov	ax,*$40
22349 65B2           50                         push	ax
22350                                           ! Debug: func () void = write_byte+0 (used reg = )
22351 65B3           E8         A068            call	_write_byte
22352 65B6           83C4                   06  add	sp,*6
22353                                           !BCC_EOS
22354                                           ! 3493       if (mf2_state & 0x02) {
22355                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22356 65B9           8A46         FB            mov	al,-5[bp]
22357 65BC           24                     02  and	al,*2
22358 65BE           84C0                       test	al,al
22359 65C0           74           1E            je  	.4CE
22360                       000065C2            .4CF:
22361                                           ! 3494         mf2_state &= ~0x08;
22362                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
22363 65C2           8A46         FB            mov	al,-5[bp]
22364 65C5           24                     F7  and	al,#$F7
22365 65C7           8846         FB            mov	-5[bp],al
22366                                           !BCC_EOS
22367                                           ! 3495         write_byte(0x0040, 0x96, mf2_state);
22368                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22369 65CA           8A46         FB            mov	al,-5[bp]
22370 65CD           30E4                       xor	ah,ah
22371 65CF           50                         push	ax
22372                                           ! Debug: list int = const $96 (used reg = )
22373 65D0           B8                   0096  mov	ax,#$96
22374 65D3           50                         push	ax
22375                                           ! Debug: list int = const $40 (used reg = )
22376 65D4           B8                   0040  mov	ax,*$40
22377 65D7           50                         push	ax
22378                                           ! Debug: func () void = write_byte+0 (used reg = )
22379 65D8           E8         A043            call	_write_byte
22380 65DB           83C4                   06  add	sp,*6
22381                                           !BCC_EOS
22382                                           ! 3496       } else {
22383 65DE           EB           1C            jmp .4D0
22384                       000065E0            .4CE:
22385                                           ! 3497         mf2_flags &= ~0x02;
22386                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
22387 65E0           8A46         FC            mov	al,-4[bp]
22388 65E3           24                     FD  and	al,#$FD
22389 65E5           8846         FC            mov	-4[bp],al
22390                                           !BCC_EOS
22391                                           ! 3498         write_byte(0x0040, 0x18, mf2_flags);
22392                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22393 65E8           8A46         FC            mov	al,-4[bp]
22394 65EB           30E4                       xor	ah,ah
22395 65ED           50                         push	ax
22396                                           ! Debug: list int = const $18 (used reg = )
22397 65EE           B8                   0018  mov	ax,*$18
22398 65F1           50                         push	ax
22399                                           ! Debug: list int = const $40 (used reg = )
22400 65F2           B8                   0040  mov	ax,*$40
22401 65F5           50                         push	ax
22402                                           ! Debug: func () void = write_byte+0 (used reg = )
22403 65F6           E8         A025            call	_write_byte
22404 65F9           83C4                   06  add	sp,*6
22405                                           !BCC_EOS
22406                                           ! 3499       }
22407                                           ! 3500       break;
22408                       000065FC            .4D0:
22409 65FC           E9         036D            br 	.4B4
22410                                           !BCC_EOS
22411                                           ! 3501     case 0x45:
22412                                           ! 3502       if ((mf2_state & 0x03) == 0) {
22413                       000065FF            .4D1:
22414                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22415 65FF           8A46         FB            mov	al,-5[bp]
22416 6602           24                     03  and	al,*3
22417                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22418 6604           84C0                       test	al,al
22419 6606           75           38            jne 	.4D2
22420                       00006608            .4D3:
22421                                           ! 3503         mf2_flags |= 0x20;
22422                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
22423 6608           8A46         FC            mov	al,-4[bp]
22424 660B           0C                     20  or	al,*$20
22425 660D           8846         FC            mov	-4[bp],al
22426                                           !BCC_EOS
22427                                           ! 3504         write_byte(0x0040, 0x18, mf2_flags);
22428                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22429 6610           8A46         FC            mov	al,-4[bp]
22430 6613           30E4                       xor	ah,ah
22431 6615           50                         push	ax
22432                                           ! Debug: list int = const $18 (used reg = )
22433 6616           B8                   0018  mov	ax,*$18
22434 6619           50                         push	ax
22435                                           ! Debug: list int = const $40 (used reg = )
22436 661A           B8                   0040  mov	ax,*$40
22437 661D           50                         push	ax
22438                                           ! Debug: func () void = write_byte+0 (used reg = )
22439 661E           E8         9FFD            call	_write_byte
22440 6621           83C4                   06  add	sp,*6
22441                                           !BCC_EOS
22442                                           ! 3505         shift_flags ^= 0x20;
22443                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
22444 6624           8A46         FD            mov	al,-3[bp]
22445 6627           34                     20  xor	al,*$20
22446 6629           8846         FD            mov	-3[bp],al
22447                                           !BCC_EOS
22448                                           ! 3506         write_byte(0x0040, 0x17, shift_flags);
22449                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22450 662C           8A46         FD            mov	al,-3[bp]
22451 662F           30E4                       xor	ah,ah
22452 6631           50                         push	ax
22453                                           ! Debug: list int = const $17 (used reg = )
22454 6632           B8                   0017  mov	ax,*$17
22455 6635           50                         push	ax
22456                                           ! Debug: list int = const $40 (used reg = )
22457 6636           B8                   0040  mov	ax,*$40
22458 6639           50                         push	ax
22459                                           ! Debug: func () void = write_byte+0 (used reg = )
22460 663A           E8         9FE1            call	_write_byte
22461 663D           83C4                   06  add	sp,*6
22462                                           !BCC_EOS
22463                                           ! 3507       }
22464                                           ! 3508       break;
22465                       00006640            .4D2:
22466 6640           E9         0329            br 	.4B4
22467                                           !BCC_EOS
22468                                           ! 3509     case 0xc5:
22469                                           ! 3510       if ((mf2_state & 0x03) == 0) {
22470                       00006643            .4D4:
22471                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22472 6643           8A46         FB            mov	al,-5[bp]
22473 6646           24                     03  and	al,*3
22474                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22475 6648           84C0                       test	al,al
22476 664A           75           1C            jne 	.4D5
22477                       0000664C            .4D6:
22478                                           ! 3511         mf2_flags &= ~0x20;
22479                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
22480 664C           8A46         FC            mov	al,-4[bp]
22481 664F           24                     DF  and	al,#$DF
22482 6651           8846         FC            mov	-4[bp],al
22483                                           !BCC_EOS
22484                                           ! 3512         write_byte(0x0040, 0x18, mf2_flags);
22485                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22486 6654           8A46         FC            mov	al,-4[bp]
22487 6657           30E4                       xor	ah,ah
22488 6659           50                         push	ax
22489                                           ! Debug: list int = const $18 (used reg = )
22490 665A           B8                   0018  mov	ax,*$18
22491 665D           50                         push	ax
22492                                           ! Debug: list int = const $40 (used reg = )
22493 665E           B8                   0040  mov	ax,*$40
22494 6661           50                         push	ax
22495                                           ! Debug: func () void = write_byte+0 (used reg = )
22496 6662           E8         9FB9            call	_write_byte
22497 6665           83C4                   06  add	sp,*6
22498                                           !BCC_EOS
22499                                           ! 3513       }
22500                                           ! 3514       break;
22501                       00006668            .4D5:
22502 6668           E9         0301            br 	.4B4
22503                                           !BCC_EOS
22504                                           ! 3515     case 0x46:
22505                                           ! 3516       mf2_flags |= 0x10;
22506                       0000666B            .4D7:
22507                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
22508 666B           8A46         FC            mov	al,-4[bp]
22509 666E           0C                     10  or	al,*$10
22510 6670           8846         FC            mov	-4[bp],al
22511                                           !BCC_EOS
22512                                           ! 3517       write_byte(0x0040, 0x18, mf2_flags);
22513                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22514 6673           8A46         FC            mov	al,-4[bp]
22515 6676           30E4                       xor	ah,ah
22516 6678           50                         push	ax
22517                                           ! Debug: list int = const $18 (used reg = )
22518 6679           B8                   0018  mov	ax,*$18
22519 667C           50                         push	ax
22520                                           ! Debug: list int = const $40 (used reg = )
22521 667D           B8                   0040  mov	ax,*$40
22522 6680           50                         push	ax
22523                                           ! Debug: func () void = write_byte+0 (used reg = )
22524 6681           E8         9F9A            call	_write_byte
22525 6684           83C4                   06  add	sp,*6
22526                                           !BCC_EOS
22527                                           ! 3518       shift_flags ^= 0x10;
22528                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
22529 6687           8A46         FD            mov	al,-3[bp]
22530 668A           34                     10  xor	al,*$10
22531 668C           8846         FD            mov	-3[bp],al
22532                                           !BCC_EOS
22533                                           ! 3519       write_byte(0x0040, 0x17, shift_flags);
22534                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22535 668F           8A46         FD            mov	al,-3[bp]
22536 6692           30E4                       xor	ah,ah
22537 6694           50                         push	ax
22538                                           ! Debug: list int = const $17 (used reg = )
22539 6695           B8                   0017  mov	ax,*$17
22540 6698           50                         push	ax
22541                                           ! Debug: list int = const $40 (used reg = )
22542 6699           B8                   0040  mov	ax,*$40
22543 669C           50                         push	ax
22544                                           ! Debug: func () void = write_byte+0 (used reg = )
22545 669D           E8         9F7E            call	_write_byte
22546 66A0           83C4                   06  add	sp,*6
22547                                           !BCC_EOS
22548                                           ! 3520       break;
22549 66A3           E9         02C6            br 	.4B4
22550                                           !BCC_EOS
22551                                           ! 3521     case 0xc6:
22552                                           ! 3522       mf2_flags &= ~0x10;
22553                       000066A6            .4D8:
22554                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
22555 66A6           8A46         FC            mov	al,-4[bp]
22556 66A9           24                     EF  and	al,#$EF
22557 66AB           8846         FC            mov	-4[bp],al
22558                                           !BCC_EOS
22559                                           ! 3523       write_byte(0x0040, 0x18, mf2_flags);
22560                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22561 66AE           8A46         FC            mov	al,-4[bp]
22562 66B1           30E4                       xor	ah,ah
22563 66B3           50                         push	ax
22564                                           ! Debug: list int = const $18 (used reg = )
22565 66B4           B8                   0018  mov	ax,*$18
22566 66B7           50                         push	ax
22567                                           ! Debug: list int = const $40 (used reg = )
22568 66B8           B8                   0040  mov	ax,*$40
22569 66BB           50                         push	ax
22570                                           ! Debug: func () void = write_byte+0 (used reg = )
22571 66BC           E8         9F5F            call	_write_byte
22572 66BF           83C4                   06  add	sp,*6
22573                                           !BCC_EOS
22574                                           ! 3524       break;
22575 66C2           E9         02A7            br 	.4B4
22576                                           !BCC_EOS
22577                                           ! 3525     default:
22578                                           ! 3526       if (scancode & 0x80) {
22579                       000066C5            .4D9:
22580                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
22581 66C5           8A46         FF            mov	al,-1[bp]
22582 66C8           24                     80  and	al,#$80
22583 66CA           84C0                       test	al,al
22584 66CC           74           03            je  	.4DA
22585                       000066CE            .4DB:
22586                                           ! 3527         break;
22587 66CE           E9         029B            br 	.4B4
22588                                           !BCC_EOS
22589                                           ! 3528       }
22590                                           ! 3529       if (scancode > 0x58) {
22591                       000066D1            .4DA:
22592                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
22593 66D1           8A46         FF            mov	al,-1[bp]
22594 66D4           3C                     58  cmp	al,*$58
22595 66D6           76           18            jbe 	.4DC
22596                       000066D8            .4DD:
22597                                           ! 3530         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
22598                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
22599 66D8           8A46         FF            mov	al,-1[bp]
22600 66DB           30E4                       xor	ah,ah
22601 66DD           50                         push	ax
22602                                           ! Debug: list * char = .4DE+0 (used reg = )
22603 66DE           BB                   D2B8  mov	bx,#.4DE
22604 66E1           53                         push	bx
22605                                           ! Debug: list int = const 4 (used reg = )
22606 66E2           B8                   0004  mov	ax,*4
22607 66E5           50                         push	ax
22608                                           ! Debug: func () void = bios_printf+0 (used reg = )
22609 66E6           E8         A2BE            call	_bios_printf
22610 66E9           83C4                   06  add	sp,*6
22611                                           !BCC_EOS
22612                                           ! 3531         return;
22613 66EC           89EC                       mov	sp,bp
22614 66EE           5D                         pop	bp
22615 66EF           C3                         ret
22616                                           !BCC_EOS
22617                                           ! 3532       }
22618                                           ! 3533       if (shift_flags & 0x08) {
22619                       000066F0            .4DC:
22620                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22621 66F0           8A46         FD            mov	al,-3[bp]
22622 66F3           24                     08  and	al,*8
22623 66F5           84C0                       test	al,al
22624 66F7           74           3D            je  	.4DF
22625                       000066F9            .4E0:
22626                                           ! 3534         asciicode = scan_to_scanascii[scancode].alt;
22627                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22628 66F9           8A46         FF            mov	al,-1[bp]
22629 66FC           30E4                       xor	ah,ah
22630 66FE           89C2                       mov	dx,ax
22631 6700           D1E0                       shl	ax,*1
22632 6702           D1E0                       shl	ax,*1
22633 6704           01D0                       add	ax,dx
22634 6706           D1E0                       shl	ax,*1
22635 6708           89C3                       mov	bx,ax
22636 670A           81C3                 01C8  add	bx,#_scan_to_scanascii
22637                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
22638 670E           8A47         06            mov	al,6[bx]
22639 6711           8846         FE            mov	-2[bp],al
22640                                           !BCC_EOS
22641                                           ! 3535         scancode = scan_to_scanascii[scancode].alt >> 8;
22642                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22643 6714           8A46         FF            mov	al,-1[bp]
22644 6717           30E4                       xor	ah,ah
22645 6719           89C2                       mov	dx,ax
22646 671B           D1E0                       shl	ax,*1
22647 671D           D1E0                       shl	ax,*1
22648 671F           01D0                       add	ax,dx
22649 6721           D1E0                       shl	ax,*1
22650 6723           89C3                       mov	bx,ax
22651 6725           81C3                 01C8  add	bx,#_scan_to_scanascii
22652                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
22653 6729           8B47         06            mov	ax,6[bx]
22654 672C           88E0                       mov	al,ah
22655 672E           30E4                       xor	ah,ah
22656                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22657 6730           8846         FF            mov	-1[bp],al
22658                                           !BCC_EOS
22659                                           ! 3536       } else if (shift_flags & 0x04) {
22660 6733           E9         01AD            br 	.4E1
22661                       00006736            .4DF:
22662                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22663 6736           8A46         FD            mov	al,-3[bp]
22664 6739           24                     04  and	al,*4
22665 673B           84C0                       test	al,al
22666 673D           74           3D            je  	.4E2
22667                       0000673F            .4E3:
22668                                           ! 3537         asciicode = scan_to_scanascii[scancode].control;
22669                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22670 673F           8A46         FF            mov	al,-1[bp]
22671 6742           30E4                       xor	ah,ah
22672 6744           89C2                       mov	dx,ax
22673 6746           D1E0                       shl	ax,*1
22674 6748           D1E0                       shl	ax,*1
22675 674A           01D0                       add	ax,dx
22676 674C           D1E0                       shl	ax,*1
22677 674E           89C3                       mov	bx,ax
22678 6750           81C3                 01C8  add	bx,#_scan_to_scanascii
22679                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
22680 6754           8A47         04            mov	al,4[bx]
22681 6757           8846         FE            mov	-2[bp],al
22682                                           !BCC_EOS
22683                                           ! 3538         scancode = scan_to_scanascii[scancode].control >> 8;
22684                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22685 675A           8A46         FF            mov	al,-1[bp]
22686 675D           30E4                       xor	ah,ah
22687 675F           89C2                       mov	dx,ax
22688 6761           D1E0                       shl	ax,*1
22689 6763           D1E0                       shl	ax,*1
22690 6765           01D0                       add	ax,dx
22691 6767           D1E0                       shl	ax,*1
22692 6769           89C3                       mov	bx,ax
22693 676B           81C3                 01C8  add	bx,#_scan_to_scanascii
22694                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
22695 676F           8B47         04            mov	ax,4[bx]
22696 6772           88E0                       mov	al,ah
22697 6774           30E4                       xor	ah,ah
22698                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22699 6776           8846         FF            mov	-1[bp],al
22700                                           !BCC_EOS
22701                                           ! 3539       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) 
22702 6779           E9         0167            br 	.4E4
22703                       0000677C            .4E2:
22704                                           ! 3539 && (scancode <= 0x53))) {
22705                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22706 677C           8A46         FB            mov	al,-5[bp]
22707 677F           24                     02  and	al,*2
22708                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22709 6781           84C0                       test	al,al
22710 6783           74           32            je  	.4E5
22711                       00006785            .4E7:
22712                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22713 6785           8A46         FF            mov	al,-1[bp]
22714 6788           3C                     47  cmp	al,*$47
22715 678A           72           2B            jb  	.4E5
22716                       0000678C            .4E8:
22717                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22718 678C           8A46         FF            mov	al,-1[bp]
22719 678F           3C                     53  cmp	al,*$53
22720 6791           77           24            ja  	.4E5
22721                       00006793            .4E6:
22722                                           ! 3540         asciicode = 0xe0;
22723                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22724 6793           B0                     E0  mov	al,#$E0
22725 6795           8846         FE            mov	-2[bp],al
22726                                           !BCC_EOS
22727                                           ! 3541         scancode = scan_to_scanascii[scancode].normal >> 8;
22728                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22729 6798           8A46         FF            mov	al,-1[bp]
22730 679B           30E4                       xor	ah,ah
22731 679D           89C2                       mov	dx,ax
22732 679F           D1E0                       shl	ax,*1
22733 67A1           D1E0                       shl	ax,*1
22734 67A3           01D0                       add	ax,dx
22735 67A5           D1E0                       shl	ax,*1
22736 67A7           89C3                       mov	bx,ax
22737                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22738 67A9           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22739 67AD           88E0                       mov	al,ah
22740 67AF           30E4                       xor	ah,ah
22741                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22742 67B1           8846         FF            mov	-1[bp],al
22743                                           !BCC_EOS
22744                                           ! 3542       } else if (shift_flags & 0x03) {
22745 67B4           E9         012C            br 	.4E9
22746                       000067B7            .4E5:
22747                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22748 67B7           8A46         FD            mov	al,-3[bp]
22749 67BA           24                     03  and	al,*3
22750 67BC           84C0                       test	al,al
22751 67BE         0F84         0092            beq 	.4EA
22752                       000067C2            .4EB:
22753                                           ! 3543         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22754                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22755 67C2           8A46         FF            mov	al,-1[bp]
22756 67C5           30E4                       xor	ah,ah
22757 67C7           89C2                       mov	dx,ax
22758 67C9           D1E0                       shl	ax,*1
22759 67CB           D1E0                       shl	ax,*1
22760 67CD           01D0                       add	ax,dx
22761 67CF           D1E0                       shl	ax,*1
22762 67D1           89C3                       mov	bx,ax
22763 67D3           81C3                 01C8  add	bx,#_scan_to_scanascii
22764                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22765 67D7           8A46         FD            mov	al,-3[bp]
22766 67DA           2247         08            and	al,8[bx]
22767 67DD           84C0                       test	al,al
22768 67DF           74           36            je  	.4EC
22769                       000067E1            .4ED:
22770                                           ! 3544           asciicode = scan_to_scanascii[scancode].normal;
22771                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22772 67E1           8A46         FF            mov	al,-1[bp]
22773 67E4           30E4                       xor	ah,ah
22774 67E6           89C2                       mov	dx,ax
22775 67E8           D1E0                       shl	ax,*1
22776 67EA           D1E0                       shl	ax,*1
22777 67EC           01D0                       add	ax,dx
22778 67EE           D1E0                       shl	ax,*1
22779 67F0           89C3                       mov	bx,ax
22780                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22781 67F2           8A87       01C8            mov	al,_scan_to_scanascii[bx]
22782 67F6           8846         FE            mov	-2[bp],al
22783                                           !BCC_EOS
22784                                           ! 3545           scancode = scan_to_scanascii[scancode].normal >> 8;
22785                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22786 67F9           8A46         FF            mov	al,-1[bp]
22787 67FC           30E4                       xor	ah,ah
22788 67FE           89C2                       mov	dx,ax
22789 6800           D1E0                       shl	ax,*1
22790 6802           D1E0                       shl	ax,*1
22791 6804           01D0                       add	ax,dx
22792 6806           D1E0                       shl	ax,*1
22793 6808           89C3                       mov	bx,ax
22794                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22795 680A           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22796 680E           88E0                       mov	al,ah
22797 6810           30E4                       xor	ah,ah
22798                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22799 6812           8846         FF            mov	-1[bp],al
22800                                           !BCC_EOS
22801                                           ! 3546         } else {
22802 6815           EB           3A            jmp .4EE
22803                       00006817            .4EC:
22804                                           ! 3547           asciicode = scan_to_scanascii[scancode].shift;
22805                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22806 6817           8A46         FF            mov	al,-1[bp]
22807 681A           30E4                       xor	ah,ah
22808 681C           89C2                       mov	dx,ax
22809 681E           D1E0                       shl	ax,*1
22810 6820           D1E0                       shl	ax,*1
22811 6822           01D0                       add	ax,dx
22812 6824           D1E0                       shl	ax,*1
22813 6826           89C3                       mov	bx,ax
22814 6828           81C3                 01C8  add	bx,#_scan_to_scanascii
22815                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22816 682C           8A47         02            mov	al,2[bx]
22817 682F           8846         FE            mov	-2[bp],al
22818                                           !BCC_EOS
22819                                           ! 3548           scancode = scan_to_scanascii[scancode].shift >> 8;
22820                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22821 6832           8A46         FF            mov	al,-1[bp]
22822 6835           30E4                       xor	ah,ah
22823 6837           89C2                       mov	dx,ax
22824 6839           D1E0                       shl	ax,*1
22825 683B           D1E0                       shl	ax,*1
22826 683D           01D0                       add	ax,dx
22827 683F           D1E0                       shl	ax,*1
22828 6841           89C3                       mov	bx,ax
22829 6843           81C3                 01C8  add	bx,#_scan_to_scanascii
22830                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22831 6847           8B47         02            mov	ax,2[bx]
22832 684A           88E0                       mov	al,ah
22833 684C           30E4                       xor	ah,ah
22834                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22835 684E           8846         FF            mov	-1[bp],al
22836                                           !BCC_EOS
22837                                           ! 3549         }
22838                                           ! 3550       } else {
22839                       00006851            .4EE:
22840 6851           E9         008F            br 	.4EF
22841                       00006854            .4EA:
22842                                           ! 3551         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22843                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22844 6854           8A46         FF            mov	al,-1[bp]
22845 6857           30E4                       xor	ah,ah
22846 6859           89C2                       mov	dx,ax
22847 685B           D1E0                       shl	ax,*1
22848 685D           D1E0                       shl	ax,*1
22849 685F           01D0                       add	ax,dx
22850 6861           D1E0                       shl	ax,*1
22851 6863           89C3                       mov	bx,ax
22852 6865           81C3                 01C8  add	bx,#_scan_to_scanascii
22853                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22854 6869           8A46         FD            mov	al,-3[bp]
22855 686C           2247         08            and	al,8[bx]
22856 686F           84C0                       test	al,al
22857 6871           74           3C            je  	.4F0
22858                       00006873            .4F1:
22859                                           ! 3552           asciicode = scan_to_scanascii[scancode].shift;
22860                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22861 6873           8A46         FF            mov	al,-1[bp]
22862 6876           30E4                       xor	ah,ah
22863 6878           89C2                       mov	dx,ax
22864 687A           D1E0                       shl	ax,*1
22865 687C           D1E0                       shl	ax,*1
22866 687E           01D0                       add	ax,dx
22867 6880           D1E0                       shl	ax,*1
22868 6882           89C3                       mov	bx,ax
22869 6884           81C3                 01C8  add	bx,#_scan_to_scanascii
22870                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22871 6888           8A47         02            mov	al,2[bx]
22872 688B           8846         FE            mov	-2[bp],al
22873                                           !BCC_EOS
22874                                           ! 3553           scancode = scan_to_scanascii[scancode].shift >> 8;
22875                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22876 688E           8A46         FF            mov	al,-1[bp]
22877 6891           30E4                       xor	ah,ah
22878 6893           89C2                       mov	dx,ax
22879 6895           D1E0                       shl	ax,*1
22880 6897           D1E0                       shl	ax,*1
22881 6899           01D0                       add	ax,dx
22882 689B           D1E0                       shl	ax,*1
22883 689D           89C3                       mov	bx,ax
22884 689F           81C3                 01C8  add	bx,#_scan_to_scanascii
22885                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22886 68A3           8B47         02            mov	ax,2[bx]
22887 68A6           88E0                       mov	al,ah
22888 68A8           30E4                       xor	ah,ah
22889                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22890 68AA           8846         FF            mov	-1[bp],al
22891                                           !BCC_EOS
22892                                           ! 3554         } else {
22893 68AD           EB           34            jmp .4F2
22894                       000068AF            .4F0:
22895                                           ! 3555           asciicode = scan_to_scanascii[scancode].normal;
22896                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22897 68AF           8A46         FF            mov	al,-1[bp]
22898 68B2           30E4                       xor	ah,ah
22899 68B4           89C2                       mov	dx,ax
22900 68B6           D1E0                       shl	ax,*1
22901 68B8           D1E0                       shl	ax,*1
22902 68BA           01D0                       add	ax,dx
22903 68BC           D1E0                       shl	ax,*1
22904 68BE           89C3                       mov	bx,ax
22905                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22906 68C0           8A87       01C8            mov	al,_scan_to_scanascii[bx]
22907 68C4           8846         FE            mov	-2[bp],al
22908                                           !BCC_EOS
22909                                           ! 3556           scancode = scan_to_scanascii[scancode].normal >> 8;
22910                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22911 68C7           8A46         FF            mov	al,-1[bp]
22912 68CA           30E4                       xor	ah,ah
22913 68CC           89C2                       mov	dx,ax
22914 68CE           D1E0                       shl	ax,*1
22915 68D0           D1E0                       shl	ax,*1
22916 68D2           01D0                       add	ax,dx
22917 68D4           D1E0                       shl	ax,*1
22918 68D6           89C3                       mov	bx,ax
22919                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22920 68D8           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22921 68DC           88E0                       mov	al,ah
22922 68DE           30E4                       xor	ah,ah
22923                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22924 68E0           8846         FF            mov	-1[bp],al
22925                                           !BCC_EOS
22926                                           ! 3557         }
22927                                           ! 3558       }
22928                       000068E3            .4F2:
22929                                           ! 3559       if (scancode==0 && asciicode==0) {
22930                       000068E3            .4EF:
22931                       000068E3            .4E9:
22932                       000068E3            .4E4:
22933                       000068E3            .4E1:
22934                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22935 68E3           8A46         FF            mov	al,-1[bp]
22936 68E6           84C0                       test	al,al
22937 68E8           75           15            jne 	.4F3
22938                       000068EA            .4F5:
22939                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22940 68EA           8A46         FE            mov	al,-2[bp]
22941 68ED           84C0                       test	al,al
22942 68EF           75           0E            jne 	.4F3
22943                       000068F1            .4F4:
22944                                           ! 3560         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
22945                                           ! Debug: list * char = .4F6+0 (used reg = )
22946 68F1           BB                   D281  mov	bx,#.4F6
22947 68F4           53                         push	bx
22948                                           ! Debug: list int = const 4 (used reg = )
22949 68F5           B8                   0004  mov	ax,*4
22950 68F8           50                         push	ax
22951                                           ! Debug: func () void = bios_printf+0 (used reg = )
22952 68F9           E8         A0AB            call	_bios_printf
22953 68FC           83C4                   04  add	sp,*4
22954                                           !BCC_EOS
22955                                           ! 3561       }
22956                                           ! 3562       enqueue_key(scancode, asciicode);
22957                       000068FF            .4F3:
22958                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22959 68FF           8A46         FE            mov	al,-2[bp]
22960 6902           30E4                       xor	ah,ah
22961 6904           50                         push	ax
22962                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22963 6905           8A46         FF            mov	al,-1[bp]
22964 6908           30E4                       xor	ah,ah
22965 690A           50                         push	ax
22966                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22967 690B           E8         008F            call	_enqueue_key
22968 690E           83C4                   04  add	sp,*4
22969                                           !BCC_EOS
22970                                           ! 3563       break;
22971 6911           EB           59            jmp .4B4
22972                                           !BCC_EOS
22973                                           ! 3564   }
22974                                           ! 3565   if ((scancode & 0x7f) != 0x1d) {
22975 6913           EB           57            jmp .4B4
22976                       00006915            .4B6:
22977 6915           2C                     1D  sub	al,*$1D
22978 6917         0F84         FB4A            beq 	.4BD
22979 691B           2C                     0D  sub	al,*$D
22980 691D         0F84         FAC8            beq 	.4B9
22981 6921           2C                     0C  sub	al,*$C
22982 6923         0F84         FB00            beq 	.4BB
22983 6927           2C                     02  sub	al,*2
22984 6929         0F84         FC0E            beq 	.4C9
22985 692D           2C                     02  sub	al,*2
22986 692F         0F84         FA5C            beq 	.4B7
22987 6933           2C                     0B  sub	al,*$B
22988 6935         0F84         FCC6            beq 	.4D1
22989 6939           2C                     01  sub	al,*1
22990 693B         0F84         FD2C            beq 	.4D7
22991 693F           2C                     57  sub	al,*$57
22992 6941         0F84         FB8B            beq 	.4C3
22993 6945           2C                     0D  sub	al,*$D
22994 6947         0F84         FABD            beq 	.4BA
22995 694B           2C                     0C  sub	al,*$C
22996 694D         0F84         FAF5            beq 	.4BC
22997 6951           2C                     02  sub	al,*2
22998 6953         0F84         FC46            beq 	.4CD
22999 6957           2C                     02  sub	al,*2
23000 6959         0F84         FA6D            beq 	.4B8
23001 695D           2C                     0B  sub	al,*$B
23002 695F         0F84         FCE0            beq 	.4D4
23003 6963           2C                     01  sub	al,*1
23004 6965         0F84         FD3D            beq 	.4D8
23005 6969           E9         FD59            br 	.4D9
23006                       0000696C            .4B4:
23007                       FFFFFFF8            ..FFF2	=	-8
23008                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
23009 696C           8A46         FF            mov	al,-1[bp]
23010 696F           24                     7F  and	al,*$7F
23011                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
23012 6971           3C                     1D  cmp	al,*$1D
23013 6973           74           08            je  	.4F7
23014                       00006975            .4F8:
23015                                           ! 3566     mf2_state &= ~0x01;
23016                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
23017 6975           8A46         FB            mov	al,-5[bp]
23018 6978           24                     FE  and	al,#$FE
23019 697A           8846         FB            mov	-5[bp],al
23020                                           !BCC_EOS
23021                                           ! 3567   }
23022                                           ! 3568   mf2_state &= ~0x02;
23023                       0000697D            .4F7:
23024                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
23025 697D           8A46         FB            mov	al,-5[bp]
23026 6980           24                     FD  and	al,#$FD
23027 6982           8846         FB            mov	-5[bp],al
23028                                           !BCC_EOS
23029                                           ! 3569   write_byte(0x0040, 0x96, mf2_state);
23030                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
23031 6985           8A46         FB            mov	al,-5[bp]
23032 6988           30E4                       xor	ah,ah
23033 698A           50                         push	ax
23034                                           ! Debug: list int = const $96 (used reg = )
23035 698B           B8                   0096  mov	ax,#$96
23036 698E           50                         push	ax
23037                                           ! Debug: list int = const $40 (used reg = )
23038 698F           B8                   0040  mov	ax,*$40
23039 6992           50                         push	ax
23040                                           ! Debug: func () void = write_byte+0 (used reg = )
23041 6993           E8         9C88            call	_write_byte
23042 6996           83C4                   06  add	sp,*6
23043                                           !BCC_EOS
23044                                           ! 3570 }
23045 6999           89EC                       mov	sp,bp
23046 699B           5D                         pop	bp
23047 699C           C3                         ret
23048                                           ! 3571   unsigned int
23049                                           ! Register BX used in function int09_function
23050                                           ! 3572 enqueue_key(scan_code, ascii_code)
23051                                           ! 3573   Bit8u scan_code, ascii_code;
23052                                           export	_enqueue_key
23053                       0000699D            _enqueue_key:
23054                                           !BCC_EOS
23055                                           ! 3574 {
23056                                           ! 3575   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
23057                                           !BCC_EOS
23058                                           ! 3576   buffer_start = read_word(0x0040, 0x0080);
23059 699D           55                         push	bp
23060 699E           89E5                       mov	bp,sp
23061 69A0           83C4                   F6  add	sp,*-$A
23062                                           ! Debug: list int = const $80 (used reg = )
23063 69A3           B8                   0080  mov	ax,#$80
23064 69A6           50                         push	ax
23065                                           ! Debug: list int = const $40 (used reg = )
23066 69A7           B8                   0040  mov	ax,*$40
23067 69AA           50                         push	ax
23068                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23069 69AB           E8         9C5D            call	_read_word
23070 69AE           83C4                   04  add	sp,*4
23071                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
23072 69B1           8946         FE            mov	-2[bp],ax
23073                                           !BCC_EOS
23074                                           ! 3577   buffer_end = read_word(0x0040, 0x0082);
23075                                           ! Debug: list int = const $82 (used reg = )
23076 69B4           B8                   0082  mov	ax,#$82
23077 69B7           50                         push	ax
23078                                           ! Debug: list int = const $40 (used reg = )
23079 69B8           B8                   0040  mov	ax,*$40
23080 69BB           50                         push	ax
23081                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23082 69BC           E8         9C4C            call	_read_word
23083 69BF           83C4                   04  add	sp,*4
23084                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
23085 69C2           8946         FC            mov	-4[bp],ax
23086                                           !BCC_EOS
23087                                           ! 3578   buffer_head = read_word(0x0040, 0x001A);
23088                                           ! Debug: list int = const $1A (used reg = )
23089 69C5           B8                   001A  mov	ax,*$1A
23090 69C8           50                         push	ax
23091                                           ! Debug: list int = const $40 (used reg = )
23092 69C9           B8                   0040  mov	ax,*$40
23093 69CC           50                         push	ax
23094                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23095 69CD           E8         9C3B            call	_read_word
23096 69D0           83C4                   04  add	sp,*4
23097                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
23098 69D3           8946         FA            mov	-6[bp],ax
23099                                           !BCC_EOS
23100                                           ! 3579   buffer_tail = read_word(0x0040, 0x001C);
23101                                           ! Debug: list int = const $1C (used reg = )
23102 69D6           B8                   001C  mov	ax,*$1C
23103 69D9           50                         push	ax
23104                                           ! Debug: list int = const $40 (used reg = )
23105 69DA           B8                   0040  mov	ax,*$40
23106 69DD           50                         push	ax
23107                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23108 69DE           E8         9C2A            call	_read_word
23109 69E1           83C4                   04  add	sp,*4
23110                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23111 69E4           8946         F8            mov	-8[bp],ax
23112                                           !BCC_EOS
23113                                           ! 3580   temp_tail = buffer_tail;
23114                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
23115 69E7           8B46         F8            mov	ax,-8[bp]
23116 69EA           8946         F6            mov	-$A[bp],ax
23117                                           !BCC_EOS
23118                                           ! 3581   buffer_tail += 2;
23119                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23120 69ED           8B46         F8            mov	ax,-8[bp]
23121 69F0           40                         inc	ax
23122 69F1           40                         inc	ax
23123 69F2           8946         F8            mov	-8[bp],ax
23124                                           !BCC_EOS
23125                                           ! 3582   if (buffer_tail >= buffer_end)
23126                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23127 69F5           8B46         F8            mov	ax,-8[bp]
23128 69F8           3B46         FC            cmp	ax,-4[bp]
23129 69FB           72           06            jb  	.4F9
23130                       000069FD            .4FA:
23131                                           ! 3583     buffer_tail = buffer_start;
23132                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23133 69FD           8B46         FE            mov	ax,-2[bp]
23134 6A00           8946         F8            mov	-8[bp],ax
23135                                           !BCC_EOS
23136                                           ! 3584   if (buffer_tail == buffer_head) {
23137                       00006A03            .4F9:
23138                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23139 6A03           8B46         F8            mov	ax,-8[bp]
23140 6A06           3B46         FA            cmp	ax,-6[bp]
23141 6A09           75           06            jne 	.4FB
23142                       00006A0B            .4FC:
23143                                           ! 3585     return(0);
23144 6A0B           31C0                       xor	ax,ax
23145 6A0D           89EC                       mov	sp,bp
23146 6A0F           5D                         pop	bp
23147 6A10           C3                         ret
23148                                           !BCC_EOS
23149                                           ! 3586   }
23150                                           ! 3587   write_byte(0x0040, temp_tail, ascii_code);
23151                       00006A11            .4FB:
23152                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
23153 6A11           8A46         06            mov	al,6[bp]
23154 6A14           30E4                       xor	ah,ah
23155 6A16           50                         push	ax
23156                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
23157 6A17           FF76         F6            push	-$A[bp]
23158                                           ! Debug: list int = const $40 (used reg = )
23159 6A1A           B8                   0040  mov	ax,*$40
23160 6A1D           50                         push	ax
23161                                           ! Debug: func () void = write_byte+0 (used reg = )
23162 6A1E           E8         9BFD            call	_write_byte
23163 6A21           83C4                   06  add	sp,*6
23164                                           !BCC_EOS
23165                                           ! 3588   write_byte(0x0040, temp_tail+1, scan_code);
23166                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
23167 6A24           8A46         04            mov	al,4[bp]
23168 6A27           30E4                       xor	ah,ah
23169 6A29           50                         push	ax
23170                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
23171 6A2A           8B46         F6            mov	ax,-$A[bp]
23172                                           ! Debug: list unsigned int = ax+1 (used reg = )
23173 6A2D           40                         inc	ax
23174 6A2E           50                         push	ax
23175                                           ! Debug: list int = const $40 (used reg = )
23176 6A2F           B8                   0040  mov	ax,*$40
23177 6A32           50                         push	ax
23178                                           ! Debug: func () void = write_byte+0 (used reg = )
23179 6A33           E8         9BE8            call	_write_byte
23180 6A36           83C4                   06  add	sp,*6
23181                                           !BCC_EOS
23182                                           ! 3589   write_word(0x0040, 0x001C, buffer_tail);
23183                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
23184 6A39           FF76         F8            push	-8[bp]
23185                                           ! Debug: list int = const $1C (used reg = )
23186 6A3C           B8                   001C  mov	ax,*$1C
23187 6A3F           50                         push	ax
23188                                           ! Debug: list int = const $40 (used reg = )
23189 6A40           B8                   0040  mov	ax,*$40
23190 6A43           50                         push	ax
23191                                           ! Debug: func () void = write_word+0 (used reg = )
23192 6A44           E8         9BEF            call	_write_word
23193 6A47           83C4                   06  add	sp,*6
23194                                           !BCC_EOS
23195                                           ! 3590   return(1);
23196 6A4A           B8                   0001  mov	ax,*1
23197 6A4D           89EC                       mov	sp,bp
23198 6A4F           5D                         pop	bp
23199 6A50           C3                         ret
23200                                           !BCC_EOS
23201                                           ! 3591 }
23202                                           ! 3592   void
23203                                           ! 3593 int74_function(make_farcall, Z, Y, X, status)
23204                                           ! 3594   Bit16u make_farcall, Z, Y, X, status;
23205                                           export	_int74_function
23206                       00006A51            _int74_function:
23207                                           !BCC_EOS
23208                                           ! 3595 {
23209                                           ! 3596   Bit16u ebda_seg=read_word(0x0040,0x000E);
23210 6A51           55                         push	bp
23211 6A52           89E5                       mov	bp,sp
23212 6A54           4C                         dec	sp
23213 6A55           4C                         dec	sp
23214                                           ! Debug: list int = const $E (used reg = )
23215 6A56           B8                   000E  mov	ax,*$E
23216 6A59           50                         push	ax
23217                                           ! Debug: list int = const $40 (used reg = )
23218 6A5A           B8                   0040  mov	ax,*$40
23219 6A5D           50                         push	ax
23220                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23221 6A5E           E8         9BAA            call	_read_word
23222 6A61           83C4                   04  add	sp,*4
23223                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
23224 6A64           8946         FE            mov	-2[bp],ax
23225                                           !BCC_EOS
23226                                           ! 3597   Bit8u in_byte, index, package_count;
23227                                           !BCC_EOS
23228                                           ! 3598   Bit8u mouse_flags_1, mouse_flags_2;
23229                                           !BCC_EOS
23230                                           ! 3599 ;
23231 6A67           83C4                   FA  add	sp,*-6
23232                                           !BCC_EOS
23233                                           ! 3600   make_farcall = 0;
23234                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
23235 6A6A           31C0                       xor	ax,ax
23236 6A6C           8946         04            mov	4[bp],ax
23237                                           !BCC_EOS
23238                                           ! 3601   in_byte = 
23239                                           ! 3601 inb(0x64);
23240                                           ! Debug: list int = const $64 (used reg = )
23241 6A6F           B8                   0064  mov	ax,*$64
23242 6A72           50                         push	ax
23243                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23244 6A73           E8         9ACC            call	_inb
23245 6A76           44                         inc	sp
23246 6A77           44                         inc	sp
23247                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23248 6A78           8846         FD            mov	-3[bp],al
23249                                           !BCC_EOS
23250                                           ! 3602   if ((in_byte & 0x21) != 0x21) {
23251                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
23252 6A7B           8A46         FD            mov	al,-3[bp]
23253 6A7E           24                     21  and	al,*$21
23254                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
23255 6A80           3C                     21  cmp	al,*$21
23256 6A82           74           04            je  	.4FD
23257                       00006A84            .4FE:
23258                                           ! 3603     return;
23259 6A84           89EC                       mov	sp,bp
23260 6A86           5D                         pop	bp
23261 6A87           C3                         ret
23262                                           !BCC_EOS
23263                                           ! 3604   }
23264                                           ! 3605   in_byte = inb(0x60);
23265                       00006A88            .4FD:
23266                                           ! Debug: list int = const $60 (used reg = )
23267 6A88           B8                   0060  mov	ax,*$60
23268 6A8B           50                         push	ax
23269                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23270 6A8C           E8         9AB3            call	_inb
23271 6A8F           44                         inc	sp
23272 6A90           44                         inc	sp
23273                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23274 6A91           8846         FD            mov	-3[bp],al
23275                                           !BCC_EOS
23276                                           ! 3606 ;
23277                                           !BCC_EOS
23278                                           ! 3607   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
23279                                           ! Debug: list int = const $26 (used reg = )
23280 6A94           B8                   0026  mov	ax,*$26
23281 6A97           50                         push	ax
23282                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23283 6A98           FF76         FE            push	-2[bp]
23284                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23285 6A9B           E8         9B5A            call	_read_byte
23286 6A9E           83C4                   04  add	sp,*4
23287                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23288 6AA1           8846         FA            mov	-6[bp],al
23289                                           !BCC_EOS
23290                                           ! 3608   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
23291                                           ! Debug: list int = const $27 (used reg = )
23292 6AA4           B8                   0027  mov	ax,*$27
23293 6AA7           50                         push	ax
23294                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23295 6AA8           FF76         FE            push	-2[bp]
23296                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23297 6AAB           E8         9B4A            call	_read_byte
23298 6AAE           83C4                   04  add	sp,*4
23299                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23300 6AB1           8846         F9            mov	-7[bp],al
23301                                           !BCC_EOS
23302                                           ! 3609   if ((mouse_flags_2 & 0x80) != 0x80) {
23303                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23304 6AB4           8A46         F9            mov	al,-7[bp]
23305 6AB7           24                     80  and	al,#$80
23306                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
23307 6AB9           3C                     80  cmp	al,#$80
23308 6ABB           74           04            je  	.4FF
23309                       00006ABD            .500:
23310                                           ! 3610       return;
23311 6ABD           89EC                       mov	sp,bp
23312 6ABF           5D                         pop	bp
23313 6AC0           C3                         ret
23314                                           !BCC_EOS
23315                                           ! 3611   }
23316                                           ! 3612   package_count = mouse_flags_2 & 0x07;
23317                       00006AC1            .4FF:
23318                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23319 6AC1           8A46         F9            mov	al,-7[bp]
23320 6AC4           24                     07  and	al,*7
23321                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
23322 6AC6           8846         FB            mov	-5[bp],al
23323                                           !BCC_EOS
23324                                           ! 3613   index = mouse_flags_1 & 0x07;
23325                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23326 6AC9           8A46         FA            mov	al,-6[bp]
23327 6ACC           24                     07  and	al,*7
23328                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
23329 6ACE           8846         FC            mov	-4[bp],al
23330                                           !BCC_EOS
23331                                           ! 3614   write_byte(ebda_seg, 0x28 + index, in_byte);
23332                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
23333 6AD1           8A46         FD            mov	al,-3[bp]
23334 6AD4           30E4                       xor	ah,ah
23335 6AD6           50                         push	ax
23336                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
23337                                           ! Debug: expression subtree swapping
23338 6AD7           8A46         FC            mov	al,-4[bp]
23339 6ADA           30E4                       xor	ah,ah
23340                                           ! Debug: list unsigned int = ax+$28 (used reg = )
23341 6ADC           05                   0028  add	ax,*$28
23342 6ADF           50                         push	ax
23343                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23344 6AE0           FF76         FE            push	-2[bp]
23345                                           ! Debug: func () void = write_byte+0 (used reg = )
23346 6AE3           E8         9B38            call	_write_byte
23347 6AE6           83C4                   06  add	sp,*6
23348                                           !BCC_EOS
23349                                           ! 3615   if ( (index+1) >= package_count ) {
23350                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
23351 6AE9           8A46         FC            mov	al,-4[bp]
23352 6AEC           30E4                       xor	ah,ah
23353                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
23354 6AEE           40                         inc	ax
23355 6AEF           50                         push	ax
23356 6AF0           8A46         FB            mov	al,-5[bp]
23357 6AF3           30E4                       xor	ah,ah
23358 6AF5           3B46         F6            cmp	ax,-$A[bp]
23359 6AF8           8D66         F8            lea	sp,-8[bp]
23360 6AFB           77           51            ja  	.501
23361                       00006AFD            .502:
23362                                           ! 3616 ;
23363                                           !BCC_EOS
23364                                           ! 3617     status = read_byte(ebda_seg, 0x0028 + 0);
23365                                           ! Debug: list int = const $28 (used reg = )
23366 6AFD           B8                   0028  mov	ax,*$28
23367 6B00           50                         push	ax
23368                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23369 6B01           FF76         FE            push	-2[bp]
23370                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23371 6B04           E8         9AF1            call	_read_byte
23372 6B07           83C4                   04  add	sp,*4
23373                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
23374 6B0A           30E4                       xor	ah,ah
23375 6B0C           8946         0C            mov	$C[bp],ax
23376                                           !BCC_EOS
23377                                           ! 3618     X = read_byte(ebda_seg, 0x0028 + 1);
23378                                           ! Debug: list int = const $29 (used reg = )
23379 6B0F           B8                   0029  mov	ax,*$29
23380 6B12           50                         push	ax
23381                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23382 6B13           FF76         FE            push	-2[bp]
23383                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23384 6B16           E8         9ADF            call	_read_byte
23385 6B19           83C4                   04  add	sp,*4
23386                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
23387 6B1C           30E4                       xor	ah,ah
23388 6B1E           8946         0A            mov	$A[bp],ax
23389                                           !BCC_EOS
23390                                           ! 3619     Y = read_byte(ebda_seg, 0x0028 + 2);
23391                                           ! Debug: list int = const $2A (used reg = )
23392 6B21           B8                   002A  mov	ax,*$2A
23393 6B24           50                         push	ax
23394                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23395 6B25           FF76         FE            push	-2[bp]
23396                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23397 6B28           E8         9ACD            call	_read_byte
23398 6B2B           83C4                   04  add	sp,*4
23399                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
23400 6B2E           30E4                       xor	ah,ah
23401 6B30           8946         08            mov	8[bp],ax
23402                                           !BCC_EOS
23403                                           ! 3620     Z = 0;
23404                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
23405 6B33           31C0                       xor	ax,ax
23406 6B35           8946         06            mov	6[bp],ax
23407                                           !BCC_EOS
23408                                           ! 3621     mouse_flags_1 = 0;
23409                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23410 6B38           30C0                       xor	al,al
23411 6B3A           8846         FA            mov	-6[bp],al
23412                                           !BCC_EOS
23413                                           ! 3622     if (mouse_flags_2 & 0x80)
23414                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23415 6B3D           8A46         F9            mov	al,-7[bp]
23416 6B40           24                     80  and	al,#$80
23417 6B42           84C0                       test	al,al
23418 6B44           74           06            je  	.503
23419                       00006B46            .504:
23420                                           ! 3623       make_farcall = 1;
23421                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
23422 6B46           B8                   0001  mov	ax,*1
23423 6B49           8946         04            mov	4[bp],ax
23424                                           !BCC_EOS
23425                                           ! 3624     }
23426                       00006B4C            .503:
23427                                           ! 3625   else {
23428 6B4C           EB           07            jmp .505
23429                       00006B4E            .501:
23430                                           ! 3626     mouse_flags_1++;
23431                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23432 6B4E           8A46         FA            mov	al,-6[bp]
23433 6B51           40                         inc	ax
23434 6B52           8846         FA            mov	-6[bp],al
23435                                           !BCC_EOS
23436                                           ! 3627   }
23437                                           ! 3628   write_byte(ebda_seg, 0x0026, mouse_flags_1);
23438                       00006B55            .505:
23439                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23440 6B55           8A46         FA            mov	al,-6[bp]
23441 6B58           30E4                       xor	ah,ah
23442 6B5A           50                         push	ax
23443                                           ! Debug: list int = const $26 (used reg = )
23444 6B5B           B8                   0026  mov	ax,*$26
23445 6B5E           50                         push	ax
23446                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23447 6B5F           FF76         FE            push	-2[bp]
23448                                           ! Debug: func () void = write_byte+0 (used reg = )
23449 6B62           E8         9AB9            call	_write_byte
23450 6B65           83C4                   06  add	sp,*6
23451                                           !BCC_EOS
23452                                           ! 3629 }
23453 6B68           89EC                       mov	sp,bp
23454 6B6A           5D                         pop	bp
23455 6B6B           C3                         ret
23456                                           ! 3630   void
23457                                           ! 3631 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23458                                           ! 3632   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23459                                           export	_int13_harddisk
23460                       00006B6C            _int13_harddisk:
23461                                           !BCC_EOS
23462                                           ! 3633 {
23463                                           ! 3634   Bit32u lba_low, lba_high;
23464                                           !BCC_EOS
23465                                           ! 3635   Bit16u ebda_seg=read_word(0x0040,0x000E);
23466 6B6C           55                         push	bp
23467 6B6D           89E5                       mov	bp,sp
23468 6B6F           83C4                   F6  add	sp,*-$A
23469                                           ! Debug: list int = const $E (used reg = )
23470 6B72           B8                   000E  mov	ax,*$E
23471 6B75           50                         push	ax
23472                                           ! Debug: list int = const $40 (used reg = )
23473 6B76           B8                   0040  mov	ax,*$40
23474 6B79           50                         push	ax
23475                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23476 6B7A           E8         9A8E            call	_read_word
23477 6B7D           83C4                   04  add	sp,*4
23478                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
23479 6B80           8946         F6            mov	-$A[bp],ax
23480                                           !BCC_EOS
23481                                           ! 3636   Bit16u cylinder, head, sector;
23482                                           !BCC_EOS
23483                                           ! 3637   Bit16u segment, offset;
23484                                           !BCC_EOS
23485                                           ! 3638   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
23486                                           !BCC_EOS
23487                                           ! 3639   Bit16u size, count;
23488                                           !BCC_EOS
23489                                           ! 3640   Bit8u device, status;
23490                                           !BCC_EOS
23491                                           ! 3641   ;
23492 6B83           83C4                   E4  add	sp,*-$1C
23493                                           !BCC_EOS
23494                                           ! 3642   write_byte(0x0040, 0x008e, 0);
23495                                           ! Debug: list int = const 0 (used reg = )
23496 6B86           31C0                       xor	ax,ax
23497 6B88           50                         push	ax
23498                                           ! Debug: list int = const $8E (used reg = )
23499 6B89           B8                   008E  mov	ax,#$8E
23500 6B8C           50                         push	ax
23501                                           ! Debug: list int = const $40 (used reg = )
23502 6B8D           B8                   0040  mov	ax,*$40
23503 6B90           50                         push	ax
23504                                           ! Debug: func () void = write_byte+0 (used reg = )
23505 6B91           E8         9A8A            call	_write_byte
23506 6B94           83C4                   06  add	sp,*6
23507                                           !BCC_EOS
23508                                           ! 3643   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
23509                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23510 6B97           8A46         10            mov	al,$10[bp]
23511                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
23512 6B9A           3C                     80  cmp	al,#$80
23513 6B9C           72           07            jb  	.507
23514                       00006B9E            .508:
23515                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23516 6B9E           8A46         10            mov	al,$10[bp]
23517                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
23518 6BA1           3C                     88  cmp	al,#$88
23519 6BA3           72           22            jb  	.506
23520                       00006BA5            .507:
23521                                           ! 3644     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23522                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23523 6BA5           8A46         10            mov	al,$10[bp]
23524                                           ! Debug: list unsigned char = al+0 (used reg = )
23525 6BA8           30E4                       xor	ah,ah
23526 6BAA           50                         push	ax
23527                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23528 6BAB           8B46         18            mov	ax,$18[bp]
23529 6BAE           88E0                       mov	al,ah
23530 6BB0           30E4                       xor	ah,ah
23531                                           ! Debug: list unsigned int = ax+0 (used reg = )
23532 6BB2           50                         push	ax
23533                                           ! Debug: list * char = .509+0 (used reg = )
23534 6BB3           BB                   D24A  mov	bx,#.509
23535 6BB6           53                         push	bx
23536                                           ! Debug: list int = const 4 (used reg = )
23537 6BB7           B8                   0004  mov	ax,*4
23538 6BBA           50                         push	ax
23539                                           ! Debug: func () void = bios_printf+0 (used reg = )
23540 6BBB           E8         9DE9            call	_bios_printf
23541 6BBE           83C4                   08  add	sp,*8
23542                                           !BCC_EOS
23543                                           ! 3645     goto int13_fail;
23544 6BC1           83C4                   00  add	sp,#..FFF1+$28
23545 6BC4           E9         0F40            br 	.FFF1
23546                                           !BCC_EOS
23547                                           ! 3646   }
23548                                           ! 3647   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
23549                       00006BC7            .506:
23550                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23551 6BC7           8A46         10            mov	al,$10[bp]
23552                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
23553 6BCA           30E4                       xor	ah,ah
23554                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
23555 6BCC           05                   FF80  add	ax,*-$80
23556 6BCF           89C3                       mov	bx,ax
23557                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
23558                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
23559 6BD1           81C3                 0233  add	bx,#$233
23560 6BD5           53                         push	bx
23561                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23562 6BD6           FF76         F6            push	-$A[bp]
23563                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23564 6BD9           E8         9A1C            call	_read_byte
23565 6BDC           83C4                   04  add	sp,*4
23566                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
23567 6BDF           8846         DB            mov	-$25[bp],al
23568                                           !BCC_EOS
23569                                           ! 3648   if (device >= (4*2)) {
23570                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
23571 6BE2           8A46         DB            mov	al,-$25[bp]
23572 6BE5           3C                     08  cmp	al,*8
23573 6BE7           72           22            jb  	.50A
23574                       00006BE9            .50B:
23575                                           ! 3649     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23576                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23577 6BE9           8A46         10            mov	al,$10[bp]
23578                                           ! Debug: list unsigned char = al+0 (used reg = )
23579 6BEC           30E4                       xor	ah,ah
23580 6BEE           50                         push	ax
23581                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23582 6BEF           8B46         18            mov	ax,$18[bp]
23583 6BF2           88E0                       mov	al,ah
23584 6BF4           30E4                       xor	ah,ah
23585                                           ! Debug: list unsigned int = ax+0 (used reg = )
23586 6BF6           50                         push	ax
23587                                           ! Debug: list * char = .50C+0 (used reg = )
23588 6BF7           BB                   D20C  mov	bx,#.50C
23589 6BFA           53                         push	bx
23590                                           ! Debug: list int = const 4 (used reg = )
23591 6BFB           B8                   0004  mov	ax,*4
23592 6BFE           50                         push	ax
23593                                           ! Debug: func () void = bios_printf+0 (used reg = )
23594 6BFF           E8         9DA5            call	_bios_printf
23595 6C02           83C4                   08  add	sp,*8
23596                                           !BCC_EOS
23597                                           ! 3650     goto int13_fail;
23598 6C05           83C4                   00  add	sp,#..FFF1+$28
23599 6C08           E9         0EFC            br 	.FFF1
23600                                           !BCC_EOS
23601                                           ! 3651   }
23602                                           ! 3652   switch (( AX >> 8 )) {
23603                       00006C0B            .50A:
23604                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23605 6C0B           8B46         18            mov	ax,$18[bp]
23606 6C0E           88E0                       mov	al,ah
23607 6C10           30E4                       xor	ah,ah
23608 6C12           E9         0E71            br 	.50F
23609                                           ! 3653     case 0x00:
23610                                           ! 3654       ata_reset (device);
23611                       00006C15            .510:
23612                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
23613 6C15           8A46         DB            mov	al,-$25[bp]
23614 6C18           30E4                       xor	ah,ah
23615 6C1A           50                         push	ax
23616                                           ! Debug: func () void = ata_reset+0 (used reg = )
23617 6C1B           E8         C0AE            call	_ata_reset
23618 6C1E           44                         inc	sp
23619 6C1F           44                         inc	sp
23620                                           !BCC_EOS
23621                                           ! 3655       goto int13_success;
23622 6C20           83C4                   0E  add	sp,#..FFEF-..FFF0
23623 6C23           E9         0F0E            br 	.FFEF
23624                                           !BCC_EOS
23625                                           ! 3656       break;
23626 6C26           E9         0EDB            br 	.50D
23627                                           !BCC_EOS
23628                                           ! 3657     case 0x01:
23629                                           ! 3658       status = read_byte(0x0040, 0x0074);
23630                       00006C29            .511:
23631                                           ! Debug: list int = const $74 (used reg = )
23632 6C29           B8                   0074  mov	ax,*$74
23633 6C2C           50                         push	ax
23634                                           ! Debug: list int = const $40 (used reg = )
23635 6C2D           B8                   0040  mov	ax,*$40
23636 6C30           50                         push	ax
23637                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23638 6C31           E8         99C4            call	_read_byte
23639 6C34           83C4                   04  add	sp,*4
23640                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23641 6C37           8846         DA            mov	-$26[bp],al
23642                                           !BCC_EOS
23643                                           ! 3659       AX = ((AX & 0x00ff) | ((status) << 8));
23644                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
23645 6C3A           8A46         DA            mov	al,-$26[bp]
23646 6C3D           30E4                       xor	ah,ah
23647 6C3F           88C4                       mov	ah,al
23648 6C41           30C0                       xor	al,al
23649 6C43           50                         push	ax
23650                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
23651 6C44           8A46         18            mov	al,$18[bp]
23652                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23653 6C47           30E4                       xor	ah,ah
23654 6C49           0B46         CA            or	ax,0+..FFF0[bp]
23655 6C4C           44                         inc	sp
23656 6C4D           44                         inc	sp
23657                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23658 6C4E           8946         18            mov	$18[bp],ax
23659                                           !BCC_EOS
23660                                           ! 3660       write_byte(0x0040, 0x0074, 0);
23661                                           ! Debug: list int = const 0 (used reg = )
23662 6C51           31C0                       xor	ax,ax
23663 6C53           50                         push	ax
23664                                           ! Debug: list int = const $74 (used reg = )
23665 6C54           B8                   0074  mov	ax,*$74
23666 6C57           50                         push	ax
23667                                           ! Debug: list int = const $40 (used reg = )
23668 6C58           B8                   0040  mov	ax,*$40
23669 6C5B           50                         push	ax
23670                                           ! Debug: func () void = write_byte+0 (used reg = )
23671 6C5C           E8         99BF            call	_write_byte
23672 6C5F           83C4                   06  add	sp,*6
23673                                           !BCC_EOS
23674                                           ! 3661       if (status) goto int13_fail_nostatus;
23675 6C62           8A46         DA            mov	al,-$26[bp]
23676 6C65           84C0                       test	al,al
23677 6C67           74           08            je  	.512
23678                       00006C69            .513:
23679 6C69           83C4                   0E  add	sp,#..FFEE-..FFF0
23680 6C6C           E9         0EB9            br 	.FFEE
23681                                           !BCC_EOS
23682                                           ! 3662       else goto int13_success_noah;
23683 6C6F           EB           06            jmp .514
23684                       00006C71            .512:
23685 6C71           83C4                   0E  add	sp,#..FFED-..FFF0
23686 6C74           E9         0EC7            br 	.FFED
23687                                           !BCC_EOS
23688                                           ! 3663       break;
23689                       00006C77            .514:
23690 6C77           E9         0E8A            br 	.50D
23691                                           !BCC_EOS
23692                                           ! 3664     case 0x02:
23693                                           ! 3665     case 0x03:
23694                       00006C7A            .515:
23695                                           ! 3666     case 0x04:
23696                       00006C7A            .516:
23697                                           ! 3667       count = ( AX & 0x00ff );
23698                       00006C7A            .517:
23699                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23700 6C7A           8A46         18            mov	al,$18[bp]
23701                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23702 6C7D           30E4                       xor	ah,ah
23703 6C7F           8946         DC            mov	-$24[bp],ax
23704                                           !BCC_EOS
23705                                           ! 3668       cylinder = ( CX >> 8 );
23706                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
23707 6C82           8B46         16            mov	ax,$16[bp]
23708 6C85           88E0                       mov	al,ah
23709 6C87           30E4                       xor	ah,ah
23710                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23711 6C89           8946         F4            mov	-$C[bp],ax
23712                                           !BCC_EOS
23713                                           ! 3669       cylinder |=
23714                                           ! 3669  ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
23715                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23716 6C8C           8A46         16            mov	al,$16[bp]
23717                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
23718 6C8F           30E4                       xor	ah,ah
23719                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
23720 6C91           D1E0                       shl	ax,*1
23721 6C93           D1E0                       shl	ax,*1
23722                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
23723 6C95           25                   0300  and	ax,#$300
23724                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23725 6C98           0B46         F4            or	ax,-$C[bp]
23726 6C9B           8946         F4            mov	-$C[bp],ax
23727                                           !BCC_EOS
23728                                           ! 3670       sector = (( CX & 0x00ff ) & 0x3f);
23729                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23730 6C9E           8A46         16            mov	al,$16[bp]
23731                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
23732 6CA1           24                     3F  and	al,*$3F
23733                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
23734 6CA3           30E4                       xor	ah,ah
23735 6CA5           8946         F0            mov	-$10[bp],ax
23736                                           !BCC_EOS
23737                                           ! 3671       head = ( DX >> 8 );
23738                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
23739 6CA8           8B46         14            mov	ax,$14[bp]
23740 6CAB           88E0                       mov	al,ah
23741 6CAD           30E4                       xor	ah,ah
23742                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
23743 6CAF           8946         F2            mov	-$E[bp],ax
23744                                           !BCC_EOS
23745                                           ! 3672       segment = ES;
23746                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
23747 6CB2           8B46         08            mov	ax,8[bp]
23748 6CB5           8946         EE            mov	-$12[bp],ax
23749                                           !BCC_EOS
23750                                           ! 3673       offset = BX;
23751                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
23752 6CB8           8B46         12            mov	ax,$12[bp]
23753 6CBB           8946         EC            mov	-$14[bp],ax
23754                                           !BCC_EOS
23755                                           ! 3674       if ((count > 128) || (count == 0) || (sector == 0)) {
23756                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23757 6CBE           8B46         DC            mov	ax,-$24[bp]
23758 6CC1           3D                   0080  cmp	ax,#$80
23759 6CC4           77           0E            ja  	.519
23760                       00006CC6            .51B:
23761                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23762 6CC6           8B46         DC            mov	ax,-$24[bp]
23763 6CC9           85C0                       test	ax,ax
23764 6CCB           74           07            je  	.519
23765                       00006CCD            .51A:
23766                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23767 6CCD           8B46         F0            mov	ax,-$10[bp]
23768 6CD0           85C0                       test	ax,ax
23769 6CD2           75           1C            jne 	.518
23770                       00006CD4            .519:
23771                                           ! 3675         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",( AX >> 8 ));
23772                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23773 6CD4           8B46         18            mov	ax,$18[bp]
23774 6CD7           88E0                       mov	al,ah
23775 6CD9           30E4                       xor	ah,ah
23776                                           ! Debug: list unsigned int = ax+0 (used reg = )
23777 6CDB           50                         push	ax
23778                                           ! Debug: list * char = .51C+0 (used reg = )
23779 6CDC           BB                   D1D4  mov	bx,#.51C
23780 6CDF           53                         push	bx
23781                                           ! Debug: list int = const 4 (used reg = )
23782 6CE0           B8                   0004  mov	ax,*4
23783 6CE3           50                         push	ax
23784                                           ! Debug: func () void = bios_printf+0 (used reg = )
23785 6CE4           E8         9CC0            call	_bios_printf
23786 6CE7           83C4                   06  add	sp,*6
23787                                           !BCC_EOS
23788                                           ! 3676         goto int13_fail;
23789 6CEA           83C4                   0E  add	sp,#..FFF1-..FFF0
23790 6CED           E9         0E17            br 	.FFF1
23791                                           !BCC_EOS
23792                                           ! 3677       }
23793                                           ! 3678       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23794                       00006CF0            .518:
23795                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23796 6CF0           8A46         DB            mov	al,-$25[bp]
23797 6CF3           30E4                       xor	ah,ah
23798 6CF5           B9                   001E  mov	cx,*$1E
23799 6CF8           F7E9                       imul	cx
23800 6CFA           89C3                       mov	bx,ax
23801                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23802                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23803 6CFC           81C3                 014E  add	bx,#$14E
23804 6D00           53                         push	bx
23805                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23806 6D01           FF76         F6            push	-$A[bp]
23807                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23808 6D04           E8         9904            call	_read_word
23809 6D07           83C4                   04  add	sp,*4
23810                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23811 6D0A           8946         E4            mov	-$1C[bp],ax
23812                                           !BCC_EOS
23813                                           ! 3679       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23814                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23815 6D0D           8A46         DB            mov	al,-$25[bp]
23816 6D10           30E4                       xor	ah,ah
23817 6D12           B9                   001E  mov	cx,*$1E
23818 6D15           F7E9                       imul	cx
23819 6D17           89C3                       mov	bx,ax
23820                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23821                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23822 6D19           81C3                 014C  add	bx,#$14C
23823 6D1D           53                         push	bx
23824                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23825 6D1E           FF76         F6            push	-$A[bp]
23826                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23827 6D21           E8         98E7            call	_read_word
23828 6D24           83C4                   04  add	sp,*4
23829                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23830 6D27           8946         E2            mov	-$1E[bp],ax
23831                                           !BCC_EOS
23832                                           ! 3680       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23833                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23834 6D2A           8A46         DB            mov	al,-$25[bp]
23835 6D2D           30E4                       xor	ah,ah
23836 6D2F           B9                   001E  mov	cx,*$1E
23837 6D32           F7E9                       imul	cx
23838 6D34           89C3                       mov	bx,ax
23839                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23840                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23841 6D36           81C3                 0150  add	bx,#$150
23842 6D3A           53                         push	bx
23843                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23844 6D3B           FF76         F6            push	-$A[bp]
23845                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23846 6D3E           E8         98CA            call	_read_word
23847 6D41           83C4                   04  add	sp,*4
23848                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23849 6D44           8946         E0            mov	-$20[bp],ax
23850                                           !BCC_EOS
23851                                           ! 3681       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
23852                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23853 6D47           8B46         F4            mov	ax,-$C[bp]
23854 6D4A           3B46         E4            cmp	ax,-$1C[bp]
23855 6D4D           73           10            jae 	.51E
23856                       00006D4F            .520:
23857                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23858 6D4F           8B46         F2            mov	ax,-$E[bp]
23859 6D52           3B46         E2            cmp	ax,-$1E[bp]
23860 6D55           73           08            jae 	.51E
23861                       00006D57            .51F:
23862                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23863 6D57           8B46         F0            mov	ax,-$10[bp]
23864 6D5A           3B46         E0            cmp	ax,-$20[bp]
23865 6D5D           76           25            jbe 	.51D
23866                       00006D5F            .51E:
23867                                           ! 3682         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
23868                                           ! Debug: list unsigned short sector = [S+$28-$12] (used reg = )
23869 6D5F           FF76         F0            push	-$10[bp]
23870                                           ! Debug: list unsigned short head = [S+$2A-$10] (used reg = )
23871 6D62           FF76         F2            push	-$E[bp]
23872                                           ! Debug: list unsigned short cylinder = [S+$2C-$E] (used reg = )
23873 6D65           FF76         F4            push	-$C[bp]
23874                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2E+$16] (used reg = )
23875 6D68           8B46         18            mov	ax,$18[bp]
23876 6D6B           88E0                       mov	al,ah
23877 6D6D           30E4                       xor	ah,ah
23878                                           ! Debug: list unsigned int = ax+0 (used reg = )
23879 6D6F           50                         push	ax
23880                                           ! Debug: list * char = .521+0 (used reg = )
23881 6D70           BB                   D18C  mov	bx,#.521
23882 6D73           53                         push	bx
23883                                           ! Debug: list int = const 4 (used reg = )
23884 6D74           B8                   0004  mov	ax,*4
23885 6D77           50                         push	ax
23886                                           ! Debug: func () void = bios_printf+0 (used reg = )
23887 6D78           E8         9C2C            call	_bios_printf
23888 6D7B           83C4                   0C  add	sp,*$C
23889                                           !BCC_EOS
23890                                           ! 3683         goto int13_fail;
23891 6D7E           83C4                   0E  add	sp,#..FFF1-..FFF0
23892 6D81           E9         0D83            br 	.FFF1
23893                                           !BCC_EOS
23894                                           ! 3684       }
23895                                           ! 3685       if (( AX >> 8 ) == 0x04) goto int13_success;
23896                       00006D84            .51D:
23897                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23898 6D84           8B46         18            mov	ax,$18[bp]
23899 6D87           88E0                       mov	al,ah
23900 6D89           30E4                       xor	ah,ah
23901                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23902 6D8B           3D                   0004  cmp	ax,*4
23903 6D8E           75           06            jne 	.522
23904                       00006D90            .523:
23905 6D90           83C4                   0E  add	sp,#..FFEF-..FFF0
23906 6D93           E9         0D9E            br 	.FFEF
23907                                           !BCC_EOS
23908                                           ! 3686       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23909                       00006D96            .522:
23910                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23911 6D96           8A46         DB            mov	al,-$25[bp]
23912 6D99           30E4                       xor	ah,ah
23913 6D9B           B9                   001E  mov	cx,*$1E
23914 6D9E           F7E9                       imul	cx
23915 6DA0           89C3                       mov	bx,ax
23916                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23917                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23918 6DA2           81C3                 0152  add	bx,#$152
23919 6DA6           53                         push	bx
23920                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23921 6DA7           FF76         F6            push	-$A[bp]
23922                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23923 6DAA           E8         985E            call	_read_word
23924 6DAD           83C4                   04  add	sp,*4
23925                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23926 6DB0           8946         E8            mov	-$18[bp],ax
23927                                           !BCC_EOS
23928                                           ! 3687       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23929                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23930 6DB3           8A46         DB            mov	al,-$25[bp]
23931 6DB6           30E4                       xor	ah,ah
23932 6DB8           B9                   001E  mov	cx,*$1E
23933 6DBB           F7E9                       imul	cx
23934 6DBD           89C3                       mov	bx,ax
23935                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23936                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23937 6DBF           81C3                 0156  add	bx,#$156
23938 6DC3           53                         push	bx
23939                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23940 6DC4           FF76         F6            push	-$A[bp]
23941                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23942 6DC7           E8         9841            call	_read_word
23943 6DCA           83C4                   04  add	sp,*4
23944                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23945 6DCD           8946         E6            mov	-$1A[bp],ax
23946                                           !BCC_EOS
23947                                           ! 3688       if ( (nph != nlh) || (npspt != nlspt)) {
23948                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23949 6DD0           8B46         E8            mov	ax,-$18[bp]
23950 6DD3           3B46         E2            cmp	ax,-$1E[bp]
23951 6DD6           75           08            jne 	.525
23952                       00006DD8            .526:
23953                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23954 6DD8           8B46         E6            mov	ax,-$1A[bp]
23955 6DDB           3B46         E0            cmp	ax,-$20[bp]
23956 6DDE           74           72            je  	.524
23957                       00006DE0            .525:
23958                                           ! 3689         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23959                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23960 6DE0           8B46         F0            mov	ax,-$10[bp]
23961 6DE3           31DB                       xor	bx,bx
23962 6DE5           53                         push	bx
23963 6DE6           50                         push	ax
23964                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23965 6DE7           8B46         E0            mov	ax,-$20[bp]
23966 6DEA           31DB                       xor	bx,bx
23967 6DEC           53                         push	bx
23968 6DED           50                         push	ax
23969                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23970 6DEE           8B46         F2            mov	ax,-$E[bp]
23971 6DF1           31DB                       xor	bx,bx
23972 6DF3           53                         push	bx
23973 6DF4           50                         push	ax
23974                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23975 6DF5           8B46         E2            mov	ax,-$1E[bp]
23976 6DF8           31DB                       xor	bx,bx
23977 6DFA           53                         push	bx
23978 6DFB           50                         push	ax
23979                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23980 6DFC           8B46         F4            mov	ax,-$C[bp]
23981 6DFF           31DB                       xor	bx,bx
23982                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23983 6E01           8D7E         BC            lea	di,-$E+..FFF0[bp]
23984 6E04           E8         92E2            call	lmulul
23985 6E07           83C4                   04  add	sp,*4
23986                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23987 6E0A           8D7E         C0            lea	di,-$A+..FFF0[bp]
23988 6E0D           E8         92B3            call	laddul
23989 6E10           83C4                   04  add	sp,*4
23990                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23991 6E13           8D7E         C4            lea	di,-6+..FFF0[bp]
23992 6E16           E8         92D0            call	lmulul
23993 6E19           83C4                   04  add	sp,*4
23994                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23995 6E1C           8D7E         C8            lea	di,-2+..FFF0[bp]
23996 6E1F           E8         92A1            call	laddul
23997 6E22           83C4                   04  add	sp,*4
23998                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23999 6E25           53                         push	bx
24000 6E26           50                         push	ax
24001 6E27           B8                   0001  mov	ax,*1
24002 6E2A           31DB                       xor	bx,bx
24003 6E2C           53                         push	bx
24004 6E2D           50                         push	ax
24005 6E2E           8B46         C8            mov	ax,-2+..FFF0[bp]
24006 6E31           8B5E         CA            mov	bx,0+..FFF0[bp]
24007 6E34           8D7E         C4            lea	di,-6+..FFF0[bp]
24008 6E37           E8         92A7            call	lsubul
24009 6E3A           83C4                   08  add	sp,*8
24010                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24011 6E3D           8946         FC            mov	-4[bp],ax
24012 6E40           895E         FE            mov	-2[bp],bx
24013                                           !BCC_EOS
24014                                           ! 3690         lba_high = 0;
24015                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24016 6E43           31C0                       xor	ax,ax
24017 6E45           31DB                       xor	bx,bx
24018 6E47           8946         F8            mov	-8[bp],ax
24019 6E4A           895E         FA            mov	-6[bp],bx
24020                                           !BCC_EOS
24021                                           ! 3691         sector = 0;
24022                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
24023 6E4D           31C0                       xor	ax,ax
24024 6E4F           8946         F0            mov	-$10[bp],ax
24025                                           !BCC_EOS
24026                                           ! 3692       }
24027                                           ! 3693       if (( AX >> 8 ) == 0x02)
24028                       00006E52            .524:
24029                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24030 6E52           8B46         18            mov	ax,$18[bp]
24031 6E55           88E0                       mov	al,ah
24032 6E57           30E4                       xor	ah,ah
24033                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
24034 6E59           3D                   0002  cmp	ax,*2
24035 6E5C           75           33            jne 	.527
24036                       00006E5E            .528:
24037                                           ! 3694         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
24038                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24039 6E5E           FF76         EC            push	-$14[bp]
24040                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24041 6E61           FF76         EE            push	-$12[bp]
24042                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24043 6E64           FF76         FA            push	-6[bp]
24044 6E67           FF76         F8            push	-8[bp]
24045                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24046 6E6A           FF76         FE            push	-2[bp]
24047 6E6D           FF76         FC            push	-4[bp]
24048                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
24049 6E70           FF76         F0            push	-$10[bp]
24050                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
24051 6E73           FF76         F2            push	-$E[bp]
24052                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
24053 6E76           FF76         F4            push	-$C[bp]
24054                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24055 6E79           FF76         DC            push	-$24[bp]
24056                                           ! Debug: list int = const $20 (used reg = )
24057 6E7C           B8                   0020  mov	ax,*$20
24058 6E7F           50                         push	ax
24059                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24060 6E80           8A46         DB            mov	al,-$25[bp]
24061 6E83           30E4                       xor	ah,ah
24062 6E85           50                         push	ax
24063                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24064 6E86           E8         BF9B            call	_ata_cmd_data_in
24065 6E89           83C4                   18  add	sp,*$18
24066                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24067 6E8C           8846         DA            mov	-$26[bp],al
24068                                           !BCC_EOS
24069                                           ! 3695       else
24070                                           ! 3696         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
24071 6E8F           EB           31            jmp .529
24072                       00006E91            .527:
24073                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24074 6E91           FF76         EC            push	-$14[bp]
24075                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24076 6E94           FF76         EE            push	-$12[bp]
24077                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24078 6E97           FF76         FA            push	-6[bp]
24079 6E9A           FF76         F8            push	-8[bp]
24080                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24081 6E9D           FF76         FE            push	-2[bp]
24082 6EA0           FF76         FC            push	-4[bp]
24083                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
24084 6EA3           FF76         F0            push	-$10[bp]
24085                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
24086 6EA6           FF76         F2            push	-$E[bp]
24087                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
24088 6EA9           FF76         F4            push	-$C[bp]
24089                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24090 6EAC           FF76         DC            push	-$24[bp]
24091                                           ! Debug: list int = const $30 (used reg = )
24092 6EAF           B8                   0030  mov	ax,*$30
24093 6EB2           50                         push	ax
24094                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24095 6EB3           8A46         DB            mov	al,-$25[bp]
24096 6EB6           30E4                       xor	ah,ah
24097 6EB8           50                         push	ax
24098                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24099 6EB9           E8         C351            call	_ata_cmd_data_out
24100 6EBC           83C4                   18  add	sp,*$18
24101                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24102 6EBF           8846         DA            mov	-$26[bp],al
24103                                           !BCC_EOS
24104                                           ! 3697       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
24105                       00006EC2            .529:
24106                                           ! Debug: list * unsigned short = const $254 (used reg = )
24107 6EC2           B8                   0254  mov	ax,#$254
24108 6EC5           50                         push	ax
24109                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24110 6EC6           FF76         F6            push	-$A[bp]
24111                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24112 6EC9           E8         973F            call	_read_word
24113 6ECC           83C4                   04  add	sp,*4
24114 6ECF           50                         push	ax
24115                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
24116 6ED0           8B46         18            mov	ax,$18[bp]
24117 6ED3           30C0                       xor	al,al
24118                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
24119 6ED5           0B46         CA            or	ax,0+..FFF0[bp]
24120 6ED8           44                         inc	sp
24121 6ED9           44                         inc	sp
24122                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24123 6EDA           8946         18            mov	$18[bp],ax
24124                                           !BCC_EOS
24125                                           ! 3698       if (status != 0) {
24126                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24127 6EDD           8A46         DA            mov	al,-$26[bp]
24128 6EE0           84C0                       test	al,al
24129 6EE2           74           2D            je  	.52A
24130                       00006EE4            .52B:
24131                                           ! 3699         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
24132                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
24133 6EE4           8A46         DA            mov	al,-$26[bp]
24134 6EE7           30E4                       xor	ah,ah
24135 6EE9           50                         push	ax
24136                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
24137 6EEA           8B46         18            mov	ax,$18[bp]
24138 6EED           88E0                       mov	al,ah
24139 6EEF           30E4                       xor	ah,ah
24140                                           ! Debug: list unsigned int = ax+0 (used reg = )
24141 6EF1           50                         push	ax
24142                                           ! Debug: list * char = .52C+0 (used reg = )
24143 6EF2           BB                   D15F  mov	bx,#.52C
24144 6EF5           53                         push	bx
24145                                           ! Debug: list int = const 4 (used reg = )
24146 6EF6           B8                   0004  mov	ax,*4
24147 6EF9           50                         push	ax
24148                                           ! Debug: func () void = bios_printf+0 (used reg = )
24149 6EFA           E8         9AAA            call	_bios_printf
24150 6EFD           83C4                   08  add	sp,*8
24151                                           !BCC_EOS
24152                                           ! 3700         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24153                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24154 6F00           8A46         18            mov	al,$18[bp]
24155                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24156 6F03           30E4                       xor	ah,ah
24157 6F05           0D                   0C00  or	ax,#$C00
24158                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24159 6F08           8946         18            mov	$18[bp],ax
24160                                           !BCC_EOS
24161                                           ! 3701         goto int13_fail_noah;
24162 6F0B           83C4                   0E  add	sp,#..FFEC-..FFF0
24163 6F0E           E9         0C01            br 	.FFEC
24164                                           !BCC_EOS
24165                                           ! 3702       }
24166                                           ! 3703       goto int13_success;
24167                       00006F11            .52A:
24168 6F11           83C4                   0E  add	sp,#..FFEF-..FFF0
24169 6F14           E9         0C1D            br 	.FFEF
24170                                           !BCC_EOS
24171                                           ! 3704       break;
24172 6F17           E9         0BEA            br 	.50D
24173                                           !BCC_EOS
24174                                           ! 3705     case 0x05:
24175                                           ! 3706       bios_printf(4, "format disk track called\n");
24176                       00006F1A            .52D:
24177                                           ! Debug: list * char = .52E+0 (used reg = )
24178 6F1A           BB                   D145  mov	bx,#.52E
24179 6F1D           53                         push	bx
24180                                           ! Debug: list int = const 4 (used reg = )
24181 6F1E           B8                   0004  mov	ax,*4
24182 6F21           50                         push	ax
24183                                           ! Debug: func () void = bios_printf+0 (used reg = )
24184 6F22           E8         9A82            call	_bios_printf
24185 6F25           83C4                   04  add	sp,*4
24186                                           !BCC_EOS
24187                                           ! 3707       goto int13_success;
24188 6F28           83C4                   0E  add	sp,#..FFEF-..FFF0
24189 6F2B           E9         0C06            br 	.FFEF
24190                                           !BCC_EOS
24191                                           ! 3708       return;
24192 6F2E           89EC                       mov	sp,bp
24193 6F30           5D                         pop	bp
24194 6F31           C3                         ret
24195                                           !BCC_EOS
24196                                           ! 3709       break;
24197 6F32           E9         0BCF            br 	.50D
24198                                           !BCC_EOS
24199                                           ! 3710     case 0x08:
24200                                           ! 3711       nlc = read_word(ebda_seg, &((ebda
24201                       00006F35            .52F:
24202                                           ! 3711 _data_t *) 0)->ata.devices[device].lchs.cylinders);
24203                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24204 6F35           8A46         DB            mov	al,-$25[bp]
24205 6F38           30E4                       xor	ah,ah
24206 6F3A           B9                   001E  mov	cx,*$1E
24207 6F3D           F7E9                       imul	cx
24208 6F3F           89C3                       mov	bx,ax
24209                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24210                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24211 6F41           81C3                 014E  add	bx,#$14E
24212 6F45           53                         push	bx
24213                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24214 6F46           FF76         F6            push	-$A[bp]
24215                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24216 6F49           E8         96BF            call	_read_word
24217 6F4C           83C4                   04  add	sp,*4
24218                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24219 6F4F           8946         E4            mov	-$1C[bp],ax
24220                                           !BCC_EOS
24221                                           ! 3712       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24222                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24223 6F52           8A46         DB            mov	al,-$25[bp]
24224 6F55           30E4                       xor	ah,ah
24225 6F57           B9                   001E  mov	cx,*$1E
24226 6F5A           F7E9                       imul	cx
24227 6F5C           89C3                       mov	bx,ax
24228                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24229                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24230 6F5E           81C3                 014C  add	bx,#$14C
24231 6F62           53                         push	bx
24232                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24233 6F63           FF76         F6            push	-$A[bp]
24234                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24235 6F66           E8         96A2            call	_read_word
24236 6F69           83C4                   04  add	sp,*4
24237                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24238 6F6C           8946         E2            mov	-$1E[bp],ax
24239                                           !BCC_EOS
24240                                           ! 3713       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24241                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24242 6F6F           8A46         DB            mov	al,-$25[bp]
24243 6F72           30E4                       xor	ah,ah
24244 6F74           B9                   001E  mov	cx,*$1E
24245 6F77           F7E9                       imul	cx
24246 6F79           89C3                       mov	bx,ax
24247                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24248                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24249 6F7B           81C3                 0150  add	bx,#$150
24250 6F7F           53                         push	bx
24251                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24252 6F80           FF76         F6            push	-$A[bp]
24253                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24254 6F83           E8         9685            call	_read_word
24255 6F86           83C4                   04  add	sp,*4
24256                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24257 6F89           8946         E0            mov	-$20[bp],ax
24258                                           !BCC_EOS
24259                                           ! 3714       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
24260                                           ! Debug: list * unsigned char = const $232 (used reg = )
24261 6F8C           B8                   0232  mov	ax,#$232
24262 6F8F           50                         push	ax
24263                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24264 6F90           FF76         F6            push	-$A[bp]
24265                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24266 6F93           E8         9662            call	_read_byte
24267 6F96           83C4                   04  add	sp,*4
24268                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
24269 6F99           30E4                       xor	ah,ah
24270 6F9B           8946         DC            mov	-$24[bp],ax
24271                                           !BCC_EOS
24272                                           ! 3715       nlc = nlc - 2;
24273                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24274 6F9E           8B46         E4            mov	ax,-$1C[bp]
24275                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24276 6FA1           48                         dec	ax
24277 6FA2           48                         dec	ax
24278 6FA3           8946         E4            mov	-$1C[bp],ax
24279                                           !BCC_EOS
24280                                           ! 3716       AX = ((AX & 0xff00) | (0));
24281                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
24282 6FA6           8B46         18            mov	ax,$18[bp]
24283 6FA9           30C0                       xor	al,al
24284                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
24285 6FAB           0C                     00  or	al,*0
24286                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24287 6FAD           8946         18            mov	$18[bp],ax
24288                                           !BCC_EOS
24289                                           ! 3717       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
24290                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
24291 6FB0           8A46         E4            mov	al,-$1C[bp]
24292                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
24293 6FB3           30E4                       xor	ah,ah
24294 6FB5           88C4                       mov	ah,al
24295 6FB7           30C0                       xor	al,al
24296 6FB9           50                         push	ax
24297                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
24298 6FBA           8A46         16            mov	al,$16[bp]
24299                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24300 6FBD           30E4                       xor	ah,ah
24301 6FBF           0B46         CA            or	ax,0+..FFF0[bp]
24302 6FC2           44                         inc	sp
24303 6FC3           44                         inc	sp
24304                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24305 6FC4           8946         16            mov	$16[bp],ax
24306                                           !BCC_EOS
24307                                           ! 3718       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
24308                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
24309 6FC7           8A46         E0            mov	al,-$20[bp]
24310 6FCA           24                     3F  and	al,*$3F
24311 6FCC           50                         push	ax
24312                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
24313 6FCD           8B46         E4            mov	ax,-$1C[bp]
24314 6FD0           D1E8                       shr	ax,*1
24315 6FD2           D1E8                       shr	ax,*1
24316                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
24317 6FD4           24                     C0  and	al,#$C0
24318                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24319 6FD6           0A46         CA            or	al,0+..FFF0[bp]
24320 6FD9           44                         inc	sp
24321 6FDA           44                         inc	sp
24322 6FDB           50                         push	ax
24323                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
24324 6FDC           8B46         16            mov	ax,$16[bp]
24325 6FDF           30C0                       xor	al,al
24326                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
24327 6FE1           0A46         CA            or	al,0+..FFF0[bp]
24328 6FE4           44                         inc	sp
24329 6FE5           44                         inc	sp
24330                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24331 6FE6           8946         16            mov	$16[bp],ax
24332                                           !BCC_EOS
24333                                           ! 3719       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
24334                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
24335 6FE9           8B46         E2            mov	ax,-$1E[bp]
24336                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
24337 6FEC           48                         dec	ax
24338 6FED           88C4                       mov	ah,al
24339 6FEF           30C0                       xor	al,al
24340 6FF1           50                         push	ax
24341                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
24342 6FF2           8A46         14            mov	al,$14[bp]
24343                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24344 6FF5           30E4                       xor	ah,ah
24345 6FF7           0B46         CA            or	ax,0+..FFF0[bp]
24346 6FFA           44                         inc	sp
24347 6FFB           44                         inc	sp
24348                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24349 6FFC           8946         14            mov	$14[bp],ax
24350                                           !BCC_EOS
24351                                           ! 3720       DX = ((DX & 0xff00) | (count));
24352                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
24353 6FFF           8B46         14            mov	ax,$14[bp]
24354 7002           30C0                       xor	al,al
24355                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
24356 7004           0B46         DC            or	ax,-$24[bp]
24357                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24358 7007           8946         14            mov	$14[bp],ax
24359                                           !BCC_EOS
24360                                           ! 3721       goto int13_success;
24361 700A           83C4                   0E  add	sp,#..FFEF-..FFF0
24362 700D           E9         0B24            br 	.FFEF
24363                                           !BCC_EOS
24364                                           ! 3722       break;
24365 7010           E9         0AF1            br 	.50D
24366                                           !BCC_EOS
24367                                           ! 3723     case 0x10:
24368                                           ! 3724       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
24369                       00007013            .530:
24370                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
24371 7013           8A46         DB            mov	al,-$25[bp]
24372 7016           30E4                       xor	ah,ah
24373 7018           D1E8                       shr	ax,*1
24374                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
24375 701A           B1                     03  mov	cl,*3
24376 701C           D3E0                       shl	ax,cl
24377 701E           89C3                       mov	bx,ax
24378                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24379                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24380 7020           81C3                 0124  add	bx,#$124
24381 7024           53                         push	bx
24382                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24383 7025           FF76         F6            push	-$A[bp]
24384                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24385 7028           E8         95E0            call	_read_word
24386 702B           83C4                   04  add	sp,*4
24387                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
24388                                           ! Debug: list unsigned int = ax+7 (used reg = )
24389 702E           05                   0007  add	ax,*7
24390 7031           50                         push	ax
24391                                           ! Debug: func () unsigned char = inb+0 (used reg = )
24392 7032           E8         950D            call	_inb
24393 7035           44                         inc	sp
24394 7036           44                         inc	sp
24395                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
24396 7037           8846         DA            mov	-$26[bp],al
24397                                           !BCC_EOS
24398                                           ! 3725       if ( (status & (0x80 | 0x40)) == 0x40 ) {
24399                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
24400 703A           8A46         DA            mov	al,-$26[bp]
24401 703D           24                     C0  and	al,#$C0
24402                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
24403 703F           3C                     40  cmp	al,*$40
24404 7041           75           08            jne 	.531
24405                       00007043            .532:
24406                                           ! 3726         goto int13_success;
24407 7043           83C4                   0E  add	sp,#..FFEF-..FFF0
24408 7046           E9         0AEB            br 	.FFEF
24409                                           !BCC_EOS
24410                                           ! 3727       }
24411                                           ! 3728       else {
24412 7049           EB           11            jmp .533
24413                       0000704B            .531:
24414                                           ! 3729         AX = ((AX & 0x00ff) | ((0xAA) << 8));
24415                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24416 704B           8A46         18            mov	al,$18[bp]
24417                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
24418 704E           30E4                       xor	ah,ah
24419 7050           0D                   AA00  or	ax,#-$5600
24420                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24421 7053           8946         18            mov	$18[bp],ax
24422                                           !BCC_EOS
24423                                           ! 3730         goto int13_fail_noah;
24424 7056           83C4                   0E  add	sp,#..FFEC-..FFF0
24425 7059           E9         0AB6            br 	.FFEC
24426                                           !BCC_EOS
24427                                           ! 3731       }
24428                                           ! 3732       break;
24429                       0000705C            .533:
24430 705C           E9         0AA5            br 	.50D
24431                                           !BCC_EOS
24432                                           ! 3733     case 0x15:
24433                                           ! 3734       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
24434                       0000705F            .534:
24435                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24436 705F           8A46         DB            mov	al,-$25[bp]
24437 7062           30E4                       xor	ah,ah
24438 7064           B9                   001E  mov	cx,*$1E
24439 7067           F7E9                       imul	cx
24440 7069           89C3                       mov	bx,ax
24441                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24442                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24443 706B           81C3                 014E  add	bx,#$14E
24444 706F           53                         push	bx
24445                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24446 7070           FF76         F6            push	-$A[bp]
24447                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24448 7073           E8         9595            call	_read_word
24449 7076           83C4                   04  add	sp,*4
24450                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24451 7079           8946         E4            mov	-$1C[bp],ax
24452                                           !BCC_EOS
24453                                           ! 3735       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24454                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24455 707C           8A46         DB            mov	al,-$25[bp]
24456 707F           30E4                       xor	ah,ah
24457 7081           B9                   001E  mov	cx,*$1E
24458 7084           F7E9                       imul	cx
24459 7086           89C3                       mov	bx,ax
24460                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24461                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24462 7088           81C3                 014C  add	bx,#$14C
24463 708C           53                         push	bx
24464                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24465 708D           FF76         F6            push	-$A[bp]
24466                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24467 7090           E8         9578            call	_read_word
24468 7093           83C4                   04  add	sp,*4
24469                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24470 7096           8946         E2            mov	-$1E[bp],ax
24471                                           !BCC_EOS
24472                                           ! 3736       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24473                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24474 7099           8A46         DB            mov	al,-$25[bp]
24475 709C           30E4                       xor	ah,ah
24476 709E           B9                   001E  mov	cx,*$1E
24477 70A1           F7E9                       imul	cx
24478 70A3           89C3                       mov	bx,ax
24479                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24480                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24481 70A5           81C3                 0150  add	bx,#$150
24482 70A9           53                         push	bx
24483                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24484 70AA           FF76         F6            push	-$A[bp]
24485                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24486 70AD           E8         955B            call	_read_word
24487 70B0           83C4                   04  add	sp,*4
24488                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24489 70B3           8946         E0            mov	-$20[bp],ax
24490                                           !BCC_EOS
24491                                           ! 3737       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
24492                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24493 70B6           8B46         E0            mov	ax,-$20[bp]
24494 70B9           31DB                       xor	bx,bx
24495 70BB           53                         push	bx
24496 70BC           50                         push	ax
24497                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
24498 70BD           8B46         E2            mov	ax,-$1E[bp]
24499 70C0           31DB                       xor	bx,bx
24500 70C2           53                         push	bx
24501 70C3           50                         push	ax
24502                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
24503 70C4           8B46         E4            mov	ax,-$1C[bp]
24504                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
24505 70C7           48                         dec	ax
24506 70C8           31DB                       xor	bx,bx
24507                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
24508 70CA           8D7E         C4            lea	di,-6+..FFF0[bp]
24509 70CD           E8         9019            call	lmulul
24510 70D0           83C4                   04  add	sp,*4
24511                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
24512 70D3           8D7E         C8            lea	di,-2+..FFF0[bp]
24513 70D6           E8         9010            call	lmulul
24514 70D9           83C4                   04  add	sp,*4
24515                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24516 70DC           8946         FC            mov	-4[bp],ax
24517 70DF           895E         FE            mov	-2[bp],bx
24518                                           !BCC_EOS
24519                                           ! 3738       CX = lba_low >> 16;
24520                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
24521 70E2           8B46         FC            mov	ax,-4[bp]
24522 70E5           8B5E         FE            mov	bx,-2[bp]
24523 70E8           93                         xchg	bx,ax
24524 70E9           31DB                       xor	bx,bx
24525                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
24526 70EB           8946         16            mov	$16[bp],ax
24527                                           !BCC_EOS
24528                                           ! 3739       DX = lba_low & 0xffff;
24529                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
24530                                           ! Debug: expression subtree swapping
24531 70EE           B8                   FFFF  mov	ax,#$FFFF
24532 70F1           31DB                       xor	bx,bx
24533 70F3           8D7E         FC            lea	di,-4[bp]
24534 70F6           E8         8FC2            call	landul
24535                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
24536 70F9           8946         14            mov	$14[bp],ax
24537                                           !BCC_EOS
24538                                           ! 3740       AX = ((AX & 0x00ff) | ((3) << 8));
24539                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24540 70FC           8A46         18            mov	al,$18[bp]
24541                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
24542 70FF           30E4                       xor	ah,ah
24543 7101           0D                   0300  or	ax,#$300
24544                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24545 7104           8946         18            mov	$18[bp],ax
24546                                           !BCC_EOS
24547                                           ! 3741       goto int13_success_noah;
24548 7107           83C4                   0E  add	sp,#..FFED-..FFF0
24549 710A           E9         0A31            br 	.FFED
24550                                           !BCC_EOS
24551                                           ! 3742       break;
24552 710D           E9         09F4            br 	.50D
24553                                           !BCC_EOS
24554                                           ! 3743     case 0x41:
24555                                           ! 3744       BX=0xaa55;
24556                       00007110            .535:
24557                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
24558 7110           B8                   AA55  mov	ax,#$AA55
24559 7113           8946         12            mov	$12[bp],ax
24560                                           !BCC_EOS
24561                                           ! 3745       AX = ((AX & 0x00ff) | ((0x30) << 8));
24562                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24563 7116           8A46         18            mov	al,$18[bp]
24564                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
24565 7119           30E4                       xor	ah,ah
24566 711B           0D                   3000  or	ax,#$3000
24567                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24568 711E           8946         18            mov	$18[bp],ax
24569                                           !BCC_EOS
24570                                           ! 3746       CX=0x0007;
24571                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
24572 7121           B8                   0007  mov	ax,*7
24573 7124           8946         16            mov	$16[bp],ax
24574                                           !BCC_EOS
24575                                           ! 3747       goto int13_success_noah;
24576 7127           83C4                   0E  add	sp,#..FFED-..FFF0
24577 712A           E9         0A11            br 	.FFED
24578                                           !BCC_EOS
24579                                           ! 3748       break;
24580 712D           E9         09D4            br 	.50D
24581                                           !BCC_EOS
24582                                           ! 3749     case 0x42:
24583                                           ! 3750     case 0x43:
24584                       00007130            .536:
24585                                           ! 3751     case 0x44:
24586                       00007130            .537:
24587                                           ! 3752     case 0x47:
24588                       00007130            .538:
24589                                           ! 3753       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
24590                       00007130            .539:
24591                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
24592 7130           8B46         0C            mov	ax,$C[bp]
24593                                           ! Debug: list unsigned int = ax+2 (used reg = )
24594 7133           40                         inc	ax
24595 7134           40                         inc	ax
24596 7135           50                         push	ax
24597                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24598 7136           FF76         06            push	6[bp]
24599                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24600 7139           E8         94CF            call	_read_word
24601 713C           83C4                   04  add	sp,*4
24602                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24603 713F           8946         DC            mov	-$24[bp],ax
24604                                           !BCC_EOS
24605                                           ! 3754       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
24606                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
24607 7142           8B46         0C            mov	ax,$C[bp]
24608                                           ! Debug: list unsigned int = ax+6 (used reg = )
24609 7145           05                   0006  add	ax,*6
24610 7148           50                         push	ax
24611                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24612 7149           FF76         06            push	6[bp]
24613                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24614 714C           E8         94BC            call	_read_word
24615 714F           83C4                   04  add	sp,*4
24616                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
24617 7152           8946         EE            mov	-$12[bp],ax
24618                                           !BCC_EOS
24619                                           ! 3755       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
24620                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
24621 7155           8B46         0C            mov	ax,$C[bp]
24622                                           ! Debug: list unsigned int = ax+4 (used reg = )
24623 7158           05                   0004  add	ax,*4
24624 715B           50                         push	ax
24625                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24626 715C           FF76         06            push	6[bp]
24627                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24628 715F           E8         94A9            call	_read_word
24629 7162           83C4                   04  add	sp,*4
24630                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
24631 7165           8946         EC            mov	-$14[bp],ax
24632                                           !BCC_EOS
24633                                           ! 3756       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
24634                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
24635 7168           8B46         0C            mov	ax,$C[bp]
24636                                           ! Debug: list unsigned int = ax+$C (used reg = )
24637 716B           05                   000C  add	ax,*$C
24638 716E           50                         push	ax
24639                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24640 716F           FF76         06            push	6[bp]
24641                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24642 7172           E8         8F0E            call	_read_dword
24643 7175           89D3                       mov	bx,dx
24644 7177           83C4                   04  add	sp,*4
24645                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24646 717A           8946         F8            mov	-8[bp],ax
24647 717D           895E         FA            mov	-6[bp],bx
24648                                           !BCC_EOS
24649                                           ! 3757       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
24650                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24651 7180           8A46         DB            mov	al,-$25[bp]
24652 7183           30E4                       xor	ah,ah
24653 7185           B9                   001E  mov	cx,*$1E
24654 7188           F7E9                       imul	cx
24655 718A           89C3                       mov	bx,ax
24656                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24657                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24658 718C           81C3                 015C  add	bx,#$15C
24659 7190           53                         push	bx
24660                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24661 7191           FF76         F6            push	-$A[bp]
24662                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24663 7194           E8         8EEC            call	_read_dword
24664 7197           89D3                       mov	bx,dx
24665 7199           83C4                   04  add	sp,*4
24666                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24667 719C           8D7E         F8            lea	di,-8[bp]
24668 719F           E8         8F29            call	lcmpul
24669 71A2           73           1C            jae 	.53A
24670                       000071A4            .53B:
24671                                           ! 3758         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24672                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24673 71A4           8B46         18            mov	ax,$18[bp]
24674 71A7           88E0                       mov	al,ah
24675 71A9           30E4                       xor	ah,ah
24676                                           ! Debug: list unsigned int = ax+0 (used reg = )
24677 71AB           50                         push	ax
24678                                           ! Debug: list * char = .53C+0 (used reg = )
24679 71AC           BB                   D114  mov	bx,#.53C
24680 71AF           53                         push	bx
24681                                           ! Debug: list int = const 4 (used reg = )
24682 71B0           B8                   0004  mov	ax,*4
24683 71B3           50                         push	ax
24684                                           ! Debug: func () void = bios_printf+0 (used reg = )
24685 71B4           E8         97F0            call	_bios_printf
24686 71B7           83C4                   06  add	sp,*6
24687                                           !BCC_EOS
24688                                           ! 3759 
24689                                           ! 3759         goto int13_fail;
24690 71BA           83C4                   0E  add	sp,#..FFF1-..FFF0
24691 71BD           E9         0947            br 	.FFF1
24692                                           !BCC_EOS
24693                                           ! 3760       }
24694                                           ! 3761       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24695                       000071C0            .53A:
24696                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
24697 71C0           8B46         0C            mov	ax,$C[bp]
24698                                           ! Debug: list unsigned int = ax+8 (used reg = )
24699 71C3           05                   0008  add	ax,*8
24700 71C6           50                         push	ax
24701                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24702 71C7           FF76         06            push	6[bp]
24703                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24704 71CA           E8         8EB6            call	_read_dword
24705 71CD           89D3                       mov	bx,dx
24706 71CF           83C4                   04  add	sp,*4
24707                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24708 71D2           8946         FC            mov	-4[bp],ax
24709 71D5           895E         FE            mov	-2[bp],bx
24710                                           !BCC_EOS
24711                                           ! 3762       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
24712                                           ! 3763           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
24713                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24714 71D8           8A46         DB            mov	al,-$25[bp]
24715 71DB           30E4                       xor	ah,ah
24716 71DD           B9                   001E  mov	cx,*$1E
24717 71E0           F7E9                       imul	cx
24718 71E2           89C3                       mov	bx,ax
24719                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24720                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24721 71E4           81C3                 015C  add	bx,#$15C
24722 71E8           53                         push	bx
24723                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24724 71E9           FF76         F6            push	-$A[bp]
24725                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24726 71EC           E8         8E94            call	_read_dword
24727 71EF           89D3                       mov	bx,dx
24728 71F1           83C4                   04  add	sp,*4
24729                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24730                                           ! Debug: expression subtree swapping
24731 71F4           8D7E         F8            lea	di,-8[bp]
24732 71F7           E8         8ED1            call	lcmpul
24733 71FA           75           40            jne 	.53D
24734                       000071FC            .53F:
24735                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24736 71FC           8A46         DB            mov	al,-$25[bp]
24737 71FF           30E4                       xor	ah,ah
24738 7201           B9                   001E  mov	cx,*$1E
24739 7204           F7E9                       imul	cx
24740 7206           89C3                       mov	bx,ax
24741                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24742                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24743 7208           81C3                 0158  add	bx,#$158
24744 720C           53                         push	bx
24745                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24746 720D           FF76         F6            push	-$A[bp]
24747                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24748 7210           E8         8E70            call	_read_dword
24749 7213           89D3                       mov	bx,dx
24750 7215           83C4                   04  add	sp,*4
24751                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24752 7218           8D7E         FC            lea	di,-4[bp]
24753 721B           E8         8EAD            call	lcmpul
24754 721E           77           1C            ja  	.53D
24755                       00007220            .53E:
24756                                           ! 3764         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24757                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24758 7220           8B46         18            mov	ax,$18[bp]
24759 7223           88E0                       mov	al,ah
24760 7225           30E4                       xor	ah,ah
24761                                           ! Debug: list unsigned int = ax+0 (used reg = )
24762 7227           50                         push	ax
24763                                           ! Debug: list * char = .540+0 (used reg = )
24764 7228           BB                   D0E3  mov	bx,#.540
24765 722B           53                         push	bx
24766                                           ! Debug: list int = const 4 (used reg = )
24767 722C           B8                   0004  mov	ax,*4
24768 722F           50                         push	ax
24769                                           ! Debug: func () void = bios_printf+0 (used reg = )
24770 7230           E8         9774            call	_bios_printf
24771 7233           83C4                   06  add	sp,*6
24772                                           !BCC_EOS
24773                                           ! 3765         goto int13_fail;
24774 7236           83C4                   0E  add	sp,#..FFF1-..FFF0
24775 7239           E9         08CB            br 	.FFF1
24776                                           !BCC_EOS
24777                                           ! 3766       }
24778                                           ! 3767       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24779                       0000723C            .53D:
24780                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24781 723C           8B46         18            mov	ax,$18[bp]
24782 723F           88E0                       mov	al,ah
24783 7241           30E4                       xor	ah,ah
24784                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24785 7243           3D                   0044  cmp	ax,*$44
24786 7246           74           0C            je  	.542
24787                       00007248            .543:
24788                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24789 7248           8B46         18            mov	ax,$18[bp]
24790 724B           88E0                       mov	al,ah
24791 724D           30E4                       xor	ah,ah
24792                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24793 724F           3D                   0047  cmp	ax,*$47
24794 7252           75           06            jne 	.541
24795                       00007254            .542:
24796                                           ! 3768         goto int13_success;
24797 7254           83C4                   0E  add	sp,#..FFEF-..FFF0
24798 7257           E9         08DA            br 	.FFEF
24799                                           !BCC_EOS
24800                                           ! 3769       if (( AX >> 8 ) == 0x42)
24801                       0000725A            .541:
24802                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24803 725A           8B46         18            mov	ax,$18[bp]
24804 725D           88E0                       mov	al,ah
24805 725F           30E4                       xor	ah,ah
24806                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
24807 7261           3D                   0042  cmp	ax,*$42
24808 7264           75           33            jne 	.544
24809                       00007266            .545:
24810                                           ! 3770         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24811                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24812 7266           FF76         EC            push	-$14[bp]
24813                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24814 7269           FF76         EE            push	-$12[bp]
24815                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24816 726C           FF76         FA            push	-6[bp]
24817 726F           FF76         F8            push	-8[bp]
24818                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24819 7272           FF76         FE            push	-2[bp]
24820 7275           FF76         FC            push	-4[bp]
24821                                           ! Debug: list int = const 0 (used reg = )
24822 7278           31C0                       xor	ax,ax
24823 727A           50                         push	ax
24824                                           ! Debug: list int = const 0 (used reg = )
24825 727B           31C0                       xor	ax,ax
24826 727D           50                         push	ax
24827                                           ! Debug: list int = const 0 (used reg = )
24828 727E           31C0                       xor	ax,ax
24829 7280           50                         push	ax
24830                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24831 7281           FF76         DC            push	-$24[bp]
24832                                           ! Debug: list int = const $20 (used reg = )
24833 7284           B8                   0020  mov	ax,*$20
24834 7287           50                         push	ax
24835                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24836 7288           8A46         DB            mov	al,-$25[bp]
24837 728B           30E4                       xor	ah,ah
24838 728D           50                         push	ax
24839                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24840 728E           E8         BB93            call	_ata_cmd_data_in
24841 7291           83C4                   18  add	sp,*$18
24842                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24843 7294           8846         DA            mov	-$26[bp],al
24844                                           !BCC_EOS
24845                                           ! 3771       else
24846                                           ! 3772         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24847 7297           EB           31            jmp .546
24848                       00007299            .544:
24849                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24850 7299           FF76         EC            push	-$14[bp]
24851                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24852 729C           FF76         EE            push	-$12[bp]
24853                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24854 729F           FF76         FA            push	-6[bp]
24855 72A2           FF76         F8            push	-8[bp]
24856                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24857 72A5           FF76         FE            push	-2[bp]
24858 72A8           FF76         FC            push	-4[bp]
24859                                           ! Debug: list int = const 0 (used reg = )
24860 72AB           31C0                       xor	ax,ax
24861 72AD           50                         push	ax
24862                                           ! Debug: list int = const 0 (used reg = )
24863 72AE           31C0                       xor	ax,ax
24864 72B0           50                         push	ax
24865                                           ! Debug: list int = const 0 (used reg = )
24866 72B1           31C0                       xor	ax,ax
24867 72B3           50                         push	ax
24868                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24869 72B4           FF76         DC            push	-$24[bp]
24870                                           ! Debug: list int = const $30 (used reg = )
24871 72B7           B8                   0030  mov	ax,*$30
24872 72BA           50                         push	ax
24873                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24874 72BB           8A46         DB            mov	al,-$25[bp]
24875 72BE           30E4                       xor	ah,ah
24876 72C0           50                         push	ax
24877                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24878 72C1           E8         BF49            call	_ata_cmd_data_out
24879 72C4           83C4                   18  add	sp,*$18
24880                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24881 72C7           8846         DA            mov	-$26[bp],al
24882                                           !BCC_EOS
24883                                           ! 3773       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24884                       000072CA            .546:
24885                                           ! Debug: list * unsigned short = const $254 (used reg = )
24886 72CA           B8                   0254  mov	ax,#$254
24887 72CD           50                         push	ax
24888                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24889 72CE           FF76         F6            push	-$A[bp]
24890                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24891 72D1           E8         9337            call	_read_word
24892 72D4           83C4                   04  add	sp,*4
24893                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24894 72D7           8946         DC            mov	-$24[bp],ax
24895                                           !BCC_EOS
24896                                           ! 3774       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24897                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24898 72DA           FF76         DC            push	-$24[bp]
24899                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24900 72DD           8B46         0C            mov	ax,$C[bp]
24901                                           ! Debug: list unsigned int = ax+2 (used reg = )
24902 72E0           40                         inc	ax
24903 72E1           40                         inc	ax
24904 72E2           50                         push	ax
24905                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24906 72E3           FF76         06            push	6[bp]
24907                                           ! Debug: func () void = write_word+0 (used reg = )
24908 72E6           E8         934D            call	_write_word
24909 72E9           83C4                   06  add	sp,*6
24910                                           !BCC_EOS
24911                                           ! 3775       if (status != 0) {
24912                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24913 72EC           8A46         DA            mov	al,-$26[bp]
24914 72EF           84C0                       test	al,al
24915 72F1           74           2D            je  	.547
24916                       000072F3            .548:
24917                                           ! 3776         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
24918                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
24919 72F3           8A46         DA            mov	al,-$26[bp]
24920 72F6           30E4                       xor	ah,ah
24921 72F8           50                         push	ax
24922                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
24923 72F9           8B46         18            mov	ax,$18[bp]
24924 72FC           88E0                       mov	al,ah
24925 72FE           30E4                       xor	ah,ah
24926                                           ! Debug: list unsigned int = ax+0 (used reg = )
24927 7300           50                         push	ax
24928                                           ! Debug: list * char = .549+0 (used reg = )
24929 7301           BB                   D0B6  mov	bx,#.549
24930 7304           53                         push	bx
24931                                           ! Debug: list int = const 4 (used reg = )
24932 7305           B8                   0004  mov	ax,*4
24933 7308           50                         push	ax
24934                                           ! Debug: func () void = bios_printf+0 (used reg = )
24935 7309           E8         969B            call	_bios_printf
24936 730C           83C4                   08  add	sp,*8
24937                                           !BCC_EOS
24938                                           ! 3777         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24939                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24940 730F           8A46         18            mov	al,$18[bp]
24941                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24942 7312           30E4                       xor	ah,ah
24943 7314           0D                   0C00  or	ax,#$C00
24944                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24945 7317           8946         18            mov	$18[bp],ax
24946                                           !BCC_EOS
24947                                           ! 3778         goto int13_fail_noah;
24948 731A           83C4                   0E  add	sp,#..FFEC-..FFF0
24949 731D           E9         07F2            br 	.FFEC
24950                                           !BCC_EOS
24951                                           ! 3779       }
24952                                           ! 3780       goto int13_success;
24953                       00007320            .547:
24954 7320           83C4                   0E  add	sp,#..FFEF-..FFF0
24955 7323           E9         080E            br 	.FFEF
24956                                           !BCC_EOS
24957                                           ! 3781       break;
24958 7326           E9         07DB            br 	.50D
24959                                           !BCC_EOS
24960                                           ! 3782     case 0x45:
24961                                           ! 3783     case 0x49:
24962                       00007329            .54A:
24963                                           ! 3784       goto int13_success;
24964                       00007329            .54B:
24965 7329           83C4                   0E  add	sp,#..FFEF-..FFF0
24966 732C           E9         0805            br 	.FFEF
24967                                           !BCC_EOS
24968                                           ! 3785       break;
24969 732F           E9         07D2            br 	.50D
24970                                           !BCC_EOS
24971                                           ! 3786     case 0x46:
24972                                           ! 3787       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24973                       00007332            .54C:
24974                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24975 7332           8A46         18            mov	al,$18[bp]
24976                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24977 7335           30E4                       xor	ah,ah
24978 7337           0D                   B200  or	ax,#-$4E00
24979                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24980 733A           8946         18            mov	$18[bp],ax
24981                                           !BCC_EOS
24982                                           ! 3788       goto int13_fail_noah;
24983 733D           83C4                   0E  add	sp,#..FFEC-..FFF0
24984 7340           E9         07CF            br 	.FFEC
24985                                           !BCC_EOS
24986                                           ! 3789       break;
24987 7343           E9         07BE            br 	.50D
24988                                           !BCC_EOS
24989                                           ! 3790     case 0x48:
24990                                           ! 3791       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24991                       00007346            .54D:
24992                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24993 7346           8B46         0C            mov	ax,$C[bp]
24994                                           ! Debug: list unsigned int = ax+0 (used reg = )
24995 7349           50                         push	ax
24996                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24997 734A           FF76         06            push	6[bp]
24998                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24999 734D           E8         92BB            call	_read_word
25000 7350           83C4                   04  add	sp,*4
25001                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
25002 7353           8946         DE            mov	-$22[bp],ax
25003                                           !BCC_EOS
25004                                           ! 3792       if(size < 0x1a)
25005                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
25006 7356           8B46         DE            mov	ax,-$22[bp]
25007 7359           3D                   001A  cmp	ax,*$1A
25008 735C           73           06            jae 	.54E
25009                       0000735E            .54F:
25010                                           ! 3793         goto int13_fail;
25011 735E           83C4                   0E  add	sp,#..FFF1-..FFF0
25012 7361           E9         07A3            br 	.FFF1
25013                                           !BCC_EOS
25014                                           ! 3794       if(size >= 0x1a) {
25015                       00007364            .54E:
25016                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
25017 7364           8B46         DE            mov	ax,-$22[bp]
25018 7367           3D                   001A  cmp	ax,*$1A
25019 736A         0F82         01E3            blo 	.550
25020                       0000736E            .551:
25021                                           ! 3795         Bit16u blksize;
25022                                           !BCC_EOS
25023                                           ! 3796         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
25024                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25025 736E           8A46         DB            mov	al,-$25[bp]
25026 7371           30E4                       xor	ah,ah
25027 7373           B9                   001E  mov	cx,*$1E
25028 7376           F7E9                       imul	cx
25029 7378           89C3                       mov	bx,ax
25030                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
25031                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
25032 737A           81C3                 0154  add	bx,#$154
25033 737E           53                         push	bx
25034                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25035 737F           FF76         F6            push	-$A[bp]
25036                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25037 7382           E8         9286            call	_read_word
25038 7385           83C4                   04  add	sp,*4
25039                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
25040 7388           8946         EA            mov	-$16[bp],ax
25041                                           !BCC_EOS
25042                                           ! 3797         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
25043                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25044 738B           8A46         DB            mov	al,-$25[bp]
25045 738E           30E4                       xor	ah,ah
25046 7390           B9                   001E  mov	cx,*$1E
25047 7393           F7E9                       imul	cx
25048 7395           89C3                       mov	bx,ax
25049                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
25050                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
25051 7397           81C3                 0152  add	bx,#$152
25052 739B           53                         push	bx
25053                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25054 739C           FF76         F6            push	-$A[bp]
25055                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25056 739F           E8         9269            call	_read_word
25057 73A2           83C4                   04  add	sp,*4
25058                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25059 73A5           8946         E8            mov	-$18[bp],ax
25060                                           !BCC_EOS
25061                                           ! 3798         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
25062                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25063 73A8           8A46         DB            mov	al,-$25[bp]
25064 73AB           30E4                       xor	ah,ah
25065 73AD           B9                   001E  mov	cx,*$1E
25066 73B0           F7E9                       imul	cx
25067 73B2           89C3                       mov	bx,ax
25068                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
25069                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
25070 73B4           81C3                 0156  add	bx,#$156
25071 73B8           53                         push	bx
25072                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25073 73B9           FF76         F6            push	-$A[bp]
25074                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25075 73BC           E8         924C            call	_read_word
25076 73BF           83C4                   04  add	sp,*4
25077                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
25078 73C2           8946         E6            mov	-$1A[bp],ax
25079                                           !BCC_EOS
25080                                           ! 3799         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
25081                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25082 73C5           8A46         DB            mov	al,-$25[bp]
25083 73C8           30E4                       xor	ah,ah
25084 73CA           B9                   001E  mov	cx,*$1E
25085 73CD           F7E9                       imul	cx
25086 73CF           89C3                       mov	bx,ax
25087                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
25088                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
25089 73D1           81C3                 0158  add	bx,#$158
25090 73D5           53                         push	bx
25091                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25092 73D6           FF76         F6            push	-$A[bp]
25093                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
25094 73D9           E8         8CA7            call	_read_dword
25095 73DC           89D3                       mov	bx,dx
25096 73DE           83C4                   04  add	sp,*4
25097                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
25098 73E1           8946         FC            mov	-4[bp],ax
25099 73E4           895E         FE            mov	-2[bp],bx
25100                                           !BCC_EOS
25101                                           ! 3800         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
25102                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25103 73E7           8A46         DB            mov	al,-$25[bp]
25104 73EA           30E4                       xor	ah,ah
25105 73EC           B9                   001E  mov	cx,*$1E
25106 73EF           F7E9                       imul	cx
25107 73F1           89C3                       mov	bx,ax
25108                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
25109                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
25110 73F3           81C3                 015C  add	bx,#$15C
25111 73F7           53                         push	bx
25112                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25113 73F8           FF76         F6            push	-$A[bp]
25114                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
25115 73FB           E8         8C85            call	_read_dword
25116 73FE           89D3                       mov	bx,dx
25117 7400           83C4                   04  add	sp,*4
25118                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
25119 7403           8946         F8            mov	-8[bp],ax
25120 7406           895E         FA            mov	-6[bp],bx
25121                                           !BCC_EOS
25122                                           ! 3801         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
25123                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25124 7409           8A46         DB            mov	al,-$25[bp]
25125 740C           30E4                       xor	ah,ah
25126 740E           B9                   001E  mov	cx,*$1E
25127 7411           F7E9                       imul	cx
25128 7413           89C3                       mov	bx,ax
25129                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
25130                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
25131 7415           81C3                 0148  add	bx,#$148
25132 7419           53                         push	bx
25133                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25134 741A           FF76         F6            push	-$A[bp]
25135                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25136 741D           E8         91EB            call	_read_word
25137 7420           83C4                   04  add	sp,*4
25138                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
25139 7423           8946         D8            mov	-$28[bp],ax
25140                                           !BCC_EOS
25141                                           ! 3802         write_word(DS,
25142                                           ! 3802  SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
25143                                           ! Debug: list int = const $1A (used reg = )
25144 7426           B8                   001A  mov	ax,*$1A
25145 7429           50                         push	ax
25146                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
25147 742A           8B46         0C            mov	ax,$C[bp]
25148                                           ! Debug: list unsigned int = ax+0 (used reg = )
25149 742D           50                         push	ax
25150                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25151 742E           FF76         06            push	6[bp]
25152                                           ! Debug: func () void = write_word+0 (used reg = )
25153 7431           E8         9202            call	_write_word
25154 7434           83C4                   06  add	sp,*6
25155                                           !BCC_EOS
25156                                           ! 3803         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
25157 7437           8B46         F8            mov	ax,-8[bp]
25158 743A           8B5E         FA            mov	bx,-6[bp]
25159 743D           E8         8CD4            call	ltstl
25160 7440           75           50            jne 	.553
25161                       00007442            .554:
25162                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25163 7442           8B46         E8            mov	ax,-$18[bp]
25164 7445           31DB                       xor	bx,bx
25165 7447           53                         push	bx
25166 7448           50                         push	ax
25167                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
25168 7449           8B46         E6            mov	ax,-$1A[bp]
25169 744C           31DB                       xor	bx,bx
25170                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
25171 744E           53                         push	bx
25172 744F           50                         push	ax
25173 7450           8B46         FC            mov	ax,-4[bp]
25174 7453           8B5E         FE            mov	bx,-2[bp]
25175 7456           8D7E         C4            lea	di,-6+..FFF0[bp]
25176 7459           E8         8D12            call	ldivul
25177 745C           83C4                   04  add	sp,*4
25178                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
25179 745F           8D7E         C8            lea	di,-2+..FFF0[bp]
25180 7462           E8         8D09            call	ldivul
25181 7465           83C4                   04  add	sp,*4
25182                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
25183 7468           53                         push	bx
25184 7469           50                         push	ax
25185 746A           B8                   3FFF  mov	ax,#$3FFF
25186 746D           31DB                       xor	bx,bx
25187 746F           53                         push	bx
25188 7470           50                         push	ax
25189 7471           8B46         C8            mov	ax,-2+..FFF0[bp]
25190 7474           8B5E         CA            mov	bx,0+..FFF0[bp]
25191 7477           8D7E         C4            lea	di,-6+..FFF0[bp]
25192 747A           E8         8C4E            call	lcmpul
25193 747D           76           04            jbe	.555
25194 747F           B0                     01  mov	al,*1
25195 7481           EB           02            jmp	.556
25196                       00007483            .555:
25197 7483           30C0                       xor	al,al
25198                       00007485            .556:
25199 7485           83C4                   08  add	sp,*8
25200                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
25201 7488           30E4                       xor	ah,ah
25202 748A           99                         cwd
25203 748B           89D3                       mov	bx,dx
25204 748D           E8         8C84            call	ltstl
25205 7490           74           28            je  	.552
25206                       00007492            .553:
25207                                           ! 3804         {
25208                                           ! 3805           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
25209                                           ! Debug: list int = const 0 (used reg = )
25210 7492           31C0                       xor	ax,ax
25211 7494           50                         push	ax
25212                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25213 7495           8B46         0C            mov	ax,$C[bp]
25214                                           ! Debug: list unsigned int = ax+2 (used reg = )
25215 7498           40                         inc	ax
25216 7499           40                         inc	ax
25217 749A           50                         push	ax
25218                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25219 749B           FF76         06            push	6[bp]
25220                                           ! Debug: func () void = write_word+0 (used reg = )
25221 749E           E8         9195            call	_write_word
25222 74A1           83C4                   06  add	sp,*6
25223                                           !BCC_EOS
25224                                           ! 3806           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
25225                                           ! Debug: list int = const $3FFF (used reg = )
25226 74A4           B8                   3FFF  mov	ax,#$3FFF
25227 74A7           50                         push	ax
25228                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
25229 74A8           8B46         0C            mov	ax,$C[bp]
25230                                           ! Debug: list unsigned int = ax+4 (used reg = )
25231 74AB           05                   0004  add	ax,*4
25232 74AE           50                         push	ax
25233                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25234 74AF           FF76         06            push	6[bp]
25235                                           ! Debug: func () void = write_dword+0 (used reg = )
25236 74B2           E8         8BE6            call	_write_dword
25237 74B5           83C4                   06  add	sp,*6
25238                                           !BCC_EOS
25239                                           ! 3807         }
25240                                           ! 3808         else
25241                                           ! 3809         {
25242 74B8           EB           2A            jmp .558
25243                       000074BA            .552:
25244                                           ! 3810           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
25245                                           ! Debug: list int = const 2 (used reg = )
25246 74BA           B8                   0002  mov	ax,*2
25247 74BD           50                         push	ax
25248                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25249 74BE           8B46         0C            mov	ax,$C[bp]
25250                                           ! Debug: list unsigned int = ax+2 (used reg = )
25251 74C1           40                         inc	ax
25252 74C2           40                         inc	ax
25253 74C3           50                         push	ax
25254                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25255 74C4           FF76         06            push	6[bp]
25256                                           ! Debug: func () void = write_word+0 (used reg = )
25257 74C7           E8         916C            call	_write_word
25258 74CA           83C4                   06  add	sp,*6
25259                                           !BCC_EOS
25260                                           ! 3811           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
25261                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
25262 74CD           8B46         EA            mov	ax,-$16[bp]
25263 74D0           31DB                       xor	bx,bx
25264                                           ! Debug: list unsigned long = bx+0 (used reg = )
25265 74D2           53                         push	bx
25266 74D3           50                         push	ax
25267                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
25268 74D4           8B46         0C            mov	ax,$C[bp]
25269                                           ! Debug: list unsigned int = ax+4 (used reg = )
25270 74D7           05                   0004  add	ax,*4
25271 74DA           50                         push	ax
25272                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25273 74DB           FF76         06            push	6[bp]
25274                                           ! Debug: func () void = write_dword+0 (used reg = )
25275 74DE           E8         8BBA            call	_write_dword
25276 74E1           83C4                   08  add	sp,*8
25277                                           !BCC_EOS
25278                                           ! 3812         }
25279                                           ! 3813         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
25280                       000074E4            .558:
25281                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25282 74E4           8B46         E8            mov	ax,-$18[bp]
25283 74E7           31DB                       xor	bx,bx
25284                                           ! Debug: list unsigned long = bx+0 (used reg = )
25285 74E9           53                         push	bx
25286 74EA           50                         push	ax
25287                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
25288 74EB           8B46         0C            mov	ax,$C[bp]
25289                                           ! Debug: list unsigned int = ax+8 (used reg = )
25290 74EE           05                   0008  add	ax,*8
25291 74F1           50                         push	ax
25292                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25293 74F2           FF76         06            push	6[bp]
25294                                           ! Debug: func () void = write_dword+0 (used reg = )
25295 74F5           E8         8BA3            call	_write_dword
25296 74F8           83C4                   08  add	sp,*8
25297                                           !BCC_EOS
25298                                           ! 3814         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
25299                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
25300 74FB           8B46         E6            mov	ax,-$1A[bp]
25301 74FE           31DB                       xor	bx,bx
25302                                           ! Debug: list unsigned long = bx+0 (used reg = )
25303 7500           53                         push	bx
25304 7501           50                         push	ax
25305                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
25306 7502           8B46         0C            mov	ax,$C[bp]
25307                                           ! Debug: list unsigned int = ax+$C (used reg = )
25308 7505           05                   000C  add	ax,*$C
25309 7508           50                         push	ax
25310                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25311 7509           FF76         06            push	6[bp]
25312                                           ! Debug: func () void = write_dword+0 (used reg = )
25313 750C           E8         8B8C            call	_write_dword
25314 750F           83C4                   08  add	sp,*8
25315                                           !BCC_EOS
25316                                           ! 3815         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
25317                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
25318 7512           FF76         FE            push	-2[bp]
25319 7515           FF76         FC            push	-4[bp]
25320                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
25321 7518           8B46         0C            mov	ax,$C[bp]
25322                                           ! Debug: list unsigned int = ax+$10 (used reg = )
25323 751B           05                   0010  add	ax,*$10
25324 751E           50                         push	ax
25325                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25326 751F           FF76         06            push	6[bp]
25327                                           ! Debug: func () void = write_dword+0 (used reg = )
25328 7522           E8         8B76            call	_write_dword
25329 7525           83C4                   08  add	sp,*8
25330                                           !BCC_EOS
25331                                           ! 3816         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
25332                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
25333 7528           FF76         FA            push	-6[bp]
25334 752B           FF76         F8            push	-8[bp]
25335                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
25336 752E           8B46         0C            mov	ax,$C[bp]
25337                                           ! Debug: list unsigned int = ax+$14 (used reg = )
25338 7531           05                   0014  add	ax,*$14
25339 7534           50                         push	ax
25340                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25341 7535           FF76         06            push	6[bp]
25342                                           ! Debug: func () void = write_dword+0 (used reg = )
25343 7538           E8         8B60            call	_write_dword
25344 753B           83C4                   08  add	sp,*8
25345                                           !BCC_EOS
25346                                           ! 3817         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
25347                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
25348 753E           FF76         D8            push	-$28[bp]
25349                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
25350 7541           8B46         0C            mov	ax,$C[bp]
25351                                           ! Debug: list unsigned int = ax+$18 (used reg = )
25352 7544           05                   0018  add	ax,*$18
25353 7547           50                         push	ax
25354                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25355 7548           FF76         06            push	6[bp]
25356                                           ! Debug: func () void = write_word+0 (used reg = )
25357 754B           E8         90E8            call	_write_word
25358 754E           83C4                   06  add	sp,*6
25359                                           !BCC_EOS
25360                                           ! 3818       }
25361                                           ! 3819       if(size >= 0x1e) {
25362                       00007551            .550:
25363                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
25364 7551           8B46         DE            mov	ax,-$22[bp]
25365 7554           3D                   001E  cmp	ax,*$1E
25366 7557         0F82         0273            blo 	.559
25367                       0000755B            .55A:
25368                                           ! 3820         Bit8u channel, dev, irq, mode, checksum, i, translation;
25369                                           !BCC_EOS
25370                                           ! 3821         Bit16u iobase1, iobase2, options;
25371                                           !BCC_EOS
25372                                           ! 3822         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
25373                                           ! Debug: list int = const $1E (used reg = )
25374 755B           B8                   001E  mov	ax,*$1E
25375 755E           50                         push	ax
25376                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
25377 755F           8B46         0C            mov	ax,$C[bp]
25378                                           ! Debug: list unsigned int = ax+0 (used reg = )
25379 7562           50                         push	ax
25380                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25381 7563           FF76         06            push	6[bp]
25382                                           ! Debug: func () void = write_word+0 (used reg = )
25383 7566           E8         90CD            call	_write_word
25384 7569           83C4                   06  add	sp,*6
25385                                           !BCC_EOS
25386                                           ! 3823         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
25387                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
25388 756C           FF76         F6            push	-$A[bp]
25389                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
25390 756F           8B46         0C            mov	ax,$C[bp]
25391                                           ! Debug: list unsigned int = ax+$1C (used reg = )
25392 7572           05                   001C  add	ax,*$1C
25393 7575           50                         push	ax
25394                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25395 7576           FF76         06            push	6[bp]
25396                                           ! Debug: func () void = write_word+0 (used reg = )
25397 7579           E8         90BA            call	_write_word
25398 757C           83C4                   06  add	sp,*6
25399                                           !BCC_EOS
25400                                           ! 3824         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
25401                                           ! Debug: list * struct  = const $244 (used reg = )
25402 757F           B8                   0244  mov	ax,#$244
25403 7582           50                         push	ax
25404                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
25405 7583           8B46         0C            mov	ax,$C[bp]
25406                                           ! Debug: list unsigned int = ax+$1A (used reg = )
25407 7586           05                   001A  add	ax,*$1A
25408 7589           50                         push	ax
25409                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25410 758A           FF76         06            push	6[bp]
25411                                           ! Debug: func () void = write_word+0 (used reg = )
25412 758D           E8         90A6            call	_write_word
25413 7590           83C4                   06  add	sp,*6
25414                                           !BCC_EOS
25415                                           ! 3825         channel = device / 2;
25416                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25417 7593           8A46         DB            mov	al,-$25[bp]
25418 7596           30E4                       xor	ah,ah
25419 7598           D1E8                       shr	ax,*1
25420                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
25421 759A           8846         D9            mov	-$27[bp],al
25422                                           !BCC_EOS
25423                                           ! 3826         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25424                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25425 759D           8A46         D9            mov	al,-$27[bp]
25426 75A0           30E4                       xor	ah,ah
25427 75A2           B1                     03  mov	cl,*3
25428 75A4           D3E0                       shl	ax,cl
25429 75A6           89C3                       mov	bx,ax
25430                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25431                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25432 75A8           81C3                 0124  add	bx,#$124
25433 75AC           53                         push	bx
25434                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25435 75AD           FF76         F6            push	-$A[bp]
25436                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25437 75B0           E8         9058            call	_read_word
25438 75B3           83C4                   04  add	sp,*4
25439                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
25440 75B6           8946         D0            mov	-$30[bp],ax
25441                                           !BCC_EOS
25442                                           ! 3827         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
25443                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25444 75B9           8A46         D9            mov	al,-$27[bp]
25445 75BC           30E4                       xor	ah,ah
25446 75BE           B1                     03  mov	cl,*3
25447 75C0           D3E0                       shl	ax,cl
25448 75C2           89C3                       mov	bx,ax
25449                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
25450                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
25451 75C4           81C3                 0126  add	bx,#$126
25452 75C8           53                         push	bx
25453                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25454 75C9           FF76         F6            push	-$A[bp]
25455                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25456 75CC           E8         903C            call	_read_word
25457 75CF           83C4                   04  add	sp,*4
25458                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25459 75D2           8946         CE            mov	-$32[bp],ax
25460                                           !BCC_EOS
25461                                           ! 3828         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
25462                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25463 75D5           8A46         D9            mov	al,-$27[bp]
25464 75D8           30E4                       xor	ah,ah
25465 75DA           B1                     03  mov	cl,*3
25466 75DC           D3E0                       shl	ax,cl
25467 75DE           89C3                       mov	bx,ax
25468                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
25469                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
25470 75E0           81C3                 0128  add	bx,#$128
25471 75E4           53                         push	bx
25472                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25473 75E5           FF76         F6            push	-$A[bp]
25474                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25475 75E8           E8         900D            call	_read_byte
25476 75EB           83C4                   04  add	sp,*4
25477                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
25478 75EE           8846         D7            mov	-$29[bp],al
25479                                           !BCC_EOS
25480                                           ! 3829         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
25481                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25482 75F1           8A46         DB            mov	al,-$25[bp]
25483 75F4           30E4                       xor	ah,ah
25484 75F6           B9                   001E  mov	cx,*$1E
25485 75F9           F7E9                       imul	cx
25486 75FB           89C3                       mov	bx,ax
25487                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
25488                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
25489 75FD           81C3                 0146  add	bx,#$146
25490 7601           53                         push	bx
25491                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25492 7602           FF76         F6            push	-$A[bp]
25493                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25494 7605           E8         8FF0            call	_read_byte
25495 7608           83C4                   04  add	sp,*4
25496                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
25497 760B           8846         D6            mov	-$2A[bp],al
25498                                           !BCC_EOS
25499                                           ! 3830         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
25500                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25501 760E           8A46         DB            mov	al,-$25[bp]
25502 7611           30E4                       xor	ah,ah
25503 7613           B9                   001E  mov	cx,*$1E
25504 7616           F7E9                       imul	cx
25505 7618           89C3                       mov	bx,ax
25506                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
25507                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
25508 761A           81C3                 014A  add	bx,#$14A
25509 761E           53                         push	bx
25510                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25511 761F           FF76         F6            push	-$A[bp]
25512                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25513 7622           E8         8FD3            call	_read_byte
25514 7625           83C4                   04  add	sp,*4
25515                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
25516 7628           8846         D3            mov	-$2D[bp],al
25517                                           !BCC_EOS
25518                                           ! 3831         options = (translation==0?0:1)<<3;
25519                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
25520 762B           8A46         D3            mov	al,-$2D[bp]
25521 762E           84C0                       test	al,al
25522 7630           75           04            jne 	.55B
25523                       00007632            .55C:
25524 7632           30C0                       xor	al,al
25525 7634           EB           02            jmp .55D
25526                       00007636            .55B:
25527 7636           B0                     01  mov	al,*1
25528                       00007638            .55D:
25529                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
25530 7638           30E4                       xor	ah,ah
25531 763A           B1                     03  mov	cl,*3
25532 763C           D3E0                       shl	ax,cl
25533                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25534 763E           8946         CC            mov	-$34[bp],ax
25535                                           !BCC_EOS
25536                                           ! 3832         options |= (1<<4);
25537                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
25538 7641           8B46         CC            mov	ax,-$34[bp]
25539 7644           0C                     10  or	al,*$10
25540 7646           8946         CC            mov	-$34[bp],ax
25541                                           !BCC_EOS
25542                                           ! 3833         options |= (mode==0x01?1:0)<<7;
25543                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
25544 7649           8A46         D6            mov	al,-$2A[bp]
25545 764C           3C                     01  cmp	al,*1
25546 764E           75           04            jne 	.55E
25547                       00007650            .55F:
25548 7650           B0                     01  mov	al,*1
25549 7652           EB           02            jmp .560
25550                       00007654            .55E:
25551 7654           30C0                       xor	al,al
25552                       00007656            .560:
25553                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
25554 7656           30E4                       xor	ah,ah
25555 7658           B1                     07  mov	cl,*7
25556 765A           D3E0                       shl	ax,cl
25557                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25558 765C           0B46         CC            or	ax,-$34[bp]
25559 765F           8946         CC            mov	-$34[bp],ax
25560                                           !BCC_EOS
25561                                           ! 3834         options |= (translation==1?1:0)<<9;
25562                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
25563 7662           8A46         D3            mov	al,-$2D[bp]
25564 7665           3C                     01  cmp	al,*1
25565 7667           75           04            jne 	.561
25566                       00007669            .562:
25567 7669           B0                     01  mov	al,*1
25568 766B           EB           02            jmp .563
25569                       0000766D            .561:
25570 766D           30C0                       xor	al,al
25571                       0000766F            .563:
25572                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25573 766F           30E4                       xor	ah,ah
25574 7671           88C4                       mov	ah,al
25575 7673           30C0                       xor	al,al
25576 7675           D1E0                       shl	ax,*1
25577                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25578 7677           0B46         CC            or	ax,-$34[bp]
25579 767A           8946         CC            mov	-$34[bp],ax
25580                                           !BCC_EOS
25581                                           ! 3835         options |= (translation==3?3:0)<<9;
25582                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
25583 767D           8A46         D3            mov	al,-$2D[bp]
25584 7680           3C                     03  cmp	al,*3
25585 7682           75           04            jne 	.564
25586                       00007684            .565:
25587 7684           B0                     03  mov	al,*3
25588 7686           EB           02            jmp .566
25589                       00007688            .564:
25590 7688           30C0                       xor	al,al
25591                       0000768A            .566:
25592                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25593 768A           30E4                       xor	ah,ah
25594 768C           88C4                       mov	ah,al
25595 768E           30C0                       xor	al,al
25596 7690           D1E0                       shl	ax,*1
25597                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25598 7692           0B46         CC            or	ax,-$34[bp]
25599 7695           8946         CC            mov	-$34[bp],ax
25600                                           !BCC_EOS
25601                                           ! 3836         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
25602                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
25603 7698           FF76         D0            push	-$30[bp]
25604                                           ! Debug: list * unsigned short = const $244 (used reg = )
25605 769B           B8                   0244  mov	ax,#$244
25606 769E           50                         push	ax
25607                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25608 769F           FF76         F6            push	-$A[bp]
25609                                           ! Debug: func () void = write_word+0 (used reg = )
25610 76A2           E8         8F91            call	_write_word
25611 76A5           83C4                   06  add	sp,*6
25612                                           !BCC_EOS
25613                                           ! 3837         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
25614                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25615 76A8           8B46         CE            mov	ax,-$32[bp]
25616                                           ! Debug: list unsigned int = ax+6 (used reg = )
25617 76AB           05                   0006  add	ax,*6
25618 76AE           50                         push	ax
25619                                           ! Debug: list * unsigned short = const $246 (used reg = )
25620 76AF           B8                   0246  mov	ax,#$246
25621 76B2           50                         push	ax
25622                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25623 76B3           FF76         F6            push	-$A[bp]
25624                                           ! Debug: func () void = write_word+0 (used reg = )
25625 76B6           E8         8F7D            call	_write_word
25626 76B9           83C4                   06  add	sp,*6
25627                                           !BCC_EOS
25628                                           ! 3838         write_byte(ebda_seg, &((ebda_
25629                                           ! 3838 data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
25630                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25631 76BC           8A46         DB            mov	al,-$25[bp]
25632 76BF           30E4                       xor	ah,ah
25633 76C1           24                     01  and	al,*1
25634                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
25635                                           ! Debug: expression subtree swapping
25636 76C3           0C                     0E  or	al,*$E
25637                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
25638 76C5           30E4                       xor	ah,ah
25639 76C7           B1                     04  mov	cl,*4
25640 76C9           D3E0                       shl	ax,cl
25641                                           ! Debug: list unsigned int = ax+0 (used reg = )
25642 76CB           50                         push	ax
25643                                           ! Debug: list * unsigned char = const $248 (used reg = )
25644 76CC           B8                   0248  mov	ax,#$248
25645 76CF           50                         push	ax
25646                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25647 76D0           FF76         F6            push	-$A[bp]
25648                                           ! Debug: func () void = write_byte+0 (used reg = )
25649 76D3           E8         8F48            call	_write_byte
25650 76D6           83C4                   06  add	sp,*6
25651                                           !BCC_EOS
25652                                           ! 3839         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
25653                                           ! Debug: list int = const $CB (used reg = )
25654 76D9           B8                   00CB  mov	ax,#$CB
25655 76DC           50                         push	ax
25656                                           ! Debug: list * unsigned char = const $249 (used reg = )
25657 76DD           B8                   0249  mov	ax,#$249
25658 76E0           50                         push	ax
25659                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25660 76E1           FF76         F6            push	-$A[bp]
25661                                           ! Debug: func () void = write_byte+0 (used reg = )
25662 76E4           E8         8F37            call	_write_byte
25663 76E7           83C4                   06  add	sp,*6
25664                                           !BCC_EOS
25665                                           ! 3840         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
25666                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
25667 76EA           8A46         D7            mov	al,-$29[bp]
25668 76ED           30E4                       xor	ah,ah
25669 76EF           50                         push	ax
25670                                           ! Debug: list * unsigned char = const $24A (used reg = )
25671 76F0           B8                   024A  mov	ax,#$24A
25672 76F3           50                         push	ax
25673                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25674 76F4           FF76         F6            push	-$A[bp]
25675                                           ! Debug: func () void = write_byte+0 (used reg = )
25676 76F7           E8         8F24            call	_write_byte
25677 76FA           83C4                   06  add	sp,*6
25678                                           !BCC_EOS
25679                                           ! 3841         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
25680                                           ! Debug: list int = const 1 (used reg = )
25681 76FD           B8                   0001  mov	ax,*1
25682 7700           50                         push	ax
25683                                           ! Debug: list * unsigned char = const $24B (used reg = )
25684 7701           B8                   024B  mov	ax,#$24B
25685 7704           50                         push	ax
25686                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25687 7705           FF76         F6            push	-$A[bp]
25688                                           ! Debug: func () void = write_byte+0 (used reg = )
25689 7708           E8         8F13            call	_write_byte
25690 770B           83C4                   06  add	sp,*6
25691                                           !BCC_EOS
25692                                           ! 3842         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
25693                                           ! Debug: list int = const 0 (used reg = )
25694 770E           31C0                       xor	ax,ax
25695 7710           50                         push	ax
25696                                           ! Debug: list * unsigned char = const $24C (used reg = )
25697 7711           B8                   024C  mov	ax,#$24C
25698 7714           50                         push	ax
25699                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25700 7715           FF76         F6            push	-$A[bp]
25701                                           ! Debug: func () void = write_byte+0 (used reg = )
25702 7718           E8         8F03            call	_write_byte
25703 771B           83C4                   06  add	sp,*6
25704                                           !BCC_EOS
25705                                           ! 3843         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
25706                                           ! Debug: list int = const 0 (used reg = )
25707 771E           31C0                       xor	ax,ax
25708 7720           50                         push	ax
25709                                           ! Debug: list * unsigned char = const $24D (used reg = )
25710 7721           B8                   024D  mov	ax,#$24D
25711 7724           50                         push	ax
25712                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25713 7725           FF76         F6            push	-$A[bp]
25714                                           ! Debug: func () void = write_byte+0 (used reg = )
25715 7728           E8         8EF3            call	_write_byte
25716 772B           83C4                   06  add	sp,*6
25717                                           !BCC_EOS
25718                                           ! 3844         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25719                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
25720 772E           FF76         CC            push	-$34[bp]
25721                                           ! Debug: list * unsigned short = const $24E (used reg = )
25722 7731           B8                   024E  mov	ax,#$24E
25723 7734           50                         push	ax
25724                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25725 7735           FF76         F6            push	-$A[bp]
25726                                           ! Debug: func () void = write_word+0 (used reg = )
25727 7738           E8         8EFB            call	_write_word
25728 773B           83C4                   06  add	sp,*6
25729                                           !BCC_EOS
25730                                           ! 3845         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25731                                           ! Debug: list int = const 0 (used reg = )
25732 773E           31C0                       xor	ax,ax
25733 7740           50                         push	ax
25734                                           ! Debug: list * unsigned short = const $250 (used reg = )
25735 7741           B8                   0250  mov	ax,#$250
25736 7744           50                         push	ax
25737                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25738 7745           FF76         F6            push	-$A[bp]
25739                                           ! Debug: func () void = write_word+0 (used reg = )
25740 7748           E8         8EEB            call	_write_word
25741 774B           83C4                   06  add	sp,*6
25742                                           !BCC_EOS
25743                                           ! 3846         if (size >=0x42)
25744                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
25745 774E           8B46         DE            mov	ax,-$22[bp]
25746 7751           3D                   0042  cmp	ax,*$42
25747 7754           72           13            jb  	.567
25748                       00007756            .568:
25749                                           ! 3847           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25750                                           ! Debug: list int = const $11 (used reg = )
25751 7756           B8                   0011  mov	ax,*$11
25752 7759           50                         push	ax
25753                                           ! Debug: list * unsigned char = const $252 (used reg = )
25754 775A           B8                   0252  mov	ax,#$252
25755 775D           50                         push	ax
25756                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25757 775E           FF76         F6            push	-$A[bp]
25758                                           ! Debug: func () void = write_byte+0 (used reg = )
25759 7761           E8         8EBA            call	_write_byte
25760 7764           83C4                   06  add	sp,*6
25761                                           !BCC_EOS
25762                                           ! 3848         else
25763                                           ! 3849           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
25764 7767           EB           11            jmp .569
25765                       00007769            .567:
25766                                           ! Debug: list int = const $10 (used reg = )
25767 7769           B8                   0010  mov	ax,*$10
25768 776C           50                         push	ax
25769                                           ! Debug: list * unsigned char = const $252 (used reg = )
25770 776D           B8                   0252  mov	ax,#$252
25771 7770           50                         push	ax
25772                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25773 7771           FF76         F6            push	-$A[bp]
25774                                           ! Debug: func () void = write_byte+0 (used reg = )
25775 7774           E8         8EA7            call	_write_byte
25776 7777           83C4                   06  add	sp,*6
25777                                           !BCC_EOS
25778                                           ! 3850         checksum=0;
25779                       0000777A            .569:
25780                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25781 777A           30C0                       xor	al,al
25782 777C           8846         D5            mov	-$2B[bp],al
25783                                           !BCC_EOS
25784                                           ! 3851         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
25785                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
25786 777F           30C0                       xor	al,al
25787 7781           8846         D4            mov	-$2C[bp],al
25788                                           !BCC_EOS
25789                                           !BCC_EOS
25790 7784           EB           24            jmp .56C
25791                       00007786            .56D:
25792                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
25793 7786           8A46         D4            mov	al,-$2C[bp]
25794 7789           30E4                       xor	ah,ah
25795                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
25796 778B           05                   0244  add	ax,#$244
25797 778E           50                         push	ax
25798                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25799 778F           FF76         F6            push	-$A[bp]
25800                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25801 7792           E8         8E63            call	_read_byte
25802 7795           83C4                   04  add	sp,*4
25803                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25804 7798           30E4                       xor	ah,ah
25805 779A           0246         D5            add	al,-$2B[bp]
25806 779D           80D4                   00  adc	ah,*0
25807 77A0           8846         D5            mov	-$2B[bp],al
25808                                           !BCC_EOS
25809                                           ! 3852         checksum = ~checksum;
25810                       000077A3            .56B:
25811                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
25812 77A3           8A46         D4            mov	al,-$2C[bp]
25813 77A6           40                         inc	ax
25814 77A7           8846         D4            mov	-$2C[bp],al
25815                       000077AA            .56C:
25816                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
25817 77AA           8A46         D4            mov	al,-$2C[bp]
25818 77AD           3C                     0F  cmp	al,*$F
25819 77AF           72           D5            jb 	.56D
25820                       000077B1            .56E:
25821                       000077B1            .56A:
25822                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
25823 77B1           8A46         D5            mov	al,-$2B[bp]
25824 77B4           30E4                       xor	ah,ah
25825 77B6           F7D0                       not	ax
25826                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25827 77B8           8846         D5            mov	-$2B[bp],al
25828                                           !BCC_EOS
25829                                           ! 3853         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25830                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
25831 77BB           8A46         D5            mov	al,-$2B[bp]
25832 77BE           30E4                       xor	ah,ah
25833 77C0           50                         push	ax
25834                                           ! Debug: list * unsigned char = const $253 (used reg = )
25835 77C1           B8                   0253  mov	ax,#$253
25836 77C4           50                         push	ax
25837                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25838 77C5           FF76         F6            push	-$A[bp]
25839                                           ! Debug: func () void = write_byte+0 (used reg = )
25840 77C8           E8         8E53            call	_write_byte
25841 77CB           83C4                   06  add	sp,*6
25842                                           !BCC_EOS
25843                                           ! 3854       }
25844                                           ! 3855       if(size >= 0x42) {
25845                       000077CE            .559:
25846                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
25847 77CE           8B46         DE            mov	ax,-$22[bp]
25848 77D1           3D                   0042  cmp	ax,*$42
25849 77D4         0F82         023B            blo 	.56F
25850                       000077D8            .570:
25851                                           ! 3856         Bit8u channel, iface, checksum, i;
25852                                           !BCC_EOS
25853                                           ! 3857         Bit16u iobase1;
25854                                           !BCC_EOS
25855                                           ! 3858         channel = device / 2;
25856                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25857 77D8           8A46         DB            mov	al,-$25[bp]
25858 77DB           30E4                       xor	ah,ah
25859 77DD           D1E8                       shr	ax,*1
25860                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
25861 77DF           8846         D9            mov	-$27[bp],al
25862                                           !BCC_EOS
25863                                           ! 3859         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25864                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25865 77E2           8A46         D9            mov	al,-$27[bp]
25866 77E5           30E4                       xor	ah,ah
25867 77E7           B1                     03  mov	cl,*3
25868 77E9           D3E0                       shl	ax,cl
25869 77EB           89C3                       mov	bx,ax
25870                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25871                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25872 77ED           81C3                 0122  add	bx,#$122
25873 77F1           53                         push	bx
25874                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25875 77F2           FF76         F6            push	-$A[bp]
25876                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25877 77F5           E8         8E00            call	_read_byte
25878 77F8           83C4                   04  add	sp,*4
25879                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25880 77FB           8846         D8            mov	-$28[bp],al
25881                                           !BCC_EOS
25882                                           ! 3860         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25883                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25884 77FE           8A46         D9            mov	al,-$27[bp]
25885 7801           30E4                       xor	ah,ah
25886 7803           B1                     03  mov	cl,*3
25887 7805           D3E0                       shl	ax,cl
25888 7807           89C3                       mov	bx,ax
25889                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25890                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25891 7809           81C3                 0124  add	bx,#$124
25892 780D           53                         push	bx
25893                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25894 780E           FF76         F6            push	-$A[bp]
25895                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25896 7811           E8         8DF7            call	_read_word
25897 7814           83C4                   04  add	sp,*4
25898                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25899 7817           8946         D4            mov	-$2C[bp],ax
25900                                           !BCC_EOS
25901                                           ! 3861         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25902                                           ! Debug: list int = const $42 (used reg = )
25903 781A           B8                   0042  mov	ax,*$42
25904 781D           50                         push	ax
25905                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25906 781E           8B46         0C            mov	ax,$C[bp]
25907                                           ! Debug: list unsigned int = ax+0 (used reg = )
25908 7821           50                         push	ax
25909                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25910 7822           FF76         06            push	6[bp]
25911                                           ! Debug: func () void = write_word+0 (used reg = )
25912 7825           E8         8E0E            call	_write_word
25913 7828           83C4                   06  add	sp,*6
25914                                           !BCC_EOS
25915                                           ! 3862         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25916                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25917 782B           B8                   BEDD  mov	ax,#$BEDD
25918 782E           50                         push	ax
25919                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25920 782F           8B46         0C            mov	ax,$C[bp]
25921                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25922 7832           05                   001E  add	ax,*$1E
25923 7835           50                         push	ax
25924                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25925 7836           FF76         06            push	6[bp]
25926                                           ! Debug: func () void = write_word+0 (used reg = )
25927 7839           E8         8DFA            call	_write_word
25928 783C           83C4                   06  add	sp,*6
25929                                           !BCC_EOS
25930                                           ! 3863         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25931                                           ! Debug: list int = const $24 (used reg = )
25932 783F           B8                   0024  mov	ax,*$24
25933 7842           50                         push	ax
25934                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25935 7843           8B46         0C            mov	ax,$C[bp]
25936                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25937 7846           05                   0020  add	ax,*$20
25938 7849           50                         push	ax
25939                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25940 784A           FF76         06            push	6[bp]
25941                                           ! Debug: func () void = write_byte+0 (used reg = )
25942 784D           E8         8DCE            call	_write_byte
25943 7850           83C4                   06  add	sp,*6
25944                                           !BCC_EOS
25945                                           ! 3864         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25946                                           ! Debug: list int = const 0 (used reg = )
25947 7853           31C0                       xor	ax,ax
25948 7855           50                         push	ax
25949                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25950 7856           8B46         0C            mov	ax,$C[bp]
25951                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25952 7859           05                   0021  add	ax,*$21
25953 785C           50                         push	ax
25954                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25955 785D           FF76         06            push	6[bp]
25956                                           ! Debug: func () void = write_byte+0 (used reg = )
25957 7860           E8         8DBB            call	_write_byte
25958 7863           83C4                   06  add	sp,*6
25959                                           !BCC_EOS
25960                                           ! 3865         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25961                                           ! Debug: list int = const 0 (used reg = )
25962 7866           31C0                       xor	ax,ax
25963 7868           50                         push	ax
25964                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25965 7869           8B46         0C            mov	ax,$C[bp]
25966                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25967 786C           05                   0022  add	ax,*$22
25968 786F           50                         push	ax
25969                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25970 7870           FF76         06            push	6[bp]
25971                                           ! Debug: func () void = write_word+0 (used reg = )
25972 7873           E8         8DC0            call	_write_word
25973 7876           83C4                   06  add	sp,*6
25974                                           !BCC_EOS
25975                                           ! 3866         if (iface==0x00) {
25976                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25977 7879           8A46         D8            mov	al,-$28[bp]
25978 787C           84C0                       test	al,al
25979 787E           75           51            jne 	.571
25980                       00007880            .572:
25981                                           ! 3867           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25982                                           ! Debug: list int = const $49 (used reg = )
25983 7880           B8                   0049  mov	ax,*$49
25984 7883           50                         push	ax
25985                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25986 7884           8B46         0C            mov	ax,$C[bp]
25987                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25988 7887           05                   0024  add	ax,*$24
25989 788A           50                         push	ax
25990                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25991 788B           FF76         06            push	6[bp]
25992                                           ! Debug: func () void = write_byte+0 (used reg = )
25993 788E           E8         8D8D            call	_write_byte
25994 7891           83C4                   06  add	sp,*6
25995                                           !BCC_EOS
25996                                           ! 3868           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25997                                           ! Debug: list int = const $53 (used reg = )
25998 7894           B8                   0053  mov	ax,*$53
25999 7897           50                         push	ax
26000                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
26001 7898           8B46         0C            mov	ax,$C[bp]
26002                                           ! Debug: list unsigned int = ax+$25 (used reg = )
26003 789B           05                   0025  add	ax,*$25
26004 789E           50                         push	ax
26005                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26006 789F           FF76         06            push	6[bp]
26007                                           ! Debug: func () void = write_byte+0 (used reg = )
26008 78A2           E8         8D79            call	_write_byte
26009 78A5           83C4                   06  add	sp,*6
26010                                           !BCC_EOS
26011                                           ! 3869           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
26012                                           ! Debug: list int = const $41 (used reg = )
26013 78A8           B8                   0041  mov	ax,*$41
26014 78AB           50                         push	ax
26015                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
26016 78AC           8B46         0C            mov	ax,$C[bp]
26017                                           ! Debug: list unsigned int = ax+$26 (used reg = )
26018 78AF           05                   0026  add	ax,*$26
26019 78B2           50                         push	ax
26020                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26021 78B3           FF76         06            push	6[bp]
26022                                           ! Debug: func () void = write_byte+0 (used reg = )
26023 78B6           E8         8D65            call	_write_byte
26024 78B9           83C4                   06  add	sp,*6
26025                                           !BCC_EOS
26026                                           ! 3870           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
26027                                           ! Debug: list int = const 0 (used reg = )
26028 78BC           31C0                       xor	ax,ax
26029 78BE           50                         push	ax
26030                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
26031 78BF           8B46         0C            mov	ax,$C[bp]
26032                                           ! Debug: list unsigned int = ax+$27 (used reg = )
26033 78C2           05                   0027  add	ax,*$27
26034 78C5           50                         push	ax
26035                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26036 78C6           FF76         06            push	6[bp]
26037                                           ! Debug: func () void = write_byte+0 (used reg = )
26038 78C9           E8         8D52            call	_write_byte
26039 78CC           83C4                   06  add	sp,*6
26040                                           !BCC_EOS
26041                                           ! 3871         }
26042                                           ! 3872         else {
26043 78CF           EB           00            jmp .573
26044                       000078D1            .571:
26045                                           ! 3873         }
26046                                           ! 3874         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_typ
26047                       000078D1            .573:
26048                                           ! 3874 e[0], 'A');
26049                                           ! Debug: list int = const $41 (used reg = )
26050 78D1           B8                   0041  mov	ax,*$41
26051 78D4           50                         push	ax
26052                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
26053 78D5           8B46         0C            mov	ax,$C[bp]
26054                                           ! Debug: list unsigned int = ax+$28 (used reg = )
26055 78D8           05                   0028  add	ax,*$28
26056 78DB           50                         push	ax
26057                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26058 78DC           FF76         06            push	6[bp]
26059                                           ! Debug: func () void = write_byte+0 (used reg = )
26060 78DF           E8         8D3C            call	_write_byte
26061 78E2           83C4                   06  add	sp,*6
26062                                           !BCC_EOS
26063                                           ! 3875         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
26064                                           ! Debug: list int = const $54 (used reg = )
26065 78E5           B8                   0054  mov	ax,*$54
26066 78E8           50                         push	ax
26067                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
26068 78E9           8B46         0C            mov	ax,$C[bp]
26069                                           ! Debug: list unsigned int = ax+$29 (used reg = )
26070 78EC           05                   0029  add	ax,*$29
26071 78EF           50                         push	ax
26072                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26073 78F0           FF76         06            push	6[bp]
26074                                           ! Debug: func () void = write_byte+0 (used reg = )
26075 78F3           E8         8D28            call	_write_byte
26076 78F6           83C4                   06  add	sp,*6
26077                                           !BCC_EOS
26078                                           ! 3876         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
26079                                           ! Debug: list int = const $41 (used reg = )
26080 78F9           B8                   0041  mov	ax,*$41
26081 78FC           50                         push	ax
26082                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
26083 78FD           8B46         0C            mov	ax,$C[bp]
26084                                           ! Debug: list unsigned int = ax+$2A (used reg = )
26085 7900           05                   002A  add	ax,*$2A
26086 7903           50                         push	ax
26087                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26088 7904           FF76         06            push	6[bp]
26089                                           ! Debug: func () void = write_byte+0 (used reg = )
26090 7907           E8         8D14            call	_write_byte
26091 790A           83C4                   06  add	sp,*6
26092                                           !BCC_EOS
26093                                           ! 3877         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
26094                                           ! Debug: list int = const 0 (used reg = )
26095 790D           31C0                       xor	ax,ax
26096 790F           50                         push	ax
26097                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
26098 7910           8B46         0C            mov	ax,$C[bp]
26099                                           ! Debug: list unsigned int = ax+$2B (used reg = )
26100 7913           05                   002B  add	ax,*$2B
26101 7916           50                         push	ax
26102                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26103 7917           FF76         06            push	6[bp]
26104                                           ! Debug: func () void = write_byte+0 (used reg = )
26105 791A           E8         8D01            call	_write_byte
26106 791D           83C4                   06  add	sp,*6
26107                                           !BCC_EOS
26108                                           ! 3878         if (iface==0x00) {
26109                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
26110 7920           8A46         D8            mov	al,-$28[bp]
26111 7923           84C0                       test	al,al
26112 7925           75           3E            jne 	.574
26113                       00007927            .575:
26114                                           ! 3879           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
26115                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
26116 7927           FF76         D4            push	-$2C[bp]
26117                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
26118 792A           8B46         0C            mov	ax,$C[bp]
26119                                           ! Debug: list unsigned int = ax+$30 (used reg = )
26120 792D           05                   0030  add	ax,*$30
26121 7930           50                         push	ax
26122                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26123 7931           FF76         06            push	6[bp]
26124                                           ! Debug: func () void = write_word+0 (used reg = )
26125 7934           E8         8CFF            call	_write_word
26126 7937           83C4                   06  add	sp,*6
26127                                           !BCC_EOS
26128                                           ! 3880           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
26129                                           ! Debug: list int = const 0 (used reg = )
26130 793A           31C0                       xor	ax,ax
26131 793C           50                         push	ax
26132                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
26133 793D           8B46         0C            mov	ax,$C[bp]
26134                                           ! Debug: list unsigned int = ax+$32 (used reg = )
26135 7940           05                   0032  add	ax,*$32
26136 7943           50                         push	ax
26137                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26138 7944           FF76         06            push	6[bp]
26139                                           ! Debug: func () void = write_word+0 (used reg = )
26140 7947           E8         8CEC            call	_write_word
26141 794A           83C4                   06  add	sp,*6
26142                                           !BCC_EOS
26143                                           ! 3881           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
26144                                           ! Debug: list long = const 0 (used reg = )
26145 794D           31C0                       xor	ax,ax
26146 794F           31DB                       xor	bx,bx
26147 7951           53                         push	bx
26148 7952           50                         push	ax
26149                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
26150 7953           8B46         0C            mov	ax,$C[bp]
26151                                           ! Debug: list unsigned int = ax+$34 (used reg = )
26152 7956           05                   0034  add	ax,*$34
26153 7959           50                         push	ax
26154                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
26155 795A           FF76         06            push	6[bp]
26156                                           ! Debug: func () void = write_dword+0 (used reg = )
26157 795D           E8         873B            call	_write_dword
26158 7960           83C4                   08  add	sp,*8
26159                                           !BCC_EOS
26160                                           ! 3882         }
26161                                           ! 3883         else {
26162 7963           EB           00            jmp .576
26163                       00007965            .574:
26164                                           ! 3884         }
26165                                           ! 3885         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
26166                       00007965            .576:
26167                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
26168 7965           8A46         DB            mov	al,-$25[bp]
26169 7968           30E4                       xor	ah,ah
26170 796A           24                     01  and	al,*1
26171                                           ! Debug: list unsigned char = al+0 (used reg = )
26172 796C           30E4                       xor	ah,ah
26173 796E           50                         push	ax
26174                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
26175 796F           8B46         0C            mov	ax,$C[bp]
26176                                           ! Debug: list unsigned int = ax+$38 (used reg = )
26177 7972           05                   0038  add	ax,*$38
26178 7975           50                         push	ax
26179                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26180 7976           FF76         06            push	6[bp]
26181                                           ! Debug: func () void = write_byte+0 (used reg = )
26182 7979           E8         8CA2            call	_write_byte
26183 797C           83C4                   06  add	sp,*6
26184                                           !BCC_EOS
26185                                           ! 3886         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
26186                                           ! Debug: list int = const 0 (used reg = )
26187 797F           31C0                       xor	ax,ax
26188 7981           50                         push	ax
26189                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
26190 7982           8B46         0C            mov	ax,$C[bp]
26191                                           ! Debug: list unsigned int = ax+$39 (used reg = )
26192 7985           05                   0039  add	ax,*$39
26193 7988           50                         push	ax
26194                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26195 7989           FF76         06            push	6[bp]
26196                                           ! Debug: func () void = write_byte+0 (used reg = )
26197 798C           E8         8C8F            call	_write_byte
26198 798F           83C4                   06  add	sp,*6
26199                                           !BCC_EOS
26200                                           ! 3887         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
26201                                           ! Debug: list int = const 0 (used reg = )
26202 7992           31C0                       xor	ax,ax
26203 7994           50                         push	ax
26204                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
26205 7995           8B46         0C            mov	ax,$C[bp]
26206                                           ! Debug: list unsigned int = ax+$3A (used reg = )
26207 7998           05                   003A  add	ax,*$3A
26208 799B           50                         push	ax
26209                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26210 799C           FF76         06            push	6[bp]
26211                                           ! Debug: func () void = write_word+0 (used reg = )
26212 799F           E8         8C94            call	_write_word
26213 79A2           83C4                   06  add	sp,*6
26214                                           !BCC_EOS
26215                                           ! 3888         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
26216                                           ! Debug: list long = const 0 (used reg = )
26217 79A5           31C0                       xor	ax,ax
26218 79A7           31DB                       xor	bx,bx
26219 79A9           53                         push	bx
26220 79AA           50                         push	ax
26221                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
26222 79AB           8B46         0C            mov	ax,$C[bp]
26223                                           ! Debug: list unsigned int = ax+$3C (used reg = )
26224 79AE           05                   003C  add	ax,*$3C
26225 79B1           50                         push	ax
26226                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
26227 79B2           FF76         06            push	6[bp]
26228                                           ! Debug: func () void = write_dword+0 (used reg = )
26229 79B5           E8         86E3            call	_write_dword
26230 79B8           83C4                   08  add	sp,*8
26231                                           !BCC_EOS
26232                                           ! 3889         checksum=0;
26233                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26234 79BB           30C0                       xor	al,al
26235 79BD           8846         D7            mov	-$29[bp],al
26236                                           !BCC_EOS
26237                                           ! 3890         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
26238                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
26239 79C0           B0                     1E  mov	al,*$1E
26240 79C2           8846         D6            mov	-$2A[bp],al
26241                                           !BCC_EOS
26242                                           !BCC_EOS
26243 79C5           EB           25            jmp .579
26244                       000079C7            .57A:
26245                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
26246 79C7           8B46         0C            mov	ax,$C[bp]
26247 79CA           0246         D6            add	al,-$2A[bp]
26248 79CD           80D4                   00  adc	ah,*0
26249                                           ! Debug: list unsigned int = ax+0 (used reg = )
26250 79D0           50                         push	ax
26251                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26252 79D1           FF76         06            push	6[bp]
26253                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26254 79D4           E8         8C21            call	_read_byte
26255 79D7           83C4                   04  add	sp,*4
26256                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26257 79DA           30E4                       xor	ah,ah
26258 79DC           0246         D7            add	al,-$29[bp]
26259 79DF           80D4                   00  adc	ah,*0
26260 79E2           8846         D7            mov	-$29[bp],al
26261                                           !BCC_EOS
26262                                           ! 3891         checksum = ~checksum;
26263                       000079E5            .578:
26264                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
26265 79E5           8A46         D6            mov	al,-$2A[bp]
26266 79E8           40                         inc	ax
26267 79E9           8846         D6            mov	-$2A[bp],al
26268                       000079EC            .579:
26269                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
26270 79EC           8A46         D6            mov	al,-$2A[bp]
26271 79EF           3C                     40  cmp	al,*$40
26272 79F1           72           D4            jb 	.57A
26273                       000079F3            .57B:
26274                       000079F3            .577:
26275                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
26276 79F3           8A46         D7            mov	al,-$29[bp]
26277 79F6           30E4                       xor	ah,ah
26278 79F8           F7D0                       not	ax
26279                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26280 79FA           8846         D7            mov	-$29[bp],al
26281                                           !BCC_EOS
26282                                           ! 3892         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
26283                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
26284 79FD           8A46         D7            mov	al,-$29[bp]
26285 7A00           30E4                       xor	ah,ah
26286 7A02           50                         push	ax
26287                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
26288 7A03           8B46         0C            mov	ax,$C[bp]
26289                                           ! Debug: list unsigned int = ax+$41 (used reg = )
26290 7A06           05                   0041  add	ax,*$41
26291 7A09           50                         push	ax
26292                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26293 7A0A           FF76         06            push	6[bp]
26294                                           ! Debug: func () void = write_byte+0 (used reg = )
26295 7A0D           E8         8C0E            call	_write_byte
26296 7A10           83C4                   06  add	sp,*6
26297                                           !BCC_EOS
26298                                           ! 3893       }
26299                                           ! 3894       goto int13_success;
26300                       00007A13            .56F:
26301 7A13           83C4                   0E  add	sp,#..FFEF-..FFF0
26302 7A16           E9         011B            br 	.FFEF
26303                                           !BCC_EOS
26304                                           ! 3895       break;
26305 7A19           E9         00E8            br 	.50D
26306                                           !BCC_EOS
26307                                           ! 3896     case 0x4e:
26308                                           ! 3897       switch (( AX & 0x00ff )) {
26309                       00007A1C            .57C:
26310                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26311 7A1C           8A46         18            mov	al,$18[bp]
26312 7A1F           EB           10            jmp .57F
26313                                           ! 3898         case 0x01:
26314                                           ! 3899         case 0x03:
26315                       00007A21            .580:
26316                                           ! 3900         case 0x04:
26317                       00007A21            .581:
26318                                           ! 3901         case 0x06:
26319                       00007A21            .582:
26320                                           ! 3902           goto int13_success;
26321                       00007A21            .583:
26322 7A21           83C4                   0E  add	sp,#..FFEF-..FFF0
26323 7A24           E9         010D            br 	.FFEF
26324                                           !BCC_EOS
26325                                           ! 3903           break;
26326 7A27           EB           1A            jmp .57D
26327                                           !BCC_EOS
26328                                           ! 3904         default:
26329                                           ! 3905           goto int13_fail;
26330                       00007A29            .584:
26331 7A29           83C4                   0E  add	sp,#..FFF1-..FFF0
26332 7A2C           E9         00D8            br 	.FFF1
26333                                           !BCC_EOS
26334                                           ! 3906       }
26335                                           ! 3907       break;
26336 7A2F           EB           12            jmp .57D
26337                       00007A31            .57F:
26338 7A31           2C                     01  sub	al,*1
26339 7A33           74           EC            je 	.580
26340 7A35           2C                     02  sub	al,*2
26341 7A37           74           E8            je 	.581
26342 7A39           2C                     01  sub	al,*1
26343 7A3B           74           E4            je 	.582
26344 7A3D           2C                     02  sub	al,*2
26345 7A3F           74           E0            je 	.583
26346 7A41           EB           E6            jmp	.584
26347                       00007A43            .57D:
26348 7A43           E9         00BE            br 	.50D
26349                                           !BCC_EOS
26350                                           ! 3908     case 0x09:
26351                                           ! 3909     case 0x0c:
26352                       00007A46            .585:
26353                                           ! 3910     case 0x0d:
26354                       00007A46            .586:
26355                                           ! 3911     case 0x11:
26356                       00007A46            .587:
26357                                           ! 3912     case 0x14:
26358                       00007A46            .588:
26359                                           ! 3913       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", ( AX >> 8 ));
26360                       00007A46            .589:
26361                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26362 7A46           8B46         18            mov	ax,$18[bp]
26363 7A49           88E0                       mov	al,ah
26364 7A4B           30E4                       xor	ah,ah
26365                                           ! Debug: list unsigned int = ax+0 (used reg = )
26366 7A4D           50                         push	ax
26367                                           ! Debug: list * char = .58A+0 (used reg = )
26368 7A4E           BB                   D077  mov	bx,#.58A
26369 7A51           53                         push	bx
26370                                           ! Debug: list int = const 4 (used reg = )
26371 7A52           B8                   0004  mov	ax,*4
26372 7A55           50                         push	ax
26373                                           ! Debug: func () void = bios_printf+0 (used reg = )
26374 7A56           E8         8F4E            call	_bios_printf
26375 7A59           83C4                   06  add	sp,*6
26376                                           !BCC_EOS
26377                                           ! 3914       goto int13_success;
26378 7A5C           83C4                   0E  add	sp,#..FFEF-..FFF0
26379 7A5F           E9         00D2            br 	.FFEF
26380                                           !BCC_EOS
26381                                           ! 3915       break;
26382 7A62           E9         009F            br 	.50D
26383                                           !BCC_EOS
26384                                           ! 3916     case 0x0a:
26385                                           ! 3917     case 0x0b:
26386                       00007A65            .58B:
26387                                           ! 3918     case 0x18:
26388                       00007A65            .58C:
26389                                           ! 3919     case 0x50:
26390                       00007A65            .58D:
26391                                           ! 3920     default:
26392                       00007A65            .58E:
26393                                           ! 3921       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", ( AX >> 8 ));
26394                       00007A65            .58F:
26395                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26396 7A65           8B46         18            mov	ax,$18[bp]
26397 7A68           88E0                       mov	al,ah
26398 7A6A           30E4                       xor	ah,ah
26399                                           ! Debug: list unsigned int = ax+0 (used reg = )
26400 7A6C           50                         push	ax
26401                                           ! Debug: list * char = .590+0 (used reg = )
26402 7A6D           BB                   D03D  mov	bx,#.590
26403 7A70           53                         push	bx
26404                                           ! Debug: list int = const 4 (used reg = )
26405 7A71           B8                   0004  mov	ax,*4
26406 7A74           50                         push	ax
26407                                           ! Debug: func () void = bios_printf+0 (used reg = )
26408 7A75           E8         8F2F            call	_bios_printf
26409 7A78           83C4                   06  add	sp,*6
26410                                           !BCC_EOS
26411                                           ! 3922       goto int13_fail;
26412 7A7B           83C4                   0E  add	sp,#..FFF1-..FFF0
26413 7A7E           E9         0086            br 	.FFF1
26414                                           !BCC_EOS
26415                                           ! 3923       break;
26416 7A81           E9         0080            br 	.50D
26417                                           !BCC_EOS
26418                                           ! 3924   }
26419                                           ! 3925 int13_fail:
26420 7A84           EB           7E            jmp .50D
26421                       00007A86            .50F:
26422 7A86           83C4                   F2  add	sp,*-$E
26423 7A89           2D                   0000  sub	ax,*0
26424 7A8C           7C           D7            jl 	.58F
26425 7A8E           3D                   0018  cmp	ax,*$18
26426 7A91           77           3B            ja  	.591
26427 7A93           D1E0                       shl	ax,*1
26428 7A95           89C3                       mov	bx,ax
26429 7A97           2E                         seg	cs
26430 7A98           FFA7       7A9C            br	.592[bx]
26431                       00007A9C            .592:
26432 7A9C                      6C15            .word	.510
26433 7A9E                      6C29            .word	.511
26434 7AA0                      6C7A            .word	.515
26435 7AA2                      6C7A            .word	.516
26436 7AA4                      6C7A            .word	.517
26437 7AA6                      6F1A            .word	.52D
26438 7AA8                      7A65            .word	.58F
26439 7AAA                      7A65            .word	.58F
26440 7AAC                      6F35            .word	.52F
26441 7AAE                      7A46            .word	.585
26442 7AB0                      7A65            .word	.58B
26443 7AB2                      7A65            .word	.58C
26444 7AB4                      7A46            .word	.586
26445 7AB6                      7A46            .word	.587
26446 7AB8                      7A65            .word	.58F
26447 7ABA                      7A65            .word	.58F
26448 7ABC                      7013            .word	.530
26449 7ABE                      7A46            .word	.588
26450 7AC0                      7A65            .word	.58F
26451 7AC2                      7A65            .word	.58F
26452 7AC4                      7A46            .word	.589
26453 7AC6                      705F            .word	.534
26454 7AC8                      7A65            .word	.58F
26455 7ACA                      7A65            .word	.58F
26456 7ACC                      7A65            .word	.58D
26457                       00007ACE            .591:
26458 7ACE           2D                   0041  sub	ax,*$41
26459 7AD1           72           92            jb 	.58F
26460 7AD3           3D                   000F  cmp	ax,*$F
26461 7AD6           77           29            ja  	.593
26462 7AD8           D1E0                       shl	ax,*1
26463 7ADA           89C3                       mov	bx,ax
26464 7ADC           2E                         seg	cs
26465 7ADD           FFA7       7AE1            br	.594[bx]
26466                       00007AE1            .594:
26467 7AE1                      7110            .word	.535
26468 7AE3                      7130            .word	.536
26469 7AE5                      7130            .word	.537
26470 7AE7                      7130            .word	.538
26471 7AE9                      7329            .word	.54A
26472 7AEB                      7332            .word	.54C
26473 7AED                      7130            .word	.539
26474 7AEF                      7346            .word	.54D
26475 7AF1                      7329            .word	.54B
26476 7AF3                      7A65            .word	.58F
26477 7AF5                      7A65            .word	.58F
26478 7AF7                      7A65            .word	.58F
26479 7AF9                      7A65            .word	.58F
26480 7AFB                      7A1C            .word	.57C
26481 7AFD                      7A65            .word	.58F
26482 7AFF                      7A65            .word	.58E
26483                       00007B01            .593:
26484 7B01           E9         FF61            br 	.58F
26485                       00007B04            .50D:
26486                       FFFFFFCA            ..FFF0	=	-$36
26487 7B04           83C4                   0E  add	sp,*$E
26488                       00007B07            .FFF1:
26489                       FFFFFFD8            ..FFF1	=	-$28
26490                                           ! 3926   AX = ((AX & 0x00ff) | ((0x01) << 8));
26491                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26492 7B07           8A46         18            mov	al,$18[bp]
26493                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
26494 7B0A           30E4                       xor	ah,ah
26495 7B0C           0D                   0100  or	ax,#$100
26496                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
26497 7B0F           8946         18            mov	$18[bp],ax
26498                                           !BCC_EOS
26499                                           ! 3927 int13_fail_noah:
26500                       00007B12            .FFEC:
26501                       FFFFFFD8            ..FFEC	=	-$28
26502                                           ! 3928   write_byte(0x0040, 0x0074, ( AX >> 8 ));
26503                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26504 7B12           8B46         18            mov	ax,$18[bp]
26505 7B15           88E0                       mov	al,ah
26506 7B17           30E4                       xor	ah,ah
26507                                           ! Debug: list unsigned int = ax+0 (used reg = )
26508 7B19           50                         push	ax
26509                                           ! Debug: list int = const $74 (used reg = )
26510 7B1A           B8                   0074  mov	ax,*$74
26511 7B1D           50                         push	ax
26512                                           ! Debug: list int = const $40 (used reg = )
26513 7B1E           B8                   0040  mov	ax,*$40
26514 7B21           50                         push	ax
26515                                           ! Debug: func () void = write_byte+0 (used reg = )
26516 7B22           E8         8AF9            call	_write_byte
26517 7B25           83C4                   06  add	sp,*6
26518                                           !BCC_EOS
26519                                           ! 3929 int13_fail_nostatus:
26520                       00007B28            .FFEE:
26521                       FFFFFFD8            ..FFEE	=	-$28
26522                                           ! 3930   FLAGS |= 0x0001;
26523                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26524 7B28           8B46         1E            mov	ax,$1E[bp]
26525 7B2B           0C                     01  or	al,*1
26526 7B2D           8946         1E            mov	$1E[bp],ax
26527                                           !BCC_EOS
26528                                           ! 3931   return;
26529 7B30           89EC                       mov	sp,bp
26530 7B32           5D                         pop	bp
26531 7B33           C3                         ret
26532                                           !BCC_EOS
26533                                           ! 3932 int13_success:
26534                       00007B34            .FFEF:
26535                       FFFFFFD8            ..FFEF	=	-$28
26536                                           ! 3933   AX = ((AX & 0x00ff) | ((0x00) << 8));
26537                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26538 7B34           8A46         18            mov	al,$18[bp]
26539                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
26540 7B37           0C                     00  or	al,*0
26541                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
26542 7B39           30E4                       xor	ah,ah
26543 7B3B           8946         18            mov	$18[bp],ax
26544                                           !BCC_EOS
26545                                           ! 3934 int13_success_noah:
26546                       00007B3E            .FFED:
26547                       FFFFFFD8            ..FFED	=	-$28
26548                                           ! 3935   write_byte(0x0040, 0x0074, 0x00);
26549                                           ! Debug: list int = const 0 (used reg = )
26550 7B3E           31C0                       xor	ax,ax
26551 7B40           50                         push	ax
26552                                           ! Debug: list int = const $74 (used reg = )
26553 7B41           B8                   0074  mov	ax,*$74
26554 7B44           50                         push	ax
26555                                           ! Debug: list int = const $40 (used reg = )
26556 7B45           B8                   0040  mov	ax,*$40
26557 7B48           50                         push	ax
26558                                           ! Debug: func () void = write_byte+0 (used reg = )
26559 7B49           E8         8AD2            call	_write_byte
26560 7B4C           83C4                   06  add	sp,*6
26561                                           !BCC_EOS
26562                                           ! 3936   FLAGS &= 0xfffe;
26563                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26564 7B4F           8B46         1E            mov	ax,$1E[bp]
26565 7B52           24                     FE  and	al,#$FE
26566 7B54           8946         1E            mov	$1E[bp],ax
26567                                           !BCC_EOS
26568                                           ! 3937 }
26569 7B57           89EC                       mov	sp,bp
26570 7B59           5D                         pop	bp
26571 7B5A           C3                         ret
26572                                           ! 3938   void
26573                                           ! Register BX used in function int13_harddisk
26574                                           ! 3939 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX,
26575                                           ! 3939  IP, CS, FLAGS)
26576                                           ! 3940   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
26577                                           export	_int13_cdrom
26578                       00007B5B            _int13_cdrom:
26579                                           !BCC_EOS
26580                                           ! 3941 {
26581                                           ! 3942   Bit16u ebda_seg=read_word(0x0040,0x000E);
26582 7B5B           55                         push	bp
26583 7B5C           89E5                       mov	bp,sp
26584 7B5E           4C                         dec	sp
26585 7B5F           4C                         dec	sp
26586                                           ! Debug: list int = const $E (used reg = )
26587 7B60           B8                   000E  mov	ax,*$E
26588 7B63           50                         push	ax
26589                                           ! Debug: list int = const $40 (used reg = )
26590 7B64           B8                   0040  mov	ax,*$40
26591 7B67           50                         push	ax
26592                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26593 7B68           E8         8AA0            call	_read_word
26594 7B6B           83C4                   04  add	sp,*4
26595                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
26596 7B6E           8946         FE            mov	-2[bp],ax
26597                                           !BCC_EOS
26598                                           ! 3943   Bit8u device, status, locks;
26599                                           !BCC_EOS
26600                                           ! 3944   Bit8u atacmd[12];
26601                                           !BCC_EOS
26602                                           ! 3945   Bit32u lba;
26603                                           !BCC_EOS
26604                                           ! 3946   Bit16u count, segment, offset, i, size;
26605                                           !BCC_EOS
26606                                           ! 3947   ;
26607 7B71           83C4                   E2  add	sp,*-$1E
26608                                           !BCC_EOS
26609                                           ! 3948   write_byte(0x0040, 0x0074, 0x00);
26610                                           ! Debug: list int = const 0 (used reg = )
26611 7B74           31C0                       xor	ax,ax
26612 7B76           50                         push	ax
26613                                           ! Debug: list int = const $74 (used reg = )
26614 7B77           B8                   0074  mov	ax,*$74
26615 7B7A           50                         push	ax
26616                                           ! Debug: list int = const $40 (used reg = )
26617 7B7B           B8                   0040  mov	ax,*$40
26618 7B7E           50                         push	ax
26619                                           ! Debug: func () void = write_byte+0 (used reg = )
26620 7B7F           E8         8A9C            call	_write_byte
26621 7B82           83C4                   06  add	sp,*6
26622                                           !BCC_EOS
26623                                           ! 3949   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
26624                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26625 7B85           8A46         10            mov	al,$10[bp]
26626                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
26627 7B88           3C                     E0  cmp	al,#$E0
26628 7B8A           72           07            jb  	.596
26629                       00007B8C            .597:
26630                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26631 7B8C           8A46         10            mov	al,$10[bp]
26632                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
26633 7B8F           3C                     E8  cmp	al,#$E8
26634 7B91           72           22            jb  	.595
26635                       00007B93            .596:
26636                                           ! 3950     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26637                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26638 7B93           8A46         10            mov	al,$10[bp]
26639                                           ! Debug: list unsigned char = al+0 (used reg = )
26640 7B96           30E4                       xor	ah,ah
26641 7B98           50                         push	ax
26642                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26643 7B99           8B46         18            mov	ax,$18[bp]
26644 7B9C           88E0                       mov	al,ah
26645 7B9E           30E4                       xor	ah,ah
26646                                           ! Debug: list unsigned int = ax+0 (used reg = )
26647 7BA0           50                         push	ax
26648                                           ! Debug: list * char = .598+0 (used reg = )
26649 7BA1           BB                   D009  mov	bx,#.598
26650 7BA4           53                         push	bx
26651                                           ! Debug: list int = const 4 (used reg = )
26652 7BA5           B8                   0004  mov	ax,*4
26653 7BA8           50                         push	ax
26654                                           ! Debug: func () void = bios_printf+0 (used reg = )
26655 7BA9           E8         8DFB            call	_bios_printf
26656 7BAC           83C4                   08  add	sp,*8
26657                                           !BCC_EOS
26658                                           ! 3951     goto int13_fail;
26659 7BAF           83C4                   00  add	sp,#..FFEB+$22
26660 7BB2           E9         0A81            br 	.FFEB
26661                                           !BCC_EOS
26662                                           ! 3952   }
26663                                           ! 3953   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
26664                       00007BB5            .595:
26665                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26666 7BB5           8A46         10            mov	al,$10[bp]
26667                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
26668 7BB8           30E4                       xor	ah,ah
26669                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
26670 7BBA           05                   FF20  add	ax,#-$E0
26671 7BBD           89C3                       mov	bx,ax
26672                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
26673                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
26674 7BBF           81C3                 023C  add	bx,#$23C
26675 7BC3           53                         push	bx
26676                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26677 7BC4           FF76         FE            push	-2[bp]
26678                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26679 7BC7           E8         8A2E            call	_read_byte
26680 7BCA           83C4                   04  add	sp,*4
26681                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
26682 7BCD           8846         FD            mov	-3[bp],al
26683                                           !BCC_EOS
26684                                           ! 3954   if (device >= (4*2)) {
26685                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
26686 7BD0           8A46         FD            mov	al,-3[bp]
26687 7BD3           3C                     08  cmp	al,*8
26688 7BD5           72           22            jb  	.599
26689                       00007BD7            .59A:
26690                                           ! 3955     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26691                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26692 7BD7           8A46         10            mov	al,$10[bp]
26693                                           ! Debug: list unsigned char = al+0 (used reg = )
26694 7BDA           30E4                       xor	ah,ah
26695 7BDC           50                         push	ax
26696                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26697 7BDD           8B46         18            mov	ax,$18[bp]
26698 7BE0           88E0                       mov	al,ah
26699 7BE2           30E4                       xor	ah,ah
26700                                           ! Debug: list unsigned int = ax+0 (used reg = )
26701 7BE4           50                         push	ax
26702                                           ! Debug: list * char = .59B+0 (used reg = )
26703 7BE5           BB                   CFCE  mov	bx,#.59B
26704 7BE8           53                         push	bx
26705                                           ! Debug: list int = const 4 (used reg = )
26706 7BE9           B8                   0004  mov	ax,*4
26707 7BEC           50                         push	ax
26708                                           ! Debug: func () void = bios_printf+0 (used reg = )
26709 7BED           E8         8DB7            call	_bios_printf
26710 7BF0           83C4                   08  add	sp,*8
26711                                           !BCC_EOS
26712                                           ! 3956     goto int13_fail;
26713 7BF3           83C4                   00  add	sp,#..FFEB+$22
26714 7BF6           E9         0A3D            br 	.FFEB
26715                                           !BCC_EOS
26716                                           ! 3957   }
26717                                           ! 3958   switch (( AX >> 8 )) {
26718                       00007BF9            .599:
26719                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26720 7BF9           8B46         18            mov	ax,$18[bp]
26721 7BFC           88E0                       mov	al,ah
26722 7BFE           30E4                       xor	ah,ah
26723 7C00           E9         09B2            br 	.59E
26724                                           ! 3959     case 0x00:
26725                                           ! 3960     case 0x09:
26726                       00007C03            .59F:
26727                                           ! 3961     case 0x0c:
26728                       00007C03            .5A0:
26729                                           ! 3962     case 0x0d:
26730                       00007C03            .5A1:
26731                                           ! 3963     case 0x10:
26732                       00007C03            .5A2:
26733                                           ! 3964     case 0x11:
26734                       00007C03            .5A3:
26735                                           ! 3965     case 0x14:
26736                       00007C03            .5A4:
26737                                           ! 3966     case 0x16:
26738                       00007C03            .5A5:
26739                                           ! 3967       goto int13_success;
26740                       00007C03            .5A6:
26741 7C03           83C4                   0C  add	sp,#..FFE9-..FFEA
26742 7C06           E9         0A5A            br 	.FFE9
26743                                           !BCC_EOS
26744                                           ! 3968       break;
26745 7C09           E9         0A27            br 	.59C
26746                                           !BCC_EOS
26747                                           ! 3969     case 0x03:
26748                                           ! 3970     case 0x05:
26749                       00007C0C            .5A7:
26750                                           ! 3971     case 0x43:
26751                       00007C0C            .5A8:
26752                                           ! 3972       AX = ((AX & 0x00ff) | ((0x03) << 8));
26753                       00007C0C            .5A9:
26754                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26755 7C0C           8A46         18            mov	al,$18[bp]
26756                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
26757 7C0F           30E4                       xor	ah,ah
26758 7C11           0D                   0300  or	ax,#$300
26759                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26760 7C14           8946         18            mov	$18[bp],ax
26761                                           !BCC_EOS
26762                                           ! 3973       goto int13_fail_noah;
26763 7C17           83C4                   0C  add	sp,#..FFE8-..FFEA
26764 7C1A           E9         0A24            br 	.FFE8
26765                                           !BCC_EOS
26766                                           ! 3974       break;
26767 7C1D           E9         0A13            br 	.59C
26768                                           !BCC_EOS
26769                                           ! 3975     case 0x01:
26770                                           ! 3976       status = read_byte(0x0040, 0x0074);
26771                       00007C20            .5AA:
26772                                           ! Debug: list int = const $74 (used reg = )
26773 7C20           B8                   0074  mov	ax,*$74
26774 7C23           50                         push	ax
26775                                           ! Debug: list int = const $40 (used reg = )
26776 7C24           B8                   0040  mov	ax,*$40
26777 7C27           50                         push	ax
26778                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26779 7C28           E8         89CD            call	_read_byte
26780 7C2B           83C4                   04  add	sp,*4
26781                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
26782 7C2E           8846         FC            mov	-4[bp],al
26783                                           !BCC_EOS
26784                                           ! 3977       AX = ((AX & 0x00ff) | ((status) << 8));
26785                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
26786 7C31           8A46         FC            mov	al,-4[bp]
26787 7C34           30E4                       xor	ah,ah
26788 7C36           88C4                       mov	ah,al
26789 7C38           30C0                       xor	al,al
26790 7C3A           50                         push	ax
26791                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
26792 7C3B           8A46         18            mov	al,$18[bp]
26793                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
26794 7C3E           30E4                       xor	ah,ah
26795 7C40           0B46         D2            or	ax,0+..FFEA[bp]
26796 7C43           44                         inc	sp
26797 7C44           44                         inc	sp
26798                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26799 7C45           8946         18            mov	$18[bp],ax
26800                                           !BCC_EOS
26801                                           ! 3978       write_byte(0x0040, 0x0074, 0);
26802                                           ! Debug: list int = const 0 (used reg = )
26803 7C48           31C0                       xor	ax,ax
26804 7C4A           50                         push	ax
26805                                           ! Debug: list int = const $74 (used reg = )
26806 7C4B           B8                   0074  mov	ax,*$74
26807 7C4E           50                         push	ax
26808                                           ! Debug: list int = const $40 (used reg = )
26809 7C4F           B8                   0040  mov	ax,*$40
26810 7C52           50                         push	ax
26811                                           ! Debug: func () void = write_byte+0 (used reg = )
26812 7C53           E8         89C8            call	_write_byte
26813 7C56           83C4                   06  add	sp,*6
26814                                           !BCC_EOS
26815                                           ! 3979       if (status) goto int13_fail_nostatus;
26816 7C59           8A46         FC            mov	al,-4[bp]
26817 7C5C           84C0                       test	al,al
26818 7C5E           74           08            je  	.5AB
26819                       00007C60            .5AC:
26820 7C60           83C4                   0C  add	sp,#..FFE7-..FFEA
26821 7C63           E9         09F1            br 	.FFE7
26822                                           !BCC_EOS
26823                                           ! 3980       else goto int13_success_noah;
26824 7C66           EB           06            jmp .5AD
26825                       00007C68            .5AB:
26826 7C68           83C4                   0C  add	sp,#..FFE6-..FFEA
26827 7C6B           E9         09FF            br 	.FFE6
26828                                           !BCC_EOS
26829                                           ! 3981       break;
26830                       00007C6E            .5AD:
26831 7C6E           E9         09C2            br 	.59C
26832                                           !BCC_EOS
26833                                           ! 3982     case 0x15:
26834                                           ! 3983       AX = ((AX & 0x00ff) | ((0x02) << 8));
26835                       00007C71            .5AE:
26836                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26837 7C71           8A46         18            mov	al,$18[bp]
26838                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
26839 7C74           30E4                       xor	ah,ah
26840 7C76           0D                   0200  or	ax,#$200
26841                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26842 7C79           8946         18            mov	$18[bp],ax
26843                                           !BCC_EOS
26844                                           ! 3984       goto int13_fail_noah;
26845 7C7C           83C4                   0C  add	sp,#..FFE8-..FFEA
26846 7C7F           E9         09BF            br 	.FFE8
26847                                           !BCC_EOS
26848                                           ! 3985       break;
26849 7C82           E9         09AE            br 	.59C
26850                                           !BCC_EOS
26851                                           ! 3986     case 0x41:
26852                                           ! 3987       BX=0xaa55;
26853                       00007C85            .5AF:
26854                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
26855 7C85           B8                   AA55  mov	ax,#$AA55
26856 7C88           8946         12            mov	$12[bp],ax
26857                                           !BCC_EOS
26858                                           ! 3988       AX = ((AX & 0x00ff) | ((0x30) << 8));
26859                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26860 7C8B           8A46         18            mov	al,$18[bp]
26861                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
26862 7C8E           30E4                       xor	ah,ah
26863 7C90           0D                   3000  or	ax,#$3000
26864                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26865 7C93           8946         18            mov	$18[bp],ax
26866                                           !BCC_EOS
26867                                           ! 3989       CX=0x0007;
26868                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
26869 7C96           B8                   0007  mov	ax,*7
26870 7C99           8946         16            mov	$16[bp],ax
26871                                           !BCC_EOS
26872                                           ! 3990       goto int13_success_noah;
26873 7C9C           83C4                   0C  add	sp,#..FFE6-..FFEA
26874 7C9F           E9         09CB            br 	.FFE6
26875                                           !BCC_EOS
26876                                           ! 3991       break;
26877 7CA2           E9         098E            br 	.59C
26878                                           !BCC_EOS
26879                                           ! 3992     case 0x42:
26880                                           ! 3993     case 0x44:
26881                       00007CA5            .5B0:
26882                                           ! 3994     case 0x47:
26883                       00007CA5            .5B1:
26884                                           ! 3995       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
26885                       00007CA5            .5B2:
26886                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
26887 7CA5           8B46         0C            mov	ax,$C[bp]
26888                                           ! Debug: list unsigned int = ax+2 (used reg = )
26889 7CA8           40                         inc	ax
26890 7CA9           40                         inc	ax
26891 7CAA           50                         push	ax
26892                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26893 7CAB           FF76         06            push	6[bp]
26894                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26895 7CAE           E8         895A            call	_read_word
26896 7CB1           83C4                   04  add	sp,*4
26897                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26898 7CB4           8946         E8            mov	-$18[bp],ax
26899                                           !BCC_EOS
26900                                           ! 3996       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
26901                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
26902 7CB7           8B46         0C            mov	ax,$C[bp]
26903                                           ! Debug: list unsigned int = ax+6 (used reg = )
26904 7CBA           05                   0006  add	ax,*6
26905 7CBD           50                         push	ax
26906                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26907 7CBE           FF76         06            push	6[bp]
26908                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26909 7CC1           E8         8947            call	_read_word
26910 7CC4           83C4                   04  add	sp,*4
26911                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
26912 7CC7           8946         E6            mov	-$1A[bp],ax
26913                                           !BCC_EOS
26914                                           ! 3997       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
26915                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
26916 7CCA           8B46         0C            mov	ax,$C[bp]
26917                                           ! Debug: list unsigned int = ax+4 (used reg = )
26918 7CCD           05                   0004  add	ax,*4
26919 7CD0           50                         push	ax
26920                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26921 7CD1           FF76         06            push	6[bp]
26922                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26923 7CD4           E8         8934            call	_read_word
26924 7CD7           83C4                   04  add	sp,*4
26925                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
26926 7CDA           8946         E4            mov	-$1C[bp],ax
26927                                           !BCC_EOS
26928                                           ! 3998       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
26929                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
26930 7CDD           8B46         0C            mov	ax,$C[bp]
26931                                           ! Debug: list unsigned int = ax+$C (used reg = )
26932 7CE0           05                   000C  add	ax,*$C
26933 7CE3           50                         push	ax
26934                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26935 7CE4           FF76         06            push	6[bp]
26936                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26937 7CE7           E8         8399            call	_read_dword
26938 7CEA           89D3                       mov	bx,dx
26939 7CEC           83C4                   04  add	sp,*4
26940                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26941 7CEF           8946         EA            mov	-$16[bp],ax
26942 7CF2           895E         EC            mov	-$14[bp],bx
26943                                           !BCC_EOS
26944                                           ! 3999       if (lba != 0L) {
26945                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26946                                           ! Debug: expression subtree swapping
26947 7CF5           31C0                       xor	ax,ax
26948 7CF7           31DB                       xor	bx,bx
26949 7CF9           53                         push	bx
26950 7CFA           50                         push	ax
26951 7CFB           8B46         EA            mov	ax,-$16[bp]
26952 7CFE           8B5E         EC            mov	bx,-$14[bp]
26953 7D01           8D7E         D0            lea	di,-2+..FFEA[bp]
26954 7D04           E8         83C4            call	lcmpul
26955 7D07           8D66         D4            lea	sp,2+..FFEA[bp]
26956 7D0A           74           1C            je  	.5B3
26957                       00007D0C            .5B4:
26958                                           ! 4000         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26959                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26960 7D0C           8B46         18            mov	ax,$18[bp]
26961 7D0F           88E0                       mov	al,ah
26962 7D11           30E4                       xor	ah,ah
26963                                           ! Debug: list unsigned int = ax+0 (used reg = )
26964 7D13           50                         push	ax
26965                                           ! Debug: list * char = .5B5+0 (used reg = )
26966 7D14           BB                   CF9C  mov	bx,#.5B5
26967 7D17           53                         push	bx
26968                                           ! Debug: list int = const 7 (used reg = )
26969 7D18           B8                   0007  mov	ax,*7
26970 7D1B           50                         push	ax
26971                                           ! Debug: func () void = bios_printf+0 (used reg = )
26972 7D1C           E8         8C88            call	_bios_printf
26973 7D1F           83C4                   06  add	sp,*6
26974                                           !BCC_EOS
26975                                           ! 4001         goto int13_fail;
26976 7D22           83C4                   0C  add	sp,#..FFEB-..FFEA
26977 7D25           E9         090E            br 	.FFEB
26978                                           !BCC_EOS
26979                                           ! 4002       }
26980                                           ! 4003       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0
26981                       00007D28            .5B3:
26982                                           ! 4003 )->lba1);
26983                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26984 7D28           8B46         0C            mov	ax,$C[bp]
26985                                           ! Debug: list unsigned int = ax+8 (used reg = )
26986 7D2B           05                   0008  add	ax,*8
26987 7D2E           50                         push	ax
26988                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26989 7D2F           FF76         06            push	6[bp]
26990                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26991 7D32           E8         834E            call	_read_dword
26992 7D35           89D3                       mov	bx,dx
26993 7D37           83C4                   04  add	sp,*4
26994                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26995 7D3A           8946         EA            mov	-$16[bp],ax
26996 7D3D           895E         EC            mov	-$14[bp],bx
26997                                           !BCC_EOS
26998                                           ! 4004       if ((( AX >> 8 ) == 0x44) || (( AX >> 8 ) == 0x47))
26999                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
27000 7D40           8B46         18            mov	ax,$18[bp]
27001 7D43           88E0                       mov	al,ah
27002 7D45           30E4                       xor	ah,ah
27003                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
27004 7D47           3D                   0044  cmp	ax,*$44
27005 7D4A           74           0C            je  	.5B7
27006                       00007D4C            .5B8:
27007                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
27008 7D4C           8B46         18            mov	ax,$18[bp]
27009 7D4F           88E0                       mov	al,ah
27010 7D51           30E4                       xor	ah,ah
27011                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
27012 7D53           3D                   0047  cmp	ax,*$47
27013 7D56           75           06            jne 	.5B6
27014                       00007D58            .5B7:
27015                                           ! 4005         goto int13_success;
27016 7D58           83C4                   0C  add	sp,#..FFE9-..FFEA
27017 7D5B           E9         0905            br 	.FFE9
27018                                           !BCC_EOS
27019                                           ! 4006       memsetb(get_SS(),atacmd,0,12);
27020                       00007D5E            .5B6:
27021                                           ! Debug: list int = const $C (used reg = )
27022 7D5E           B8                   000C  mov	ax,*$C
27023 7D61           50                         push	ax
27024                                           ! Debug: list int = const 0 (used reg = )
27025 7D62           31C0                       xor	ax,ax
27026 7D64           50                         push	ax
27027                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
27028 7D65           8D5E         EF            lea	bx,-$11[bp]
27029 7D68           53                         push	bx
27030                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27031 7D69           E8         88E5            call	_get_SS
27032                                           ! Debug: list unsigned short = ax+0 (used reg = )
27033 7D6C           50                         push	ax
27034                                           ! Debug: func () void = memsetb+0 (used reg = )
27035 7D6D           E8         8290            call	_memsetb
27036 7D70           83C4                   08  add	sp,*8
27037                                           !BCC_EOS
27038                                           ! 4007       atacmd[0]=0x28;
27039                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
27040 7D73           B0                     28  mov	al,*$28
27041 7D75           8846         EF            mov	-$11[bp],al
27042                                           !BCC_EOS
27043                                           ! 4008       atacmd[7]=(count & 0xff00) >> 8;
27044                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
27045 7D78           8B46         E8            mov	ax,-$18[bp]
27046 7D7B           30C0                       xor	al,al
27047                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
27048 7D7D           88E0                       mov	al,ah
27049 7D7F           30E4                       xor	ah,ah
27050                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
27051 7D81           8846         F6            mov	-$A[bp],al
27052                                           !BCC_EOS
27053                                           ! 4009       atacmd[8]=(count & 0x00ff);
27054                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
27055 7D84           8A46         E8            mov	al,-$18[bp]
27056                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
27057 7D87           8846         F7            mov	-9[bp],al
27058                                           !BCC_EOS
27059                                           ! 4010       atacmd[2]=(lba & 0xff000000) >> 24;
27060                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
27061                                           ! Debug: expression subtree swapping
27062 7D8A           31C0                       xor	ax,ax
27063 7D8C           BB                   FF00  mov	bx,#$FF00
27064 7D8F           8D7E         EA            lea	di,-$16[bp]
27065 7D92           E8         8326            call	landul
27066                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
27067 7D95           93                         xchg	bx,ax
27068 7D96           88E0                       mov	al,ah
27069 7D98           30E4                       xor	ah,ah
27070 7D9A           31DB                       xor	bx,bx
27071                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
27072 7D9C           8846         F1            mov	-$F[bp],al
27073                                           !BCC_EOS
27074                                           ! 4011       atacmd[3]=(lba & 0x00ff0000) >> 16;
27075                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
27076                                           ! Debug: expression subtree swapping
27077 7D9F           31C0                       xor	ax,ax
27078 7DA1           BB                   00FF  mov	bx,#$FF
27079 7DA4           8D7E         EA            lea	di,-$16[bp]
27080 7DA7           E8         8311            call	landul
27081                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
27082 7DAA           93                         xchg	bx,ax
27083 7DAB           31DB                       xor	bx,bx
27084                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
27085 7DAD           8846         F2            mov	-$E[bp],al
27086                                           !BCC_EOS
27087                                           ! 4012       atacmd[4]=(lba & 0x0000ff00) >> 8;
27088                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
27089                                           ! Debug: expression subtree swapping
27090 7DB0           B8                   FF00  mov	ax,#$FF00
27091 7DB3           31DB                       xor	bx,bx
27092 7DB5           8D7E         EA            lea	di,-$16[bp]
27093 7DB8           E8         8300            call	landul
27094                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
27095 7DBB           88E0                       mov	al,ah
27096 7DBD           88DC                       mov	ah,bl
27097 7DBF           88FB                       mov	bl,bh
27098 7DC1           28FF                       sub	bh,bh
27099                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
27100 7DC3           8846         F3            mov	-$D[bp],al
27101                                           !BCC_EOS
27102                                           ! 4013       atacmd[5]=(lba & 0x000000ff);
27103                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
27104                                           ! Debug: expression subtree swapping
27105 7DC6           B8                   00FF  mov	ax,#$FF
27106 7DC9           31DB                       xor	bx,bx
27107 7DCB           8D7E         EA            lea	di,-$16[bp]
27108 7DCE           E8         82EA            call	landul
27109                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
27110 7DD1           8846         F4            mov	-$C[bp],al
27111                                           !BCC_EOS
27112                                           ! 4014       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
27113                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
27114 7DD4           FF76         E4            push	-$1C[bp]
27115                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
27116 7DD7           FF76         E6            push	-$1A[bp]
27117                                           ! Debug: list int = const 1 (used reg = )
27118 7DDA           B8                   0001  mov	ax,*1
27119 7DDD           50                         push	ax
27120                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
27121 7DDE           8B46         E8            mov	ax,-$18[bp]
27122 7DE1           31DB                       xor	bx,bx
27123                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
27124 7DE3           53                         push	bx
27125 7DE4           50                         push	ax
27126 7DE5           B8                   0800  mov	ax,#$800
27127 7DE8           31DB                       xor	bx,bx
27128 7DEA           53                         push	bx
27129 7DEB           50                         push	ax
27130 7DEC           8B46         CA            mov	ax,-8+..FFEA[bp]
27131 7DEF           8B5E         CC            mov	bx,-6+..FFEA[bp]
27132 7DF2           8D7E         C6            lea	di,-$C+..FFEA[bp]
27133 7DF5           E8         82F1            call	lmulul
27134 7DF8           83C4                   08  add	sp,*8
27135                                           ! Debug: list unsigned long = bx+0 (used reg = )
27136 7DFB           53                         push	bx
27137 7DFC           50                         push	ax
27138                                           ! Debug: list int = const 0 (used reg = )
27139 7DFD           31C0                       xor	ax,ax
27140 7DFF           50                         push	ax
27141                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
27142 7E00           8D5E         EF            lea	bx,-$11[bp]
27143 7E03           53                         push	bx
27144                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27145 7E04           E8         884A            call	_get_SS
27146                                           ! Debug: list unsigned short = ax+0 (used reg = )
27147 7E07           50                         push	ax
27148                                           ! Debug: list int = const $C (used reg = )
27149 7E08           B8                   000C  mov	ax,*$C
27150 7E0B           50                         push	ax
27151                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
27152 7E0C           8A46         FD            mov	al,-3[bp]
27153 7E0F           30E4                       xor	ah,ah
27154 7E11           50                         push	ax
27155                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
27156 7E12           E8         B7D2            call	_ata_cmd_packet
27157 7E15           83C4                   14  add	sp,*$14
27158                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
27159 7E18           8846         FC            mov	-4[bp],al
27160                                           !BCC_EOS
27161                                           ! 4015       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
27162                                           ! Debug: list * unsigned long = const $256 (used reg = )
27163 7E1B           B8                   0256  mov	ax,#$256
27164 7E1E           50                         push	ax
27165                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27166 7E1F           FF76         FE            push	-2[bp]
27167                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
27168 7E22           E8         825E            call	_read_dword
27169 7E25           89D3                       mov	bx,dx
27170 7E27           83C4                   04  add	sp,*4
27171                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
27172 7E2A           88E0                       mov	al,ah
27173 7E2C           88DC                       mov	ah,bl
27174 7E2E           88FB                       mov	bl,bh
27175 7E30           28FF                       sub	bh,bh
27176 7E32           BF                   0003  mov	di,*3
27177 7E35           E8         82F1            call	lsrul
27178                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
27179                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
27180 7E38           8946         E8            mov	-$18[bp],ax
27181                                           !BCC_EOS
27182                                           ! 4016       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
27183                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
27184 7E3B           FF76         E8            push	-$18[bp]
27185                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
27186 7E3E           8B46         0C            mov	ax,$C[bp]
27187                                           ! Debug: list unsigned int = ax+2 (used reg = )
27188 7E41           40                         inc	ax
27189 7E42           40                         inc	ax
27190 7E43           50                         push	ax
27191                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
27192 7E44           FF76         06            push	6[bp]
27193                                           ! Debug: func () void = write_word+0 (used reg = )
27194 7E47           E8         87EC            call	_write_word
27195 7E4A           83C4                   06  add	sp,*6
27196                                           !BCC_EOS
27197                                           ! 4017       if (status != 0) {
27198                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27199 7E4D           8A46         FC            mov	al,-4[bp]
27200 7E50           84C0                       test	al,al
27201 7E52           74           2D            je  	.5B9
27202                       00007E54            .5BA:
27203                                           ! 4018         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
27204                                           ! Debug: list unsigned char status = [S+$22-6] (used reg = )
27205 7E54           8A46         FC            mov	al,-4[bp]
27206 7E57           30E4                       xor	ah,ah
27207 7E59           50                         push	ax
27208                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
27209 7E5A           8B46         18            mov	ax,$18[bp]
27210 7E5D           88E0                       mov	al,ah
27211 7E5F           30E4                       xor	ah,ah
27212                                           ! Debug: list unsigned int = ax+0 (used reg = )
27213 7E61           50                         push	ax
27214                                           ! Debug: list * char = .5BB+0 (used reg = )
27215 7E62           BB                   CF71  mov	bx,#.5BB
27216 7E65           53                         push	bx
27217                                           ! Debug: list int = const 4 (used reg = )
27218 7E66           B8                   0004  mov	ax,*4
27219 7E69           50                         push	ax
27220                                           ! Debug: func () void = bios_printf+0 (used reg = )
27221 7E6A           E8         8B3A            call	_bios_printf
27222 7E6D           83C4                   08  add	sp,*8
27223                                           !BCC_EOS
27224                                           ! 4019         AX = ((AX & 0x00ff) | ((0x0c) << 8));
27225                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27226 7E70           8A46         18            mov	al,$18[bp]
27227                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
27228 7E73           30E4                       xor	ah,ah
27229 7E75           0D                   0C00  or	ax,#$C00
27230                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27231 7E78           8946         18            mov	$18[bp],ax
27232                                           !BCC_EOS
27233                                           ! 4020         goto int13_fail_noah;
27234 7E7B           83C4                   0C  add	sp,#..FFE8-..FFEA
27235 7E7E           E9         07C0            br 	.FFE8
27236                                           !BCC_EOS
27237                                           ! 4021       }
27238                                           ! 4022       goto int13_success;
27239                       00007E81            .5B9:
27240 7E81           83C4                   0C  add	sp,#..FFE9-..FFEA
27241 7E84           E9         07DC            br 	.FFE9
27242                                           !BCC_EOS
27243                                           ! 4023       break;
27244 7E87           E9         07A9            br 	.59C
27245                                           !BCC_EOS
27246                                           ! 4024     case 0x45:
27247                                           ! 4025       if (( AX & 0x00ff ) > 2) goto int13_fail;
27248                       00007E8A            .5BC:
27249                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27250 7E8A           8A46         18            mov	al,$18[bp]
27251                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
27252 7E8D           3C                     02  cmp	al,*2
27253 7E8F           76           06            jbe 	.5BD
27254                       00007E91            .5BE:
27255 7E91           83C4                   0C  add	sp,#..FFEB-..FFEA
27256 7E94           E9         079F            br 	.FFEB
27257                                           !BCC_EOS
27258                                           ! 4026       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27259                       00007E97            .5BD:
27260                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27261 7E97           8A46         FD            mov	al,-3[bp]
27262 7E9A           30E4                       xor	ah,ah
27263 7E9C           B9                   001E  mov	cx,*$1E
27264 7E9F           F7E9                       imul	cx
27265 7EA1           89C3                       mov	bx,ax
27266                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27267                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27268 7EA3           81C3                 0145  add	bx,#$145
27269 7EA7           53                         push	bx
27270                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27271 7EA8           FF76         FE            push	-2[bp]
27272                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27273 7EAB           E8         874A            call	_read_byte
27274 7EAE           83C4                   04  add	sp,*4
27275                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27276 7EB1           8846         FB            mov	-5[bp],al
27277                                           !BCC_EOS
27278                                           ! 4027       switch (( AX & 0x00ff )) {
27279                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27280 7EB4           8A46         18            mov	al,$18[bp]
27281 7EB7           E9         00D5            br 	.5C1
27282                                           ! 4028         case 0 :
27283                                           ! 4029           if (locks == 0xff) {
27284                       00007EBA            .5C2:
27285                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
27286 7EBA           8A46         FB            mov	al,-5[bp]
27287 7EBD           3C                     FF  cmp	al,#$FF
27288 7EBF           75           1B            jne 	.5C3
27289                       00007EC1            .5C4:
27290                                           ! 4030             AX = ((AX & 0x00ff) | ((0xb4) << 8));
27291                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27292 7EC1           8A46         18            mov	al,$18[bp]
27293                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
27294 7EC4           30E4                       xor	ah,ah
27295 7EC6           0D                   B400  or	ax,#-$4C00
27296                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27297 7EC9           8946         18            mov	$18[bp],ax
27298                                           !BCC_EOS
27299                                           ! 4031             AX = ((AX & 0xff00) | (1));
27300                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27301 7ECC           8B46         18            mov	ax,$18[bp]
27302 7ECF           30C0                       xor	al,al
27303                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27304 7ED1           0C                     01  or	al,*1
27305                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27306 7ED3           8946         18            mov	$18[bp],ax
27307                                           !BCC_EOS
27308                                           ! 4032             goto int13_fail_noah;
27309 7ED6           83C4                   0C  add	sp,#..FFE8-..FFEA
27310 7ED9           E9         0765            br 	.FFE8
27311                                           !BCC_EOS
27312                                           ! 4033           }
27313                                           ! 4034           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
27314                       00007EDC            .5C3:
27315                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
27316 7EDC           8A46         FB            mov	al,-5[bp]
27317 7EDF           40                         inc	ax
27318 7EE0           8846         FB            mov	-5[bp],al
27319                                           ! Debug: list unsigned char = al+0 (used reg = )
27320 7EE3           30E4                       xor	ah,ah
27321 7EE5           50                         push	ax
27322                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27323 7EE6           8A46         FD            mov	al,-3[bp]
27324 7EE9           30E4                       xor	ah,ah
27325 7EEB           B9                   001E  mov	cx,*$1E
27326 7EEE           F7E9                       imul	cx
27327 7EF0           89C3                       mov	bx,ax
27328                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27329                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27330 7EF2           81C3                 0145  add	bx,#$145
27331 7EF6           53                         push	bx
27332                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27333 7EF7           FF76         FE            push	-2[bp]
27334                                           ! Debug: func () void = write_byte+0 (used reg = )
27335 7EFA           E8         8721            call	_write_byte
27336 7EFD           83C4                   06  add	sp,*6
27337                                           !BCC_EOS
27338                                           ! 4035           AX = ((AX & 0xff00) | (1));
27339                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27340 7F00           8B46         18            mov	ax,$18[bp]
27341 7F03           30C0                       xor	al,al
27342                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27343 7F05           0C                     01  or	al,*1
27344                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27345 7F07           8946         18            mov	$18[bp],ax
27346                                           !BCC_EOS
27347                                           ! 4036           break;
27348 7F0A           E9         0092            br 	.5BF
27349                                           !BCC_EOS
27350                                           ! 4037         case 1 :
27351                                           ! 4038           if (locks == 0x00) {
27352                       00007F0D            .5C5:
27353                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27354 7F0D           8A46         FB            mov	al,-5[bp]
27355 7F10           84C0                       test	al,al
27356 7F12           75           1B            jne 	.5C6
27357                       00007F14            .5C7:
27358                                           ! 4039             AX = ((AX & 0x00ff) | ((0xb0) << 8));
27359                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27360 7F14           8A46         18            mov	al,$18[bp]
27361                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
27362 7F17           30E4                       xor	ah,ah
27363 7F19           0D                   B000  or	ax,#-$5000
27364                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27365 7F1C           8946         18            mov	$18[bp],ax
27366                                           !BCC_EOS
27367                                           ! 4040             AX = ((AX & 0xff00) | (0));
27368                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27369 7F1F           8B46         18            mov	ax,$18[bp]
27370 7F22           30C0                       xor	al,al
27371                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27372 7F24           0C                     00  or	al,*0
27373                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27374 7F26           8946         18            mov	$18[bp],ax
27375                                           !BCC_EOS
27376                                           ! 4041             goto int13_fail_noah;
27377 7F29           83C4                   0C  add	sp,#..FFE8-..FFEA
27378 7F2C           E9         0712            br 	.FFE8
27379                                           !BCC_EOS
27380                                           ! 4042           }
27381                                           ! 4043           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
27382                       00007F2F            .5C6:
27383                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
27384 7F2F           8A46         FB            mov	al,-5[bp]
27385 7F32           48                         dec	ax
27386 7F33           8846         FB            mov	-5[bp],al
27387                                           ! Debug: list unsigned char = al+0 (used reg = )
27388 7F36           30E4                       xor	ah,ah
27389 7F38           50                         push	ax
27390                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27391 7F39           8A46         FD            mov	al,-3[bp]
27392 7F3C           30E4                       xor	ah,ah
27393 7F3E           B9                   001E  mov	cx,*$1E
27394 7F41           F7E9                       imul	cx
27395 7F43           89C3                       mov	bx,ax
27396                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27397                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27398 7F45           81C3                 0145  add	bx,#$145
27399 7F49           53                         push	bx
27400                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27401 7F4A           FF76         FE            push	-2[bp]
27402                                           ! Debug: func () void = write_byte+0 (used reg = )
27403 7F4D           E8         86CE            call	_write_byte
27404 7F50           83C4                   06  add	sp,*6
27405                                           !BCC_EOS
27406                                           ! 4044           AX = ((AX & 0xff00) | (locks==0?0:1));
27407                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27408 7F53           8A46         FB            mov	al,-5[bp]
27409 7F56           84C0                       test	al,al
27410 7F58           75           04            jne 	.5C8
27411                       00007F5A            .5C9:
27412 7F5A           30C0                       xor	al,al
27413 7F5C           EB           02            jmp .5CA
27414                       00007F5E            .5C8:
27415 7F5E           B0                     01  mov	al,*1
27416                       00007F60            .5CA:
27417 7F60           50                         push	ax
27418                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27419 7F61           8B46         18            mov	ax,$18[bp]
27420 7F64           30C0                       xor	al,al
27421                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27422 7F66           0A46         D2            or	al,0+..FFEA[bp]
27423 7F69           44                         inc	sp
27424 7F6A           44                         inc	sp
27425                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27426 7F6B           8946         18            mov	$18[bp],ax
27427                                           !BCC_EOS
27428                                           ! 4045           break;
27429 7F6E           EB           2F            jmp .5BF
27430                                           !BCC_EOS
27431                                           ! 4046         case 2 :
27432                                           ! 4047           AX = ((AX & 0xff00) | (locks==0?0:1));
27433                       00007F70            .5CB:
27434                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27435 7F70           8A46         FB            mov	al,-5[bp]
27436 7F73           84C0                       test	al,al
27437 7F75           75           04            jne 	.5CC
27438                       00007F77            .5CD:
27439 7F77           30C0                       xor	al,al
27440 7F79           EB           02            jmp .5CE
27441                       00007F7B            .5CC:
27442 7F7B           B0                     01  mov	al,*1
27443                       00007F7D            .5CE:
27444 7F7D           50                         push	ax
27445                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27446 7F7E           8B46         18            mov	ax,$18[bp]
27447 7F81           30C0                       xor	al,al
27448                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27449 7F83           0A46         D2            or	al,0+..FFEA[bp]
27450 7F86           44                         inc	sp
27451 7F87           44                         inc	sp
27452                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27453 7F88           8946         18            mov	$18[bp],ax
27454                                           !BCC_EOS
27455                                           ! 4048           break;
27456 7F8B           EB           12            jmp .5BF
27457                                           !BCC_EOS
27458                                           ! 4049       }
27459                                           ! 4050       goto int13_success;
27460 7F8D           EB           10            jmp .5BF
27461                       00007F8F            .5C1:
27462 7F8F           2C                     00  sub	al,*0
27463 7F91         0F84         FF25            beq 	.5C2
27464 7F95           2C                     01  sub	al,*1
27465 7F97         0F84         FF72            beq 	.5C5
27466 7F9B           2C                     01  sub	al,*1
27467 7F9D           74           D1            je 	.5CB
27468                       00007F9F            .5BF:
27469 7F9F           83C4                   0C  add	sp,#..FFE9-..FFEA
27470 7FA2           E9         06BE            br 	.FFE9
27471                                           !BCC_EOS
27472                                           ! 4051       break;
27473 7FA5           E9         068B            br 	.59C
27474                                           !BCC_EOS
27475                                           ! 4052     case 0x46:
27476                                           ! 4053       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27477                       00007FA8            .5CF:
27478                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27479 7FA8           8A46         FD            mov	al,-3[bp]
27480 7FAB           30E4                       xor	ah,ah
27481 7FAD           B9                   001E  mov	cx,*$1E
27482 7FB0           F7E9                       imul	cx
27483 7FB2           89C3                       mov	bx,ax
27484                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27485                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27486 7FB4           81C3                 0145  add	bx,#$145
27487 7FB8           53                         push	bx
27488                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27489 7FB9           FF76         FE            push	-2[bp]
27490                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27491 7FBC           E8         8639            call	_read_byte
27492 7FBF           83C4                   04  add	sp,*4
27493                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27494 7FC2           8846         FB            mov	-5[bp],al
27495                                           !BCC_EOS
27496                                           ! 4054       if (locks != 0) {
27497                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27498 7FC5           8A46         FB            mov	al,-5[bp]
27499 7FC8           84C0                       test	al,al
27500 7FCA           74           11            je  	.5D0
27501                       00007FCC            .5D1:
27502                                           ! 4055         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27503                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27504 7FCC           8A46         18            mov	al,$18[bp]
27505                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27506 7FCF           30E4                       xor	ah,ah
27507 7FD1           0D                   B100  or	ax,#-$4F00
27508                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27509 7FD4           8946         18            mov	$18[bp],ax
27510                                           !BCC_EOS
27511                                           ! 4056         goto int13_fa
27512                                           ! 4056 il_noah;
27513 7FD7           83C4                   0C  add	sp,#..FFE8-..FFEA
27514 7FDA           E9         0664            br 	.FFE8
27515                                           !BCC_EOS
27516                                           ! 4057       }
27517                                           ! 4058 #asm
27518                       00007FDD            .5D0:
27519                                           !BCC_EOS
27520                                           !BCC_ASM
27521                       0000002E            _int13_cdrom.BP	set	$2E
27522                       0000000E            .int13_cdrom.BP	set	$E
27523                       00000024            _int13_cdrom.EHBX	set	$24
27524                       00000004            .int13_cdrom.EHBX	set	4
27525                       0000003C            _int13_cdrom.CS	set	$3C
27526                       0000001C            .int13_cdrom.CS	set	$1C
27527                       00000008            _int13_cdrom.count	set	8
27528                       FFFFFFE8            .int13_cdrom.count	set	-$18
27529                       00000036            _int13_cdrom.CX	set	$36
27530                       00000016            .int13_cdrom.CX	set	$16
27531                       00000006            _int13_cdrom.segment	set	6
27532                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
27533                       0000002A            _int13_cdrom.DI	set	$2A
27534                       0000000A            .int13_cdrom.DI	set	$A
27535                       0000003E            _int13_cdrom.FLAGS	set	$3E
27536                       0000001E            .int13_cdrom.FLAGS	set	$1E
27537                       00000026            _int13_cdrom.DS	set	$26
27538                       00000006            .int13_cdrom.DS	set	6
27539                       00000030            _int13_cdrom.ELDX	set	$30
27540                       00000010            .int13_cdrom.ELDX	set	$10
27541                       00000034            _int13_cdrom.DX	set	$34
27542                       00000014            .int13_cdrom.DX	set	$14
27543                       00000000            _int13_cdrom.size	set	0
27544                       FFFFFFE0            .int13_cdrom.size	set	-$20
27545                       00000002            _int13_cdrom.i	set	2
27546                       FFFFFFE2            .int13_cdrom.i	set	-$1E
27547                       0000001D            _int13_cdrom.device	set	$1D
27548                       FFFFFFFD            .int13_cdrom.device	set	-3
27549                       00000028            _int13_cdrom.ES	set	$28
27550                       00000008            .int13_cdrom.ES	set	8
27551                       0000001E            _int13_cdrom.ebda_seg	set	$1E
27552                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
27553                       0000002C            _int13_cdrom.SI	set	$2C
27554                       0000000C            .int13_cdrom.SI	set	$C
27555                       0000003A            _int13_cdrom.IP	set	$3A
27556                       0000001A            .int13_cdrom.IP	set	$1A
27557                       0000000A            _int13_cdrom.lba	set	$A
27558                       FFFFFFEA            .int13_cdrom.lba	set	-$16
27559                       0000001C            _int13_cdrom.status	set	$1C
27560                       FFFFFFFC            .int13_cdrom.status	set	-4
27561                       0000000F            _int13_cdrom.atacmd	set	$F
27562                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
27563                       00000038            _int13_cdrom.AX	set	$38
27564                       00000018            .int13_cdrom.AX	set	$18
27565                       00000004            _int13_cdrom.offset	set	4
27566                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
27567                       00000032            _int13_cdrom.BX	set	$32
27568                       00000012            .int13_cdrom.BX	set	$12
27569                       0000001B            _int13_cdrom.locks	set	$1B
27570                       FFFFFFFB            .int13_cdrom.locks	set	-5
27571 7FDD           55                                 push bp
27572 7FDE           89E5                               mov bp, sp
27573 7FE0           B4                     52          mov ah, #0x52
27574 7FE2           CD                     15          int #0x15
27575 7FE4           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
27576 7FE7           73           06                    jnc int13_cdrom_rme_end
27577 7FE9           C706       001C      0001          mov _int13_cdrom.status, #1
27578                       00007FEF            int13_cdrom_rme_end:
27579 7FEF           5D                                 pop bp
27580                                           ! 4068 endasm
27581                                           !BCC_ENDASM
27582                                           !BCC_EOS
27583                                           ! 4069       if (status != 0) {
27584                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27585 7FF0           8A46         FC            mov	al,-4[bp]
27586 7FF3           84C0                       test	al,al
27587 7FF5           74           11            je  	.5D2
27588                       00007FF7            .5D3:
27589                                           ! 4070         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27590                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27591 7FF7           8A46         18            mov	al,$18[bp]
27592                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27593 7FFA           30E4                       xor	ah,ah
27594 7FFC           0D                   B100  or	ax,#-$4F00
27595                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27596 7FFF           8946         18            mov	$18[bp],ax
27597                                           !BCC_EOS
27598                                           ! 4071         goto int13_fail_noah;
27599 8002           83C4                   0C  add	sp,#..FFE8-..FFEA
27600 8005           E9         0639            br 	.FFE8
27601                                           !BCC_EOS
27602                                           ! 4072       }
27603                                           ! 4073       goto int13_success;
27604                       00008008            .5D2:
27605 8008           83C4                   0C  add	sp,#..FFE9-..FFEA
27606 800B           E9         0655            br 	.FFE9
27607                                           !BCC_EOS
27608                                           ! 4074       break;
27609 800E           E9         0622            br 	.59C
27610                                           !BCC_EOS
27611                                           ! 4075     case 0x48:
27612                                           ! 4076       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
27613                       00008011            .5D4:
27614                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
27615 8011           8B46         0C            mov	ax,$C[bp]
27616                                           ! Debug: list unsigned int = ax+0 (used reg = )
27617 8014           50                         push	ax
27618                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
27619 8015           FF76         06            push	6[bp]
27620                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27621 8018           E8         85F0            call	_read_word
27622 801B           83C4                   04  add	sp,*4
27623                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
27624 801E           8946         E0            mov	-$20[bp],ax
27625                                           !BCC_EOS
27626                                           ! 4077       if(size < 0x1a)
27627                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27628 8021           8B46         E0            mov	ax,-$20[bp]
27629 8024           3D                   001A  cmp	ax,*$1A
27630 8027           73           06            jae 	.5D5
27631                       00008029            .5D6:
27632                                           ! 4078         goto int13_fail;
27633 8029           83C4                   0C  add	sp,#..FFEB-..FFEA
27634 802C           E9         0607            br 	.FFEB
27635                                           !BCC_EOS
27636                                           ! 4079       if(size >= 0x1a) {
27637                       0000802F            .5D5:
27638                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27639 802F           8B46         E0            mov	ax,-$20[bp]
27640 8032           3D                   001A  cmp	ax,*$1A
27641 8035         0F82         00CC            blo 	.5D7
27642                       00008039            .5D8:
27643                                           ! 4080         Bit16u cylinders, heads, spt, blksize;
27644                                           !BCC_EOS
27645                                           ! 4081         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
27646                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
27647 8039           8A46         FD            mov	al,-3[bp]
27648 803C           30E4                       xor	ah,ah
27649 803E           B9                   001E  mov	cx,*$1E
27650 8041           F7E9                       imul	cx
27651 8043           89C3                       mov	bx,ax
27652                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
27653                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
27654 8045           81C3                 0148  add	bx,#$148
27655 8049           53                         push	bx
27656                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
27657 804A           FF76         FE            push	-2[bp]
27658                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27659 804D           E8         85BB            call	_read_word
27660 8050           83C4                   04  add	sp,*4
27661                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
27662 8053           8946         D8            mov	-$28[bp],ax
27663                                           !BCC_EOS
27664                                           ! 4082         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
27665                                           ! Debug: list int = const $1A (used reg = )
27666 8056           B8                   001A  mov	ax,*$1A
27667 8059           50                         push	ax
27668                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
27669 805A           8B46         0C            mov	ax,$C[bp]
27670                                           ! Debug: list unsigned int = ax+0 (used reg = )
27671 805D           50                         push	ax
27672                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27673 805E           FF76         06            push	6[bp]
27674                                           ! Debug: func () void = write_word+0 (used reg = )
27675 8061           E8         85D2            call	_write_word
27676 8064           83C4                   06  add	sp,*6
27677                                           !BCC_EOS
27678                                           ! 4083         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
27679                                           ! Debug: list int = const $74 (used reg = )
27680 8067           B8                   0074  mov	ax,*$74
27681 806A           50                         push	ax
27682                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
27683 806B           8B46         0C            mov	ax,$C[bp]
27684                                           ! Debug: list unsigned int = ax+2 (used reg = )
27685 806E           40                         inc	ax
27686 806F           40                         inc	ax
27687 8070           50                         push	ax
27688                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27689 8071           FF76         06            push	6[bp]
27690                                           ! Debug: func () void = write_word+0 (used reg = )
27691 8074           E8         85BF            call	_write_word
27692 8077           83C4                   06  add	sp,*6
27693                                           !BCC_EOS
27694                                           ! 4084         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
27695                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27696 807A           B8                   FFFF  mov	ax,#$FFFF
27697 807D           BB                   FFFF  mov	bx,#$FFFF
27698 8080           53                         push	bx
27699 8081           50                         push	ax
27700                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
27701 8082           8B46         0C            mov	ax,$C[bp]
27702                                           ! Debug: list unsigned int = ax+4 (used reg = )
27703 8085           05                   0004  add	ax,*4
27704 8088           50                         push	ax
27705                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27706 8089           FF76         06            push	6[bp]
27707                                           ! Debug: func () void = write_dword+0 (used reg = )
27708 808C           E8         800C            call	_write_dword
27709 808F           83C4                   08  add	sp,*8
27710                                           !BCC_EOS
27711                                           ! 4085         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
27712                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27713 8092           B8                   FFFF  mov	ax,#$FFFF
27714 8095           BB                   FFFF  mov	bx,#$FFFF
27715 8098           53                         push	bx
27716 8099           50                         push	ax
27717                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
27718 809A           8B46         0C            mov	ax,$C[bp]
27719                                           ! Debug: list unsigned int = ax+8 (used reg = )
27720 809D           05                   0008  add	ax,*8
27721 80A0           50                         push	ax
27722                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27723 80A1           FF76         06            push	6[bp]
27724                                           ! Debug: func () void = write_dword+0 (used reg = )
27725 80A4           E8         7FF4            call	_write_dword
27726 80A7           83C4                   08  add	sp,*8
27727                                           !BCC_EOS
27728                                           ! 4086         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
27729                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27730 80AA           B8                   FFFF  mov	ax,#$FFFF
27731 80AD           BB                   FFFF  mov	bx,#$FFFF
27732 80B0           53                         push	bx
27733 80B1           50                         push	ax
27734                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
27735 80B2           8B46         0C            mov	ax,$C[bp]
27736                                           ! Debug: list unsigned int = ax+$C (used reg = )
27737 80B5           05                   000C  add	ax,*$C
27738 80B8           50                         push	ax
27739                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27740 80B9           FF76         06            push	6[bp]
27741                                           ! Debug: func () void = write_dword+0 (used reg = )
27742 80BC           E8         7FDC            call	_write_dword
27743 80BF           83C4                   08  add	sp,*8
27744                                           !BCC_EOS
27745                                           ! 4087         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
27746                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27747 80C2           B8                   FFFF  mov	ax,#$FFFF
27748 80C5           BB                   FFFF  mov	bx,#$FFFF
27749 80C8           53                         push	bx
27750 80C9           50                         push	ax
27751                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
27752 80CA           8B46         0C            mov	ax,$C[bp]
27753                                           ! Debug: list unsigned int = ax+$10 (used reg = )
27754 80CD           05                   0010  add	ax,*$10
27755 80D0           50                         push	ax
27756                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27757 80D1           FF76         06            push	6[bp]
27758                                           ! Debug: func () void = write_dword+0 (used reg = )
27759 80D4           E8         7FC4            call	_write_dword
27760 80D7           83C4                   08  add	sp,*8
27761                                           !BCC_EOS
27762                                           ! 4088         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
27763                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27764 80DA           B8                   FFFF  mov	ax,#$FFFF
27765 80DD           BB                   FFFF  mov	bx,#$FFFF
27766 80E0           53                         push	bx
27767 80E1           50                         push	ax
27768                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
27769 80E2           8B46         0C            mov	ax,$C[bp]
27770                                           ! Debug: list unsigned int = ax+$14 (used reg = )
27771 80E5           05                   0014  add	ax,*$14
27772 80E8           50                         push	ax
27773                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27774 80E9           FF76         06            push	6[bp]
27775                                           ! Debug: func () void = write_dword+0 (used reg = )
27776 80EC           E8         7FAC            call	_write_dword
27777 80EF           83C4                   08  add	sp,*8
27778                                           !BCC_EOS
27779                                           ! 4089         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
27780                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
27781 80F2           FF76         D8            push	-$28[bp]
27782                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
27783 80F5           8B46         0C            mov	ax,$C[bp]
27784                                           ! Debug: list unsigned int = ax+$18 (used reg = )
27785 80F8           05                   0018  add	ax,*$18
27786 80FB           50                         push	ax
27787                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27788 80FC           FF76         06            push	6[bp]
27789                                           ! Debug: func () void = write_word+0 (used reg = )
27790 80FF           E8         8534            call	_write_word
27791 8102           83C4                   06  add	sp,*6
27792                                           !BCC_EOS
27793                                           ! 4090       }
27794                                           ! 4091       if(size >= 0x1e) {
27795                       00008105            .5D7:
27796                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
27797 8105           8B46         E0            mov	ax,-$20[bp]
27798 8108           3D                   001E  cmp	ax,*$1E
27799 810B         0F82         01F9            blo 	.5D9
27800                       0000810F            .5DA:
27801                                           ! 4092         Bit8u channel, dev, irq, mode, checksum, i;
27802                                           !BCC_EOS
27803                                           ! 4093         Bit16u iobase1, iobase2, options;
27804                                           !BCC_EOS
27805                                           ! 4094         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
27806                                           ! Debug: list int = const $1E (used reg = )
27807 810F           B8                   001E  mov	ax,*$1E
27808 8112           50                         push	ax
27809                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
27810 8113           8B46         0C            mov	ax,$C[bp]
27811                                           ! Debug: list unsigned int = ax+0 (used reg = )
27812 8116           50                         push	ax
27813                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27814 8117           FF76         06            push	6[bp]
27815                                           ! Debug: func () void = write_word+0 (used reg = )
27816 811A           E8         8519            call	_write_word
27817 811D           83C4                   06  add	sp,*6
27818                                           !BCC_EOS
27819                                           ! 4095         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
27820                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
27821 8120           FF76         FE            push	-2[bp]
27822                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
27823 8123           8B46         0C            mov	ax,$C[bp]
27824                                           ! Debug: list unsigned int = ax+$1C (used reg = )
27825 8126           05                   001C  add	ax,*$1C
27826 8129           50                         push	ax
27827                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27828 812A           FF76         06            push	6[bp]
27829                                           ! Debug: func () void = write_word+0 (used reg = )
27830 812D           E8         8506            call	_write_word
27831 8130           83C4                   06  add	sp,*6
27832                                           !BCC_EOS
27833                                           ! 4096         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
27834                                           ! Debug: list * struct  = const $244 (used reg = )
27835 8133           B8                   0244  mov	ax,#$244
27836 8136           50                         push	ax
27837                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
27838 8137           8B46         0C            mov	ax,$C[bp]
27839                                           ! Debug: list unsigned int = ax+$1A (used reg = )
27840 813A           05                   001A  add	ax,*$1A
27841 813D           50                         push	ax
27842                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27843 813E           FF76         06            push	6[bp]
27844                                           ! Debug: func () void = write_word+0 (used reg = )
27845 8141           E8         84F2            call	_write_word
27846 8144           83C4                   06  add	sp,*6
27847                                           !BCC_EOS
27848                                           ! 4097         channel = device / 2;
27849                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27850 8147           8A46         FD            mov	al,-3[bp]
27851 814A           30E4                       xor	ah,ah
27852 814C           D1E8                       shr	ax,*1
27853                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
27854 814E           8846         DF            mov	-$21[bp],al
27855                                           !BCC_EOS
27856                                           ! 4098         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27857                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27858 8151           8A46         DF            mov	al,-$21[bp]
27859 8154           30E4                       xor	ah,ah
27860 8156           B1                     03  mov	cl,*3
27861 8158           D3E0                       shl	ax,cl
27862 815A           89C3                       mov	bx,ax
27863                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27864                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27865 815C           81C3                 0124  add	bx,#$124
27866 8160           53                         push	bx
27867                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27868 8161           FF76         FE            push	-2[bp]
27869                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27870 8164           E8         84A4            call	_read_word
27871 8167           83C4                   04  add	sp,*4
27872                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27873 816A           8946         D8            mov	-$28[bp],ax
27874                                           !BCC_EOS
27875                                           ! 4099         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
27876                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27877 816D           8A46         DF            mov	al,-$21[bp]
27878 8170           30E4                       xor	ah,ah
27879 8172           B1                     03  mov	cl,*3
27880 8174           D3E0                       shl	ax,cl
27881 8176           89C3                       mov	bx,ax
27882                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
27883                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
27884 8178           81C3                 0126  add	bx,#$126
27885 817C           53                         push	bx
27886                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27887 817D           FF76         FE            push	-2[bp]
27888                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27889 8180           E8         8488            call	_read_word
27890 8183           83C4                   04  add	sp,*4
27891                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27892 8186           8946         D6            mov	-$2A[bp],ax
27893                                           !BCC_EOS
27894                                           ! 4100         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
27895                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27896 8189           8A46         DF            mov	al,-$21[bp]
27897 818C           30E4                       xor	ah,ah
27898 818E           B1                     03  mov	cl,*3
27899 8190           D3E0                       shl	ax,cl
27900 8192           89C3                       mov	bx,ax
27901                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
27902                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
27903 8194           81C3                 0128  add	bx,#$128
27904 8198           53                         push	bx
27905                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27906 8199           FF76         FE            push	-2[bp]
27907                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27908 819C           E8         8459            call	_read_byte
27909 819F           83C4                   04  add	sp,*4
27910                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
27911 81A2           8846         DD            mov	-$23[bp],al
27912                                           !BCC_EOS
27913                                           ! 4101         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
27914                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
27915 81A5           8A46         FD            mov	al,-3[bp]
27916 81A8           30E4                       xor	ah,ah
27917 81AA           B9                   001E  mov	cx,*$1E
27918 81AD           F7E9                       imul	cx
27919 81AF           89C3                       mov	bx,ax
27920                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
27921                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
27922 81B1           81C3                 0146  add	bx,#$146
27923 81B5           53                         push	bx
27924                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27925 81B6           FF76         FE            push	-2[bp]
27926                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27927 81B9           E8         843C            call	_read_byte
27928 81BC           83C4                   04  add	sp,*4
27929                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
27930 81BF           8846         DC            mov	-$24[bp],al
27931                                           !BCC_EOS
27932                                           ! 4102         options = (1<<4);
27933                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
27934 81C2           B8                   0010  mov	ax,*$10
27935 81C5           8946         D4            mov	-$2C[bp],ax
27936                                           !BCC_EOS
27937                                           ! 4103         options |= (
27938                                           ! 4103 1<<5);
27939                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
27940 81C8           8B46         D4            mov	ax,-$2C[bp]
27941 81CB           0C                     20  or	al,*$20
27942 81CD           8946         D4            mov	-$2C[bp],ax
27943                                           !BCC_EOS
27944                                           ! 4104         options |= (1<<6);
27945                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
27946 81D0           8B46         D4            mov	ax,-$2C[bp]
27947 81D3           0C                     40  or	al,*$40
27948 81D5           8946         D4            mov	-$2C[bp],ax
27949                                           !BCC_EOS
27950                                           ! 4105         options |= (mode==0x01?1:0<<7);
27951                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
27952 81D8           8A46         DC            mov	al,-$24[bp]
27953 81DB           3C                     01  cmp	al,*1
27954 81DD           75           04            jne 	.5DB
27955                       000081DF            .5DC:
27956 81DF           B0                     01  mov	al,*1
27957 81E1           EB           02            jmp .5DD
27958                       000081E3            .5DB:
27959 81E3           30C0                       xor	al,al
27960                       000081E5            .5DD:
27961                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27962 81E5           30E4                       xor	ah,ah
27963 81E7           0B46         D4            or	ax,-$2C[bp]
27964 81EA           8946         D4            mov	-$2C[bp],ax
27965                                           !BCC_EOS
27966                                           ! 4106         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27967                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27968 81ED           FF76         D8            push	-$28[bp]
27969                                           ! Debug: list * unsigned short = const $244 (used reg = )
27970 81F0           B8                   0244  mov	ax,#$244
27971 81F3           50                         push	ax
27972                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27973 81F4           FF76         FE            push	-2[bp]
27974                                           ! Debug: func () void = write_word+0 (used reg = )
27975 81F7           E8         843C            call	_write_word
27976 81FA           83C4                   06  add	sp,*6
27977                                           !BCC_EOS
27978                                           ! 4107         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27979                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27980 81FD           8B46         D6            mov	ax,-$2A[bp]
27981                                           ! Debug: list unsigned int = ax+6 (used reg = )
27982 8200           05                   0006  add	ax,*6
27983 8203           50                         push	ax
27984                                           ! Debug: list * unsigned short = const $246 (used reg = )
27985 8204           B8                   0246  mov	ax,#$246
27986 8207           50                         push	ax
27987                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27988 8208           FF76         FE            push	-2[bp]
27989                                           ! Debug: func () void = write_word+0 (used reg = )
27990 820B           E8         8428            call	_write_word
27991 820E           83C4                   06  add	sp,*6
27992                                           !BCC_EOS
27993                                           ! 4108         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
27994                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27995 8211           8A46         FD            mov	al,-3[bp]
27996 8214           30E4                       xor	ah,ah
27997 8216           24                     01  and	al,*1
27998                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27999                                           ! Debug: expression subtree swapping
28000 8218           0C                     0E  or	al,*$E
28001                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
28002 821A           30E4                       xor	ah,ah
28003 821C           B1                     04  mov	cl,*4
28004 821E           D3E0                       shl	ax,cl
28005                                           ! Debug: list unsigned int = ax+0 (used reg = )
28006 8220           50                         push	ax
28007                                           ! Debug: list * unsigned char = const $248 (used reg = )
28008 8221           B8                   0248  mov	ax,#$248
28009 8224           50                         push	ax
28010                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28011 8225           FF76         FE            push	-2[bp]
28012                                           ! Debug: func () void = write_byte+0 (used reg = )
28013 8228           E8         83F3            call	_write_byte
28014 822B           83C4                   06  add	sp,*6
28015                                           !BCC_EOS
28016                                           ! 4109         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
28017                                           ! Debug: list int = const $CB (used reg = )
28018 822E           B8                   00CB  mov	ax,#$CB
28019 8231           50                         push	ax
28020                                           ! Debug: list * unsigned char = const $249 (used reg = )
28021 8232           B8                   0249  mov	ax,#$249
28022 8235           50                         push	ax
28023                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28024 8236           FF76         FE            push	-2[bp]
28025                                           ! Debug: func () void = write_byte+0 (used reg = )
28026 8239           E8         83E2            call	_write_byte
28027 823C           83C4                   06  add	sp,*6
28028                                           !BCC_EOS
28029                                           ! 4110         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
28030                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
28031 823F           8A46         DD            mov	al,-$23[bp]
28032 8242           30E4                       xor	ah,ah
28033 8244           50                         push	ax
28034                                           ! Debug: list * unsigned char = const $24A (used reg = )
28035 8245           B8                   024A  mov	ax,#$24A
28036 8248           50                         push	ax
28037                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28038 8249           FF76         FE            push	-2[bp]
28039                                           ! Debug: func () void = write_byte+0 (used reg = )
28040 824C           E8         83CF            call	_write_byte
28041 824F           83C4                   06  add	sp,*6
28042                                           !BCC_EOS
28043                                           ! 4111         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
28044                                           ! Debug: list int = const 1 (used reg = )
28045 8252           B8                   0001  mov	ax,*1
28046 8255           50                         push	ax
28047                                           ! Debug: list * unsigned char = const $24B (used reg = )
28048 8256           B8                   024B  mov	ax,#$24B
28049 8259           50                         push	ax
28050                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28051 825A           FF76         FE            push	-2[bp]
28052                                           ! Debug: func () void = write_byte+0 (used reg = )
28053 825D           E8         83BE            call	_write_byte
28054 8260           83C4                   06  add	sp,*6
28055                                           !BCC_EOS
28056                                           ! 4112         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
28057                                           ! Debug: list int = const 0 (used reg = )
28058 8263           31C0                       xor	ax,ax
28059 8265           50                         push	ax
28060                                           ! Debug: list * unsigned char = const $24C (used reg = )
28061 8266           B8                   024C  mov	ax,#$24C
28062 8269           50                         push	ax
28063                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28064 826A           FF76         FE            push	-2[bp]
28065                                           ! Debug: func () void = write_byte+0 (used reg = )
28066 826D           E8         83AE            call	_write_byte
28067 8270           83C4                   06  add	sp,*6
28068                                           !BCC_EOS
28069                                           ! 4113         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
28070                                           ! Debug: list int = const 0 (used reg = )
28071 8273           31C0                       xor	ax,ax
28072 8275           50                         push	ax
28073                                           ! Debug: list * unsigned char = const $24D (used reg = )
28074 8276           B8                   024D  mov	ax,#$24D
28075 8279           50                         push	ax
28076                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28077 827A           FF76         FE            push	-2[bp]
28078                                           ! Debug: func () void = write_byte+0 (used reg = )
28079 827D           E8         839E            call	_write_byte
28080 8280           83C4                   06  add	sp,*6
28081                                           !BCC_EOS
28082                                           ! 4114         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
28083                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
28084 8283           FF76         D4            push	-$2C[bp]
28085                                           ! Debug: list * unsigned short = const $24E (used reg = )
28086 8286           B8                   024E  mov	ax,#$24E
28087 8289           50                         push	ax
28088                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28089 828A           FF76         FE            push	-2[bp]
28090                                           ! Debug: func () void = write_word+0 (used reg = )
28091 828D           E8         83A6            call	_write_word
28092 8290           83C4                   06  add	sp,*6
28093                                           !BCC_EOS
28094                                           ! 4115         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
28095                                           ! Debug: list int = const 0 (used reg = )
28096 8293           31C0                       xor	ax,ax
28097 8295           50                         push	ax
28098                                           ! Debug: list * unsigned short = const $250 (used reg = )
28099 8296           B8                   0250  mov	ax,#$250
28100 8299           50                         push	ax
28101                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28102 829A           FF76         FE            push	-2[bp]
28103                                           ! Debug: func () void = write_word+0 (used reg = )
28104 829D           E8         8396            call	_write_word
28105 82A0           83C4                   06  add	sp,*6
28106                                           !BCC_EOS
28107                                           ! 4116         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
28108                                           ! Debug: list int = const $11 (used reg = )
28109 82A3           B8                   0011  mov	ax,*$11
28110 82A6           50                         push	ax
28111                                           ! Debug: list * unsigned char = const $252 (used reg = )
28112 82A7           B8                   0252  mov	ax,#$252
28113 82AA           50                         push	ax
28114                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28115 82AB           FF76         FE            push	-2[bp]
28116                                           ! Debug: func () void = write_byte+0 (used reg = )
28117 82AE           E8         836D            call	_write_byte
28118 82B1           83C4                   06  add	sp,*6
28119                                           !BCC_EOS
28120                                           ! 4117         checksum=0;
28121                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28122 82B4           30C0                       xor	al,al
28123 82B6           8846         DB            mov	-$25[bp],al
28124                                           !BCC_EOS
28125                                           ! 4118         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
28126                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
28127 82B9           30C0                       xor	al,al
28128 82BB           8846         DA            mov	-$26[bp],al
28129                                           !BCC_EOS
28130                                           !BCC_EOS
28131 82BE           EB           24            jmp .5E0
28132                       000082C0            .5E1:
28133                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
28134 82C0           8A46         DA            mov	al,-$26[bp]
28135 82C3           30E4                       xor	ah,ah
28136                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
28137 82C5           05                   0244  add	ax,#$244
28138 82C8           50                         push	ax
28139                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
28140 82C9           FF76         FE            push	-2[bp]
28141                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28142 82CC           E8         8329            call	_read_byte
28143 82CF           83C4                   04  add	sp,*4
28144                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28145 82D2           30E4                       xor	ah,ah
28146 82D4           0246         DB            add	al,-$25[bp]
28147 82D7           80D4                   00  adc	ah,*0
28148 82DA           8846         DB            mov	-$25[bp],al
28149                                           !BCC_EOS
28150                                           ! 4119         checksum = ~checksum;
28151                       000082DD            .5DF:
28152                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
28153 82DD           8A46         DA            mov	al,-$26[bp]
28154 82E0           40                         inc	ax
28155 82E1           8846         DA            mov	-$26[bp],al
28156                       000082E4            .5E0:
28157                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
28158 82E4           8A46         DA            mov	al,-$26[bp]
28159 82E7           3C                     0F  cmp	al,*$F
28160 82E9           72           D5            jb 	.5E1
28161                       000082EB            .5E2:
28162                       000082EB            .5DE:
28163                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
28164 82EB           8A46         DB            mov	al,-$25[bp]
28165 82EE           30E4                       xor	ah,ah
28166 82F0           F7D0                       not	ax
28167                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28168 82F2           8846         DB            mov	-$25[bp],al
28169                                           !BCC_EOS
28170                                           ! 4120         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
28171                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
28172 82F5           8A46         DB            mov	al,-$25[bp]
28173 82F8           30E4                       xor	ah,ah
28174 82FA           50                         push	ax
28175                                           ! Debug: list * unsigned char = const $253 (used reg = )
28176 82FB           B8                   0253  mov	ax,#$253
28177 82FE           50                         push	ax
28178                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28179 82FF           FF76         FE            push	-2[bp]
28180                                           ! Debug: func () void = write_byte+0 (used reg = )
28181 8302           E8         8319            call	_write_byte
28182 8305           83C4                   06  add	sp,*6
28183                                           !BCC_EOS
28184                                           ! 4121       }
28185                                           ! 4122       if(size >= 0x42) {
28186                       00008308            .5D9:
28187                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
28188 8308           8B46         E0            mov	ax,-$20[bp]
28189 830B           3D                   0042  cmp	ax,*$42
28190 830E         0F82         023B            blo 	.5E3
28191                       00008312            .5E4:
28192                                           ! 4123         Bit8u channel, iface, checksum, i;
28193                                           !BCC_EOS
28194                                           ! 4124         Bit16u iobase1;
28195                                           !BCC_EOS
28196                                           ! 4125         channel = device / 2;
28197                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28198 8312           8A46         FD            mov	al,-3[bp]
28199 8315           30E4                       xor	ah,ah
28200 8317           D1E8                       shr	ax,*1
28201                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
28202 8319           8846         DF            mov	-$21[bp],al
28203                                           !BCC_EOS
28204                                           ! 4126         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
28205                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28206 831C           8A46         DF            mov	al,-$21[bp]
28207 831F           30E4                       xor	ah,ah
28208 8321           B1                     03  mov	cl,*3
28209 8323           D3E0                       shl	ax,cl
28210 8325           89C3                       mov	bx,ax
28211                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
28212                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
28213 8327           81C3                 0122  add	bx,#$122
28214 832B           53                         push	bx
28215                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28216 832C           FF76         FE            push	-2[bp]
28217                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28218 832F           E8         82C6            call	_read_byte
28219 8332           83C4                   04  add	sp,*4
28220                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
28221 8335           8846         DE            mov	-$22[bp],al
28222                                           !BCC_EOS
28223                                           ! 4127         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
28224                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28225 8338           8A46         DF            mov	al,-$21[bp]
28226 833B           30E4                       xor	ah,ah
28227 833D           B1                     03  mov	cl,*3
28228 833F           D3E0                       shl	ax,cl
28229 8341           89C3                       mov	bx,ax
28230                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
28231                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
28232 8343           81C3                 0124  add	bx,#$124
28233 8347           53                         push	bx
28234                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28235 8348           FF76         FE            push	-2[bp]
28236                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28237 834B           E8         82BD            call	_read_word
28238 834E           83C4                   04  add	sp,*4
28239                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
28240 8351           8946         DA            mov	-$26[bp],ax
28241                                           !BCC_EOS
28242                                           ! 4128         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
28243                                           ! Debug: list int = const $42 (used reg = )
28244 8354           B8                   0042  mov	ax,*$42
28245 8357           50                         push	ax
28246                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
28247 8358           8B46         0C            mov	ax,$C[bp]
28248                                           ! Debug: list unsigned int = ax+0 (used reg = )
28249 835B           50                         push	ax
28250                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28251 835C           FF76         06            push	6[bp]
28252                                           ! Debug: func () void = write_word+0 (used reg = )
28253 835F           E8         82D4            call	_write_word
28254 8362           83C4                   06  add	sp,*6
28255                                           !BCC_EOS
28256                                           ! 4129         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
28257                                           ! Debug: list unsigned int = const $BEDD (used reg = )
28258 8365           B8                   BEDD  mov	ax,#$BEDD
28259 8368           50                         push	ax
28260                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
28261 8369           8B46         0C            mov	ax,$C[bp]
28262                                           ! Debug: list unsigned int = ax+$1E (used reg = )
28263 836C           05                   001E  add	ax,*$1E
28264 836F           50                         push	ax
28265                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28266 8370           FF76         06            push	6[bp]
28267                                           ! Debug: func () void = write_word+0 (used reg = )
28268 8373           E8         82C0            call	_write_word
28269 8376           83C4                   06  add	sp,*6
28270                                           !BCC_EOS
28271                                           ! 4130         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
28272                                           ! Debug: list int = const $24 (used reg = )
28273 8379           B8                   0024  mov	ax,*$24
28274 837C           50                         push	ax
28275                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
28276 837D           8B46         0C            mov	ax,$C[bp]
28277                                           ! Debug: list unsigned int = ax+$20 (used reg = )
28278 8380           05                   0020  add	ax,*$20
28279 8383           50                         push	ax
28280                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28281 8384           FF76         06            push	6[bp]
28282                                           ! Debug: func () void = write_byte+0 (used reg = )
28283 8387           E8         8294            call	_write_byte
28284 838A           83C4                   06  add	sp,*6
28285                                           !BCC_EOS
28286                                           ! 4131         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
28287                                           ! Debug: list int = const 0 (used reg = )
28288 838D           31C0                       xor	ax,ax
28289 838F           50                         push	ax
28290                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
28291 8390           8B46         0C            mov	ax,$C[bp]
28292                                           ! Debug: list unsigned int = ax+$21 (used reg = )
28293 8393           05                   0021  add	ax,*$21
28294 8396           50                         push	ax
28295                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28296 8397           FF76         06            push	6[bp]
28297                                           ! Debug: func () void = write_byte+0 (used reg = )
28298 839A           E8         8281            call	_write_byte
28299 839D           83C4                   06  add	sp,*6
28300                                           !BCC_EOS
28301                                           ! 4132         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
28302                                           ! Debug: list int = const 0 (used reg = )
28303 83A0           31C0                       xor	ax,ax
28304 83A2           50                         push	ax
28305                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
28306 83A3           8B46         0C            mov	ax,$C[bp]
28307                                           ! Debug: list unsigned int = ax+$22 (used reg = )
28308 83A6           05                   0022  add	ax,*$22
28309 83A9           50                         push	ax
28310                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28311 83AA           FF76         06            push	6[bp]
28312                                           ! Debug: func () void = write_word+0 (used reg = )
28313 83AD           E8         8286            call	_write_word
28314 83B0           83C4                   06  add	sp,*6
28315                                           !BCC_EOS
28316                                           ! 4133         if (iface==0x00) {
28317                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28318 83B3           8A46         DE            mov	al,-$22[bp]
28319 83B6           84C0                       test	al,al
28320 83B8           75           51            jne 	.5E5
28321                       000083BA            .5E6:
28322                                           ! 4134           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
28323                                           ! Debug: list int = const $49 (used reg = )
28324 83BA           B8                   0049  mov	ax,*$49
28325 83BD           50                         push	ax
28326                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
28327 83BE           8B46         0C            mov	ax,$C[bp]
28328                                           ! Debug: list unsigned int = ax+$24 (used reg = )
28329 83C1           05                   0024  add	ax,*$24
28330 83C4           50                         push	ax
28331                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28332 83C5           FF76         06            push	6[bp]
28333                                           ! Debug: func () void = write_byte+0 (used reg = )
28334 83C8           E8         8253            call	_write_byte
28335 83CB           83C4                   06  add	sp,*6
28336                                           !BCC_EOS
28337                                           ! 4135           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
28338                                           ! Debug: list int = const $53 (used reg = )
28339 83CE           B8                   0053  mov	ax,*$53
28340 83D1           50                         push	ax
28341                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
28342 83D2           8B46         0C            mov	ax,$C[bp]
28343                                           ! Debug: list unsigned int = ax+$25 (used reg = )
28344 83D5           05                   0025  add	ax,*$25
28345 83D8           50                         push	ax
28346                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28347 83D9           FF76         06            push	6[bp]
28348                                           ! Debug: func () void = write_byte+0 (used reg = )
28349 83DC           E8         823F            call	_write_byte
28350 83DF           83C4                   06  add	sp,*6
28351                                           !BCC_EOS
28352                                           ! 4136           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
28353                                           ! Debug: list int = const $41 (used reg = )
28354 83E2           B8                   0041  mov	ax,*$41
28355 83E5           50                         push	ax
28356                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
28357 83E6           8B46         0C            mov	ax,$C[bp]
28358                                           ! Debug: list unsigned int = ax+$26 (used reg = )
28359 83E9           05                   0026  add	ax,*$26
28360 83EC           50                         push	ax
28361                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28362 83ED           FF76         06            push	6[bp]
28363                                           ! Debug: func () void = write_byte+0 (used reg = )
28364 83F0           E8         822B            call	_write_byte
28365 83F3           83C4                   06  add	sp,*6
28366                                           !BCC_EOS
28367                                           ! 4137          
28368                                           ! 4137  write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
28369                                           ! Debug: list int = const 0 (used reg = )
28370 83F6           31C0                       xor	ax,ax
28371 83F8           50                         push	ax
28372                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
28373 83F9           8B46         0C            mov	ax,$C[bp]
28374                                           ! Debug: list unsigned int = ax+$27 (used reg = )
28375 83FC           05                   0027  add	ax,*$27
28376 83FF           50                         push	ax
28377                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28378 8400           FF76         06            push	6[bp]
28379                                           ! Debug: func () void = write_byte+0 (used reg = )
28380 8403           E8         8218            call	_write_byte
28381 8406           83C4                   06  add	sp,*6
28382                                           !BCC_EOS
28383                                           ! 4138         }
28384                                           ! 4139         else {
28385 8409           EB           00            jmp .5E7
28386                       0000840B            .5E5:
28387                                           ! 4140         }
28388                                           ! 4141         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
28389                       0000840B            .5E7:
28390                                           ! Debug: list int = const $41 (used reg = )
28391 840B           B8                   0041  mov	ax,*$41
28392 840E           50                         push	ax
28393                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
28394 840F           8B46         0C            mov	ax,$C[bp]
28395                                           ! Debug: list unsigned int = ax+$28 (used reg = )
28396 8412           05                   0028  add	ax,*$28
28397 8415           50                         push	ax
28398                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28399 8416           FF76         06            push	6[bp]
28400                                           ! Debug: func () void = write_byte+0 (used reg = )
28401 8419           E8         8202            call	_write_byte
28402 841C           83C4                   06  add	sp,*6
28403                                           !BCC_EOS
28404                                           ! 4142         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
28405                                           ! Debug: list int = const $54 (used reg = )
28406 841F           B8                   0054  mov	ax,*$54
28407 8422           50                         push	ax
28408                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
28409 8423           8B46         0C            mov	ax,$C[bp]
28410                                           ! Debug: list unsigned int = ax+$29 (used reg = )
28411 8426           05                   0029  add	ax,*$29
28412 8429           50                         push	ax
28413                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28414 842A           FF76         06            push	6[bp]
28415                                           ! Debug: func () void = write_byte+0 (used reg = )
28416 842D           E8         81EE            call	_write_byte
28417 8430           83C4                   06  add	sp,*6
28418                                           !BCC_EOS
28419                                           ! 4143         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
28420                                           ! Debug: list int = const $41 (used reg = )
28421 8433           B8                   0041  mov	ax,*$41
28422 8436           50                         push	ax
28423                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
28424 8437           8B46         0C            mov	ax,$C[bp]
28425                                           ! Debug: list unsigned int = ax+$2A (used reg = )
28426 843A           05                   002A  add	ax,*$2A
28427 843D           50                         push	ax
28428                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28429 843E           FF76         06            push	6[bp]
28430                                           ! Debug: func () void = write_byte+0 (used reg = )
28431 8441           E8         81DA            call	_write_byte
28432 8444           83C4                   06  add	sp,*6
28433                                           !BCC_EOS
28434                                           ! 4144         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
28435                                           ! Debug: list int = const 0 (used reg = )
28436 8447           31C0                       xor	ax,ax
28437 8449           50                         push	ax
28438                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
28439 844A           8B46         0C            mov	ax,$C[bp]
28440                                           ! Debug: list unsigned int = ax+$2B (used reg = )
28441 844D           05                   002B  add	ax,*$2B
28442 8450           50                         push	ax
28443                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28444 8451           FF76         06            push	6[bp]
28445                                           ! Debug: func () void = write_byte+0 (used reg = )
28446 8454           E8         81C7            call	_write_byte
28447 8457           83C4                   06  add	sp,*6
28448                                           !BCC_EOS
28449                                           ! 4145         if (iface==0x00) {
28450                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28451 845A           8A46         DE            mov	al,-$22[bp]
28452 845D           84C0                       test	al,al
28453 845F           75           3E            jne 	.5E8
28454                       00008461            .5E9:
28455                                           ! 4146           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
28456                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
28457 8461           FF76         DA            push	-$26[bp]
28458                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
28459 8464           8B46         0C            mov	ax,$C[bp]
28460                                           ! Debug: list unsigned int = ax+$30 (used reg = )
28461 8467           05                   0030  add	ax,*$30
28462 846A           50                         push	ax
28463                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28464 846B           FF76         06            push	6[bp]
28465                                           ! Debug: func () void = write_word+0 (used reg = )
28466 846E           E8         81C5            call	_write_word
28467 8471           83C4                   06  add	sp,*6
28468                                           !BCC_EOS
28469                                           ! 4147           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
28470                                           ! Debug: list int = const 0 (used reg = )
28471 8474           31C0                       xor	ax,ax
28472 8476           50                         push	ax
28473                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
28474 8477           8B46         0C            mov	ax,$C[bp]
28475                                           ! Debug: list unsigned int = ax+$32 (used reg = )
28476 847A           05                   0032  add	ax,*$32
28477 847D           50                         push	ax
28478                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28479 847E           FF76         06            push	6[bp]
28480                                           ! Debug: func () void = write_word+0 (used reg = )
28481 8481           E8         81B2            call	_write_word
28482 8484           83C4                   06  add	sp,*6
28483                                           !BCC_EOS
28484                                           ! 4148           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
28485                                           ! Debug: list long = const 0 (used reg = )
28486 8487           31C0                       xor	ax,ax
28487 8489           31DB                       xor	bx,bx
28488 848B           53                         push	bx
28489 848C           50                         push	ax
28490                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
28491 848D           8B46         0C            mov	ax,$C[bp]
28492                                           ! Debug: list unsigned int = ax+$34 (used reg = )
28493 8490           05                   0034  add	ax,*$34
28494 8493           50                         push	ax
28495                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28496 8494           FF76         06            push	6[bp]
28497                                           ! Debug: func () void = write_dword+0 (used reg = )
28498 8497           E8         7C01            call	_write_dword
28499 849A           83C4                   08  add	sp,*8
28500                                           !BCC_EOS
28501                                           ! 4149         }
28502                                           ! 4150         else {
28503 849D           EB           00            jmp .5EA
28504                       0000849F            .5E8:
28505                                           ! 4151         }
28506                                           ! 4152         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
28507                       0000849F            .5EA:
28508                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28509 849F           8A46         FD            mov	al,-3[bp]
28510 84A2           30E4                       xor	ah,ah
28511 84A4           24                     01  and	al,*1
28512                                           ! Debug: list unsigned char = al+0 (used reg = )
28513 84A6           30E4                       xor	ah,ah
28514 84A8           50                         push	ax
28515                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
28516 84A9           8B46         0C            mov	ax,$C[bp]
28517                                           ! Debug: list unsigned int = ax+$38 (used reg = )
28518 84AC           05                   0038  add	ax,*$38
28519 84AF           50                         push	ax
28520                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28521 84B0           FF76         06            push	6[bp]
28522                                           ! Debug: func () void = write_byte+0 (used reg = )
28523 84B3           E8         8168            call	_write_byte
28524 84B6           83C4                   06  add	sp,*6
28525                                           !BCC_EOS
28526                                           ! 4153         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
28527                                           ! Debug: list int = const 0 (used reg = )
28528 84B9           31C0                       xor	ax,ax
28529 84BB           50                         push	ax
28530                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
28531 84BC           8B46         0C            mov	ax,$C[bp]
28532                                           ! Debug: list unsigned int = ax+$39 (used reg = )
28533 84BF           05                   0039  add	ax,*$39
28534 84C2           50                         push	ax
28535                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28536 84C3           FF76         06            push	6[bp]
28537                                           ! Debug: func () void = write_byte+0 (used reg = )
28538 84C6           E8         8155            call	_write_byte
28539 84C9           83C4                   06  add	sp,*6
28540                                           !BCC_EOS
28541                                           ! 4154         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
28542                                           ! Debug: list int = const 0 (used reg = )
28543 84CC           31C0                       xor	ax,ax
28544 84CE           50                         push	ax
28545                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
28546 84CF           8B46         0C            mov	ax,$C[bp]
28547                                           ! Debug: list unsigned int = ax+$3A (used reg = )
28548 84D2           05                   003A  add	ax,*$3A
28549 84D5           50                         push	ax
28550                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28551 84D6           FF76         06            push	6[bp]
28552                                           ! Debug: func () void = write_word+0 (used reg = )
28553 84D9           E8         815A            call	_write_word
28554 84DC           83C4                   06  add	sp,*6
28555                                           !BCC_EOS
28556                                           ! 4155         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
28557                                           ! Debug: list long = const 0 (used reg = )
28558 84DF           31C0                       xor	ax,ax
28559 84E1           31DB                       xor	bx,bx
28560 84E3           53                         push	bx
28561 84E4           50                         push	ax
28562                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
28563 84E5           8B46         0C            mov	ax,$C[bp]
28564                                           ! Debug: list unsigned int = ax+$3C (used reg = )
28565 84E8           05                   003C  add	ax,*$3C
28566 84EB           50                         push	ax
28567                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28568 84EC           FF76         06            push	6[bp]
28569                                           ! Debug: func () void = write_dword+0 (used reg = )
28570 84EF           E8         7BA9            call	_write_dword
28571 84F2           83C4                   08  add	sp,*8
28572                                           !BCC_EOS
28573                                           ! 4156         checksum=0;
28574                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
28575 84F5           30C0                       xor	al,al
28576 84F7           8846         DD            mov	-$23[bp],al
28577                                           !BCC_EOS
28578                                           ! 4157         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
28579                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
28580 84FA           B0                     1E  mov	al,*$1E
28581 84FC           8846         DC            mov	-$24[bp],al
28582                                           !BCC_EOS
28583                                           !BCC_EOS
28584 84FF           EB           25            jmp .5ED
28585                       00008501            .5EE:
28586                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
28587 8501           8B46         0C            mov	ax,$C[bp]
28588 8504           0246         DC            add	al,-$24[bp]
28589 8507           80D4                   00  adc	ah,*0
28590                                           ! Debug: list unsigned int = ax+0 (used reg = )
28591 850A           50                         push	ax
28592                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
28593 850B           FF76         06            push	6[bp]
28594                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28595 850E           E8         80E7            call	_read_byte
28596 8511           83C4                   04  add	sp,*4
28597                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28598 8514           30E4                       xor	ah,ah
28599 8516           0246         DD            add	al,-$23[bp]
28600 8519           80D4                   00  adc	ah,*0
28601 851C           8846         DD            mov	-$23[bp],al
28602                                           !BCC_EOS
28603                                           ! 4158         checksum = ~checksum;
28604                       0000851F            .5EC:
28605                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
28606 851F           8A46         DC            mov	al,-$24[bp]
28607 8522           40                         inc	ax
28608 8523           8846         DC            mov	-$24[bp],al
28609                       00008526            .5ED:
28610                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
28611 8526           8A46         DC            mov	al,-$24[bp]
28612 8529           3C                     40  cmp	al,*$40
28613 852B           72           D4            jb 	.5EE
28614                       0000852D            .5EF:
28615                       0000852D            .5EB:
28616                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
28617 852D           8A46         DD            mov	al,-$23[bp]
28618 8530           30E4                       xor	ah,ah
28619 8532           F7D0                       not	ax
28620                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28621 8534           8846         DD            mov	-$23[bp],al
28622                                           !BCC_EOS
28623                                           ! 4159         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
28624                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
28625 8537           8A46         DD            mov	al,-$23[bp]
28626 853A           30E4                       xor	ah,ah
28627 853C           50                         push	ax
28628                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
28629 853D           8B46         0C            mov	ax,$C[bp]
28630                                           ! Debug: list unsigned int = ax+$41 (used reg = )
28631 8540           05                   0041  add	ax,*$41
28632 8543           50                         push	ax
28633                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28634 8544           FF76         06            push	6[bp]
28635                                           ! Debug: func () void = write_byte+0 (used reg = )
28636 8547           E8         80D4            call	_write_byte
28637 854A           83C4                   06  add	sp,*6
28638                                           !BCC_EOS
28639                                           ! 4160       }
28640                                           ! 4161       goto int13_success;
28641                       0000854D            .5E3:
28642 854D           83C4                   0C  add	sp,#..FFE9-..FFEA
28643 8550           E9         0110            br 	.FFE9
28644                                           !BCC_EOS
28645                                           ! 4162       break;
28646 8553           E9         00DD            br 	.59C
28647                                           !BCC_EOS
28648                                           ! 4163     case 0x49:
28649                                           ! 4164       AX = ((AX & 0x00ff) | ((06) << 8));
28650                       00008556            .5F0:
28651                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28652 8556           8A46         18            mov	al,$18[bp]
28653                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
28654 8559           30E4                       xor	ah,ah
28655 855B           0D                   0600  or	ax,#$600
28656                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28657 855E           8946         18            mov	$18[bp],ax
28658                                           !BCC_EOS
28659                                           ! 4165       goto int13_fail_nostatus;
28660 8561           83C4                   0C  add	sp,#..FFE7-..FFEA
28661 8564           E9         00F0            br 	.FFE7
28662                                           !BCC_EOS
28663                                           ! 4166       break;
28664 8567           E9         00C9            br 	.59C
28665                                           !BCC_EOS
28666                                           ! 4167     case 0x4e:
28667                                           ! 4168       switch (( AX & 0x00ff )) {
28668                       0000856A            .5F1:
28669                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28670 856A           8A46         18            mov	al,$18[bp]
28671 856D           EB           10            jmp .5F4
28672                                           ! 4169         case 0x01:
28673                                           ! 4170         case 0x03:
28674                       0000856F            .5F5:
28675                                           ! 4171         case 0x04:
28676                       0000856F            .5F6:
28677                                           ! 4172         case 0x06:
28678                       0000856F            .5F7:
28679                                           ! 4173           goto int13_success;
28680                       0000856F            .5F8:
28681 856F           83C4                   0C  add	sp,#..FFE9-..FFEA
28682 8572           E9         00EE            br 	.FFE9
28683                                           !BCC_EOS
28684                                           ! 4174           break;
28685 8575           EB           1A            jmp .5F2
28686                                           !BCC_EOS
28687                                           ! 4175         default:
28688                                           ! 4176           goto int13_fail;
28689                       00008577            .5F9:
28690 8577           83C4                   0C  add	sp,#..FFEB-..FFEA
28691 857A           E9         00B9            br 	.FFEB
28692                                           !BCC_EOS
28693                                           ! 4177       }
28694                                           ! 4178       break;
28695 857D           EB           12            jmp .5F2
28696                       0000857F            .5F4:
28697 857F           2C                     01  sub	al,*1
28698 8581           74           EC            je 	.5F5
28699 8583           2C                     02  sub	al,*2
28700 8585           74           E8            je 	.5F6
28701 8587           2C                     01  sub	al,*1
28702 8589           74           E4            je 	.5F7
28703 858B           2C                     02  sub	al,*2
28704 858D           74           E0            je 	.5F8
28705 858F           EB           E6            jmp	.5F9
28706                       00008591            .5F2:
28707 8591           E9         009F            br 	.59C
28708                                           !BCC_EOS
28709                                           ! 4179     case 0x02:
28710                                           ! 4180     case 0x04:
28711                       00008594            .5FA:
28712                                           ! 4181     case 0x08:
28713                       00008594            .5FB:
28714                                           ! 4182     case 0x0a:
28715                       00008594            .5FC:
28716                                           ! 4183     case 0x0b:
28717                       00008594            .5FD:
28718                                           ! 4184     case 0x18:
28719                       00008594            .5FE:
28720                                           ! 4185     case 0x50:
28721                       00008594            .5FF:
28722                                           ! 4186     default:
28723                       00008594            .600:
28724                                           ! 4187       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
28725                       00008594            .601:
28726                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28727 8594           8B46         18            mov	ax,$18[bp]
28728 8597           88E0                       mov	al,ah
28729 8599           30E4                       xor	ah,ah
28730                                           ! Debug: list unsigned int = ax+0 (used reg = )
28731 859B           50                         push	ax
28732                                           ! Debug: list * char = .602+0 (used reg = )
28733 859C           BB                   CF4F  mov	bx,#.602
28734 859F           53                         push	bx
28735                                           ! Debug: list int = const 4 (used reg = )
28736 85A0           B8                   0004  mov	ax,*4
28737 85A3           50                         push	ax
28738                                           ! Debug: func () void = bios_printf+0 (used reg = )
28739 85A4           E8         8400            call	_bios_printf
28740 85A7           83C4                   06  add	sp,*6
28741                                           !BCC_EOS
28742                                           ! 4188       goto int13_fail;
28743 85AA           83C4                   0C  add	sp,#..FFEB-..FFEA
28744 85AD           E9         0086            br 	.FFEB
28745                                           !BCC_EOS
28746                                           ! 4189       break;
28747 85B0           E9         0080            br 	.59C
28748                                           !BCC_EOS
28749                                           ! 4190   }
28750                                           ! 4191 int13_fail:
28751 85B3           EB           7E            jmp .59C
28752                       000085B5            .59E:
28753 85B5           83C4                   F4  add	sp,*-$C
28754 85B8           2D                   0000  sub	ax,*0
28755 85BB           7C           D7            jl 	.601
28756 85BD           3D                   0018  cmp	ax,*$18
28757 85C0           77           3B            ja  	.603
28758 85C2           D1E0                       shl	ax,*1
28759 85C4           89C3                       mov	bx,ax
28760 85C6           2E                         seg	cs
28761 85C7           FFA7       85CB            br	.604[bx]
28762                       000085CB            .604:
28763 85CB                      7C03            .word	.59F
28764 85CD                      7C20            .word	.5AA
28765 85CF                      8594            .word	.5FA
28766 85D1                      7C0C            .word	.5A7
28767 85D3                      8594            .word	.5FB
28768 85D5                      7C0C            .word	.5A8
28769 85D7                      8594            .word	.601
28770 85D9                      8594            .word	.601
28771 85DB                      8594            .word	.5FC
28772 85DD                      7C03            .word	.5A0
28773 85DF                      8594            .word	.5FD
28774 85E1                      8594            .word	.5FE
28775 85E3                      7C03            .word	.5A1
28776 85E5                      7C03            .word	.5A2
28777 85E7                      8594            .word	.601
28778 85E9                      8594            .word	.601
28779 85EB                      7C03            .word	.5A3
28780 85ED                      7C03            .word	.5A4
28781 85EF                      8594            .word	.601
28782 85F1                      8594            .word	.601
28783 85F3                      7C03            .word	.5A5
28784 85F5                      7C71            .word	.5AE
28785 85F7                      7C03            .word	.5A6
28786 85F9                      8594            .word	.601
28787 85FB                      8594            .word	.5FF
28788                       000085FD            .603:
28789 85FD           2D                   0041  sub	ax,*$41
28790 8600           72           92            jb 	.601
28791 8602           3D                   000F  cmp	ax,*$F
28792 8605           77           29            ja  	.605
28793 8607           D1E0                       shl	ax,*1
28794 8609           89C3                       mov	bx,ax
28795 860B           2E                         seg	cs
28796 860C           FFA7       8610            br	.606[bx]
28797                       00008610            .606:
28798 8610                      7C85            .word	.5AF
28799 8612                      7CA5            .word	.5B0
28800 8614                      7C0C            .word	.5A9
28801 8616                      7CA5            .word	.5B1
28802 8618                      7E8A            .word	.5BC
28803 861A                      7FA8            .word	.5CF
28804 861C                      7CA5            .word	.5B2
28805 861E                      8011            .word	.5D4
28806 8620                      8556            .word	.5F0
28807 8622                      8594            .word	.601
28808 8624                      8594            .word	.601
28809 8626                      8594            .word	.601
28810 8628                      8594            .word	.601
28811 862A                      856A            .word	.5F1
28812 862C                      8594            .word	.601
28813 862E                      8594            .word	.600
28814                       00008630            .605:
28815 8630           E9         FF61            br 	.601
28816                       00008633            .59C:
28817                       FFFFFFD2            ..FFEA	=	-$2E
28818 8633           83C4                   0C  add	sp,*$C
28819                       00008636            .FFEB:
28820                       FFFFFFDE            ..FFEB	=	-$22
28821                                           ! 4192   AX = ((AX & 0x00ff) | ((0x01) << 8));
28822                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28823 8636           8A46         18            mov	al,$18[bp]
28824                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28825 8639           30E4                       xor	ah,ah
28826 863B           0D                   0100  or	ax,#$100
28827                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28828 863E           8946         18            mov	$18[bp],ax
28829                                           !BCC_EOS
28830                                           ! 4193 int13_fail_noah:
28831                       00008641            .FFE8:
28832                       FFFFFFDE            ..FFE8	=	-$22
28833                                           ! 4194   write_byte(0x0040, 0x0074, ( AX >> 8 ));
28834                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28835 8641           8B46         18            mov	ax,$18[bp]
28836 8644           88E0                       mov	al,ah
28837 8646           30E4                       xor	ah,ah
28838                                           ! Debug: list unsigned int = ax+0 (used reg = )
28839 8648           50                         push	ax
28840                                           ! Debug: list int = const $74 (used reg = )
28841 8649           B8                   0074  mov	ax,*$74
28842 864C           50                         push	ax
28843                                           ! Debug: list int = const $40 (used reg = )
28844 864D           B8                   0040  mov	ax,*$40
28845 8650           50                         push	ax
28846                                           ! Debug: func () void = write_byte+0 (used reg = )
28847 8651           E8         7FCA            call	_write_byte
28848 8654           83C4                   06  add	sp,*6
28849                                           !BCC_EOS
28850                                           ! 4195 int13_fail_nostatus:
28851                       00008657            .FFE7:
28852                       FFFFFFDE            ..FFE7	=	-$22
28853                                           ! 4196   FLAGS |= 0x0001;
28854                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28855 8657           8B46         1E            mov	ax,$1E[bp]
28856 865A           0C                     01  or	al,*1
28857 865C           8946         1E            mov	$1E[bp],ax
28858                                           !BCC_EOS
28859                                           ! 4197   return;
28860 865F           89EC                       mov	sp,bp
28861 8661           5D                         pop	bp
28862 8662           C3                         ret
28863                                           !BCC_EOS
28864                                           ! 4198 int13_success:
28865                       00008663            .FFE9:
28866                       FFFFFFDE            ..FFE9	=	-$22
28867                                           ! 4199   AX = ((AX & 0x00ff) | ((0x00) << 8));
28868                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28869 8663           8A46         18            mov	al,$18[bp]
28870                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28871 8666           0C                     00  or	al,*0
28872                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
28873 8668           30E4                       xor	ah,ah
28874 866A           8946         18            mov	$18[bp],ax
28875                                           !BCC_EOS
28876                                           ! 4200 int13_success_noah:
28877                       0000866D            .FFE6:
28878                       FFFFFFDE            ..FFE6	=	-$22
28879                                           ! 4201   write_byte(0x0040, 0x0074, 0x00);
28880                                           ! Debug: list int = const 0 (used reg = )
28881 866D           31C0                       xor	ax,ax
28882 866F           50                         push	ax
28883                                           ! Debug: list int = const $74 (used reg = )
28884 8670           B8                   0074  mov	ax,*$74
28885 8673           50                         push	ax
28886                                           ! Debug: list int = const $40 (used reg = )
28887 8674           B8                   0040  mov	ax,*$40
28888 8677           50                         push	ax
28889                                           ! Debug: func () void = write_byte+0 (used reg = )
28890 8678           E8         7FA3            call	_write_byte
28891 867B           83C4                   06  add	sp,*6
28892                                           !BCC_EOS
28893                                           ! 4202   FLAGS &= 0xfffe;
28894                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28895 867E           8B46         1E            mov	ax,$1E[bp]
28896 8681           24                     FE  and	al,#$FE
28897 8683           8946         1E            mov	$1E[bp],ax
28898                                           !BCC_EOS
28899                                           ! 4203 }
28900 8686           89EC                       mov	sp,bp
28901 8688           5D                         pop	bp
28902 8689           C3                         ret
28903                                           ! 4204   voi
28904                                           ! 4204 d
28905                                           ! Register BX used in function int13_cdrom
28906                                           ! 4205 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28907                                           ! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28908                                           export	_int13_eltorito
28909                       0000868A            _int13_eltorito:
28910                                           !BCC_EOS
28911                                           ! 4207 {
28912                                           ! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
28913 868A           55                         push	bp
28914 868B           89E5                       mov	bp,sp
28915 868D           4C                         dec	sp
28916 868E           4C                         dec	sp
28917                                           ! Debug: list int = const $E (used reg = )
28918 868F           B8                   000E  mov	ax,*$E
28919 8692           50                         push	ax
28920                                           ! Debug: list int = const $40 (used reg = )
28921 8693           B8                   0040  mov	ax,*$40
28922 8696           50                         push	ax
28923                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28924 8697           E8         7F71            call	_read_word
28925 869A           83C4                   04  add	sp,*4
28926                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28927 869D           8946         FE            mov	-2[bp],ax
28928                                           !BCC_EOS
28929                                           ! 4209   ;
28930                                           !BCC_EOS
28931                                           ! 4210   switch (( AX >> 8 )) {
28932                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28933 86A0           8B46         16            mov	ax,$16[bp]
28934 86A3           88E0                       mov	al,ah
28935 86A5           30E4                       xor	ah,ah
28936 86A7           E9         01BE            br 	.609
28937                                           ! 4211     case 0x4a:
28938                                           ! 4212     case 0x4c:
28939                       000086AA            .60A:
28940                                           ! 4213     case 0x4d:
28941                       000086AA            .60B:
28942                                           ! 4214       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
28943                       000086AA            .60C:
28944                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
28945 86AA           FF76         16            push	$16[bp]
28946                                           ! Debug: list * char = .60D+0 (used reg = )
28947 86AD           BB                   CF1E  mov	bx,#.60D
28948 86B0           53                         push	bx
28949                                           ! Debug: list int = const 7 (used reg = )
28950 86B1           B8                   0007  mov	ax,*7
28951 86B4           50                         push	ax
28952                                           ! Debug: func () void = bios_printf+0 (used reg = )
28953 86B5           E8         82EF            call	_bios_printf
28954 86B8           83C4                   06  add	sp,*6
28955                                           !BCC_EOS
28956                                           ! 4215       goto int13_fail;
28957 86BB           83C4                   00  add	sp,#..FFE4-..FFE5
28958 86BE           E9         01C5            br 	.FFE4
28959                                           !BCC_EOS
28960                                           ! 4216       break;
28961 86C1           E9         01C2            br 	.607
28962                                           !BCC_EOS
28963                                           ! 4217     case 0x4b:
28964                                           ! 4218       write_byte(DS,SI+0x00,0x13);
28965                       000086C4            .60E:
28966                                           ! Debug: list int = const $13 (used reg = )
28967 86C4           B8                   0013  mov	ax,*$13
28968 86C7           50                         push	ax
28969                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28970 86C8           8B46         0A            mov	ax,$A[bp]
28971                                           ! Debug: list unsigned int = ax+0 (used reg = )
28972 86CB           50                         push	ax
28973                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28974 86CC           FF76         04            push	4[bp]
28975                                           ! Debug: func () void = write_byte+0 (used reg = )
28976 86CF           E8         7F4C            call	_write_byte
28977 86D2           83C4                   06  add	sp,*6
28978                                           !BCC_EOS
28979                                           ! 4219       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28980                                           ! Debug: list * unsigned char = const $25B (used reg = )
28981 86D5           B8                   025B  mov	ax,#$25B
28982 86D8           50                         push	ax
28983                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28984 86D9           FF76         FE            push	-2[bp]
28985                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28986 86DC           E8         7F19            call	_read_byte
28987 86DF           83C4                   04  add	sp,*4
28988                                           ! Debug: list unsigned char = al+0 (used reg = )
28989 86E2           30E4                       xor	ah,ah
28990 86E4           50                         push	ax
28991                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28992 86E5           8B46         0A            mov	ax,$A[bp]
28993                                           ! Debug: list unsigned int = ax+1 (used reg = )
28994 86E8           40                         inc	ax
28995 86E9           50                         push	ax
28996                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28997 86EA           FF76         04            push	4[bp]
28998                                           ! Debug: func () void = write_byte+0 (used reg = )
28999 86ED           E8         7F2E            call	_write_byte
29000 86F0           83C4                   06  add	sp,*6
29001                                           !BCC_EOS
29002                                           ! 4220       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
29003                                           ! Debug: list * unsigned char = const $25C (used reg = )
29004 86F3           B8                   025C  mov	ax,#$25C
29005 86F6           50                         push	ax
29006                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29007 86F7           FF76         FE            push	-2[bp]
29008                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29009 86FA           E8         7EFB            call	_read_byte
29010 86FD           83C4                   04  add	sp,*4
29011                                           ! Debug: list unsigned char = al+0 (used reg = )
29012 8700           30E4                       xor	ah,ah
29013 8702           50                         push	ax
29014                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
29015 8703           8B46         0A            mov	ax,$A[bp]
29016                                           ! Debug: list unsigned int = ax+2 (used reg = )
29017 8706           40                         inc	ax
29018 8707           40                         inc	ax
29019 8708           50                         push	ax
29020                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29021 8709           FF76         04            push	4[bp]
29022                                           ! Debug: func () void = write_byte+0 (used reg = )
29023 870C           E8         7F0F            call	_write_byte
29024 870F           83C4                   06  add	sp,*6
29025                                           !BCC_EOS
29026                                           ! 4221       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
29027                                           ! Debug: list * unsigned char = const $25D (used reg = )
29028 8712           B8                   025D  mov	ax,#$25D
29029 8715           50                         push	ax
29030                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29031 8716           FF76         FE            push	-2[bp]
29032                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29033 8719           E8         7EDC            call	_read_byte
29034 871C           83C4                   04  add	sp,*4
29035                                           ! Debug: list unsigned char = al+0 (used reg = )
29036 871F           30E4                       xor	ah,ah
29037 8721           50                         push	ax
29038                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
29039 8722           8B46         0A            mov	ax,$A[bp]
29040                                           ! Debug: list unsigned int = ax+3 (used reg = )
29041 8725           05                   0003  add	ax,*3
29042 8728           50                         push	ax
29043                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29044 8729           FF76         04            push	4[bp]
29045                                           ! Debug: func () void = write_byte+0 (used reg = )
29046 872C           E8         7EEF            call	_write_byte
29047 872F           83C4                   06  add	sp,*6
29048                                           !BCC_EOS
29049                                           ! 4222       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
29050                                           ! Debug: list * unsigned long = const $260 (used reg = )
29051 8732           B8                   0260  mov	ax,#$260
29052 8735           50                         push	ax
29053                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29054 8736           FF76         FE            push	-2[bp]
29055                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
29056 8739           E8         7947            call	_read_dword
29057 873C           89D3                       mov	bx,dx
29058 873E           83C4                   04  add	sp,*4
29059                                           ! Debug: list unsigned long = bx+0 (used reg = )
29060 8741           53                         push	bx
29061 8742           50                         push	ax
29062                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
29063 8743           8B46         0A            mov	ax,$A[bp]
29064                                           ! Debug: list unsigned int = ax+4 (used reg = )
29065 8746           05                   0004  add	ax,*4
29066 8749           50                         push	ax
29067                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
29068 874A           FF76         04            push	4[bp]
29069                                           ! Debug: func () void = write_dword+0 (used reg = )
29070 874D           E8         794B            call	_write_dword
29071 8750           83C4                   08  add	sp,*8
29072                                           !BCC_EOS
29073                                           ! 4223       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
29074                                           ! Debug: list * unsigned short = const $25E (used reg = )
29075 8753           B8                   025E  mov	ax,#$25E
29076 8756           50                         push	ax
29077                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29078 8757           FF76         FE            push	-2[bp]
29079                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29080 875A           E8         7EAE            call	_read_word
29081 875D           83C4                   04  add	sp,*4
29082                                           ! Debug: list unsigned short = ax+0 (used reg = )
29083 8760           50                         push	ax
29084                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
29085 8761           8B46         0A            mov	ax,$A[bp]
29086                                           ! Debug: list unsigned int = ax+8 (used reg = )
29087 8764           05                   0008  add	ax,*8
29088 8767           50                         push	ax
29089                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29090 8768           FF76         04            push	4[bp]
29091                                           ! Debug: func () void = write_word+0 (used reg = )
29092 876B           E8         7EC8            call	_write_word
29093 876E           83C4                   06  add	sp,*6
29094                                           !BCC_EOS
29095                                           ! 4224       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
29096                                           ! Debug: list * unsigned short = const $264 (used reg = )
29097 8771           B8                   0264  mov	ax,#$264
29098 8774           50                         push	ax
29099                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29100 8775           FF76         FE            push	-2[bp]
29101                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29102 8778           E8         7E90            call	_read_word
29103 877B           83C4                   04  add	sp,*4
29104                                           ! Debug: list unsigned short = ax+0 (used reg = )
29105 877E           50                         push	ax
29106                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
29107 877F           8B46         0A            mov	ax,$A[bp]
29108                                           ! Debug: list unsigned int = ax+$A (used reg = )
29109 8782           05                   000A  add	ax,*$A
29110 8785           50                         push	ax
29111                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29112 8786           FF76         04            push	4[bp]
29113                                           ! Debug: func () void = write_word+0 (used reg = )
29114 8789           E8         7EAA            call	_write_word
29115 878C           83C4                   06  add	sp,*6
29116                                           !BCC_EOS
29117                                           ! 4225       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
29118                                           ! Debug: list * unsigned short = const $266 (used reg = )
29119 878F           B8                   0266  mov	ax,#$266
29120 8792           50                         push	ax
29121                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29122 8793           FF76         FE            push	-2[bp]
29123                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29124 8796           E8         7E72            call	_read_word
29125 8799           83C4                   04  add	sp,*4
29126                                           ! Debug: list unsigned short = ax+0 (used reg = )
29127 879C           50                         push	ax
29128                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
29129 879D           8B46         0A            mov	ax,$A[bp]
29130                                           ! Debug: list unsigned int = ax+$C (used reg = )
29131 87A0           05                   000C  add	ax,*$C
29132 87A3           50                         push	ax
29133                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29134 87A4           FF76         04            push	4[bp]
29135                                           ! Debug: func () void = write_word+0 (used reg = )
29136 87A7           E8         7E8C            call	_write_word
29137 87AA           83C4                   06  add	sp,*6
29138                                           !BCC_EOS
29139                                           ! 4226       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
29140                                           ! Debug: list * unsigned short = const $268 (used reg = )
29141 87AD           B8                   0268  mov	ax,#$268
29142 87B0           50                         push	ax
29143                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29144 87B1           FF76         FE            push	-2[bp]
29145                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29146 87B4           E8         7E54            call	_read_word
29147 87B7           83C4                   04  add	sp,*4
29148                                           ! Debug: list unsigned short = ax+0 (used reg = )
29149 87BA           50                         push	ax
29150                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
29151 87BB           8B46         0A            mov	ax,$A[bp]
29152                                           ! Debug: list unsigned int = ax+$E (used reg = )
29153 87BE           05                   000E  add	ax,*$E
29154 87C1           50                         push	ax
29155                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29156 87C2           FF76         04            push	4[bp]
29157                                           ! Debug: func () void = write_word+0 (used reg = )
29158 87C5           E8         7E6E            call	_write_word
29159 87C8           83C4                   06  add	sp,*6
29160                                           !BCC_EOS
29161                                           ! 4227       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
29162                                           ! Debug: list * unsigned short = const $26C (used reg = )
29163 87CB           B8                   026C  mov	ax,#$26C
29164 87CE           50                         push	ax
29165                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29166 87CF           FF76         FE            push	-2[bp]
29167                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29168 87D2           E8         7E23            call	_read_byte
29169 87D5           83C4                   04  add	sp,*4
29170                                           ! Debug: list unsigned char = al+0 (used reg = )
29171 87D8           30E4                       xor	ah,ah
29172 87DA           50                         push	ax
29173                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
29174 87DB           8B46         0A            mov	ax,$A[bp]
29175                                           ! Debug: list unsigned int = ax+$10 (used reg = )
29176 87DE           05                   0010  add	ax,*$10
29177 87E1           50                         push	ax
29178                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29179 87E2           FF76         04            push	4[bp]
29180                                           ! Debug: func () void = write_byte+0 (used reg = )
29181 87E5           E8         7E36            call	_write_byte
29182 87E8           83C4                   06  add	sp,*6
29183                                           !BCC_EOS
29184                                           ! 4228       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
29185                                           ! Debug: list * unsigned short = const $26E (used reg = )
29186 87EB           B8                   026E  mov	ax,#$26E
29187 87EE           50                         push	ax
29188                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29189 87EF           FF76         FE            push	-2[bp]
29190                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29191 87F2           E8         7E03            call	_read_byte
29192 87F5           83C4                   04  add	sp,*4
29193                                           ! Debug: list unsigned char = al+0 (used reg = )
29194 87F8           30E4                       xor	ah,ah
29195 87FA           50                         push	ax
29196                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
29197 87FB           8B46         0A            mov	ax,$A[bp]
29198                                           ! Debug: list unsigned int = ax+$11 (used reg = )
29199 87FE           05                   0011  add	ax,*$11
29200 8801           50                         push	ax
29201                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29202 8802           FF76         04            push	4[bp]
29203                                           ! Debug: func () void = write_byte+0 (used reg = )
29204 8805           E8         7E16            call	_write_byte
29205 8808           83C4                   06  add	sp,*6
29206                                           !BCC_EOS
29207                                           ! 4229       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
29208                                           ! Debug: list * unsigned short = const $26A (used reg = )
29209 880B           B8                   026A  mov	ax,#$26A
29210 880E           50                         push	ax
29211                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29212 880F           FF76         FE            push	-2[bp]
29213                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29214 8812           E8         7DE3            call	_read_byte
29215 8815           83C4                   04  add	sp,*4
29216                                           ! Debug: list unsigned char = al+0 (used reg = )
29217 8818           30E4                       xor	ah,ah
29218 881A           50                         push	ax
29219                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
29220 881B           8B46         0A            mov	ax,$A[bp]
29221                                           ! Debug: list unsigned int = ax+$12 (used reg = )
29222 881E           05                   0012  add	ax,*$12
29223 8821           50                         push	ax
29224                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29225 8822           FF76         04            push	4[bp]
29226                                           ! Debug: func () void = write_byte+0 (used reg = )
29227 8825           E8         7DF6            call	_write_byte
29228 8828           83C4                   06  add	sp,*6
29229                                           !BCC_EOS
29230                                           ! 4230       if(( AX & 0x00ff ) == 0x00) {
29231                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29232 882B           8A46         16            mov	al,$16[bp]
29233                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29234 882E           84C0                       test	al,al
29235 8830           75           10            jne 	.60F
29236                       00008832            .610:
29237                                           ! 4231         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
29238                                           ! Debug: list int = const 0 (used reg = )
29239 8832           31C0                       xor	ax,ax
29240 8834           50                         push	ax
29241                                           ! Debug: list * unsigned char = const $25A (used reg = )
29242 8835           B8                   025A  mov	ax,#$25A
29243 8838           50                         push	ax
29244                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
29245 8839           FF76         FE            push	-2[bp]
29246                                           ! Debug: func () void = write_byte+0 (used reg = )
29247 883C           E8         7DDF            call	_write_byte
29248 883F           83C4                   06  add	sp,*6
29249                                           !BCC_EOS
29250                                           ! 4232       }
29251                                           ! 4233       goto int13_success;
29252                       00008842            .60F:
29253 8842           83C4                   00  add	sp,#..FFE3-..FFE5
29254 8845           EB           6C            jmp .FFE3
29255                                           !BCC_EOS
29256                                           ! 4234       break;
29257 8847           EB           3D            jmp .607
29258                                           !BCC_EOS
29259                                           ! 4235     default:
29260                                           ! 4236       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
29261                       00008849            .611:
29262                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29263 8849           8B46         16            mov	ax,$16[bp]
29264 884C           88E0                       mov	al,ah
29265 884E           30E4                       xor	ah,ah
29266                                           ! Debug: list unsigned int = ax+0 (used reg = )
29267 8850           50                         push	ax
29268                                           ! Debug: list * char = .612+0 (used reg = )
29269 8851           BB                   CEF9  mov	bx,#.612
29270 8854           53                         push	bx
29271                                           ! Debug: list int = const 4 (used reg = )
29272 8855           B8                   0004  mov	ax,*4
29273 8858           50                         push	ax
29274                                           ! Debug: func () void = bios_printf+0 (used reg = )
29275 8859           E8         814B            call	_bios_printf
29276 885C           83C4                   06  add	sp,*6
29277                                           !BCC_EOS
29278                                           ! 4237       goto int13_fail;
29279 885F           83C4                   00  add	sp,#..FFE4-..FFE5
29280 8862           EB           22            jmp .FFE4
29281                                           !BCC_EOS
29282                                           ! 4238       break;
29283 8864           EB           20            jmp .607
29284                                           !BCC_EOS
29285                                           ! 4239   }
29286                                           ! 4240 int13_fail:
29287 8866           EB           1E            jmp .607
29288                       00008868            .609:
29289 8868           2D                   004A  sub	ax,*$4A
29290 886B         0F84         FE3B            beq 	.60A
29291 886F           2D                   0001  sub	ax,*1
29292 8872         0F84         FE4E            beq 	.60E
29293 8876           2D                   0001  sub	ax,*1
29294 8879         0F84         FE2D            beq 	.60B
29295 887D           2D                   0001  sub	ax,*1
29296 8880         0F84         FE26            beq 	.60C
29297 8884           EB           C3            jmp	.611
29298                       00008886            .607:
29299                       FFFFFFFC            ..FFE5	=	-4
29300                       00008886            .FFE4:
29301                       FFFFFFFC            ..FFE4	=	-4
29302                                           ! 4241   AX = ((AX & 0x00ff) | ((0x01) << 8));
29303                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29304 8886           8A46         16            mov	al,$16[bp]
29305                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29306 8889           30E4                       xor	ah,ah
29307 888B           0D                   0100  or	ax,#$100
29308                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
29309 888E           8946         16            mov	$16[bp],ax
29310                                           !BCC_EOS
29311                                           ! 4242   write_byte(0x0040, 0x0074, ( AX >> 8 ));
29312                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29313 8891           8B46         16            mov	ax,$16[bp]
29314 8894           88E0                       mov	al,ah
29315 8896           30E4                       xor	ah,ah
29316                                           ! Debug: list unsigned int = ax+0 (used reg = )
29317 8898           50                         push	ax
29318                                           ! Debug: list int = const $74 (used reg = )
29319 8899           B8                   0074  mov	ax,*$74
29320 889C           50                         push	ax
29321                                           ! Debug: list int = const $40 (used reg = )
29322 889D           B8                   0040  mov	ax,*$40
29323 88A0           50                         push	ax
29324                                           ! Debug: func () void = write_byte+0 (used reg = )
29325 88A1           E8         7D7A            call	_write_byte
29326 88A4           83C4                   06  add	sp,*6
29327                                           !BCC_EOS
29328                                           ! 4243   FLAGS |= 0x0001;
29329                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
29330 88A7           8B46         1C            mov	ax,$1C[bp]
29331 88AA           0C                     01  or	al,*1
29332 88AC           8946         1C            mov	$1C[bp],ax
29333                                           !BCC_EOS
29334                                           ! 4244   return;
29335 88AF           89EC                       mov	sp,bp
29336 88B1           5D                         pop	bp
29337 88B2           C3                         ret
29338                                           !BCC_EOS
29339                                           ! 4245 int13_success:
29340                       000088B3            .FFE3:
29341                       FFFFFFFC            ..FFE3	=	-4
29342                                           ! 4246   AX = ((AX & 0x00ff) | ((0x00) << 8));
29343                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29344 88B3           8A46         16            mov	al,$16[bp]
29345                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29346 88B6           0C                     00  or	al,*0
29347                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
29348 88B8           30E4                       xor	ah,ah
29349 88BA           8946         16            mov	$16[bp],ax
29350                                           !BCC_EOS
29351                                           ! 4247   write_byte(0x0040, 0x0074, 0x00);
29352                                           ! Debug: list int = const 0 (used reg = )
29353 88BD           31C0                       xor	ax,ax
29354 88BF           50                         push	ax
29355                                           ! Debug: list int = const $74 (used reg = )
29356 88C0           B8                   0074  mov	ax,*$74
29357 88C3           50                         push	ax
29358                                           ! Debug: list int = const $40 (used reg = )
29359 88C4           B8                   0040  mov	ax,*$40
29360 88C7           50                         push	ax
29361                                           ! Debug: func () void = write_byte+0 (used reg = )
29362 88C8           E8         7D53            call	_write_byte
29363 88CB           83C4                   06  add	sp,*6
29364                                           !BCC_EOS
29365                                           ! 4248   FLAGS &= 0xfffe;
29366                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
29367 88CE           8B46         1C            mov	ax,$1C[bp]
29368 88D1           24                     FE  and	al,#$FE
29369 88D3           8946         1C            mov	$1C[bp],ax
29370                                           !BCC_EOS
29371                                           ! 4249 }
29372 88D6           89EC                       mov	sp,bp
29373 88D8           5D                         pop	bp
29374 88D9           C3                         ret
29375                                           ! 4250   void
29376                                           ! Register BX used in function int13_eltorito
29377                                           ! 4251 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
29378                                           ! 4252   Bit16u DS, ES, DI, SI, 
29379                                           export	_int13_cdemu
29380                       000088DA            _int13_cdemu:
29381                                           ! 4252 BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
29382                                           !BCC_EOS
29383                                           ! 4253 {
29384                                           ! 4254   Bit16u ebda_seg=read_word(0x0040,0x000E);
29385 88DA           55                         push	bp
29386 88DB           89E5                       mov	bp,sp
29387 88DD           4C                         dec	sp
29388 88DE           4C                         dec	sp
29389                                           ! Debug: list int = const $E (used reg = )
29390 88DF           B8                   000E  mov	ax,*$E
29391 88E2           50                         push	ax
29392                                           ! Debug: list int = const $40 (used reg = )
29393 88E3           B8                   0040  mov	ax,*$40
29394 88E6           50                         push	ax
29395                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29396 88E7           E8         7D21            call	_read_word
29397 88EA           83C4                   04  add	sp,*4
29398                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
29399 88ED           8946         FE            mov	-2[bp],ax
29400                                           !BCC_EOS
29401                                           ! 4255   Bit8u device, status;
29402                                           !BCC_EOS
29403                                           ! 4256   Bit16u vheads, vspt, vcylinders;
29404                                           !BCC_EOS
29405                                           ! 4257   Bit16u head, sector, cylinder, nbsectors;
29406                                           !BCC_EOS
29407                                           ! 4258   Bit32u vlba, ilba, slba, elba;
29408                                           !BCC_EOS
29409                                           ! 4259   Bit16u before, segment, offset;
29410                                           !BCC_EOS
29411                                           ! 4260   Bit8u atacmd[12];
29412                                           !BCC_EOS
29413                                           ! 4261   ;
29414 88F0           83C4                   CE  add	sp,*-$32
29415                                           !BCC_EOS
29416                                           ! 4262   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
29417                                           ! Debug: list * unsigned char = const $25D (used reg = )
29418 88F3           B8                   025D  mov	ax,#$25D
29419 88F6           50                         push	ax
29420                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29421 88F7           FF76         FE            push	-2[bp]
29422                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29423 88FA           E8         7CFB            call	_read_byte
29424 88FD           83C4                   04  add	sp,*4
29425                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
29426 8900           30E4                       xor	ah,ah
29427 8902           D1E0                       shl	ax,*1
29428                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
29429 8904           8846         FD            mov	-3[bp],al
29430                                           !BCC_EOS
29431                                           ! 4263   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
29432                                           ! Debug: list * unsigned short = const $25E (used reg = )
29433 8907           B8                   025E  mov	ax,#$25E
29434 890A           50                         push	ax
29435                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29436 890B           FF76         FE            push	-2[bp]
29437                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29438 890E           E8         7CE7            call	_read_byte
29439 8911           83C4                   04  add	sp,*4
29440                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
29441 8914           30E4                       xor	ah,ah
29442 8916           0246         FD            add	al,-3[bp]
29443 8919           80D4                   00  adc	ah,*0
29444 891C           8846         FD            mov	-3[bp],al
29445                                           !BCC_EOS
29446                                           ! 4264   write_byte(0x0040, 0x0074, 0x00);
29447                                           ! Debug: list int = const 0 (used reg = )
29448 891F           31C0                       xor	ax,ax
29449 8921           50                         push	ax
29450                                           ! Debug: list int = const $74 (used reg = )
29451 8922           B8                   0074  mov	ax,*$74
29452 8925           50                         push	ax
29453                                           ! Debug: list int = const $40 (used reg = )
29454 8926           B8                   0040  mov	ax,*$40
29455 8929           50                         push	ax
29456                                           ! Debug: func () void = write_byte+0 (used reg = )
29457 892A           E8         7CF1            call	_write_byte
29458 892D           83C4                   06  add	sp,*6
29459                                           !BCC_EOS
29460                                           ! 4265   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0) ||
29461                                           ! 4266       (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
29462                                           ! Debug: list * unsigned char = const $25A (used reg = )
29463 8930           B8                   025A  mov	ax,#$25A
29464 8933           50                         push	ax
29465                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29466 8934           FF76         FE            push	-2[bp]
29467                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29468 8937           E8         7CBE            call	_read_byte
29469 893A           83C4                   04  add	sp,*4
29470                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29471 893D           84C0                       test	al,al
29472 893F           74           19            je  	.614
29473                       00008941            .615:
29474                                           ! Debug: expression subtree swapping
29475                                           ! Debug: list * unsigned char = const $25C (used reg = )
29476 8941           B8                   025C  mov	ax,#$25C
29477 8944           50                         push	ax
29478                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29479 8945           FF76         FE            push	-2[bp]
29480                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29481 8948           E8         7CAD            call	_read_byte
29482 894B           83C4                   04  add	sp,*4
29483 894E           50                         push	ax
29484                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29485 894F           8A46         12            mov	al,$12[bp]
29486                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29487 8952           3A46         CA            cmp	al,-$36[bp]
29488 8955           8D66         CC            lea	sp,-$34[bp]
29489 8958           74           22            je  	.613
29490                       0000895A            .614:
29491                                           ! 4267     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
29492                                           ! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
29493 895A           8A46         12            mov	al,$12[bp]
29494                                           ! Debug: list unsigned char = al+0 (used reg = )
29495 895D           30E4                       xor	ah,ah
29496 895F           50                         push	ax
29497                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
29498 8960           8B46         16            mov	ax,$16[bp]
29499 8963           88E0                       mov	al,ah
29500 8965           30E4                       xor	ah,ah
29501                                           ! Debug: list unsigned int = ax+0 (used reg = )
29502 8967           50                         push	ax
29503                                           ! Debug: list * char = .616+0 (used reg = )
29504 8968           BB                   CEBA  mov	bx,#.616
29505 896B           53                         push	bx
29506                                           ! Debug: list int = const 4 (used reg = )
29507 896C           B8                   0004  mov	ax,*4
29508 896F           50                         push	ax
29509                                           ! Debug: func () void = bios_printf+0 (used reg = )
29510 8970           E8         8034            call	_bios_printf
29511 8973           83C4                   08  add	sp,*8
29512                                           !BCC_EOS
29513                                           ! 4268     goto int13_fail;
29514 8976           83C4                   00  add	sp,#..FFE2+$36
29515 8979           E9         0563            br 	.FFE2
29516                                           !BCC_EOS
29517                                           ! 4269   }
29518                                           ! 4270   switch (( AX >> 8 )) {
29519                       0000897C            .613:
29520                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29521 897C           8B46         16            mov	ax,$16[bp]
29522 897F           88E0                       mov	al,ah
29523 8981           30E4                       xor	ah,ah
29524 8983           E9         04DE            br 	.619
29525                                           ! 4271     case 0x00:
29526                                           ! 4272     case 0x09:
29527                       00008986            .61A:
29528                                           ! 4273     case 0x0c:
29529                       00008986            .61B:
29530                                           ! 4274     case 0x0d:
29531                       00008986            .61C:
29532                                           ! 4275     case 0x10:
29533                       00008986            .61D:
29534                                           ! 4276     case 0x11:
29535                       00008986            .61E:
29536                                           ! 4277     case 0x14:
29537                       00008986            .61F:
29538                                           ! 4278     case 0x16:
29539                       00008986            .620:
29540                                           ! 4279       goto int13_success;
29541                       00008986            .621:
29542 8986           83C4                   00  add	sp,#..FFE0-..FFE1
29543 8989           E9         0580            br 	.FFE0
29544                                           !BCC_EOS
29545                                           ! 4280       break;
29546 898C           E9         0550            br 	.617
29547                                           !BCC_EOS
29548                                           ! 4281     case 0x03:
29549                                           ! 4282     case 0x05:
29550                       0000898F            .622:
29551                                           ! 4283       AX = ((AX & 0x00ff) | ((0x03) << 8));
29552                       0000898F            .623:
29553                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29554 898F           8A46         16            mov	al,$16[bp]
29555                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29556 8992           30E4                       xor	ah,ah
29557 8994           0D                   0300  or	ax,#$300
29558                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29559 8997           8946         16            mov	$16[bp],ax
29560                                           !BCC_EOS
29561                                           ! 4284       goto int13_fail_noah;
29562 899A           83C4                   00  add	sp,#..FFDF-..FFE1
29563 899D           E9         054A            br 	.FFDF
29564                                           !BCC_EOS
29565                                           ! 4285       break;
29566 89A0           E9         053C            br 	.617
29567                                           !BCC_EOS
29568                                           ! 4286     case 0x01:
29569                                           ! 4287       status=read_byte(0x0040, 0x0074);
29570                       000089A3            .624:
29571                                           ! Debug: list int = const $74 (used reg = )
29572 89A3           B8                   0074  mov	ax,*$74
29573 89A6           50                         push	ax
29574                                           ! Debug: list int = const $40 (used reg = )
29575 89A7           B8                   0040  mov	ax,*$40
29576 89AA           50                         push	ax
29577                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29578 89AB           E8         7C4A            call	_read_byte
29579 89AE           83C4                   04  add	sp,*4
29580                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
29581 89B1           8846         FC            mov	-4[bp],al
29582                                           !BCC_EOS
29583                                           ! 4288       AX = ((AX & 0x00ff) | ((status) << 8));
29584                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
29585 89B4           8A46         FC            mov	al,-4[bp]
29586 89B7           30E4                       xor	ah,ah
29587 89B9           88C4                       mov	ah,al
29588 89BB           30C0                       xor	al,al
29589 89BD           50                         push	ax
29590                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
29591 89BE           8A46         16            mov	al,$16[bp]
29592                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29593 89C1           30E4                       xor	ah,ah
29594 89C3           0B46         CA            or	ax,0+..FFE1[bp]
29595 89C6           44                         inc	sp
29596 89C7           44                         inc	sp
29597                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29598 89C8           8946         16            mov	$16[bp],ax
29599                                           !BCC_EOS
29600                                           ! 4289       write_byte(0x0040, 0x0074, 0);
29601                                           ! Debug: list int = const 0 (used reg = )
29602 89CB           31C0                       xor	ax,ax
29603 89CD           50                         push	ax
29604                                           ! Debug: list int = const $74 (used reg = )
29605 89CE           B8                   0074  mov	ax,*$74
29606 89D1           50                         push	ax
29607                                           ! Debug: list int = const $40 (used reg = )
29608 89D2           B8                   0040  mov	ax,*$40
29609 89D5           50                         push	ax
29610                                           ! Debug: func () void = write_byte+0 (used reg = )
29611 89D6           E8         7C45            call	_write_byte
29612 89D9           83C4                   06  add	sp,*6
29613                                           !BCC_EOS
29614                                           ! 4290       if (status) goto int13_fail_nostatus;
29615 89DC           8A46         FC            mov	al,-4[bp]
29616 89DF           84C0                       test	al,al
29617 89E1           74           08            je  	.625
29618                       000089E3            .626:
29619 89E3           83C4                   00  add	sp,#..FFDE-..FFE1
29620 89E6           E9         0517            br 	.FFDE
29621                                           !BCC_EOS
29622                                           ! 4291       else goto int13_success_noah;
29623 89E9           EB           06            jmp .627
29624                       000089EB            .625:
29625 89EB           83C4                   00  add	sp,#..FFDD-..FFE1
29626 89EE           E9         0525            br 	.FFDD
29627                                           !BCC_EOS
29628                                           ! 4292       break;
29629                       000089F1            .627:
29630 89F1           E9         04EB            br 	.617
29631                                           !BCC_EOS
29632                                           ! 4293     case 0x02:
29633                                           ! 4294     case 0x04:
29634                       000089F4            .628:
29635                                           ! 4295       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29636                       000089F4            .629:
29637                                           ! Debug: list * unsigned short = const $26E (used reg = )
29638 89F4           B8                   026E  mov	ax,#$26E
29639 89F7           50                         push	ax
29640                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29641 89F8           FF76         FE            push	-2[bp]
29642                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29643 89FB           E8         7C0D            call	_read_word
29644 89FE           83C4                   04  add	sp,*4
29645                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29646 8A01           8946         F8            mov	-8[bp],ax
29647                                           !BCC_EOS
29648                                           ! 4296       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
29649                                           ! Debug: list * unsigned short = const $26C (used reg = )
29650 8A04           B8                   026C  mov	ax,#$26C
29651 8A07           50                         push	ax
29652                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29653 8A08           FF76         FE            push	-2[bp]
29654                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29655 8A0B           E8         7BFD            call	_read_word
29656 8A0E           83C4                   04  add	sp,*4
29657                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29658 8A11           8946         F6            mov	-$A[bp],ax
29659                                           !BCC_EOS
29660                                           ! 4297       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
29661                                           ! Debug: list * unsigned short = const $26A (used reg = )
29662 8A14           B8                   026A  mov	ax,#$26A
29663 8A17           50                         push	ax
29664                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29665 8A18           FF76         FE            push	-2[bp]
29666                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29667 8A1B           E8         7BED            call	_read_word
29668 8A1E           83C4                   04  add	sp,*4
29669                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
29670 8A21           8946         FA            mov	-6[bp],ax
29671                                           !BCC_EOS
29672                                           ! 4298       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
29673                                           ! Debug: list * unsigned long = const $260 (used reg = )
29674 8A24           B8                   0260  mov	ax,#$260
29675 8A27           50                         push	ax
29676                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29677 8A28           FF76         FE            push	-2[bp]
29678                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
29679 8A2B           E8         7655            call	_read_dword
29680 8A2E           89D3                       mov	bx,dx
29681 8A30           83C4                   04  add	sp,*4
29682                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
29683 8A33           8946         E6            mov	-$1A[bp],ax
29684 8A36           895E         E8            mov	-$18[bp],bx
29685                                           !BCC_EOS
29686                                           ! 4299       sector = ( CX & 0x00ff ) & 0x003f;
29687                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
29688 8A39           8A46         14            mov	al,$14[bp]
29689                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
29690 8A3C           24                     3F  and	al,*$3F
29691                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
29692 8A3E           30E4                       xor	ah,ah
29693 8A40           8946         F2            mov	-$E[bp],ax
29694                                           !BCC_EOS
29695                                           ! 4300       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
29696                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
29697 8A43           8B46         14            mov	ax,$14[bp]
29698 8A46           88E0                       mov	al,ah
29699 8A48           30E4                       xor	ah,ah
29700 8A4A           50                         push	ax
29701                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29702 8A4B           8A46         14            mov	al,$14[bp]
29703                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
29704 8A4E           24                     C0  and	al,#$C0
29705                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
29706 8A50           30E4                       xor	ah,ah
29707 8A52           D1E0                       shl	ax,*1
29708 8A54           D1E0                       shl	ax,*1
29709                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29710 8A56           0B46         CA            or	ax,0+..FFE1[bp]
29711 8A59           44                         inc	sp
29712 8A5A           44                         inc	sp
29713                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
29714 8A5B           8946         F0            mov	-$10[bp],ax
29715                                           !BCC_EOS
29716                                           ! 4301       head = ( DX >> 8 );
29717                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
29718 8A5E           8B46         12            mov	ax,$12[bp]
29719 8A61           88E0                       mov	al,ah
29720 8A63           30E4                       xor	ah,ah
29721                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
29722 8A65           8946         F4            mov	-$C[bp],ax
29723                                           !BCC_EOS
29724                                           ! 4302       nbsectors = ( AX & 0x00ff );
29725                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29726 8A68           8A46         16            mov	al,$16[bp]
29727                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29728 8A6B           30E4                       xor	ah,ah
29729 8A6D           8946         EE            mov	-$12[bp],ax
29730                                           !BCC_EOS
29731                                           ! 4303       segment = ES;
29732                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
29733 8A70           8B46         06            mov	ax,6[bp]
29734 8A73           8946         DA            mov	-$26[bp],ax
29735                                           !BCC_EOS
29736                                           ! 4304       offset = BX;
29737                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
29738 8A76           8B46         10            mov	ax,$10[bp]
29739 8A79           8946         D8            mov	-$28[bp],ax
29740                                           !BCC_EOS
29741                                           ! 4305       if(nbsectors==0) goto int13_success;
29742                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29743 8A7C           8B46         EE            mov	ax,-$12[bp]
29744 8A7F           85C0                       test	ax,ax
29745 8A81           75           06            jne 	.62A
29746                       00008A83            .62B:
29747 8A83           83C4                   00  add	sp,#..FFE0-..FFE1
29748 8A86           E9         0483            br 	.FFE0
29749                                           !BCC_EOS
29750                                           ! 4306       if ((sector > vspt)
29751                       00008A89            .62A:
29752                                           ! 4307        || (cylinder >= vcylinders)
29753                                           ! 4308        || (head >= vheads)) {
29754                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
29755 8A89           8B46         F2            mov	ax,-$E[bp]
29756 8A8C           3B46         F8            cmp	ax,-8[bp]
29757 8A8F           77           10            ja  	.62D
29758                       00008A91            .62F:
29759                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
29760 8A91           8B46         F0            mov	ax,-$10[bp]
29761 8A94           3B46         F6            cmp	ax,-$A[bp]
29762 8A97           73           08            jae 	.62D
29763                       00008A99            .62E:
29764                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
29765 8A99           8B46         F4            mov	ax,-$C[bp]
29766 8A9C           3B46         FA            cmp	ax,-6[bp]
29767 8A9F           72           06            jb  	.62C
29768                       00008AA1            .62D:
29769                                           ! 4309         goto int13_fail;
29770 8AA1           83C4                   00  add	sp,#..FFE2-..FFE1
29771 8AA4           E9         0438            br 	.FFE2
29772                                           !BCC_EOS
29773                                           ! 4310       }
29774                                           ! 4311       if (( AX >> 8 ) == 0x04) goto
29775                       00008AA7            .62C:
29776                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29777 8AA7           8B46         16            mov	ax,$16[bp]
29778 8AAA           88E0                       mov	al,ah
29779 8AAC           30E4                       xor	ah,ah
29780                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
29781 8AAE           3D                   0004  cmp	ax,*4
29782 8AB1           75           06            jne 	.630
29783                       00008AB3            .631:
29784                                           ! 4311  int13_success;
29785 8AB3           83C4                   00  add	sp,#..FFE0-..FFE1
29786 8AB6           E9         0453            br 	.FFE0
29787                                           !BCC_EOS
29788                                           ! 4312       segment = ES+(BX / 16);
29789                       00008AB9            .630:
29790                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29791 8AB9           8B46         10            mov	ax,$10[bp]
29792 8ABC           B1                     04  mov	cl,*4
29793 8ABE           D3E8                       shr	ax,cl
29794                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
29795                                           ! Debug: expression subtree swapping
29796 8AC0           0346         06            add	ax,6[bp]
29797                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
29798 8AC3           8946         DA            mov	-$26[bp],ax
29799                                           !BCC_EOS
29800                                           ! 4313       offset = BX % 16;
29801                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29802 8AC6           8B46         10            mov	ax,$10[bp]
29803 8AC9           24                     0F  and	al,*$F
29804                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
29805 8ACB           30E4                       xor	ah,ah
29806 8ACD           8946         D8            mov	-$28[bp],ax
29807                                           !BCC_EOS
29808                                           ! 4314       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
29809                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
29810 8AD0           8B46         F2            mov	ax,-$E[bp]
29811                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
29812 8AD3           48                         dec	ax
29813 8AD4           31DB                       xor	bx,bx
29814 8AD6           53                         push	bx
29815 8AD7           50                         push	ax
29816                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
29817 8AD8           8B46         F8            mov	ax,-8[bp]
29818 8ADB           31DB                       xor	bx,bx
29819 8ADD           53                         push	bx
29820 8ADE           50                         push	ax
29821                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
29822 8ADF           8B46         F4            mov	ax,-$C[bp]
29823 8AE2           31DB                       xor	bx,bx
29824 8AE4           53                         push	bx
29825 8AE5           50                         push	ax
29826                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
29827 8AE6           8B46         FA            mov	ax,-6[bp]
29828 8AE9           31DB                       xor	bx,bx
29829 8AEB           53                         push	bx
29830 8AEC           50                         push	ax
29831                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
29832 8AED           8B46         F0            mov	ax,-$10[bp]
29833 8AF0           31DB                       xor	bx,bx
29834                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
29835 8AF2           8D7E         BC            lea	di,-$E+..FFE1[bp]
29836 8AF5           E8         75F1            call	lmulul
29837 8AF8           83C4                   04  add	sp,*4
29838                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
29839 8AFB           8D7E         C0            lea	di,-$A+..FFE1[bp]
29840 8AFE           E8         75C2            call	laddul
29841 8B01           83C4                   04  add	sp,*4
29842                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
29843 8B04           8D7E         C4            lea	di,-6+..FFE1[bp]
29844 8B07           E8         75DF            call	lmulul
29845 8B0A           83C4                   04  add	sp,*4
29846                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
29847 8B0D           8D7E         C8            lea	di,-2+..FFE1[bp]
29848 8B10           E8         75B0            call	laddul
29849 8B13           83C4                   04  add	sp,*4
29850                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29851 8B16           8946         EA            mov	-$16[bp],ax
29852 8B19           895E         EC            mov	-$14[bp],bx
29853                                           !BCC_EOS
29854                                           ! 4315       AX = ((AX & 0xff00) | (nbsectors));
29855                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29856 8B1C           8B46         16            mov	ax,$16[bp]
29857 8B1F           30C0                       xor	al,al
29858                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
29859 8B21           0B46         EE            or	ax,-$12[bp]
29860                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29861 8B24           8946         16            mov	$16[bp],ax
29862                                           !BCC_EOS
29863                                           ! 4316       slba = (Bit32u)vlba/4;
29864                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
29865 8B27           B8                   0004  mov	ax,*4
29866 8B2A           31DB                       xor	bx,bx
29867 8B2C           53                         push	bx
29868 8B2D           50                         push	ax
29869 8B2E           8B46         EA            mov	ax,-$16[bp]
29870 8B31           8B5E         EC            mov	bx,-$14[bp]
29871 8B34           8D7E         C8            lea	di,-2+..FFE1[bp]
29872 8B37           E8         7634            call	ldivul
29873 8B3A           83C4                   04  add	sp,*4
29874                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
29875 8B3D           8946         E2            mov	-$1E[bp],ax
29876 8B40           895E         E4            mov	-$1C[bp],bx
29877                                           !BCC_EOS
29878                                           ! 4317       before= (Bit16u)vlba%4;
29879                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
29880 8B43           8B46         EA            mov	ax,-$16[bp]
29881 8B46           24                     03  and	al,*3
29882                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
29883 8B48           30E4                       xor	ah,ah
29884 8B4A           8946         DC            mov	-$24[bp],ax
29885                                           !BCC_EOS
29886                                           ! 4318       elba = (Bit32u)(vlba+nbsectors-1)/4;
29887                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29888 8B4D           8B46         EE            mov	ax,-$12[bp]
29889 8B50           31DB                       xor	bx,bx
29890                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29891                                           ! Debug: expression subtree swapping
29892 8B52           8D7E         EA            lea	di,-$16[bp]
29893 8B55           E8         756B            call	laddul
29894                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29895 8B58           53                         push	bx
29896 8B59           50                         push	ax
29897 8B5A           B8                   0001  mov	ax,*1
29898 8B5D           31DB                       xor	bx,bx
29899 8B5F           53                         push	bx
29900 8B60           50                         push	ax
29901 8B61           8B46         C8            mov	ax,-2+..FFE1[bp]
29902 8B64           8B5E         CA            mov	bx,0+..FFE1[bp]
29903 8B67           8D7E         C4            lea	di,-6+..FFE1[bp]
29904 8B6A           E8         7574            call	lsubul
29905 8B6D           83C4                   08  add	sp,*8
29906                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
29907                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
29908 8B70           53                         push	bx
29909 8B71           50                         push	ax
29910 8B72           B8                   0004  mov	ax,*4
29911 8B75           31DB                       xor	bx,bx
29912 8B77           53                         push	bx
29913 8B78           50                         push	ax
29914 8B79           8B46         C8            mov	ax,-2+..FFE1[bp]
29915 8B7C           8B5E         CA            mov	bx,0+..FFE1[bp]
29916 8B7F           8D7E         C4            lea	di,-6+..FFE1[bp]
29917 8B82           E8         75E9            call	ldivul
29918 8B85           83C4                   08  add	sp,*8
29919                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
29920 8B88           8946         DE            mov	-$22[bp],ax
29921 8B8B           895E         E0            mov	-$20[bp],bx
29922                                           !BCC_EOS
29923                                           ! 4319       memsetb(get_SS(),atacmd,0,12);
29924                                           ! Debug: list int = const $C (used reg = )
29925 8B8E           B8                   000C  mov	ax,*$C
29926 8B91           50                         push	ax
29927                                           ! Debug: list int = const 0 (used reg = )
29928 8B92           31C0                       xor	ax,ax
29929 8B94           50                         push	ax
29930                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
29931 8B95           8D5E         CC            lea	bx,-$34[bp]
29932 8B98           53                         push	bx
29933                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29934 8B99           E8         7AB5            call	_get_SS
29935                                           ! Debug: list unsigned short = ax+0 (used reg = )
29936 8B9C           50                         push	ax
29937                                           ! Debug: func () void = memsetb+0 (used reg = )
29938 8B9D           E8         7460            call	_memsetb
29939 8BA0           83C4                   08  add	sp,*8
29940                                           !BCC_EOS
29941                                           ! 4320       atacmd[0]=0x28;
29942                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
29943 8BA3           B0                     28  mov	al,*$28
29944 8BA5           8846         CC            mov	-$34[bp],al
29945                                           !BCC_EOS
29946                                           ! 4321       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
29947                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29948 8BA8           8B46         DE            mov	ax,-$22[bp]
29949 8BAB           8B5E         E0            mov	bx,-$20[bp]
29950 8BAE           8D7E         E2            lea	di,-$1E[bp]
29951 8BB1           E8         752D            call	lsubul
29952                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29953 8BB4           53                         push	bx
29954 8BB5           50                         push	ax
29955 8BB6           B8                   0001  mov	ax,*1
29956 8BB9           31DB                       xor	bx,bx
29957 8BBB           53                         push	bx
29958 8BBC           50                         push	ax
29959 8BBD           8B46         C8            mov	ax,-2+..FFE1[bp]
29960 8BC0           8B5E         CA            mov	bx,0+..FFE1[bp]
29961 8BC3           8D7E         C4            lea	di,-6+..FFE1[bp]
29962 8BC6           E8         74FA            call	laddul
29963 8BC9           83C4                   08  add	sp,*8
29964                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29965                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
29966 8BCC           30C0                       xor	al,al
29967                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
29968 8BCE           88E0                       mov	al,ah
29969 8BD0           30E4                       xor	ah,ah
29970                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
29971 8BD2           8846         D3            mov	-$2D[bp],al
29972                                           !BCC_EOS
29973                                           ! 4322       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
29974                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29975 8BD5           8B46         DE            mov	ax,-$22[bp]
29976 8BD8           8B5E         E0            mov	bx,-$20[bp]
29977 8BDB           8D7E         E2            lea	di,-$1E[bp]
29978 8BDE           E8         7500            call	lsubul
29979                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29980 8BE1           53                         push	bx
29981 8BE2           50                         push	ax
29982 8BE3           B8                   0001  mov	ax,*1
29983 8BE6           31DB                       xor	bx,bx
29984 8BE8           53                         push	bx
29985 8BE9           50                         push	ax
29986 8BEA           8B46         C8            mov	ax,-2+..FFE1[bp]
29987 8BED           8B5E         CA            mov	bx,0+..FFE1[bp]
29988 8BF0           8D7E         C4            lea	di,-6+..FFE1[bp]
29989 8BF3           E8         74CD            call	laddul
29990 8BF6           83C4                   08  add	sp,*8
29991                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29992                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
29993                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
29994 8BF9           8846         D4            mov	-$2C[bp],al
29995                                           !BCC_EOS
29996                                           ! 4323       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
29997                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29998 8BFC           8B46         E6            mov	ax,-$1A[bp]
29999 8BFF           8B5E         E8            mov	bx,-$18[bp]
30000 8C02           8D7E         E2            lea	di,-$1E[bp]
30001 8C05           E8         74BB            call	laddul
30002                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
30003 8C08           53                         push	bx
30004 8C09           50                         push	ax
30005 8C0A           31C0                       xor	ax,ax
30006 8C0C           BB                   FF00  mov	bx,#$FF00
30007 8C0F           53                         push	bx
30008 8C10           50                         push	ax
30009 8C11           8B46         C8            mov	ax,-2+..FFE1[bp]
30010 8C14           8B5E         CA            mov	bx,0+..FFE1[bp]
30011 8C17           8D7E         C4            lea	di,-6+..FFE1[bp]
30012 8C1A           E8         749E            call	landul
30013 8C1D           83C4                   08  add	sp,*8
30014                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
30015 8C20           93                         xchg	bx,ax
30016 8C21           88E0                       mov	al,ah
30017 8C23           30E4                       xor	ah,ah
30018 8C25           31DB                       xor	bx,bx
30019                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
30020 8C27           8846         CE            mov	-$32[bp],al
30021                                           !BCC_EOS
30022                                           ! 4324       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
30023                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30024 8C2A           8B46         E6            mov	ax,-$1A[bp]
30025 8C2D           8B5E         E8            mov	bx,-$18[bp]
30026 8C30           8D7E         E2            lea	di,-$1E[bp]
30027 8C33           E8         748D            call	laddul
30028                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
30029 8C36           53                         push	bx
30030 8C37           50                         push	ax
30031 8C38           31C0                       xor	ax,ax
30032 8C3A           BB                   00FF  mov	bx,#$FF
30033 8C3D           53                         push	bx
30034 8C3E           50                         push	ax
30035 8C3F           8B46         C8            mov	ax,-2+..FFE1[bp]
30036 8C42           8B5E         CA            mov	bx,0+..FFE1[bp]
30037 8C45           8D7E         C4            lea	di,-6+..FFE1[bp]
30038 8C48           E8         7470            call	landul
30039 8C4B           83C4                   08  add	sp,*8
30040                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
30041 8C4E           93                         xchg	bx,ax
30042 8C4F           31DB                       xor	bx,bx
30043                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
30044 8C51           8846         CF            mov	-$31[bp],al
30045                                           !BCC_EOS
30046                                           ! 4325       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
30047                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30048 8C54           8B46         E6            mov	ax,-$1A[bp]
30049 8C57           8B5E         E8            mov	bx,-$18[bp]
30050 8C5A           8D7E         E2            lea	di,-$1E[bp]
30051 8C5D           E8         7463            call	laddul
30052                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
30053 8C60           53                         push	bx
30054 8C61           50                         push	ax
30055 8C62           B8                   FF00  mov	ax,#$FF00
30056 8C65           31DB                       xor	bx,bx
30057 8C67           53                         push	bx
30058 8C68           50                         push	ax
30059 8C69           8B46         C8            mov	ax,-2+..FFE1[bp]
30060 8C6C           8B5E         CA            mov	bx,0+..FFE1[bp]
30061 8C6F           8D7E         C4            lea	di,-6+..FFE1[bp]
30062 8C72           E8         7446            call	landul
30063 8C75           83C4                   08  add	sp,*8
30064                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
30065 8C78           88E0                       mov	al,ah
30066 8C7A           88DC                       mov	ah,bl
30067 8C7C           88FB                       mov	bl,bh
30068 8C7E           28FF                       sub	bh,bh
30069                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
30070 8C80           8846         D0            mov	-$30[bp],al
30071                                           !BCC_EOS
30072                                           ! 4326       atacmd[5]=(ilba+slba & 0x000000ff);
30073                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30074 8C83           8B46         E6            mov	ax,-$1A[bp]
30075 8C86           8B5E         E8            mov	bx,-$18[bp]
30076 8C89           8D7E         E2            lea	di,-$1E[bp]
30077 8C8C           E8         7434            call	laddul
30078                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
30079 8C8F           53                         push	bx
30080 8C90           50                         push	ax
30081 8C91           B8                   00FF  mov	ax,#$FF
30082 8C94           31DB                       xor	bx,bx
30083 8C96           53                         push	bx
30084 8C97           50                         push	ax
30085 8C98           8B46         C8            mov	ax,-2+..FFE1[bp]
30086 8C9B           8B5E         CA            mov	bx,0+..FFE1[bp]
30087 8C9E           8D7E         C4            lea	di,-6+..FFE1[bp]
30088 8CA1           E8         7417            call	landul
30089 8CA4           83C4                   08  add	sp,*8
30090                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
30091 8CA7           8846         D1            mov	-$2F[bp],al
30092                                           !BCC_EOS
30093                                           ! 4327       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
30094                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
30095 8CAA           FF76         D8            push	-$28[bp]
30096                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
30097 8CAD           FF76         DA            push	-$26[bp]
30098                                           ! Debug: list int = const 1 (used reg = )
30099 8CB0           B8                   0001  mov	ax,*1
30100 8CB3           50                         push	ax
30101                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
30102 8CB4           8B46         EE            mov	ax,-$12[bp]
30103 8CB7           31DB                       xor	bx,bx
30104                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
30105 8CB9           53                         push	bx
30106 8CBA           50                         push	ax
30107 8CBB           B8                   0200  mov	ax,#$200
30108 8CBE           31DB                       xor	bx,bx
30109 8CC0           53                         push	bx
30110 8CC1           50                         push	ax
30111 8CC2           8B46         C2            mov	ax,-8+..FFE1[bp]
30112 8CC5           8B5E         C4            mov	bx,-6+..FFE1[bp]
30113 8CC8           8D7E         BE            lea	di,-$C+..FFE1[bp]
30114 8CCB           E8         741B            call	lmulul
30115 8CCE           83C4                   08  add	sp,*8
30116                                           ! Debug: list unsigned long = bx+0 (used reg = )
30117 8CD1           53                         push	bx
30118 8CD2           50                         push	ax
30119                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
30120 8CD3           8B46         DC            mov	ax,-$24[bp]
30121 8CD6           B9                   0200  mov	cx,#$200
30122 8CD9           F7E9                       imul	cx
30123                                           ! Debug: list unsigned int = ax+0 (used reg = )
30124 8CDB           50                         push	ax
30125                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
30126 8CDC           8D5E         CC            lea	bx,-$34[bp]
30127 8CDF           53                         push	bx
30128                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
30129 8CE0           E8         796E            call	_get_SS
30130                                           ! Debug: list unsigned short = ax+0 (used reg = )
30131 8CE3           50                         push	ax
30132                                           ! Debug: list int = const $C (used reg = )
30133 8CE4           B8                   000C  mov	ax,*$C
30134 8CE7           50                         push	ax
30135                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
30136 8CE8           8A46         FD            mov	al,-3[bp]
30137 8CEB           30E4                       xor	ah,ah
30138 8CED           50                         push	ax
30139                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
30140 8CEE           E8         A8F6            call	_ata_cmd_packet
30141 8CF1           83C4                   14  add	sp,*$14
30142                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
30143 8CF4           8846         FC            mov	-4[bp],al
30144                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
30145 8CF7           84C0                       test	al,al
30146 8CF9           74           37            je  	.632
30147                       00008CFB            .633:
30148                                           ! 4328         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
30149                                           ! Debug: list unsigned char status = [S+$36-6] (used reg = )
30150 8CFB           8A46         FC            mov	al,-4[bp]
30151 8CFE           30E4                       xor	ah,ah
30152 8D00           50                         push	ax
30153                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
30154 8D01           8B46         16            mov	ax,$16[bp]
30155 8D04           88E0                       mov	al,ah
30156 8D06           30E4                       xor	ah,ah
30157                                           ! Debug: list unsigned int = ax+0 (used reg = )
30158 8D08           50                         push	ax
30159                                           ! Debug: list * char = .634+0 (used reg = )
30160 8D09           BB                   CE90  mov	bx,#.634
30161 8D0C           53                         push	bx
30162                                           ! Debug: list int = const 4 (used reg = )
30163 8D0D           B8                   0004  mov	ax,*4
30164 8D10           50                         push	ax
30165                                           ! Debug: func () void = bios_printf+0 (used reg = )
30166 8D11           E8         7C93            call	_bios_printf
30167 8D14           83C4                   08  add	sp,*8
30168                                           !BCC_EOS
30169                                           ! 4329         AX = ((AX & 0x00ff) | ((0x02) << 8));
30170                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30171 8D17           8A46         16            mov	al,$16[bp]
30172                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
30173 8D1A           30E4                       xor	ah,ah
30174 8D1C           0D                   0200  or	ax,#$200
30175                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30176 8D1F           8946         16            mov	$16[bp],ax
30177                                           !BCC_EOS
30178                                           ! 4330         AX = ((AX & 0xff00) | (0));
30179                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
30180 8D22           8B46         16            mov	ax,$16[bp]
30181 8D25           30C0                       xor	al,al
30182                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30183 8D27           0C                     00  or	al,*0
30184                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30185 8D29           8946         16            mov	$16[bp],ax
30186                                           !BCC_EOS
30187                                           ! 4331         goto int13_fail_noah;
30188 8D2C           83C4                   00  add	sp,#..FFDF-..FFE1
30189 8D2F           E9         01B8            br 	.FFDF
30190                                           !BCC_EOS
30191                                           ! 4332       }
30192                                           ! 4333       goto int13_success;
30193                       00008D32            .632:
30194 8D32           83C4                   00  add	sp,#..FFE0-..FFE1
30195 8D35           E9         01D4            br 	.FFE0
30196                                           !BCC_EOS
30197                                           ! 4334       break;
30198 8D38           E9         01A4            br 	.617
30199                                           !BCC_EOS
30200                                           ! 4335     case 0x08:
30201                                           ! 4336       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
30202                       00008D3B            .635:
30203                                           ! Debug: list * unsigned short = const $26E (used reg = )
30204 8D3B           B8                   026E  mov	ax,#$26E
30205 8D3E           50                         push	ax
30206                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30207 8D3F           FF76         FE            push	-2[bp]
30208                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30209 8D42           E8         78C6            call	_read_word
30210 8D45           83C4                   04  add	sp,*4
30211                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
30212 8D48           8946         F8            mov	-8[bp],ax
30213                                           !BCC_EOS
30214                                           ! 4337       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
30215                                           ! Debug: list * unsigned short = const $26C (used reg = )
30216 8D4B           B8                   026C  mov	ax,#$26C
30217 8D4E           50                         push	ax
30218                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30219 8D4F           FF76         FE            push	-2[bp]
30220                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30221 8D52           E8         78B6            call	_read_word
30222 8D55           83C4                   04  add	sp,*4
30223                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30224                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
30225 8D58           48                         dec	ax
30226 8D59           8946         F6            mov	-$A[bp],ax
30227                                           !BCC_EOS
30228                                           ! 4338       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
30229                                           ! Debug: list * unsigned short = const $26A (used reg = )
30230 8D5C           B8                   026A  mov	ax,#$26A
30231 8D5F           50                         push	ax
30232                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30233 8D60           FF76         FE            push	-2[bp]
30234                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30235 8D63           E8         78A5            call	_read_word
30236 8D66           83C4                   04  add	sp,*4
30237                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30238                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
30239 8D69           48                         dec	ax
30240 8D6A           8946         FA            mov	-6[bp],ax
30241                                           !BCC_EOS
30242                                           ! 4339       AX = ((AX & 0xff00) | (0x00));
30243                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
30244 8D6D           8B46         16            mov	ax,$16[bp]
30245 8D70           30C0                       xor	al,al
30246                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30247 8D72           0C                     00  or	al,*0
30248                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30249 8D74           8946         16            mov	$16[bp],ax
30250                                           !BCC_EOS
30251                                           ! 4340       BX = ((BX & 0xff00) | (0x00));
30252                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30253 8D77           8B46         10            mov	ax,$10[bp]
30254 8D7A           30C0                       xor	al,al
30255                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30256 8D7C           0C                     00  or	al,*0
30257                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30258 8D7E           8946         10            mov	$10[bp],ax
30259                                           !BCC_EOS
30260                                           ! 4341       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
30261                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
30262 8D81           8A46         F6            mov	al,-$A[bp]
30263                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
30264 8D84           30E4                       xor	ah,ah
30265 8D86           88C4                       mov	ah,al
30266 8D88           30C0                       xor	al,al
30267 8D8A           50                         push	ax
30268                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
30269 8D8B           8A46         14            mov	al,$14[bp]
30270                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30271 8D8E           30E4                       xor	ah,ah
30272 8D90           0B46         CA            or	ax,0+..FFE1[bp]
30273 8D93           44                         inc	sp
30274 8D94           44                         inc	sp
30275                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30276 8D95           8946         14            mov	$14[bp],ax
30277                                           !BCC_EOS
30278                                           ! 4342       CX = ((CX & 0xff00) | (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f)));
30279                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
30280 8D98           8A46         F8            mov	al,-8[bp]
30281 8D9B           24                     3F  and	al,*$3F
30282 8D9D           50                         push	ax
30283                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
30284 8D9E           8B46         F6            mov	ax,-$A[bp]
30285 8DA1           D1E8                       shr	ax,*1
30286 8DA3           D1E8                       shr	ax,*1
30287                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
30288 8DA5           24                     C0  and	al,#$C0
30289                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30290 8DA7           0A46         CA            or	al,0+..FFE1[bp]
30291 8DAA           44                         inc	sp
30292 8DAB           44                         inc	sp
30293 8DAC           50                         push	ax
30294                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
30295 8DAD           8B46         14            mov	ax,$14[bp]
30296 8DB0           30C0                       xor	al,al
30297                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
30298 8DB2           0A46         CA            or	al,0+..FFE1[bp]
30299 8DB5           44                         inc	sp
30300 8DB6           44                         inc	sp
30301                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30302 8DB7           8946         14            mov	$14[bp],ax
30303                                           !BCC_EOS
30304                                           ! 4343       DX = ((DX & 0x00ff) | ((vheads) << 8));
30305                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
30306 8DBA           8B46         FA            mov	ax,-6[bp]
30307 8DBD           88C4                       mov	ah,al
30308 8DBF           30C0                       xor	al,al
30309 8DC1           50                         push	ax
30310                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
30311 8DC2           8A46         12            mov	al,$12[bp]
30312                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30313 8DC5           30E4                       xor	ah,ah
30314 8DC7           0B46         CA            or	ax,0+..FFE1[bp]
30315 8DCA           44                         inc	sp
30316 8DCB           44                         inc	sp
30317                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30318 8DCC           8946         12            mov	$12[bp],ax
30319                                           !BCC_EOS
30320                                           ! 4344       DX = ((DX & 0xff00) | (0x02));
30321                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
30322 8DCF           8B46         12            mov	ax,$12[bp]
30323 8DD2           30C0                       xor	al,al
30324                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30325 8DD4           0C                     02  or	al,*2
30326                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30327 8DD6           8946         12            mov	$12[bp],ax
30328                                           !BCC_EOS
30329                                           ! 4345       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
30330                                           ! Debug: list * unsigned char = const $25B (used reg = )
30331 8DD9           B8                   025B  mov	ax,#$25B
30332 8DDC           50                         push	ax
30333                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30334 8DDD           FF76         FE            push	-2[bp]
30335                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30336 8DE0           E8         7815            call	_read_byte
30337 8DE3           83C4                   04  add	sp,*4
30338 8DE6           EB           26            jmp .638
30339                                           ! 4346         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
30340                       00008DE8            .639:
30341                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30342 8DE8           8B46         10            mov	ax,$10[bp]
30343 8DEB           30C0                       xor	al,al
30344                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30345 8DED           0C                     02  or	al,*2
30346                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30347 8DEF           8946         10            mov	$10[bp],ax
30348                                           !BCC_EOS
30349 8DF2           EB           26            jmp .636
30350                                           !BCC_EOS
30351                                           ! 4347         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
30352                       00008DF4            .63A:
30353                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30354 8DF4           8B46         10            mov	ax,$10[bp]
30355 8DF7           30C0                       xor	al,al
30356                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
30357 8DF9           0C                     04  or	al,*4
30358                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30359 8DFB           8946         10            mov	$10[bp],ax
30360                                           !BCC_EOS
30361 8DFE           EB           1A            jmp .636
30362                                           !BCC_EOS
30363                                           ! 4348         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
30364                       00008E00            .63B:
30365                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30366 8E00           8B46         10            mov	ax,$10[bp]
30367 8E03           30C0                       xor	al,al
30368                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
30369 8E05           0C                     06  or	al,*6
30370                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30371 8E07           8946         10            mov	$10[bp],ax
30372                                           !BCC_EOS
30373 8E0A           EB           0E            jmp .636
30374                                           !BCC_EOS
30375                                           ! 4349     }
30376                                           ! 4350 #asm
30377 8E0C           EB           0C            jmp .636
30378                       00008E0E            .638:
30379 8E0E           2C                     01  sub	al,*1
30380 8E10           74           D6            je 	.639
30381 8E12           2C                     01  sub	al,*1
30382 8E14           74           DE            je 	.63A
30383 8E16           2C                     01  sub	al,*1
30384 8E18           74           E6            je 	.63B
30385                       00008E1A            .636:
30386                                           !BCC_EOS
30387                                           !BCC_ASM
30388                       00000040            _int13_cdemu.BP	set	$40
30389                       0000000C            .int13_cdemu.BP	set	$C
30390                       0000004E            _int13_cdemu.CS	set	$4E
30391                       0000001A            .int13_cdemu.CS	set	$1A
30392                       00000022            _int13_cdemu.nbsectors	set	$22
30393                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
30394                       00000048            _int13_cdemu.CX	set	$48
30395                       00000014            .int13_cdemu.CX	set	$14
30396                       00000012            _int13_cdemu.elba	set	$12
30397                       FFFFFFDE            .int13_cdemu.elba	set	-$22
30398                       0000000E            _int13_cdemu.segment	set	$E
30399                       FFFFFFDA            .int13_cdemu.segment	set	-$26
30400                       0000003C            _int13_cdemu.DI	set	$3C
30401                       00000008            .int13_cdemu.DI	set	8
30402                       00000050            _int13_cdemu.FLAGS	set	$50
30403                       0000001C            .int13_cdemu.FLAGS	set	$1C
30404                       0000002A            _int13_cdemu.vcylinders	set	$2A
30405                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
30406                       00000026            _int13_cdemu.sector	set	$26
30407                       FFFFFFF2            .int13_cdemu.sector	set	-$E
30408                       00000038            _int13_cdemu.DS	set	$38
30409                       00000004            .int13_cdemu.DS	set	4
30410                       00000028            _int13_cdemu.head	set	$28
30411                       FFFFFFF4            .int13_cdemu.head	set	-$C
30412                       00000024            _int13_cdemu.cylinder	set	$24
30413                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
30414                       00000046            _int13_cdemu.DX	set	$46
30415                       00000012            .int13_cdemu.DX	set	$12
30416                       00000031            _int13_cdemu.device	set	$31
30417                       FFFFFFFD            .int13_cdemu.device	set	-3
30418                       0000003A            _int13_cdemu.ES	set	$3A
30419                       00000006            .int13_cdemu.ES	set	6
30420                       0000002C            _int13_cdemu.vspt	set	$2C
30421                       FFFFFFF8            .int13_cdemu.vspt	set	-8
30422                       0000001E            _int13_cdemu.vlba	set	$1E
30423                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
30424                       00000032            _int13_cdemu.ebda_seg	set	$32
30425                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
30426                       0000003E            _int13_cdemu.SI	set	$3E
30427                       0000000A            .int13_cdemu.SI	set	$A
30428                       0000004C            _int13_cdemu.IP	set	$4C
30429                       00000018            .int13_cdemu.IP	set	$18
30430                       00000030            _int13_cdemu.status	set	$30
30431                       FFFFFFFC            .int13_cdemu.status	set	-4
30432                       00000000            _int13_cdemu.atacmd	set	0
30433                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
30434                       0000004A            _int13_cdemu.AX	set	$4A
30435                       00000016            .int13_cdemu.AX	set	$16
30436                       0000001A            _int13_cdemu.ilba	set	$1A
30437                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
30438                       00000010            _int13_cdemu.before	set	$10
30439                       FFFFFFDC            .int13_cdemu.before	set	-$24
30440                       0000000C            _int13_cdemu.offset	set	$C
30441                       FFFFFFD8            .int13_cdemu.offset	set	-$28
30442                       00000016            _int13_cdemu.slba	set	$16
30443                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
30444                       00000042            _int13_cdemu.SP	set	$42
30445                       0000000E            .int13_cdemu.SP	set	$E
30446                       0000002E            _int13_cdemu.vheads	set	$2E
30447                       FFFFFFFA            .int13_cdemu.vheads	set	-6
30448                       00000044            _int13_cdemu.BX	set	$44
30449                       00000010            .int13_cdemu.BX	set	$10
30450 8E1A           55                               push bp
30451 8E1B           89E5                             mov bp, sp
30452 8E1D           B8                   EFDE        mov ax, #diskette_param_table2
30453 8E20           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
30454 8E23           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
30455 8E26           5D                               pop bp
30456                                           ! 4357 endasm
30457                                           !BCC_ENDASM
30458                                           !BCC_EOS
30459                                           ! 4358       goto int13_success;
30460 8E27           83C4                   00  add	sp,#..FFE0-..FFE1
30461 8E2A           E9         00DF            br 	.FFE0
30462                                           !BCC_EOS
30463                                           ! 4359       break;
30464 8E2D           E9         00AF            br 	.617
30465                                           !BCC_EOS
30466                                           ! 4360     case 0x15:
30467                                           ! 4361       
30468                                           ! 4361 AX = ((AX & 0x00ff) | ((0x03) << 8));
30469                       00008E30            .63C:
30470                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30471 8E30           8A46         16            mov	al,$16[bp]
30472                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
30473 8E33           30E4                       xor	ah,ah
30474 8E35           0D                   0300  or	ax,#$300
30475                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30476 8E38           8946         16            mov	$16[bp],ax
30477                                           !BCC_EOS
30478                                           ! 4362       goto int13_success_noah;
30479 8E3B           83C4                   00  add	sp,#..FFDD-..FFE1
30480 8E3E           E9         00D5            br 	.FFDD
30481                                           !BCC_EOS
30482                                           ! 4363       break;
30483 8E41           E9         009B            br 	.617
30484                                           !BCC_EOS
30485                                           ! 4364     case 0x0a:
30486                                           ! 4365     case 0x0b:
30487                       00008E44            .63D:
30488                                           ! 4366     case 0x18:
30489                       00008E44            .63E:
30490                                           ! 4367     case 0x41:
30491                       00008E44            .63F:
30492                                           ! 4368     case 0x42:
30493                       00008E44            .640:
30494                                           ! 4369     case 0x43:
30495                       00008E44            .641:
30496                                           ! 4370     case 0x44:
30497                       00008E44            .642:
30498                                           ! 4371     case 0x45:
30499                       00008E44            .643:
30500                                           ! 4372     case 0x46:
30501                       00008E44            .644:
30502                                           ! 4373     case 0x47:
30503                       00008E44            .645:
30504                                           ! 4374     case 0x48:
30505                       00008E44            .646:
30506                                           ! 4375     case 0x49:
30507                       00008E44            .647:
30508                                           ! 4376     case 0x4e:
30509                       00008E44            .648:
30510                                           ! 4377     case 0x50:
30511                       00008E44            .649:
30512                                           ! 4378     default:
30513                       00008E44            .64A:
30514                                           ! 4379       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
30515                       00008E44            .64B:
30516                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30517 8E44           8B46         16            mov	ax,$16[bp]
30518 8E47           88E0                       mov	al,ah
30519 8E49           30E4                       xor	ah,ah
30520                                           ! Debug: list unsigned int = ax+0 (used reg = )
30521 8E4B           50                         push	ax
30522                                           ! Debug: list * char = .64C+0 (used reg = )
30523 8E4C           BB                   CE58  mov	bx,#.64C
30524 8E4F           53                         push	bx
30525                                           ! Debug: list int = const 4 (used reg = )
30526 8E50           B8                   0004  mov	ax,*4
30527 8E53           50                         push	ax
30528                                           ! Debug: func () void = bios_printf+0 (used reg = )
30529 8E54           E8         7B50            call	_bios_printf
30530 8E57           83C4                   06  add	sp,*6
30531                                           !BCC_EOS
30532                                           ! 4380       goto int13_fail;
30533 8E5A           83C4                   00  add	sp,#..FFE2-..FFE1
30534 8E5D           E9         007F            jmp .FFE2
30535                                           !BCC_EOS
30536                                           ! 4381       break;
30537 8E60           EB           7D            jmp .617
30538                                           !BCC_EOS
30539                                           ! 4382   }
30540                                           ! 4383 int13_fail:
30541 8E62           EB           7B            jmp .617
30542                       00008E64            .619:
30543 8E64           2D                   0000  sub	ax,*0
30544 8E67           7C           DB            jl 	.64B
30545 8E69           3D                   0018  cmp	ax,*$18
30546 8E6C           77           3B            ja  	.64D
30547 8E6E           D1E0                       shl	ax,*1
30548 8E70           89C3                       mov	bx,ax
30549 8E72           2E                         seg	cs
30550 8E73           FFA7       8E77            br	.64E[bx]
30551                       00008E77            .64E:
30552 8E77                      8986            .word	.61A
30553 8E79                      89A3            .word	.624
30554 8E7B                      89F4            .word	.628
30555 8E7D                      898F            .word	.622
30556 8E7F                      89F4            .word	.629
30557 8E81                      898F            .word	.623
30558 8E83                      8E44            .word	.64B
30559 8E85                      8E44            .word	.64B
30560 8E87                      8D3B            .word	.635
30561 8E89                      8986            .word	.61B
30562 8E8B                      8E44            .word	.63D
30563 8E8D                      8E44            .word	.63E
30564 8E8F                      8986            .word	.61C
30565 8E91                      8986            .word	.61D
30566 8E93                      8E44            .word	.64B
30567 8E95                      8E44            .word	.64B
30568 8E97                      8986            .word	.61E
30569 8E99                      8986            .word	.61F
30570 8E9B                      8E44            .word	.64B
30571 8E9D                      8E44            .word	.64B
30572 8E9F                      8986            .word	.620
30573 8EA1                      8E30            .word	.63C
30574 8EA3                      8986            .word	.621
30575 8EA5                      8E44            .word	.64B
30576 8EA7                      8E44            .word	.63F
30577                       00008EA9            .64D:
30578 8EA9           2D                   0041  sub	ax,*$41
30579 8EAC           72           96            jb 	.64B
30580 8EAE           3D                   000F  cmp	ax,*$F
30581 8EB1           77           29            ja  	.64F
30582 8EB3           D1E0                       shl	ax,*1
30583 8EB5           89C3                       mov	bx,ax
30584 8EB7           2E                         seg	cs
30585 8EB8           FFA7       8EBC            br	.650[bx]
30586                       00008EBC            .650:
30587 8EBC                      8E44            .word	.640
30588 8EBE                      8E44            .word	.641
30589 8EC0                      8E44            .word	.642
30590 8EC2                      8E44            .word	.643
30591 8EC4                      8E44            .word	.644
30592 8EC6                      8E44            .word	.645
30593 8EC8                      8E44            .word	.646
30594 8ECA                      8E44            .word	.647
30595 8ECC                      8E44            .word	.648
30596 8ECE                      8E44            .word	.64B
30597 8ED0                      8E44            .word	.64B
30598 8ED2                      8E44            .word	.64B
30599 8ED4                      8E44            .word	.64B
30600 8ED6                      8E44            .word	.649
30601 8ED8                      8E44            .word	.64B
30602 8EDA                      8E44            .word	.64A
30603                       00008EDC            .64F:
30604 8EDC           E9         FF65            br 	.64B
30605                       00008EDF            .617:
30606                       FFFFFFCA            ..FFE1	=	-$36
30607                       00008EDF            .FFE2:
30608                       FFFFFFCA            ..FFE2	=	-$36
30609                                           ! 4384   AX = ((AX & 0x00ff) | ((0x01) << 8));
30610                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30611 8EDF           8A46         16            mov	al,$16[bp]
30612                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30613 8EE2           30E4                       xor	ah,ah
30614 8EE4           0D                   0100  or	ax,#$100
30615                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30616 8EE7           8946         16            mov	$16[bp],ax
30617                                           !BCC_EOS
30618                                           ! 4385 int13_fail_noah:
30619                       00008EEA            .FFDF:
30620                       FFFFFFCA            ..FFDF	=	-$36
30621                                           ! 4386   write_byte(0x0040, 0x0074, ( AX >> 8 ));
30622                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30623 8EEA           8B46         16            mov	ax,$16[bp]
30624 8EED           88E0                       mov	al,ah
30625 8EEF           30E4                       xor	ah,ah
30626                                           ! Debug: list unsigned int = ax+0 (used reg = )
30627 8EF1           50                         push	ax
30628                                           ! Debug: list int = const $74 (used reg = )
30629 8EF2           B8                   0074  mov	ax,*$74
30630 8EF5           50                         push	ax
30631                                           ! Debug: list int = const $40 (used reg = )
30632 8EF6           B8                   0040  mov	ax,*$40
30633 8EF9           50                         push	ax
30634                                           ! Debug: func () void = write_byte+0 (used reg = )
30635 8EFA           E8         7721            call	_write_byte
30636 8EFD           83C4                   06  add	sp,*6
30637                                           !BCC_EOS
30638                                           ! 4387 int13_fail_nostatus:
30639                       00008F00            .FFDE:
30640                       FFFFFFCA            ..FFDE	=	-$36
30641                                           ! 4388   FLAGS |= 0x0001;
30642                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30643 8F00           8B46         1C            mov	ax,$1C[bp]
30644 8F03           0C                     01  or	al,*1
30645 8F05           8946         1C            mov	$1C[bp],ax
30646                                           !BCC_EOS
30647                                           ! 4389   return;
30648 8F08           89EC                       mov	sp,bp
30649 8F0A           5D                         pop	bp
30650 8F0B           C3                         ret
30651                                           !BCC_EOS
30652                                           ! 4390 int13_success:
30653                       00008F0C            .FFE0:
30654                       FFFFFFCA            ..FFE0	=	-$36
30655                                           ! 4391   AX = ((AX & 0x00ff) | ((0x00) << 8));
30656                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30657 8F0C           8A46         16            mov	al,$16[bp]
30658                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
30659 8F0F           0C                     00  or	al,*0
30660                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
30661 8F11           30E4                       xor	ah,ah
30662 8F13           8946         16            mov	$16[bp],ax
30663                                           !BCC_EOS
30664                                           ! 4392 int13_success_noah:
30665                       00008F16            .FFDD:
30666                       FFFFFFCA            ..FFDD	=	-$36
30667                                           ! 4393   write_byte(0x0040, 0x0074, 0x00);
30668                                           ! Debug: list int = const 0 (used reg = )
30669 8F16           31C0                       xor	ax,ax
30670 8F18           50                         push	ax
30671                                           ! Debug: list int = const $74 (used reg = )
30672 8F19           B8                   0074  mov	ax,*$74
30673 8F1C           50                         push	ax
30674                                           ! Debug: list int = const $40 (used reg = )
30675 8F1D           B8                   0040  mov	ax,*$40
30676 8F20           50                         push	ax
30677                                           ! Debug: func () void = write_byte+0 (used reg = )
30678 8F21           E8         76FA            call	_write_byte
30679 8F24           83C4                   06  add	sp,*6
30680                                           !BCC_EOS
30681                                           ! 4394   FLAGS &= 0xfffe;
30682                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30683 8F27           8B46         1C            mov	ax,$1C[bp]
30684 8F2A           24                     FE  and	al,#$FE
30685 8F2C           8946         1C            mov	$1C[bp],ax
30686                                           !BCC_EOS
30687                                           ! 4395 }
30688 8F2F           89EC                       mov	sp,bp
30689 8F31           5D                         pop	bp
30690 8F32           C3                         ret
30691                                           ! 4396 void floppy_reset_controller()
30692                                           ! Register BX used in function int13_cdemu
30693                                           ! 4397 {
30694                                           export	_floppy_reset_controller
30695                       00008F33            _floppy_reset_controller:
30696                                           ! 4398   Bit8u val8;
30697                                           !BCC_EOS
30698                                           ! 4399   val8 = inb(0x03f2);
30699 8F33           55                         push	bp
30700 8F34           89E5                       mov	bp,sp
30701 8F36           4C                         dec	sp
30702 8F37           4C                         dec	sp
30703                                           ! Debug: list int = const $3F2 (used reg = )
30704 8F38           B8                   03F2  mov	ax,#$3F2
30705 8F3B           50                         push	ax
30706                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30707 8F3C           E8         7603            call	_inb
30708 8F3F           44                         inc	sp
30709 8F40           44                         inc	sp
30710                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30711 8F41           8846         FF            mov	-1[bp],al
30712                                           !BCC_EOS
30713                                           ! 4400   outb(0x03f2, val8 & ~0x04);
30714                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
30715 8F44           8A46         FF            mov	al,-1[bp]
30716 8F47           24                     FB  and	al,#$FB
30717                                           ! Debug: list unsigned char = al+0 (used reg = )
30718 8F49           30E4                       xor	ah,ah
30719 8F4B           50                         push	ax
30720                                           ! Debug: list int = const $3F2 (used reg = )
30721 8F4C           B8                   03F2  mov	ax,#$3F2
30722 8F4F           50                         push	ax
30723                                           ! Debug: func () void = outb+0 (used reg = )
30724 8F50           E8         7605            call	_outb
30725 8F53           83C4                   04  add	sp,*4
30726                                           !BCC_EOS
30727                                           ! 4401   outb(0x03f2, val8 | 0x04);
30728                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
30729 8F56           8A46         FF            mov	al,-1[bp]
30730 8F59           0C                     04  or	al,*4
30731                                           ! Debug: list unsigned char = al+0 (used reg = )
30732 8F5B           30E4                       xor	ah,ah
30733 8F5D           50                         push	ax
30734                                           ! Debug: list int = const $3F2 (used reg = )
30735 8F5E           B8                   03F2  mov	ax,#$3F2
30736 8F61           50                         push	ax
30737                                           ! Debug: func () void = outb+0 (used reg = )
30738 8F62           E8         75F3            call	_outb
30739 8F65           83C4                   04  add	sp,*4
30740                                           !BCC_EOS
30741                                           ! 4402   do {
30742                       00008F68            .653:
30743                                           ! 4403     val8 = inb(0x3f4);
30744                                           ! Debug: list int = const $3F4 (used reg = )
30745 8F68           B8                   03F4  mov	ax,#$3F4
30746 8F6B           50                         push	ax
30747                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30748 8F6C           E8         75D3            call	_inb
30749 8F6F           44                         inc	sp
30750 8F70           44                         inc	sp
30751                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30752 8F71           8846         FF            mov	-1[bp],al
30753                                           !BCC_EOS
30754                                           ! 4404   } while ((val8 & 0xc0) != 0x80);
30755                       00008F74            .652:
30756                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
30757 8F74           8A46         FF            mov	al,-1[bp]
30758 8F77           24                     C0  and	al,#$C0
30759                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30760 8F79           3C                     80  cmp	al,#$80
30761 8F7B           75           EB            jne	.653
30762                       00008F7D            .654:
30763                                           !BCC_EOS
30764                                           ! 4405 }
30765                       00008F7D            .651:
30766 8F7D           89EC                       mov	sp,bp
30767 8F7F           5D                         pop	bp
30768 8F80           C3                         ret
30769                                           ! 4406 void floppy_prepare_controller(drive)
30770                                           ! 4407   Bit16u drive;
30771                                           export	_floppy_prepare_controller
30772                       00008F81            _floppy_prepare_controller:
30773                                           !BCC_EOS
30774                                           ! 4408 {
30775                                           ! 4409   Bit8u val8, dor, prev_reset;
30776                                           !BCC_EOS
30777                                           ! 4410   val8 = read_byte(0x0040, 0x003e);
30778 8F81           55                         push	bp
30779 8F82           89E5                       mov	bp,sp
30780 8F84           83C4                   FC  add	sp,*-4
30781                                           ! Debug: list int = const $3E (used reg = )
30782 8F87           B8                   003E  mov	ax,*$3E
30783 8F8A           50                         push	ax
30784                                           ! Debug: list int = const $40 (used reg = )
30785 8F8B           B8                   0040  mov	ax,*$40
30786 8F8E           50                         push	ax
30787                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30788 8F8F           E8         7666            call	_read_byte
30789 8F92           83C4                   04  add	sp,*4
30790                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30791 8F95           8846         FF            mov	-1[bp],al
30792                                           !BCC_EOS
30793                                           ! 4411   val8 &= 0x7f;
30794                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30795 8F98           8A46         FF            mov	al,-1[bp]
30796 8F9B           24                     7F  and	al,*$7F
30797 8F9D           8846         FF            mov	-1[bp],al
30798                                           !BCC_EOS
30799                                           ! 4412   write_byte(0x0040, 0x003e, val8);
30800                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30801 8FA0           8A46         FF            mov	al,-1[bp]
30802 8FA3           30E4                       xor	ah,ah
30803 8FA5           50                         push	ax
30804                                           ! Debug: list int = const $3E (used reg = )
30805 8FA6           B8                   003E  mov	ax,*$3E
30806 8FA9           50                         push	ax
30807                                           ! Debug: list int = const $40 (used reg = )
30808 8FAA           B8                   0040  mov	ax,*$40
30809 8FAD           50                         push	ax
30810                                           ! Debug: func () void = write_byte+0 (used reg = )
30811 8FAE           E8         766D            call	_write_byte
30812 8FB1           83C4                   06  add	sp,*6
30813                                           !BCC_EOS
30814                                           ! 4413   prev_reset = inb(0x03f2) & 0x04;
30815                                           ! Debug: list int = const $3F2 (used reg = )
30816 8FB4           B8                   03F2  mov	ax,#$3F2
30817 8FB7           50                         push	ax
30818                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30819 8FB8           E8         7587            call	_inb
30820 8FBB           44                         inc	sp
30821 8FBC           44                         inc	sp
30822                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
30823 8FBD           24                     04  and	al,*4
30824                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
30825 8FBF           8846         FD            mov	-3[bp],al
30826                                           !BCC_EOS
30827                                           ! 4414   if (drive)
30828 8FC2           8B46         04            mov	ax,4[bp]
30829 8FC5           85C0                       test	ax,ax
30830 8FC7           74           07            je  	.655
30831                       00008FC9            .656:
30832                                           ! 4415     dor = 0x20;
30833                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
30834 8FC9           B0                     20  mov	al,*$20
30835 8FCB           8846         FE            mov	-2[bp],al
30836                                           !BCC_EOS
30837                                           ! 4416   else
30838                                           ! 4417     dor = 0x10;
30839 8FCE           EB           05            jmp .657
30840                       00008FD0            .655:
30841                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
30842 8FD0           B0                     10  mov	al,*$10
30843 8FD2           8846         FE            mov	-2[bp],al
30844                                           !BCC_EOS
30845                                           ! 4418   dor |= 0x0c;
30846                       00008FD5            .657:
30847                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
30848 8FD5           8A46         FE            mov	al,-2[bp]
30849 8FD8           0C                     0C  or	al,*$C
30850 8FDA           8846         FE            mov	-2[bp],al
30851                                           !BCC_EOS
30852                                           ! 4419   dor |= drive;
30853                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
30854 8FDD           8B46         04            mov	ax,4[bp]
30855 8FE0           0A46         FE            or	al,-2[bp]
30856 8FE3           8846         FE            mov	-2[bp],al
30857                                           !BCC_EOS
30858                                           ! 4420   outb(0x03f2, dor);
30859                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
30860 8FE6           8A46         FE            mov	al,-2[bp]
30861 8FE9           30E4                       xor	ah,ah
30862 8FEB           50                         push	ax
30863                                           ! Debug: list int = const $3F2 (used reg = )
30864 8FEC           B8                   03F2  mov	ax,#$3F2
30865 8FEF           50                         push	ax
30866                                           ! Debug: func () void = outb+0 (used reg = )
30867 8FF0           E8         7565            call	_outb
30868 8FF3           83C4                   04  add	sp,*4
30869                                           !BCC_EOS
30870                                           ! 4421   write_byte(0x40,0x40, 37);
30871                                           ! Debug: list int = const $25 (used reg = )
30872 8FF6           B8                   0025  mov	ax,*$25
30873 8FF9           50                         push	ax
30874                                           ! Debug: list int = const $40 (used reg = )
30875 8FFA           B8                   0040  mov	ax,*$40
30876 8FFD           50                         push	ax
30877                                           ! Debug: list int = const $40 (used reg = )
30878 8FFE           B8                   0040  mov	ax,*$40
30879 9001           50                         push	ax
30880                                           ! Debug: func () void = write_byte+0 (used reg = )
30881 9002           E8         7619            call	_write_byte
30882 9005           83C4                   06  add	sp,*6
30883                                           !BCC_EOS
30884                                           ! 4422   do {
30885                       00009008            .65A:
30886                                           ! 4423     val8 = inb(0x3f4);
30887                                           ! Debug: list int = const $3F4 (used reg = )
30888 9008           B8                   03F4  mov	ax,#$3F4
30889 900B           50                         push	ax
30890                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30891 900C           E8         7533            call	_inb
30892 900F           44                         inc	sp
30893 9010           44                         inc	sp
30894                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30895 9011           8846         FF            mov	-1[bp],al
30896                                           !BCC_EOS
30897                                           ! 4424   } while ( (val8 & 0xc0) != 0x80 );
30898                       00009014            .659:
30899                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
30900 9014           8A46         FF            mov	al,-1[bp]
30901 9017           24                     C0  and	al,#$C0
30902                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30903 9019           3C                     80  cmp	al,#$80
30904 901B           75           EB            jne	.65A
30905                       0000901D            .65B:
30906                                           !BCC_EOS
30907                                           ! 4425   if (prev_reset == 0) {
30908                       0000901D            .658:
30909                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
30910 901D           8A46         FD            mov	al,-3[bp]
30911 9020           84C0                       test	al,al
30912 9022           75           38            jne 	.65C
30913                       00009024            .65D:
30914                                           ! 4426 #asm
30915                                           !BCC_EOS
30916                                           !BCC_ASM
30917                       00000002            _floppy_prepare_controller.dor	set	2
30918                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30919                       00000001            _floppy_prepare_controller.prev_reset	set	1
30920                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30921                       00000003            _floppy_prepare_controller.val8	set	3
30922                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30923                       00000008            _floppy_prepare_controller.drive	set	8
30924                       00000004            .floppy_prepare_controller.drive	set	4
30925 9024           FB                             sti
30926                                           ! 4428 endasm
30927                                           !BCC_ENDASM
30928                                           !BCC_EOS
30929                                           ! 4429     do {
30930                       00009025            .660:
30931                                           ! 4430       val8 = read_byte(0x0040, 0x003e);
30932                                           ! Debug: list int = const $3E (used reg = )
30933 9025           B8                   003E  mov	ax,*$3E
30934 9028           50                         push	ax
30935                                           ! Debug: list int = const $40 (used reg = )
30936 9029           B8                   0040  mov	ax,*$40
30937 902C           50                         push	ax
30938                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30939 902D           E8         75C8            call	_read_byte
30940 9030           83C4                   04  add	sp,*4
30941                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30942 9033           8846         FF            mov	-1[bp],al
30943                                           !BCC_EOS
30944                                           ! 4431     } while ( (val8 & 0x80) == 0 );
30945                       00009036            .65F:
30946                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
30947 9036           8A46         FF            mov	al,-1[bp]
30948 9039           24                     80  and	al,#$80
30949                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
30950 903B           84C0                       test	al,al
30951 903D           74           E6            je 	.660
30952                       0000903F            .661:
30953                                           !BCC_EOS
30954                                           ! 4432     val8 &= 0x7f;
30955                       0000903F            .65E:
30956                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30957 903F           8A46         FF            mov	al,-1[bp]
30958 9042           24                     7F  and	al,*$7F
30959 9044           8846         FF            mov	-1[bp],al
30960                                           !BCC_EOS
30961                                           ! 4433 #asm
30962                                           !BCC_EOS
30963                                           !BCC_ASM
30964                       00000002            _floppy_prepare_controller.dor	set	2
30965                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30966                       00000001            _floppy_prepare_controller.prev_reset	set	1
30967                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30968                       00000003            _floppy_prepare_controller.val8	set	3
30969                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30970                       00000008            _floppy_prepare_controller.drive	set	8
30971                       00000004            .floppy_prepare_controller.drive	set	4
30972 9047           FA                             cli
30973                                           ! 4435 endasm
30974                                           !BCC_ENDASM
30975                                           !BCC_EOS
30976                                           ! 4436     write_byte(0x0040, 0x003e, val8);
30977                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30978 9048           8A46         FF            mov	al,-1[bp]
30979 904B           30E4                       xor	ah,ah
30980 904D           50                         push	ax
30981                                           ! Debug: list int = const $3E (used reg = )
30982 904E           B8                   003E  mov	ax,*$3E
30983 9051           50                         push	ax
30984                                           ! Debug: list int = const $40 (used reg = )
30985 9052           B8                   0040  mov	ax,*$40
30986 9055           50                         push	ax
30987                                           ! Debug: func () void = write_byte+0 (used reg = )
30988 9056           E8         75C5            call	_write_byte
30989 9059           83C4                   06  add	sp,*6
30990                                           !BCC_EOS
30991                                           ! 4437   }
30992                                           ! 4438 }
30993                       0000905C            .65C:
30994 905C           89EC                       mov	sp,bp
30995 905E           5D                         pop	bp
30996 905F           C3                         ret
30997                                           ! 4439   bx_bool
30998                                           ! 4440 floppy_media_known(drive)
30999                                           ! 4441   Bit16u drive;
31000                                           export	_floppy_media_known
31001                       00009060            _floppy_media_known:
31002                                           !BCC_EOS
31003                                           ! 4442 {
31004                                           ! 4443   Bit8u val8;
31005                                           !BCC_EOS
31006                                           ! 4444   Bit16u media_state_offset;
31007                                           !BCC_EOS
31008                                           ! 4445   val8 = read_byte(0x0040, 0x003e);
31009 9060           55                         push	bp
31010 9061           89E5                       mov	bp,sp
31011 9063           83C4                   FC  add	sp,*-4
31012                                           ! Debug: list int = const $3E (used reg = )
31013 9066           B8                   003E  mov	ax,*$3E
31014 9069           50                         push	ax
31015                                           ! Debug: list int = const $40 (used reg = )
31016 906A           B8                   0040  mov	ax,*$40
31017 906D           50                         push	ax
31018                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31019 906E           E8         7587            call	_read_byte
31020 9071           83C4                   04  add	sp,*4
31021                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31022 9074           8846         FF            mov	-1[bp],al
31023                                           !BCC_EOS
31024                                           ! 4446   if (drive)
31025 9077           8B46         04            mov	ax,4[bp]
31026 907A           85C0                       test	ax,ax
31027 907C           74           0A            je  	.662
31028                       0000907E            .663:
31029                                           ! 4447     val8 >>= 1;
31030                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31031 907E           8A46         FF            mov	al,-1[bp]
31032 9081           30E4                       xor	ah,ah
31033 9083           D1E8                       shr	ax,*1
31034 9085           8846         FF            mov	-1[bp],al
31035                                           !BCC_EOS
31036                                           ! 4448   val8 &= 0x01;
31037                       00009088            .662:
31038                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31039 9088           8A46         FF            mov	al,-1[bp]
31040 908B           24                     01  and	al,*1
31041 908D           8846         FF            mov	-1[bp],al
31042                                           !BCC_EOS
31043                                           ! 4449   if (val8 == 0)
31044                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31045 9090           8A46         FF            mov	al,-1[bp]
31046 9093           84C0                       test	al,al
31047 9095           75           06            jne 	.664
31048                       00009097            .665:
31049                                           ! 4450     return(0);
31050 9097           31C0                       xor	ax,ax
31051 9099           89EC                       mov	sp,bp
31052 909B           5D                         pop	bp
31053 909C           C3                         ret
31054                                           !BCC_EOS
31055                                           ! 4451   media_state_offset = 0x0090;
31056                       0000909D            .664:
31057                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
31058 909D           B8                   0090  mov	ax,#$90
31059 90A0           8946         FC            mov	-4[bp],ax
31060                                           !BCC_EOS
31061                                           ! 4452   if (drive)
31062 90A3           8B46         04            mov	ax,4[bp]
31063 90A6           85C0                       test	ax,ax
31064 90A8           74           07            je  	.666
31065                       000090AA            .667:
31066                                           ! 4453     media_state_offset += 1;
31067                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
31068 90AA           8B46         FC            mov	ax,-4[bp]
31069 90AD           40                         inc	ax
31070 90AE           8946         FC            mov	-4[bp],ax
31071                                           !BCC_EOS
31072                                           ! 4454   val8 = read_byte(0x0040, media_state_offset);
31073                       000090B1            .666:
31074                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
31075 90B1           FF76         FC            push	-4[bp]
31076                                           ! Debug: list int = const $40 (used reg = )
31077 90B4           B8                   0040  mov	ax,*$40
31078 90B7           50                         push	ax
31079                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31080 90B8           E8         753D            call	_read_byte
31081 90BB           83C4                   04  add	sp,*4
31082                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31083 90BE           8846         FF            mov	-1[bp],al
31084                                           !BCC_EOS
31085                                           ! 4455   val8 = (val8 >> 4) & 0x01;
31086                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
31087 90C1           8A46         FF            mov	al,-1[bp]
31088 90C4           30E4                       xor	ah,ah
31089 90C6           B1                     04  mov	cl,*4
31090 90C8           D3E8                       shr	ax,cl
31091                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
31092 90CA           24                     01  and	al,*1
31093                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31094 90CC           8846         FF            mov	-1[bp],al
31095                                           !BCC_EOS
31096                                           ! 4456   if (val8 == 0)
31097                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31098 90CF           8A46         FF            mov	al,-1[bp]
31099 90D2           84C0                       test	al,al
31100 90D4           75           06            jne 	.668
31101                       000090D6            .669:
31102                                           ! 4457     return(0);
31103 90D6           31C0                       xor	ax,ax
31104 90D8           89EC                       mov	sp,bp
31105 90DA           5D                         pop	bp
31106 90DB           C3                         ret
31107                                           !BCC_EOS
31108                                           ! 4458   return(1);
31109                       000090DC            .668:
31110 90DC           B8                   0001  mov	ax,*1
31111 90DF           89EC                       mov	sp,bp
31112 90E1           5D                         pop	bp
31113 90E2           C3                         ret
31114                                           !BCC_EOS
31115                                           ! 4459 }
31116                                           ! 4460   bx_bool
31117                                           ! 4461 floppy_media_sense(drive)
31118                                           ! 4462   Bit16u drive;
31119                                           export	_floppy_media_sense
31120                       000090E3            _floppy_media_sense:
31121                                           !BCC_EOS
31122                                           ! 4463 {
31123                                           ! 4464   bx_bool retval;
31124                                           !BCC_EOS
31125                                           ! 4465   Bit16u media_s
31126                                           ! 4465 tate_offset;
31127                                           !BCC_EOS
31128                                           ! 4466   Bit8u drive_type, config_data, media_state;
31129                                           !BCC_EOS
31130                                           ! 4467   if (floppy_drive_recal(drive) == 0) {
31131 90E3           55                         push	bp
31132 90E4           89E5                       mov	bp,sp
31133 90E6           83C4                   F8  add	sp,*-8
31134                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
31135 90E9           FF76         04            push	4[bp]
31136                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
31137 90EC           E8         0153            call	_floppy_drive_recal
31138 90EF           44                         inc	sp
31139 90F0           44                         inc	sp
31140                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31141 90F1           85C0                       test	ax,ax
31142 90F3           75           06            jne 	.66A
31143                       000090F5            .66B:
31144                                           ! 4468     return(0);
31145 90F5           31C0                       xor	ax,ax
31146 90F7           89EC                       mov	sp,bp
31147 90F9           5D                         pop	bp
31148 90FA           C3                         ret
31149                                           !BCC_EOS
31150                                           ! 4469   }
31151                                           ! 4470   drive_type = inb_cmos(0x10);
31152                       000090FB            .66A:
31153                                           ! Debug: list int = const $10 (used reg = )
31154 90FB           B8                   0010  mov	ax,*$10
31155 90FE           50                         push	ax
31156                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31157 90FF           E8         7485            call	_inb_cmos
31158 9102           44                         inc	sp
31159 9103           44                         inc	sp
31160                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
31161 9104           8846         FB            mov	-5[bp],al
31162                                           !BCC_EOS
31163                                           ! 4471   if (drive == 0)
31164                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
31165 9107           8B46         04            mov	ax,4[bp]
31166 910A           85C0                       test	ax,ax
31167 910C           75           0E            jne 	.66C
31168                       0000910E            .66D:
31169                                           ! 4472     drive_type >>= 4;
31170                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
31171 910E           8A46         FB            mov	al,-5[bp]
31172 9111           30E4                       xor	ah,ah
31173 9113           B1                     04  mov	cl,*4
31174 9115           D3E8                       shr	ax,cl
31175 9117           8846         FB            mov	-5[bp],al
31176                                           !BCC_EOS
31177                                           ! 4473   else
31178                                           ! 4474     drive_type &= 0x0f;
31179 911A           EB           08            jmp .66E
31180                       0000911C            .66C:
31181                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
31182 911C           8A46         FB            mov	al,-5[bp]
31183 911F           24                     0F  and	al,*$F
31184 9121           8846         FB            mov	-5[bp],al
31185                                           !BCC_EOS
31186                                           ! 4475   if (drive_type == 1) {
31187                       00009124            .66E:
31188                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
31189 9124           8A46         FB            mov	al,-5[bp]
31190 9127           3C                     01  cmp	al,*1
31191 9129           75           13            jne 	.66F
31192                       0000912B            .670:
31193                                           ! 4476     config_data = 0x00;
31194                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31195 912B           30C0                       xor	al,al
31196 912D           8846         FA            mov	-6[bp],al
31197                                           !BCC_EOS
31198                                           ! 4477     media_state = 0x25;
31199                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31200 9130           B0                     25  mov	al,*$25
31201 9132           8846         F9            mov	-7[bp],al
31202                                           !BCC_EOS
31203                                           ! 4478     retval = 1;
31204                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31205 9135           B8                   0001  mov	ax,*1
31206 9138           8946         FE            mov	-2[bp],ax
31207                                           !BCC_EOS
31208                                           ! 4479   }
31209                                           ! 4480   else if (drive_type == 2) {
31210 913B           E9         00C1            br 	.671
31211                       0000913E            .66F:
31212                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
31213 913E           8A46         FB            mov	al,-5[bp]
31214 9141           3C                     02  cmp	al,*2
31215 9143           75           13            jne 	.672
31216                       00009145            .673:
31217                                           ! 4481     config_data = 0x00;
31218                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31219 9145           30C0                       xor	al,al
31220 9147           8846         FA            mov	-6[bp],al
31221                                           !BCC_EOS
31222                                           ! 4482     media_state = 0x25;
31223                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31224 914A           B0                     25  mov	al,*$25
31225 914C           8846         F9            mov	-7[bp],al
31226                                           !BCC_EOS
31227                                           ! 4483     retval = 1;
31228                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31229 914F           B8                   0001  mov	ax,*1
31230 9152           8946         FE            mov	-2[bp],ax
31231                                           !BCC_EOS
31232                                           ! 4484   }
31233                                           ! 4485   else if (drive_type == 3) {
31234 9155           E9         00A7            br 	.674
31235                       00009158            .672:
31236                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
31237 9158           8A46         FB            mov	al,-5[bp]
31238 915B           3C                     03  cmp	al,*3
31239 915D           75           13            jne 	.675
31240                       0000915F            .676:
31241                                           ! 4486     config_data = 0x00;
31242                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31243 915F           30C0                       xor	al,al
31244 9161           8846         FA            mov	-6[bp],al
31245                                           !BCC_EOS
31246                                           ! 4487     media_state = 0x17;
31247                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31248 9164           B0                     17  mov	al,*$17
31249 9166           8846         F9            mov	-7[bp],al
31250                                           !BCC_EOS
31251                                           ! 4488     retval = 1;
31252                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31253 9169           B8                   0001  mov	ax,*1
31254 916C           8946         FE            mov	-2[bp],ax
31255                                           !BCC_EOS
31256                                           ! 4489   }
31257                                           ! 4490   else if (drive_type == 4) {
31258 916F           E9         008D            br 	.677
31259                       00009172            .675:
31260                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
31261 9172           8A46         FB            mov	al,-5[bp]
31262 9175           3C                     04  cmp	al,*4
31263 9177           75           13            jne 	.678
31264                       00009179            .679:
31265                                           ! 4491     config_data = 0x00;
31266                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31267 9179           30C0                       xor	al,al
31268 917B           8846         FA            mov	-6[bp],al
31269                                           !BCC_EOS
31270                                           ! 4492     media_state = 0x17;
31271                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31272 917E           B0                     17  mov	al,*$17
31273 9180           8846         F9            mov	-7[bp],al
31274                                           !BCC_EOS
31275                                           ! 4493     retval = 1;
31276                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31277 9183           B8                   0001  mov	ax,*1
31278 9186           8946         FE            mov	-2[bp],ax
31279                                           !BCC_EOS
31280                                           ! 4494   }
31281                                           ! 4495   else if (drive_type == 5) {
31282 9189           E9         0073            br 	.67A
31283                       0000918C            .678:
31284                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
31285 918C           8A46         FB            mov	al,-5[bp]
31286 918F           3C                     05  cmp	al,*5
31287 9191           75           12            jne 	.67B
31288                       00009193            .67C:
31289                                           ! 4496     config_data = 0xCC;
31290                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
31291 9193           B0                     CC  mov	al,#$CC
31292 9195           8846         FA            mov	-6[bp],al
31293                                           !BCC_EOS
31294                                           ! 4497     media_state = 0xD7;
31295                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
31296 9198           B0                     D7  mov	al,#$D7
31297 919A           8846         F9            mov	-7[bp],al
31298                                           !BCC_EOS
31299                                           ! 4498     retval = 1;
31300                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31301 919D           B8                   0001  mov	ax,*1
31302 91A0           8946         FE            mov	-2[bp],ax
31303                                           !BCC_EOS
31304                                           ! 4499   }
31305                                           ! 4500   else if (drive_type == 6) {
31306 91A3           EB           5A            jmp .67D
31307                       000091A5            .67B:
31308                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
31309 91A5           8A46         FB            mov	al,-5[bp]
31310 91A8           3C                     06  cmp	al,*6
31311 91AA           75           12            jne 	.67E
31312                       000091AC            .67F:
31313                                           ! 4501     config_data = 0x00;
31314                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31315 91AC           30C0                       xor	al,al
31316 91AE           8846         FA            mov	-6[bp],al
31317                                           !BCC_EOS
31318                                           ! 4502     media_state = 0x27;
31319                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31320 91B1           B0                     27  mov	al,*$27
31321 91B3           8846         F9            mov	-7[bp],al
31322                                           !BCC_EOS
31323                                           ! 4503     retval = 1;
31324                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31325 91B6           B8                   0001  mov	ax,*1
31326 91B9           8946         FE            mov	-2[bp],ax
31327                                           !BCC_EOS
31328                                           ! 4504   }
31329                                           ! 4505   else if (drive_type == 7) {
31330 91BC           EB           41            jmp .680
31331                       000091BE            .67E:
31332                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
31333 91BE           8A46         FB            mov	al,-5[bp]
31334 91C1           3C                     07  cmp	al,*7
31335 91C3           75           12            jne 	.681
31336                       000091C5            .682:
31337                                           ! 4506     config_data = 0x00;
31338                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31339 91C5           30C0                       xor	al,al
31340 91C7           8846         FA            mov	-6[bp],al
31341                                           !BCC_EOS
31342                                           ! 4507     media_state = 0x27;
31343                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31344 91CA           B0                     27  mov	al,*$27
31345 91CC           8846         F9            mov	-7[bp],al
31346                                           !BCC_EOS
31347                                           ! 4508     retval = 1;
31348                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31349 91CF           B8                   0001  mov	ax,*1
31350 91D2           8946         FE            mov	-2[bp],ax
31351                                           !BCC_EOS
31352                                           ! 4509   }
31353                                           ! 4510   else if (drive_type == 8) {
31354 91D5           EB           28            jmp .683
31355                       000091D7            .681:
31356                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
31357 91D7           8A46         FB            mov	al,-5[bp]
31358 91DA           3C                     08  cmp	al,*8
31359 91DC           75           12            jne 	.684
31360                       000091DE            .685:
31361                                           ! 4511     config_data = 0x00;
31362                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31363 91DE           30C0                       xor	al,al
31364 91E0           8846         FA            mov	-6[bp],al
31365                                           !BCC_EOS
31366                                           ! 4512     media_state = 0x27;
31367                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31368 91E3           B0                     27  mov	al,*$27
31369 91E5           8846         F9            mov	-7[bp],al
31370                                           !BCC_EOS
31371                                           ! 4513     retval = 1;
31372                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31373 91E8           B8                   0001  mov	ax,*1
31374 91EB           8946         FE            mov	-2[bp],ax
31375                                           !BCC_EOS
31376                                           ! 4514   }
31377                                           ! 4515   else {
31378 91EE           EB           0F            jmp .686
31379                       000091F0            .684:
31380                                           ! 4516     config_data = 0x00;
31381                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31382 91F0           30C0                       xor	al,al
31383 91F2           8846         FA            mov	-6[bp],al
31384                                           !BCC_EOS
31385                                           ! 4517     media_state = 0x00;
31386                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
31387 91F5           30C0                       xor	al,al
31388 91F7           8846         F9            mov	-7[bp],al
31389                                           !BCC_EOS
31390                                           ! 4518     retval = 0;
31391                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
31392 91FA           31C0                       xor	ax,ax
31393 91FC           8946         FE            mov	-2[bp],ax
31394                                           !BCC_EOS
31395                                           ! 4519   }
31396                                           ! 4520   if (drive == 0)
31397                       000091FF            .686:
31398                       000091FF            .683:
31399                       000091FF            .680:
31400                       000091FF            .67D:
31401                       000091FF            .67A:
31402                       000091FF            .677:
31403                       000091FF            .674:
31404                       000091FF            .671:
31405                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
31406 91FF           8B46         04            mov	ax,4[bp]
31407 9202           85C0                       test	ax,ax
31408 9204           75           08            jne 	.687
31409                       00009206            .688:
31410                                           ! 4521     media_state_offset = 0x90;
31411                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31412 9206           B8                   0090  mov	ax,#$90
31413 9209           8946         FC            mov	-4[bp],ax
31414                                           !BCC_EOS
31415                                           ! 4522   else
31416                                           ! 4523     media_state_offset = 0x91;
31417 920C           EB           06            jmp .689
31418                       0000920E            .687:
31419                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31420 920E           B8                   0091  mov	ax,#$91
31421 9211           8946         FC            mov	-4[bp],ax
31422                                           !BCC_EOS
31423                                           ! 4524   write_byte(0x0040, 0x008B, config_data);
31424                       00009214            .689:
31425                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
31426 9214           8A46         FA            mov	al,-6[bp]
31427 9217           30E4                       xor	ah,ah
31428 9219           50                         push	ax
31429                                           ! Debug: list int = const $8B (used reg = )
31430 921A           B8                   008B  mov	ax,#$8B
31431 921D           50                         push	ax
31432                                           ! Debug: list int = const $40 (used reg = )
31433 921E           B8                   0040  mov	ax,*$40
31434 9221           50                         push	ax
31435                                           ! Debug: func () void = write_byte+0 (used reg = )
31436 9222           E8         73F9            call	_write_byte
31437 9225           83C4                   06  add	sp,*6
31438                                           !BCC_EOS
31439                                           ! 4525   write_byte(0x0040, media_state_offset, media_state);
31440                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
31441 9228           8A46         F9            mov	al,-7[bp]
31442 922B           30E4                       xor	ah,ah
31443 922D           50                         push	ax
31444                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
31445 922E           FF76         FC            push	-4[bp]
31446                                           ! Debug: list int = const $40 (used reg = )
31447 9231           B8                   0040  mov	ax,*$40
31448 9234           50                         push	ax
31449                                           ! Debug: func () void = write_byte+0 (used reg = )
31450 9235           E8         73E6            call	_write_byte
31451 9238           83C4                   06  add	sp,*6
31452                                           !BCC_EOS
31453                                           ! 4526   return(retval);
31454 923B           8B46         FE            mov	ax,-2[bp]
31455 923E           89EC                       mov	sp,bp
31456 9240           5D                         pop	bp
31457 9241           C3                         ret
31458                                           !BCC_EOS
31459                                           ! 4527 }
31460                                           ! 4528   bx_bool
31461                                           ! 4529 floppy_drive_recal(drive)
31462                                           ! 4530   Bit16u drive;
31463                                           export	_floppy_drive_recal
31464                       00009242            _floppy_drive_recal:
31465                                           !BCC_EOS
31466                                           ! 4531 {
31467                                           ! 4532   Bit8u val8;
31468                                           !BCC_EOS
31469                                           ! 4533   Bit16u curr_cyl_offset;
31470                                           !BCC_EOS
31471                                           ! 4534   floppy_prepare_controller(drive);
31472 9242           55                         push	bp
31473 9243           89E5                       mov	bp,sp
31474 9245           83C4                   FC  add	sp,*-4
31475                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31476 9248           FF76         04            push	4[bp]
31477                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31478 924B           E8         FD33            call	_floppy_prepare_controller
31479 924E           44                         inc	sp
31480 924F           44                         inc	sp
31481                                           !BCC_EOS
31482                                           ! 4535   outb(0x03f5, 0x07);
31483                                           ! Debug: list int = const 7 (used reg = )
31484 9250           B8                   0007  mov	ax,*7
31485 9253           50                         push	ax
31486                                           ! Debug: list int = const $3F5 (used reg = )
31487 9254           B8                   03F5  mov	ax,#$3F5
31488 9257           50                         push	ax
31489                                           ! Debug: func () void = outb+0 (used reg = )
31490 9258           E8         72FD            call	_outb
31491 925B           83C4                   04  add	sp,*4
31492                                           !BCC_EOS
31493                                           ! 4536   outb(0x03f5, drive);
31494                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31495 925E           FF76         04            push	4[bp]
31496                                           ! Debug: list int = const $3F5 (used reg = )
31497 9261           B8                   03F5  mov	ax,#$3F5
31498 9264           50                         push	ax
31499                                           ! Debug: func () void = outb+0 (used reg = )
31500 9265           E8         72F0            call	_outb
31501 9268           83C4                   04  add	sp,*4
31502                                           !BCC_EOS
31503                                           ! 4537 #asm
31504                                           !BCC_EOS
31505                                           !BCC_ASM
31506                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31507                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31508                       00000003            _floppy_drive_recal.val8	set	3
31509                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31510                       00000008            _floppy_drive_recal.drive	set	8
31511                       00000004            .floppy_drive_recal.drive	set	4
31512 926B           FB                           sti
31513                                           ! 4539 endasm
31514                                           !BCC_ENDASM
31515                                           !BCC_EOS
31516                                           ! 4540   do {
31517                       0000926C            .68C:
31518                                           ! 4541     val8 = (read_byte(0x0040, 0x003e) & 0x80);
31519                                           ! Debug: list int = const $3E (used reg = )
31520 926C           B8                   003E  mov	ax,*$3E
31521 926F           50                         push	ax
31522                                           ! Debug: list int = const $40 (used reg = )
31523 9270           B8                   0040  mov	ax,*$40
31524 9273           50                         push	ax
31525                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31526 9274           E8         7381            call	_read_byte
31527 9277           83C4                   04  add	sp,*4
31528                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31529 927A           24                     80  and	al,#$80
31530                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31531 927C           8846         FF            mov	-1[bp],al
31532                                           !BCC_EOS
31533                                           ! 4542   } while ( val8 == 0 );
31534                       0000927F            .68B:
31535                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31536 927F           8A46         FF            mov	al,-1[bp]
31537 9282           84C0                       test	al,al
31538 9284           74           E6            je 	.68C
31539                       00009286            .68D:
31540                                           !BCC_EOS
31541                                           ! 4543   val8 = 0;
31542                       00009286            .68A:
31543                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31544 9286           30C0                       xor	al,al
31545 9288           8846         FF            mov	-1[bp],al
31546                                           !BCC_EOS
31547                                           ! 4544 #asm
31548                                           !BCC_EOS
31549                                           !BCC_ASM
31550                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31551                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31552                       00000003            _floppy_drive_recal.val8	set	3
31553                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31554                       00000008            _floppy_drive_recal.drive	set	8
31555                       00000004            .floppy_drive_recal.drive	set	4
31556 928B           FA                           cli
31557                                           ! 4546 endasm
31558                                           !BCC_ENDASM
31559                                           !BCC_EOS
31560                                           ! 4547   val8 = read_byte(0x0040, 0x003e);
31561                                           ! Debug: list int = const $3E (used reg = )
31562 928C           B8                   003E  mov	ax,*$3E
31563 928F           50                         push	ax
31564                                           ! Debug: list int = const $40 (used reg = )
31565 9290           B8                   0040  mov	ax,*$40
31566 9293           50                         push	ax
31567                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31568 9294           E8         7361            call	_read_byte
31569 9297           83C4                   04  add	sp,*4
31570                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31571 929A           8846         FF            mov	-1[bp],al
31572                                           !BCC_EOS
31573                                           ! 4548   val8 &= 0x7f;
31574                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
31575 929D           8A46         FF            mov	al,-1[bp]
31576 92A0           24                     7F  and	al,*$7F
31577 92A2           8846         FF            mov	-1[bp],al
31578                                           !BCC_EOS
31579                                           ! 4549   if (drive) {
31580 92A5           8B46         04            mov	ax,4[bp]
31581 92A8           85C0                       test	ax,ax
31582 92AA           74           10            je  	.68E
31583                       000092AC            .68F:
31584                                           ! 4550     val8 |= 0x02;
31585                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
31586 92AC           8A46         FF            mov	al,-1[bp]
31587 92AF           0C                     02  or	al,*2
31588 92B1           8846         FF            mov	-1[bp],al
31589                                           !BCC_EOS
31590                                           ! 4551     curr_cyl_offset = 0x0095;
31591                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31592 92B4           B8                   0095  mov	ax,#$95
31593 92B7           8946         FC            mov	-4[bp],ax
31594                                           !BCC_EOS
31595                                           ! 4552   } else {
31596 92BA           EB           0E            jmp .690
31597                       000092BC            .68E:
31598                                           ! 4553     val8 |= 0x01;
31599                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31600 92BC           8A46         FF            mov	al,-1[bp]
31601 92BF           0C                     01  or	al,*1
31602 92C1           8846         FF            mov	-1[bp],al
31603                                           !BCC_EOS
31604                                           ! 4554     curr_cyl_offset = 0x0094;
31605                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31606 92C4           B8                   0094  mov	ax,#$94
31607 92C7           8946         FC            mov	-4[bp],ax
31608                                           !BCC_EOS
31609                                           ! 4555   }
31610                                           ! 4556   write_byte(0x0040, 0x003e, val8);
31611                       000092CA            .690:
31612                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
31613 92CA           8A46         FF            mov	al,-1[bp]
31614 92CD           30E4                       xor	ah,ah
31615 92CF           50                         push	ax
31616                                           ! Debug: list int = const $3E (used reg = )
31617 92D0           B8                   003E  mov	ax,*$3E
31618 92D3           50                         push	ax
31619                                           ! Debug: list int = const $40 (used reg = )
31620 92D4           B8                   0040  mov	ax,*$40
31621 92D7           50                         push	ax
31622                                           ! Debug: func () void = write_byte+0 (used reg = )
31623 92D8           E8         7343            call	_write_byte
31624 92DB           83C4                   06  add	sp,*6
31625                                           !BCC_EOS
31626                                           ! 4557   write_byte(0x0040, curr_cyl_offset, 0);
31627                                           ! Debug: list int = const 0 (used reg = )
31628 92DE           31C0                       xor	ax,ax
31629 92E0           50                         push	ax
31630                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
31631 92E1           FF76         FC            push	-4[bp]
31632                                           ! Debug: list int = const $40 (used reg = )
31633 92E4           B8                   0040  mov	ax,*$40
31634 92E7           50                         push	ax
31635                                           ! Debug: func () void = write_byte+0 (used reg = )
31636 92E8           E8         7333            call	_write_byte
31637 92EB           83C4                   06  add	sp,*6
31638                                           !BCC_EOS
31639                                           ! 4558   return(1);
31640 92EE           B8                   0001  mov	ax,*1
31641 92F1           89EC                       mov	sp,bp
31642 92F3           5D                         pop	bp
31643 92F4           C3                         ret
31644                                           !BCC_EOS
31645                                           ! 4559 }
31646                                           ! 4560   bx_bool
31647                                           ! 4561 floppy_drive_exists(drive)
31648                                           ! 4562   Bit16u drive;
31649                                           export	_floppy_drive_exists
31650                       000092F5            _floppy_drive_exists:
31651                                           !BCC_EOS
31652                                           ! 4563 {
31653                                           ! 4564   Bit8u drive_type;
31654                                           !BCC_EOS
31655                                           ! 4565   drive_type = inb_cmos(0x10);
31656 92F5           55                         push	bp
31657 92F6           89E5                       mov	bp,sp
31658 92F8           4C                         dec	sp
31659 92F9           4C                         dec	sp
31660                                           ! Debug: list int = const $10 (used reg = )
31661 92FA           B8                   0010  mov	ax,*$10
31662 92FD           50                         push	ax
31663                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31664 92FE           E8         7286            call	_inb_cmos
31665 9301           44                         inc	sp
31666 9302           44                         inc	sp
31667                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
31668 9303           8846         FF            mov	-1[bp],al
31669                                           !BCC_EOS
31670                                           ! 4566   if (drive == 0)
31671                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
31672 9306           8B46         04            mov	ax,4[bp]
31673 9309           85C0                       test	ax,ax
31674 930B           75           0E            jne 	.691
31675                       0000930D            .692:
31676                                           ! 4567     drive_type >>= 4;
31677                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
31678 930D           8A46         FF            mov	al,-1[bp]
31679 9310           30E4                       xor	ah,ah
31680 9312           B1                     04  mov	cl,*4
31681 9314           D3E8                       shr	ax,cl
31682 9316           8846         FF            mov	-1[bp],al
31683                                           !BCC_EOS
31684                                           ! 4568   else
31685                                           ! 4569     drive_type &= 0x0f;
31686 9319           EB           08            jmp .693
31687                       0000931B            .691:
31688                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
31689 931B           8A46         FF            mov	al,-1[bp]
31690 931E           24                     0F  and	al,*$F
31691 9320           8846         FF            mov	-1[bp],al
31692                                           !BCC_EOS
31693                                           ! 4570   if ( drive_ty
31694                       00009323            .693:
31695                                           ! 4570 pe == 0 )
31696                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
31697 9323           8A46         FF            mov	al,-1[bp]
31698 9326           84C0                       test	al,al
31699 9328           75           08            jne 	.694
31700                       0000932A            .695:
31701                                           ! 4571     return(0);
31702 932A           31C0                       xor	ax,ax
31703 932C           89EC                       mov	sp,bp
31704 932E           5D                         pop	bp
31705 932F           C3                         ret
31706                                           !BCC_EOS
31707                                           ! 4572   else
31708                                           ! 4573     return(1);
31709 9330           EB           07            jmp .696
31710                       00009332            .694:
31711 9332           B8                   0001  mov	ax,*1
31712 9335           89EC                       mov	sp,bp
31713 9337           5D                         pop	bp
31714 9338           C3                         ret
31715                                           !BCC_EOS
31716                                           ! 4574 }
31717                       00009339            .696:
31718 9339           89EC                       mov	sp,bp
31719 933B           5D                         pop	bp
31720 933C           C3                         ret
31721                                           ! 4575   void
31722                                           ! 4576 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
31723                                           ! 4577   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
31724                                           export	_int13_diskette_function
31725                       0000933D            _int13_diskette_function:
31726                                           !BCC_EOS
31727                                           ! 4578 {
31728                                           ! 4579   Bit8u drive, num_sectors, track, sector, head, status;
31729                                           !BCC_EOS
31730                                           ! 4580   Bit16u base_address, base_count, base_es;
31731                                           !BCC_EOS
31732                                           ! 4581   Bit8u page, mode_register, val8, dor;
31733                                           !BCC_EOS
31734                                           ! 4582   Bit8u return_status[7];
31735                                           !BCC_EOS
31736                                           ! 4583   Bit8u drive_type, num_floppies, ah;
31737                                           !BCC_EOS
31738                                           ! 4584   Bit16u es, last_addr;
31739                                           !BCC_EOS
31740                                           ! 4585   ;
31741 933D           55                         push	bp
31742 933E           89E5                       mov	bp,sp
31743 9340           83C4                   E2  add	sp,*-$1E
31744                                           !BCC_EOS
31745                                           ! 4586   ah = ( AX >> 8 );
31746                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
31747 9343           8B46         16            mov	ax,$16[bp]
31748 9346           88E0                       mov	al,ah
31749 9348           30E4                       xor	ah,ah
31750                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
31751 934A           8846         E6            mov	-$1A[bp],al
31752                                           !BCC_EOS
31753                                           ! 4587   switch ( ah ) {
31754 934D           8A46         E6            mov	al,-$1A[bp]
31755 9350           E9         10C3            br 	.699
31756                                           ! 4588     case 0x00:
31757                                           ! 4589 ;
31758                       00009353            .69A:
31759                                           !BCC_EOS
31760                                           ! 4590       drive = ( ELDX & 0x00ff );
31761                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31762 9353           8A46         0E            mov	al,$E[bp]
31763                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31764 9356           8846         FF            mov	-1[bp],al
31765                                           !BCC_EOS
31766                                           ! 4591       if (drive > 1) {
31767                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31768 9359           8A46         FF            mov	al,-1[bp]
31769 935C           3C                     01  cmp	al,*1
31770 935E           76           20            jbe 	.69B
31771                       00009360            .69C:
31772                                           ! 4592         AX = ((AX & 0x00ff) | ((1) << 8));
31773                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31774 9360           8A46         16            mov	al,$16[bp]
31775                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31776 9363           30E4                       xor	ah,ah
31777 9365           0D                   0100  or	ax,#$100
31778                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31779 9368           8946         16            mov	$16[bp],ax
31780                                           !BCC_EOS
31781                                           ! 4593         set_diskette_ret_status(1);
31782                                           ! Debug: list int = const 1 (used reg = )
31783 936B           B8                   0001  mov	ax,*1
31784 936E           50                         push	ax
31785                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31786 936F           E8         10E7            call	_set_diskette_ret_status
31787 9372           44                         inc	sp
31788 9373           44                         inc	sp
31789                                           !BCC_EOS
31790                                           ! 4594         FLAGS |= 0x0001;
31791                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31792 9374           8B46         1C            mov	ax,$1C[bp]
31793 9377           0C                     01  or	al,*1
31794 9379           8946         1C            mov	$1C[bp],ax
31795                                           !BCC_EOS
31796                                           ! 4595         return;
31797 937C           89EC                       mov	sp,bp
31798 937E           5D                         pop	bp
31799 937F           C3                         ret
31800                                           !BCC_EOS
31801                                           ! 4596       }
31802                                           ! 4597       drive_type = inb_cmos(0x10);
31803                       00009380            .69B:
31804                                           ! Debug: list int = const $10 (used reg = )
31805 9380           B8                   0010  mov	ax,*$10
31806 9383           50                         push	ax
31807                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31808 9384           E8         7200            call	_inb_cmos
31809 9387           44                         inc	sp
31810 9388           44                         inc	sp
31811                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31812 9389           8846         E8            mov	-$18[bp],al
31813                                           !BCC_EOS
31814                                           ! 4598       if (drive == 0)
31815                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
31816 938C           8A46         FF            mov	al,-1[bp]
31817 938F           84C0                       test	al,al
31818 9391           75           0E            jne 	.69D
31819                       00009393            .69E:
31820                                           ! 4599         drive_type >>= 4;
31821                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31822 9393           8A46         E8            mov	al,-$18[bp]
31823 9396           30E4                       xor	ah,ah
31824 9398           B1                     04  mov	cl,*4
31825 939A           D3E8                       shr	ax,cl
31826 939C           8846         E8            mov	-$18[bp],al
31827                                           !BCC_EOS
31828                                           ! 4600       else
31829                                           ! 4601         drive_type &= 0x0f;
31830 939F           EB           08            jmp .69F
31831                       000093A1            .69D:
31832                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
31833 93A1           8A46         E8            mov	al,-$18[bp]
31834 93A4           24                     0F  and	al,*$F
31835 93A6           8846         E8            mov	-$18[bp],al
31836                                           !BCC_EOS
31837                                           ! 4602       if (drive_type == 0) {
31838                       000093A9            .69F:
31839                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31840 93A9           8A46         E8            mov	al,-$18[bp]
31841 93AC           84C0                       test	al,al
31842 93AE           75           20            jne 	.6A0
31843                       000093B0            .6A1:
31844                                           ! 4603         AX = ((AX & 0x00ff) | ((0x80) << 8));
31845                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31846 93B0           8A46         16            mov	al,$16[bp]
31847                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31848 93B3           30E4                       xor	ah,ah
31849 93B5           0D                   8000  or	ax,#-$8000
31850                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31851 93B8           8946         16            mov	$16[bp],ax
31852                                           !BCC_EOS
31853                                           ! 4604         set_diskette_ret_status(0x80);
31854                                           ! Debug: list int = const $80 (used reg = )
31855 93BB           B8                   0080  mov	ax,#$80
31856 93BE           50                         push	ax
31857                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31858 93BF           E8         1097            call	_set_diskette_ret_status
31859 93C2           44                         inc	sp
31860 93C3           44                         inc	sp
31861                                           !BCC_EOS
31862                                           ! 4605         FLAGS |= 0x0001;
31863                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31864 93C4           8B46         1C            mov	ax,$1C[bp]
31865 93C7           0C                     01  or	al,*1
31866 93C9           8946         1C            mov	$1C[bp],ax
31867                                           !BCC_EOS
31868                                           ! 4606         return;
31869 93CC           89EC                       mov	sp,bp
31870 93CE           5D                         pop	bp
31871 93CF           C3                         ret
31872                                           !BCC_EOS
31873                                           ! 4607       }
31874                                           ! 4608       AX = ((AX & 0x00ff) | ((0) << 8));
31875                       000093D0            .6A0:
31876                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31877 93D0           8A46         16            mov	al,$16[bp]
31878                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31879 93D3           0C                     00  or	al,*0
31880                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31881 93D5           30E4                       xor	ah,ah
31882 93D7           8946         16            mov	$16[bp],ax
31883                                           !BCC_EOS
31884                                           ! 4609       set_diskette_ret_status(0);
31885                                           ! Debug: list int = const 0 (used reg = )
31886 93DA           31C0                       xor	ax,ax
31887 93DC           50                         push	ax
31888                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31889 93DD           E8         1079            call	_set_diskette_ret_status
31890 93E0           44                         inc	sp
31891 93E1           44                         inc	sp
31892                                           !BCC_EOS
31893                                           ! 4610       FLAGS &= 0xfffe;
31894                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31895 93E2           8B46         1C            mov	ax,$1C[bp]
31896 93E5           24                     FE  and	al,#$FE
31897 93E7           8946         1C            mov	$1C[bp],ax
31898                                           !BCC_EOS
31899                                           ! 4611       set_diskette_current_cyl(drive, 0);
31900                                           ! Debug: list int = const 0 (used reg = )
31901 93EA           31C0                       xor	ax,ax
31902 93EC           50                         push	ax
31903                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31904 93ED           8A46         FF            mov	al,-1[bp]
31905 93F0           30E4                       xor	ah,ah
31906 93F2           50                         push	ax
31907                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31908 93F3           E8         107B            call	_set_diskette_current_cyl
31909 93F6           83C4                   04  add	sp,*4
31910                                           !BCC_EOS
31911                                           ! 4612       return;
31912 93F9           89EC                       mov	sp,bp
31913 93FB           5D                         pop	bp
31914 93FC           C3                         ret
31915                                           !BCC_EOS
31916                                           ! 4613     case 0x01:
31917                                           ! 4614       FLAGS &= 0xfffe;
31918                       000093FD            .6A2:
31919                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31920 93FD           8B46         1C            mov	ax,$1C[bp]
31921 9400           24                     FE  and	al,#$FE
31922 9402           8946         1C            mov	$1C[bp],ax
31923                                           !BCC_EOS
31924                                           ! 4615       val8 = read_byte(0x0000, 0x0441);
31925                                           ! Debug: list int = const $441 (used reg = )
31926 9405           B8                   0441  mov	ax,#$441
31927 9408           50                         push	ax
31928                                           ! Debug: list int = const 0 (used reg = )
31929 9409           31C0                       xor	ax,ax
31930 940B           50                         push	ax
31931                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31932 940C           E8         71E9            call	_read_byte
31933 940F           83C4                   04  add	sp,*4
31934                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31935 9412           8846         F1            mov	-$F[bp],al
31936                                           !BCC_EOS
31937                                           ! 4616       AX = ((AX & 0x00ff) | ((val8) << 8));
31938                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
31939 9415           8A46         F1            mov	al,-$F[bp]
31940 9418           30E4                       xor	ah,ah
31941 941A           88C4                       mov	ah,al
31942 941C           30C0                       xor	al,al
31943 941E           50                         push	ax
31944                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
31945 941F           8A46         16            mov	al,$16[bp]
31946                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
31947 9422           30E4                       xor	ah,ah
31948 9424           0B46         E0            or	ax,0+..FFDC[bp]
31949 9427           44                         inc	sp
31950 9428           44                         inc	sp
31951                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31952 9429           8946         16            mov	$16[bp],ax
31953                                           !BCC_EOS
31954                                           ! 4617       if (val8) {
31955 942C           8A46         F1            mov	al,-$F[bp]
31956 942F           84C0                       test	al,al
31957 9431           74           08            je  	.6A3
31958                       00009433            .6A4:
31959                                           ! 4618         FLAGS |= 0x0001;
31960                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31961 9433           8B46         1C            mov	ax,$1C[bp]
31962 9436           0C                     01  or	al,*1
31963 9438           8946         1C            mov	$1C[bp],ax
31964                                           !BCC_EOS
31965                                           ! 4619       }
31966                                           ! 4620       return;
31967                       0000943B            .6A3:
31968 943B           89EC                       mov	sp,bp
31969 943D           5D                         pop	bp
31970 943E           C3                         ret
31971                                           !BCC_EOS
31972                                           ! 4621     case 0x02:
31973                                           ! 4622     case 0x03:
31974                       0000943F            .6A5:
31975                                           ! 4623     case 0x04:
31976                       0000943F            .6A6:
31977                                           ! 4624       num_sectors = ( AX & 0x00ff );
31978                       0000943F            .6A7:
31979                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31980 943F           8A46         16            mov	al,$16[bp]
31981                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31982 9442           8846         FE            mov	-2[bp],al
31983                                           !BCC_EOS
31984                                           ! 4625       track = ( CX >> 8 );
31985                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31986 9445           8B46         14            mov	ax,$14[bp]
31987 9448           88E0                       mov	al,ah
31988 944A           30E4                       xor	ah,ah
31989                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31990 944C           8846         FD            mov	-3[bp],al
31991                                           !BCC_EOS
31992                                           ! 4626       sector = ( CX & 0x00ff );
31993                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
31994 944F           8A46         14            mov	al,$14[bp]
31995                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
31996 9452           8846         FC            mov	-4[bp],al
31997                                           !BCC_EOS
31998                                           ! 4627       head = ( DX >> 8 );
31999                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
32000 9455           8B46         12            mov	ax,$12[bp]
32001 9458           88E0                       mov	al,ah
32002 945A           30E4                       xor	ah,ah
32003                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
32004 945C           8846         FB            mov	-5[bp],al
32005                                           !BCC_EOS
32006                                           ! 4628       drive = ( ELDX & 0x00ff );
32007                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
32008 945F           8A46         0E            mov	al,$E[bp]
32009                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
32010 9462           8846         FF            mov	-1[bp],al
32011                                           !BCC_EOS
32012                                           ! 4629       if ((drive > 1) || (head > 1) || (sector == 0) ||
32013                                           ! 4630           (num_sectors == 0) || (num_sectors > 72)) {
32014                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
32015 9465           8A46         FF            mov	al,-1[bp]
32016 9468           3C                     01  cmp	al,*1
32017 946A           77           1C            ja  	.6A9
32018                       0000946C            .6AD:
32019                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
32020 946C           8A46         FB            mov	al,-5[bp]
32021 946F           3C                     01  cmp	al,*1
32022 9471           77           15            ja  	.6A9
32023                       00009473            .6AC:
32024                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
32025 9473           8A46         FC            mov	al,-4[bp]
32026 9476           84C0                       test	al,al
32027 9478           74           0E            je  	.6A9
32028                       0000947A            .6AB:
32029                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
32030 947A           8A46         FE            mov	al,-2[bp]
32031 947D           84C0                       test	al,al
32032 947F           74           07            je  	.6A9
32033                       00009481            .6AA:
32034                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
32035 9481           8A46         FE            mov	al,-2[bp]
32036 9484           3C                     48  cmp	al,*$48
32037 9486           76           38            jbe 	.6A8
32038                       00009488            .6A9:
32039                                           ! 4631         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
32040                                           ! Debug: list * char = .6AE+0 (used reg = )
32041 9488           BB                   CE1D  mov	bx,#.6AE
32042 948B           53                         push	bx
32043                                           ! Debug: list int = const 4 (used reg = )
32044 948C           B8                   0004  mov	ax,*4
32045 948F           50                         push	ax
32046                                           ! Debug: func () void = bios_printf+0 (used reg = )
32047 9490           E8         7514            call	_bios_printf
32048 9493           83C4                   04  add	sp,*4
32049                                           !BCC_EOS
32050                                           ! 4632         AX = ((AX & 0x00ff) | ((1) << 8));
32051                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32052 9496           8A46         16            mov	al,$16[bp]
32053                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32054 9499           30E4                       xor	ah,ah
32055 949B           0D                   0100  or	ax,#$100
32056                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32057 949E           8946         16            mov	$16[bp],ax
32058                                           !BCC_EOS
32059                                           ! 4633         set_diskette_ret_status(1);
32060                                           ! Debug: list int = const 1 (used reg = )
32061 94A1           B8                   0001  mov	ax,*1
32062 94A4           50                         push	ax
32063                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32064 94A5           E8         0FB1            call	_set_diskette_ret_status
32065 94A8           44                         inc	sp
32066 94A9           44                         inc	sp
32067                                           !BCC_EOS
32068                                           ! 4634         AX = ((AX & 0xff00) | (0));
32069                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32070 94AA           8B46         16            mov	ax,$16[bp]
32071 94AD           30C0                       xor	al,al
32072                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32073 94AF           0C                     00  or	al,*0
32074                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32075 94B1           8946         16            mov	$16[bp],ax
32076                                           !BCC_EOS
32077                                           ! 4635         FLAGS |= 0x0001;
32078                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32079 94B4           8B46         1C            mov	ax,$1C[bp]
32080 94B7           0C                     01  or	al,*1
32081 94B9           8946         1C            mov	$1C[bp],ax
32082                                           !BCC_EOS
32083                                           ! 4636         return;
32084 94BC           89EC                       mov	sp,bp
32085 94BE           5D                         pop	bp
32086 94BF           C3                         ret
32087                                           !BCC_EOS
32088                                           ! 4637       }
32089                                           ! 4638       if (floppy_drive_exists(drive) == 0) {
32090                       000094C0            .6A8:
32091                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32092 94C0           8A46         FF            mov	al,-1[bp]
32093 94C3           30E4                       xor	ah,ah
32094 94C5           50                         push	ax
32095                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
32096 94C6           E8         FE2C            call	_floppy_drive_exists
32097 94C9           44                         inc	sp
32098 94CA           44                         inc	sp
32099                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32100 94CB           85C0                       test	ax,ax
32101 94CD           75           2A            jne 	.6AF
32102                       000094CF            .6B0:
32103                                           ! 4639         AX = ((AX & 0x00ff) | ((0x80) << 8));
32104                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32105 94CF           8A46         16            mov	al,$16[bp]
32106                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32107 94D2           30E4                       xor	ah,ah
32108 94D4           0D                   8000  or	ax,#-$8000
32109                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32110 94D7           8946         16            mov	$16[bp],ax
32111                                           !BCC_EOS
32112                                           ! 4640         set_diskette_ret_status(0x80);
32113                                           ! Debug: list int = const $80 (used reg = )
32114 94DA           B8                   0080  mov	ax,#$80
32115 94DD           50                         push	ax
32116                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32117 94DE           E8         0F78            call	_set_diskette_ret_status
32118 94E1           44                         inc	sp
32119 94E2           44                         inc	sp
32120                                           !BCC_EOS
32121                                           ! 4641         AX = ((AX & 0xff00) | (0));
32122                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32123 94E3           8B46         16            mov	ax,$16[bp]
32124 94E6           30C0                       xor	al,al
32125                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32126 94E8           0C                     00  or	al,*0
32127                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32128 94EA           8946         16            mov	$16[bp],ax
32129                                           !BCC_EOS
32130                                           ! 4642         FLAGS |= 0
32131                                           ! 4642 x0001;
32132                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32133 94ED           8B46         1C            mov	ax,$1C[bp]
32134 94F0           0C                     01  or	al,*1
32135 94F2           8946         1C            mov	$1C[bp],ax
32136                                           !BCC_EOS
32137                                           ! 4643         return;
32138 94F5           89EC                       mov	sp,bp
32139 94F7           5D                         pop	bp
32140 94F8           C3                         ret
32141                                           !BCC_EOS
32142                                           ! 4644       }
32143                                           ! 4645       if (floppy_media_known(drive) == 0) {
32144                       000094F9            .6AF:
32145                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32146 94F9           8A46         FF            mov	al,-1[bp]
32147 94FC           30E4                       xor	ah,ah
32148 94FE           50                         push	ax
32149                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
32150 94FF           E8         FB5E            call	_floppy_media_known
32151 9502           44                         inc	sp
32152 9503           44                         inc	sp
32153                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32154 9504           85C0                       test	ax,ax
32155 9506           75           39            jne 	.6B1
32156                       00009508            .6B2:
32157                                           ! 4646         if (floppy_media_sense(drive) == 0) {
32158                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32159 9508           8A46         FF            mov	al,-1[bp]
32160 950B           30E4                       xor	ah,ah
32161 950D           50                         push	ax
32162                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
32163 950E           E8         FBD2            call	_floppy_media_sense
32164 9511           44                         inc	sp
32165 9512           44                         inc	sp
32166                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32167 9513           85C0                       test	ax,ax
32168 9515           75           2A            jne 	.6B3
32169                       00009517            .6B4:
32170                                           ! 4647           AX = ((AX & 0x00ff) | ((0x0C) << 8));
32171                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32172 9517           8A46         16            mov	al,$16[bp]
32173                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
32174 951A           30E4                       xor	ah,ah
32175 951C           0D                   0C00  or	ax,#$C00
32176                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32177 951F           8946         16            mov	$16[bp],ax
32178                                           !BCC_EOS
32179                                           ! 4648           set_diskette_ret_status(0x0C);
32180                                           ! Debug: list int = const $C (used reg = )
32181 9522           B8                   000C  mov	ax,*$C
32182 9525           50                         push	ax
32183                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32184 9526           E8         0F30            call	_set_diskette_ret_status
32185 9529           44                         inc	sp
32186 952A           44                         inc	sp
32187                                           !BCC_EOS
32188                                           ! 4649           AX = ((AX & 0xff00) | (0));
32189                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32190 952B           8B46         16            mov	ax,$16[bp]
32191 952E           30C0                       xor	al,al
32192                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32193 9530           0C                     00  or	al,*0
32194                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32195 9532           8946         16            mov	$16[bp],ax
32196                                           !BCC_EOS
32197                                           ! 4650           FLAGS |= 0x0001;
32198                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32199 9535           8B46         1C            mov	ax,$1C[bp]
32200 9538           0C                     01  or	al,*1
32201 953A           8946         1C            mov	$1C[bp],ax
32202                                           !BCC_EOS
32203                                           ! 4651           return;
32204 953D           89EC                       mov	sp,bp
32205 953F           5D                         pop	bp
32206 9540           C3                         ret
32207                                           !BCC_EOS
32208                                           ! 4652         }
32209                                           ! 4653       }
32210                       00009541            .6B3:
32211                                           ! 4654       if (ah == 0x02) {
32212                       00009541            .6B1:
32213                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
32214 9541           8A46         E6            mov	al,-$1A[bp]
32215 9544           3C                     02  cmp	al,*2
32216 9546         0F85         03B4            bne 	.6B5
32217                       0000954A            .6B6:
32218                                           ! 4655         page = (ES >> 12);
32219                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32220 954A           8B46         06            mov	ax,6[bp]
32221 954D           88E0                       mov	al,ah
32222 954F           30E4                       xor	ah,ah
32223 9551           B1                     04  mov	cl,*4
32224 9553           D3E8                       shr	ax,cl
32225                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32226 9555           8846         F3            mov	-$D[bp],al
32227                                           !BCC_EOS
32228                                           ! 4656         base_es = (ES << 4);
32229                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32230 9558           8B46         06            mov	ax,6[bp]
32231 955B           B1                     04  mov	cl,*4
32232 955D           D3E0                       shl	ax,cl
32233                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32234 955F           8946         F4            mov	-$C[bp],ax
32235                                           !BCC_EOS
32236                                           ! 4657         base_address = base_es + BX;
32237                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32238 9562           8B46         F4            mov	ax,-$C[bp]
32239 9565           0346         10            add	ax,$10[bp]
32240                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32241 9568           8946         F8            mov	-8[bp],ax
32242                                           !BCC_EOS
32243                                           ! 4658         if ( base_address < base_es ) {
32244                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32245 956B           8B46         F8            mov	ax,-8[bp]
32246 956E           3B46         F4            cmp	ax,-$C[bp]
32247 9571           73           07            jae 	.6B7
32248                       00009573            .6B8:
32249                                           ! 4659           page++;
32250                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32251 9573           8A46         F3            mov	al,-$D[bp]
32252 9576           40                         inc	ax
32253 9577           8846         F3            mov	-$D[bp],al
32254                                           !BCC_EOS
32255                                           ! 4660         }
32256                                           ! 4661         base_count = (num_sectors * 512) - 1;
32257                       0000957A            .6B7:
32258                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32259 957A           8A46         FE            mov	al,-2[bp]
32260 957D           30E4                       xor	ah,ah
32261 957F           B9                   0200  mov	cx,#$200
32262 9582           F7E9                       imul	cx
32263                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32264                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32265 9584           48                         dec	ax
32266 9585           8946         F6            mov	-$A[bp],ax
32267                                           !BCC_EOS
32268                                           ! 4662         last_addr = base_address + base_count;
32269                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32270 9588           8B46         F8            mov	ax,-8[bp]
32271 958B           0346         F6            add	ax,-$A[bp]
32272                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32273 958E           8946         E2            mov	-$1E[bp],ax
32274                                           !BCC_EOS
32275                                           ! 4663         if (last_addr < base_address) {
32276                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32277 9591           8B46         E2            mov	ax,-$1E[bp]
32278 9594           3B46         F8            cmp	ax,-8[bp]
32279 9597           73           2A            jae 	.6B9
32280                       00009599            .6BA:
32281                                           ! 4664           AX = ((AX & 0x00ff) | ((0x09) << 8));
32282                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32283 9599           8A46         16            mov	al,$16[bp]
32284                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32285 959C           30E4                       xor	ah,ah
32286 959E           0D                   0900  or	ax,#$900
32287                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32288 95A1           8946         16            mov	$16[bp],ax
32289                                           !BCC_EOS
32290                                           ! 4665           set_diskette_ret_status(0x09);
32291                                           ! Debug: list int = const 9 (used reg = )
32292 95A4           B8                   0009  mov	ax,*9
32293 95A7           50                         push	ax
32294                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32295 95A8           E8         0EAE            call	_set_diskette_ret_status
32296 95AB           44                         inc	sp
32297 95AC           44                         inc	sp
32298                                           !BCC_EOS
32299                                           ! 4666           AX = ((AX & 0xff00) | (0));
32300                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32301 95AD           8B46         16            mov	ax,$16[bp]
32302 95B0           30C0                       xor	al,al
32303                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32304 95B2           0C                     00  or	al,*0
32305                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32306 95B4           8946         16            mov	$16[bp],ax
32307                                           !BCC_EOS
32308                                           ! 4667           FLAGS |= 0x0001;
32309                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32310 95B7           8B46         1C            mov	ax,$1C[bp]
32311 95BA           0C                     01  or	al,*1
32312 95BC           8946         1C            mov	$1C[bp],ax
32313                                           !BCC_EOS
32314                                           ! 4668           return;
32315 95BF           89EC                       mov	sp,bp
32316 95C1           5D                         pop	bp
32317 95C2           C3                         ret
32318                                           !BCC_EOS
32319                                           ! 4669         }
32320                                           ! 4670         ;
32321                       000095C3            .6B9:
32322                                           !BCC_EOS
32323                                           ! 4671         outb(0x000a, 0x06);
32324                                           ! Debug: list int = const 6 (used reg = )
32325 95C3           B8                   0006  mov	ax,*6
32326 95C6           50                         push	ax
32327                                           ! Debug: list int = const $A (used reg = )
32328 95C7           B8                   000A  mov	ax,*$A
32329 95CA           50                         push	ax
32330                                           ! Debug: func () void = outb+0 (used reg = )
32331 95CB           E8         6F8A            call	_outb
32332 95CE           83C4                   04  add	sp,*4
32333                                           !BCC_EOS
32334                                           ! 4672   ;
32335                                           !BCC_EOS
32336                                           ! 4673         outb(0x000c, 0x00);
32337                                           ! Debug: list int = const 0 (used reg = )
32338 95D1           31C0                       xor	ax,ax
32339 95D3           50                         push	ax
32340                                           ! Debug: list int = const $C (used reg = )
32341 95D4           B8                   000C  mov	ax,*$C
32342 95D7           50                         push	ax
32343                                           ! Debug: func () void = outb+0 (used reg = )
32344 95D8           E8         6F7D            call	_outb
32345 95DB           83C4                   04  add	sp,*4
32346                                           !BCC_EOS
32347                                           ! 4674         outb(0x0004, base_address);
32348                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32349 95DE           FF76         F8            push	-8[bp]
32350                                           ! Debug: list int = const 4 (used reg = )
32351 95E1           B8                   0004  mov	ax,*4
32352 95E4           50                         push	ax
32353                                           ! Debug: func () void = outb+0 (used reg = )
32354 95E5           E8         6F70            call	_outb
32355 95E8           83C4                   04  add	sp,*4
32356                                           !BCC_EOS
32357                                           ! 4675         outb(0x0004, base_address>>8);
32358                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32359 95EB           8B46         F8            mov	ax,-8[bp]
32360 95EE           88E0                       mov	al,ah
32361 95F0           30E4                       xor	ah,ah
32362                                           ! Debug: list unsigned int = ax+0 (used reg = )
32363 95F2           50                         push	ax
32364                                           ! Debug: list int = const 4 (used reg = )
32365 95F3           B8                   0004  mov	ax,*4
32366 95F6           50                         push	ax
32367                                           ! Debug: func () void = outb+0 (used reg = )
32368 95F7           E8         6F5E            call	_outb
32369 95FA           83C4                   04  add	sp,*4
32370                                           !BCC_EOS
32371                                           ! 4676   ;
32372                                           !BCC_EOS
32373                                           ! 4677         outb(0x000c, 0x00);
32374                                           ! Debug: list int = const 0 (used reg = )
32375 95FD           31C0                       xor	ax,ax
32376 95FF           50                         push	ax
32377                                           ! Debug: list int = const $C (used reg = )
32378 9600           B8                   000C  mov	ax,*$C
32379 9603           50                         push	ax
32380                                           ! Debug: func () void = outb+0 (used reg = )
32381 9604           E8         6F51            call	_outb
32382 9607           83C4                   04  add	sp,*4
32383                                           !BCC_EOS
32384                                           ! 4678         outb(0x0005, base_count);
32385                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32386 960A           FF76         F6            push	-$A[bp]
32387                                           ! Debug: list int = const 5 (used reg = )
32388 960D           B8                   0005  mov	ax,*5
32389 9610           50                         push	ax
32390                                           ! Debug: func () void = outb+0 (used reg = )
32391 9611           E8         6F44            call	_outb
32392 9614           83C4                   04  add	sp,*4
32393                                           !BCC_EOS
32394                                           ! 4679         outb(0x0005, base_count>>8);
32395                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32396 9617           8B46         F6            mov	ax,-$A[bp]
32397 961A           88E0                       mov	al,ah
32398 961C           30E4                       xor	ah,ah
32399                                           ! Debug: list unsigned int = ax+0 (used reg = )
32400 961E           50                         push	ax
32401                                           ! Debug: list int = const 5 (used reg = )
32402 961F           B8                   0005  mov	ax,*5
32403 9622           50                         push	ax
32404                                           ! Debug: func () void = outb+0 (used reg = )
32405 9623           E8         6F32            call	_outb
32406 9626           83C4                   04  add	sp,*4
32407                                           !BCC_EOS
32408                                           ! 4680         mode_register = 0x46;
32409                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
32410 9629           B0                     46  mov	al,*$46
32411 962B           8846         F2            mov	-$E[bp],al
32412                                           !BCC_EOS
32413                                           ! 4681   ;
32414                                           !BCC_EOS
32415                                           ! 4682         outb(0x000b, mode_register);
32416                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32417 962E           8A46         F2            mov	al,-$E[bp]
32418 9631           30E4                       xor	ah,ah
32419 9633           50                         push	ax
32420                                           ! Debug: list int = const $B (used reg = )
32421 9634           B8                   000B  mov	ax,*$B
32422 9637           50                         push	ax
32423                                           ! Debug: func () void = outb+0 (used reg = )
32424 9638           E8         6F1D            call	_outb
32425 963B           83C4                   04  add	sp,*4
32426                                           !BCC_EOS
32427                                           ! 4683   ;
32428                                           !BCC_EOS
32429                                           ! 4684         outb(0x0081, page);
32430                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32431 963E           8A46         F3            mov	al,-$D[bp]
32432 9641           30E4                       xor	ah,ah
32433 9643           50                         push	ax
32434                                           ! Debug: list int = const $81 (used reg = )
32435 9644           B8                   0081  mov	ax,#$81
32436 9647           50                         push	ax
32437                                           ! Debug: func () void = outb+0 (used reg = )
32438 9648           E8         6F0D            call	_outb
32439 964B           83C4                   04  add	sp,*4
32440                                           !BCC_EOS
32441                                           ! 4685   ;
32442                                           !BCC_EOS
32443                                           ! 4686         outb(0x000a, 0x02);
32444                                           ! Debug: list int = const 2 (used reg = )
32445 964E           B8                   0002  mov	ax,*2
32446 9651           50                         push	ax
32447                                           ! Debug: list int = const $A (used reg = )
32448 9652           B8                   000A  mov	ax,*$A
32449 9655           50                         push	ax
32450                                           ! Debug: func () void = outb+0 (used reg = )
32451 9656           E8         6EFF            call	_outb
32452 9659           83C4                   04  add	sp,*4
32453                                           !BCC_EOS
32454                                           ! 4687         ;
32455                                           !BCC_EOS
32456                                           ! 4688         outb(0x000a, 0x02);
32457                                           ! Debug: list int = const 2 (used reg = )
32458 965C           B8                   0002  mov	ax,*2
32459 965F           50                         push	ax
32460                                           ! Debug: list int = const $A (used reg = )
32461 9660           B8                   000A  mov	ax,*$A
32462 9663           50                         push	ax
32463                                           ! Debug: func () void = outb+0 (used reg = )
32464 9664           E8         6EF1            call	_outb
32465 9667           83C4                   04  add	sp,*4
32466                                           !BCC_EOS
32467                                           ! 4689         floppy_prepare_controller(drive);
32468                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32469 966A           8A46         FF            mov	al,-1[bp]
32470 966D           30E4                       xor	ah,ah
32471 966F           50                         push	ax
32472                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32473 9670           E8         F90E            call	_floppy_prepare_controller
32474 9673           44                         inc	sp
32475 9674           44                         inc	sp
32476                                           !BCC_EOS
32477                                           ! 4690         outb(0x03f5, 0xe6);
32478                                           ! Debug: list int = const $E6 (used reg = )
32479 9675           B8                   00E6  mov	ax,#$E6
32480 9678           50                         push	ax
32481                                           ! Debug: list int = const $3F5 (used reg = )
32482 9679           B8                   03F5  mov	ax,#$3F5
32483 967C           50                         push	ax
32484                                           ! Debug: func () void = outb+0 (used reg = )
32485 967D           E8         6ED8            call	_outb
32486 9680           83C4                   04  add	sp,*4
32487                                           !BCC_EOS
32488                                           ! 4691         outb(0x03f5, (head << 2) | drive);
32489                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32490 9683           8A46         FB            mov	al,-5[bp]
32491 9686           30E4                       xor	ah,ah
32492 9688           D1E0                       shl	ax,*1
32493 968A           D1E0                       shl	ax,*1
32494                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32495 968C           0A46         FF            or	al,-1[bp]
32496                                           ! Debug: list unsigned int = ax+0 (used reg = )
32497 968F           50                         push	ax
32498                                           ! Debug: list int = const $3F5 (used reg = )
32499 9690           B8                   03F5  mov	ax,#$3F5
32500 9693           50                         push	ax
32501                                           ! Debug: func () void = outb+0 (used reg = )
32502 9694           E8         6EC1            call	_outb
32503 9697           83C4                   04  add	sp,*4
32504                                           !BCC_EOS
32505                                           ! 4692         outb(0x03f5, track);
32506                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32507 969A           8A46         FD            mov	al,-3[bp]
32508 969D           30E4                       xor	ah,ah
32509 969F           50                         push	ax
32510                                           ! Debug: list int = const $3F5 (used reg = )
32511 96A0           B8                   03F5  mov	ax,#$3F5
32512 96A3           50                         push	ax
32513                                           ! Debug: func () void = outb+0 (used reg = )
32514 96A4           E8         6EB1            call	_outb
32515 96A7           83C4                   04  add	sp,*4
32516                                           !BCC_EOS
32517                                           ! 4693         outb(0x03f5, head);
32518                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32519 96AA           8A46         FB            mov	al,-5[bp]
32520 96AD           30E4                       xor	ah,ah
32521 96AF           50                         push	ax
32522                                           ! Debug: list int = const $3F5 (used reg = )
32523 96B0           B8                   03F5  mov	ax,#$3F5
32524 96B3           50                         push	ax
32525                                           ! Debug: func () void = outb+0 (used reg = )
32526 96B4           E8         6EA1            call	_outb
32527 96B7           83C4                   04  add	sp,*4
32528                                           !BCC_EOS
32529                                           ! 4694         outb(0x03f5, sector);
32530                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32531 96BA           8A46         FC            mov	al,-4[bp]
32532 96BD           30E4                       xor	ah,ah
32533 96BF           50                         push	ax
32534                                           ! Debug: list int = const $3F5 (used reg = )
32535 96C0           B8                   03F5  mov	ax,#$3F5
32536 96C3           50                         push	ax
32537                                           ! Debug: func () void = outb+0 (used reg = )
32538 96C4           E8         6E91            call	_outb
32539 96C7           83C4                   04  add	sp,*4
32540                                           !BCC_EOS
32541                                           ! 4695         outb(0x03f5, 2);
32542                                           ! Debug: list int = const 2 (used reg = )
32543 96CA           B8                   0002  mov	ax,*2
32544 96CD           50                         push	ax
32545                                           ! Debug: list int = const $3F5 (used reg = )
32546 96CE           B8                   03F5  mov	ax,#$3F5
32547 96D1           50                         push	ax
32548                                           ! Debug: func () void = outb+0 (used reg = )
32549 96D2           E8         6E83            call	_outb
32550 96D5           83C4                   04  add	sp,*4
32551                                           !BCC_EOS
32552                                           ! 4696         outb(0x03f5, sector + num_sectors - 1);
32553                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32554 96D8           8A46         FC            mov	al,-4[bp]
32555 96DB           30E4                       xor	ah,ah
32556 96DD           0246         FE            add	al,-2[bp]
32557 96E0           80D4                   00  adc	ah,*0
32558                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32559                                           ! Debug: list unsigned int = ax-1 (used reg = )
32560 96E3           48                         dec	ax
32561 96E4           50                         push	ax
32562                                           ! Debug: list int = const $3F5 (used reg = )
32563 96E5           B8                   03F5  mov	ax,#$3F5
32564 96E8           50                         push	ax
32565                                           ! Debug: func () void = outb+0 (used reg = )
32566 96E9           E8         6E6C            call	_outb
32567 96EC           83C4                   04  add	sp,*4
32568                                           !BCC_EOS
32569                                           ! 4697         outb(0x03f5, 0);
32570                                           ! Debug: list int = const 0 (used reg = )
32571 96EF           31C0                       xor	ax,ax
32572 96F1           50                         push	ax
32573                                           ! Debug: list int = const $3F5 (used reg = )
32574 96F2           B8                   03F5  mov	ax,#$3F5
32575 96F5           50                         push	ax
32576                                           ! Debug: func () void = outb+0 (used reg = )
32577 96F6           E8         6E5F            call	_outb
32578 96F9           83C4                   04  add	sp,*4
32579                                           !BCC_EOS
32580                                           ! 4698         outb(0x03f5, 0xff);
32581                                           ! Debug: list int = const $FF (used reg = )
32582 96FC           B8                   00FF  mov	ax,#$FF
32583 96FF           50                         push	ax
32584                                           ! Debug: list int = const $3F5 (used reg = )
32585 9700           B8                   03F5  mov	ax,#$3F5
32586 9703           50                         push	ax
32587                                           ! Debug: func () void = outb+0 (used reg = )
32588 9704           E8         6E51            call	_outb
32589 9707           83C4                   04  add	sp,*4
32590                                           !BCC_EOS
32591                                           ! 4699 #asm
32592                                           !BCC_EOS
32593                                           !BCC_ASM
32594                       0000002A            _int13_diskette_function.BP	set	$2A
32595                       0000000C            .int13_diskette_function.BP	set	$C
32596                       00000038            _int13_diskette_function.CS	set	$38
32597                       0000001A            .int13_diskette_function.CS	set	$1A
32598                       00000032            _int13_diskette_function.CX	set	$32
32599                       00000014            .int13_diskette_function.CX	set	$14
32600                       00000016            _int13_diskette_function.base_address	set	$16
32601                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32602                       00000026            _int13_diskette_function.DI	set	$26
32603                       00000008            .int13_diskette_function.DI	set	8
32604                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32605                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32606                       00000014            _int13_diskette_function.base_count	set	$14
32607                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32608                       0000001A            _int13_diskette_function.sector	set	$1A
32609                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32610                       00000022            _int13_diskette_function.DS	set	$22
32611                       00000004            .int13_diskette_function.DS	set	4
32612                       00000019            _int13_diskette_function.head	set	$19
32613                       FFFFFFFB            .int13_diskette_function.head	set	-5
32614                       0000002C            _int13_diskette_function.ELDX	set	$2C
32615                       0000000E            .int13_diskette_function.ELDX	set	$E
32616                       0000000E            _int13_diskette_function.dor	set	$E
32617                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32618                       00000030            _int13_diskette_function.DX	set	$30
32619                       00000012            .int13_diskette_function.DX	set	$12
32620                       00000007            _int13_diskette_function.return_status	set	7
32621                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32622                       00000002            _int13_diskette_function.es	set	2
32623                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32624                       00000010            _int13_diskette_function.mode_register	set	$10
32625                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32626                       00000024            _int13_diskette_function.ES	set	$24
32627                       00000006            .int13_diskette_function.ES	set	6
32628                       00000012            _int13_diskette_function.base_es	set	$12
32629                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32630                       0000001B            _int13_diskette_function.track	set	$1B
32631                       FFFFFFFD            .int13_diskette_function.track	set	-3
32632                       00000028            _int13_diskette_function.SI	set	$28
32633                       0000000A            .int13_diskette_function.SI	set	$A
32634                       00000006            _int13_diskette_function.drive_type	set	6
32635                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32636                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32637                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32638                       00000036            _int13_diskette_function.IP	set	$36
32639                       00000018            .int13_diskette_function.IP	set	$18
32640                       00000018            _int13_diskette_function.status	set	$18
32641                       FFFFFFFA            .int13_diskette_function.status	set	-6
32642                       00000034            _int13_diskette_function.AX	set	$34
32643                       00000016            .int13_diskette_function.AX	set	$16
32644                       0000000F            _int13_diskette_function.val8	set	$F
32645                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32646                       00000000            _int13_diskette_function.last_addr	set	0
32647                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32648                       00000011            _int13_diskette_function.page	set	$11
32649                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32650                       00000004            _int13_diskette_function.ah	set	4
32651                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32652                       0000001D            _int13_diskette_function.drive	set	$1D
32653                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32654                       00000005            _int13_diskette_function.num_floppies	set	5
32655                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32656                       0000002E            _int13_diskette_function.BX	set	$2E
32657                       00000010            .int13_diskette_function.BX	set	$10
32658 970A           FB                                 sti
32659                                           ! 4701 endasm
32660                                           !BCC_ENDASM
32661                                           !BCC_EOS
32662                                           ! 4702         do {
32663                       0000970B            .6BD:
32664                                           ! 4703           val8 = read_byte(0x0040, 0x0040);
32665                                           ! Debug: list int = const $40 (used reg = )
32666 970B           B8                   0040  mov	ax,*$40
32667 970E           50                         push	ax
32668                                           ! Debug: list int = const $40 (used reg = )
32669 970F           B8                   0040  mov	ax,*$40
32670 9712           50                         push	ax
32671                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32672 9713           E8         6EE2            call	_read_byte
32673 9716           83C4                   04  add	sp,*4
32674                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32675 9719           8846         F1            mov	-$F[bp],al
32676                                           !BCC_EOS
32677                                           ! 4704           if (val8 == 0) {
32678                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32679 971C           8A46         F1            mov	al,-$F[bp]
32680 971F           84C0                       test	al,al
32681 9721           75           2D            jne 	.6BE
32682                       00009723            .6BF:
32683                                           ! 4705             floppy_reset_controller();
32684                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32685 9723           E8         F80D            call	_floppy_reset_controller
32686                                           !BCC_EOS
32687                                           ! 4706             AX = ((AX & 0x00ff) | ((0x80) << 8));
32688                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32689 9726           8A46         16            mov	al,$16[bp]
32690                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32691 9729           30E4                       xor	ah,ah
32692 972B           0D                   8000  or	ax,#-$8000
32693                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32694 972E           8946         16            mov	$16[bp],ax
32695                                           !BCC_EOS
32696                                           ! 4707             set_diskette_ret_status(0x80);
32697                                           ! Debug: list int = const $80 (used reg = )
32698 9731           B8                   0080  mov	ax,#$80
32699 9734           50                         push	ax
32700                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32701 9735           E8         0D21            call	_set_diskette_ret_status
32702 9738           44                         inc	sp
32703 9739           44                         inc	sp
32704                                           !BCC_EOS
32705                                           ! 4708             AX = ((AX & 0xff00) | (0));
32706                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32707 973A           8B46         16            mov	ax,$16[bp]
32708 973D           30C0                       xor	al,al
32709                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32710 973F           0C                     00  or	al,*0
32711                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32712 9741           8946         16            mov	$16[bp],ax
32713                                           !BCC_EOS
32714                                           ! 4709             FLAGS |= 0x0001;
32715                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32716 9744           8B46         1C            mov	ax,$1C[bp]
32717 9747           0C                     01  or	al,*1
32718 9749           8946         1C            mov	$1C[bp],ax
32719                                           !BCC_EOS
32720                                           ! 4710             return;
32721 974C           89EC                       mov	sp,bp
32722 974E           5D                         pop	bp
32723 974F           C3                         ret
32724                                           !BCC_EOS
32725                                           ! 4711           }
32726                                           ! 4712           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32727                       00009750            .6BE:
32728                                           ! Debug: list int = const $3E (used reg = )
32729 9750           B8                   003E  mov	ax,*$3E
32730 9753           50                         push	ax
32731                                           ! Debug: list int = const $40 (used reg = )
32732 9754           B8                   0040  mov	ax,*$40
32733 9757           50                         push	ax
32734                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32735 9758           E8         6E9D            call	_read_byte
32736 975B           83C4                   04  add	sp,*4
32737                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32738 975E           24                     80  and	al,#$80
32739                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32740 9760           8846         F1            mov	-$F[bp],al
32741                                           !BCC_EOS
32742                                           ! 4713         } while ( val8 == 0 );
32743                       00009763            .6BC:
32744                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32745 9763           8A46         F1            mov	al,-$F[bp]
32746 9766           84C0                       test	al,al
32747 9768           74           A1            je 	.6BD
32748                       0000976A            .6C0:
32749                                           !BCC_EOS
32750                                           ! 4714         val8 = 0;
32751                       0000976A            .6BB:
32752                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32753 976A           30C0                       xor	al,al
32754 976C           8846         F1            mov	-$F[bp],al
32755                                           !BCC_EOS
32756                                           ! 4715 #asm
32757                                           !BCC_EOS
32758                                           !BCC_ASM
32759                       0000002A            _int13_diskette_function.BP	set	$2A
32760                       0000000C            .int13_diskette_function.BP	set	$C
32761                       00000038            _int13_diskette_function.CS	set	$38
32762                       0000001A            .int13_diskette_function.CS	set	$1A
32763                       00000032            _int13_diskette_function.CX	set	$32
32764                       00000014            .int13_diskette_function.CX	set	$14
32765                       00000016            _int13_diskette_function.base_address	set	$16
32766                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32767                       00000026            _int13_diskette_function.DI	set	$26
32768                       00000008            .int13_diskette_function.DI	set	8
32769                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32770                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32771                       00000014            _int13_diskette_function.base_count	set	$14
32772                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32773                       0000001A            _int13_diskette_function.sector	set	$1A
32774                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32775                       00000022            _int13_diskette_function.DS	set	$22
32776                       00000004            .int13_diskette_function.DS	set	4
32777                       00000019            _int13_diskette_function.head	set	$19
32778                       FFFFFFFB            .int13_diskette_function.head	set	-5
32779                       0000002C            _int13_diskette_function.ELDX	set	$2C
32780                       0000000E            .int13_diskette_function.ELDX	set	$E
32781                       0000000E            _int13_diskette_function.dor	set	$E
32782                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32783                       00000030            _int13_diskette_function.DX	set	$30
32784                       00000012            .int13_diskette_function.DX	set	$12
32785                       00000007            _int13_diskette_function.return_status	set	7
32786                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32787                       00000002            _int13_diskette_function.es	set	2
32788                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32789                       00000010            _int13_diskette_function.mode_register	set	$10
32790                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32791                       00000024            _int13_diskette_function.ES	set	$24
32792                       00000006            .int13_diskette_function.ES	set	6
32793                       00000012            _int13_diskette_function.base_es	set	$12
32794                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32795                       0000001B            _int13_diskette_function.track	set	$1B
32796                       FFFFFFFD            .int13_diskette_function.track	set	-3
32797                       00000028            _int13_diskette_function.SI	set	$28
32798                       0000000A            .int13_diskette_function.SI	set	$A
32799                       00000006            _int13_diskette_function.drive_type	set	6
32800                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32801                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32802                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32803                       00000036            _int13_diskette_function.IP	set	$36
32804                       00000018            .int13_diskette_function.IP	set	$18
32805                       00000018            _int13_diskette_function.status	set	$18
32806                       FFFFFFFA            .int13_diskette_function.status	set	-6
32807                       00000034            _int13_diskette_function.AX	set	$34
32808                       00000016            .int13_diskette_function.AX	set	$16
32809                       0000000F            _int13_diskette_function.val8	set	$F
32810                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32811                       00000000            _int13_diskette_function.last_addr	set	0
32812                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32813                       00000011            _int13_diskette_function.page	set	$11
32814                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32815                       00000004            _int13_diskette_function.ah	set	4
32816                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32817                       0000001D            _int13_diskette_function.drive	set	$1D
32818                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32819                       00000005            _int13_diskette_function.num_floppies	set	5
32820                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32821                       0000002E            _int13_diskette_function.BX	set	$2E
32822                       00000010            .int13_diskette_function.BX	set	$10
32823 976F           FA                                 cli
32824                                           ! 4717 endasm
32825                                           !BCC_ENDASM
32826                                           !BCC_EOS
32827                                           ! 4718         val8 = read_b
32828                                           ! 4718 yte(0x0040, 0x003e);
32829                                           ! Debug: list int = const $3E (used reg = )
32830 9770           B8                   003E  mov	ax,*$3E
32831 9773           50                         push	ax
32832                                           ! Debug: list int = const $40 (used reg = )
32833 9774           B8                   0040  mov	ax,*$40
32834 9777           50                         push	ax
32835                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32836 9778           E8         6E7D            call	_read_byte
32837 977B           83C4                   04  add	sp,*4
32838                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32839 977E           8846         F1            mov	-$F[bp],al
32840                                           !BCC_EOS
32841                                           ! 4719         val8 &= 0x7f;
32842                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32843 9781           8A46         F1            mov	al,-$F[bp]
32844 9784           24                     7F  and	al,*$7F
32845 9786           8846         F1            mov	-$F[bp],al
32846                                           !BCC_EOS
32847                                           ! 4720         write_byte(0x0040, 0x003e, val8);
32848                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32849 9789           8A46         F1            mov	al,-$F[bp]
32850 978C           30E4                       xor	ah,ah
32851 978E           50                         push	ax
32852                                           ! Debug: list int = const $3E (used reg = )
32853 978F           B8                   003E  mov	ax,*$3E
32854 9792           50                         push	ax
32855                                           ! Debug: list int = const $40 (used reg = )
32856 9793           B8                   0040  mov	ax,*$40
32857 9796           50                         push	ax
32858                                           ! Debug: func () void = write_byte+0 (used reg = )
32859 9797           E8         6E84            call	_write_byte
32860 979A           83C4                   06  add	sp,*6
32861                                           !BCC_EOS
32862                                           ! 4721         val8 = inb(0x3f4);
32863                                           ! Debug: list int = const $3F4 (used reg = )
32864 979D           B8                   03F4  mov	ax,#$3F4
32865 97A0           50                         push	ax
32866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32867 97A1           E8         6D9E            call	_inb
32868 97A4           44                         inc	sp
32869 97A5           44                         inc	sp
32870                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32871 97A6           8846         F1            mov	-$F[bp],al
32872                                           !BCC_EOS
32873                                           ! 4722         if ( (val8 & 0xc0) != 0xc0 )
32874                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32875 97A9           8A46         F1            mov	al,-$F[bp]
32876 97AC           24                     C0  and	al,#$C0
32877                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32878 97AE           3C                     C0  cmp	al,#$C0
32879 97B0           74           0E            je  	.6C1
32880                       000097B2            .6C2:
32881                                           ! 4723           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32882                                           ! Debug: list * char = .6C3+0 (used reg = )
32883 97B2           BB                   CDFD  mov	bx,#.6C3
32884 97B5           53                         push	bx
32885                                           ! Debug: list int = const 7 (used reg = )
32886 97B6           B8                   0007  mov	ax,*7
32887 97B9           50                         push	ax
32888                                           ! Debug: func () void = bios_printf+0 (used reg = )
32889 97BA           E8         71EA            call	_bios_printf
32890 97BD           83C4                   04  add	sp,*4
32891                                           !BCC_EOS
32892                                           ! 4724         return_status[0] = inb(0x3f5);
32893                       000097C0            .6C1:
32894                                           ! Debug: list int = const $3F5 (used reg = )
32895 97C0           B8                   03F5  mov	ax,#$3F5
32896 97C3           50                         push	ax
32897                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32898 97C4           E8         6D7B            call	_inb
32899 97C7           44                         inc	sp
32900 97C8           44                         inc	sp
32901                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32902 97C9           8846         E9            mov	-$17[bp],al
32903                                           !BCC_EOS
32904                                           ! 4725         return_status[1] = inb(0x3f5);
32905                                           ! Debug: list int = const $3F5 (used reg = )
32906 97CC           B8                   03F5  mov	ax,#$3F5
32907 97CF           50                         push	ax
32908                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32909 97D0           E8         6D6F            call	_inb
32910 97D3           44                         inc	sp
32911 97D4           44                         inc	sp
32912                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32913 97D5           8846         EA            mov	-$16[bp],al
32914                                           !BCC_EOS
32915                                           ! 4726         return_status[2] = inb(0x3f5);
32916                                           ! Debug: list int = const $3F5 (used reg = )
32917 97D8           B8                   03F5  mov	ax,#$3F5
32918 97DB           50                         push	ax
32919                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32920 97DC           E8         6D63            call	_inb
32921 97DF           44                         inc	sp
32922 97E0           44                         inc	sp
32923                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32924 97E1           8846         EB            mov	-$15[bp],al
32925                                           !BCC_EOS
32926                                           ! 4727         return_status[3] = inb(0x3f5);
32927                                           ! Debug: list int = const $3F5 (used reg = )
32928 97E4           B8                   03F5  mov	ax,#$3F5
32929 97E7           50                         push	ax
32930                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32931 97E8           E8         6D57            call	_inb
32932 97EB           44                         inc	sp
32933 97EC           44                         inc	sp
32934                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32935 97ED           8846         EC            mov	-$14[bp],al
32936                                           !BCC_EOS
32937                                           ! 4728         return_status[4] = inb(0x3f5);
32938                                           ! Debug: list int = const $3F5 (used reg = )
32939 97F0           B8                   03F5  mov	ax,#$3F5
32940 97F3           50                         push	ax
32941                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32942 97F4           E8         6D4B            call	_inb
32943 97F7           44                         inc	sp
32944 97F8           44                         inc	sp
32945                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32946 97F9           8846         ED            mov	-$13[bp],al
32947                                           !BCC_EOS
32948                                           ! 4729         return_status[5] = inb(0x3f5);
32949                                           ! Debug: list int = const $3F5 (used reg = )
32950 97FC           B8                   03F5  mov	ax,#$3F5
32951 97FF           50                         push	ax
32952                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32953 9800           E8         6D3F            call	_inb
32954 9803           44                         inc	sp
32955 9804           44                         inc	sp
32956                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32957 9805           8846         EE            mov	-$12[bp],al
32958                                           !BCC_EOS
32959                                           ! 4730         return_status[6] = inb(0x3f5);
32960                                           ! Debug: list int = const $3F5 (used reg = )
32961 9808           B8                   03F5  mov	ax,#$3F5
32962 980B           50                         push	ax
32963                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32964 980C           E8         6D33            call	_inb
32965 980F           44                         inc	sp
32966 9810           44                         inc	sp
32967                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32968 9811           8846         EF            mov	-$11[bp],al
32969                                           !BCC_EOS
32970                                           ! 4731         write_byte(0x0040, 0x0042, return_status[0]);
32971                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32972 9814           8A46         E9            mov	al,-$17[bp]
32973 9817           30E4                       xor	ah,ah
32974 9819           50                         push	ax
32975                                           ! Debug: list int = const $42 (used reg = )
32976 981A           B8                   0042  mov	ax,*$42
32977 981D           50                         push	ax
32978                                           ! Debug: list int = const $40 (used reg = )
32979 981E           B8                   0040  mov	ax,*$40
32980 9821           50                         push	ax
32981                                           ! Debug: func () void = write_byte+0 (used reg = )
32982 9822           E8         6DF9            call	_write_byte
32983 9825           83C4                   06  add	sp,*6
32984                                           !BCC_EOS
32985                                           ! 4732         write_byte(0x0040, 0x0043, return_status[1]);
32986                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32987 9828           8A46         EA            mov	al,-$16[bp]
32988 982B           30E4                       xor	ah,ah
32989 982D           50                         push	ax
32990                                           ! Debug: list int = const $43 (used reg = )
32991 982E           B8                   0043  mov	ax,*$43
32992 9831           50                         push	ax
32993                                           ! Debug: list int = const $40 (used reg = )
32994 9832           B8                   0040  mov	ax,*$40
32995 9835           50                         push	ax
32996                                           ! Debug: func () void = write_byte+0 (used reg = )
32997 9836           E8         6DE5            call	_write_byte
32998 9839           83C4                   06  add	sp,*6
32999                                           !BCC_EOS
33000                                           ! 4733         write_byte(0x0040, 0x0044, return_status[2]);
33001                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33002 983C           8A46         EB            mov	al,-$15[bp]
33003 983F           30E4                       xor	ah,ah
33004 9841           50                         push	ax
33005                                           ! Debug: list int = const $44 (used reg = )
33006 9842           B8                   0044  mov	ax,*$44
33007 9845           50                         push	ax
33008                                           ! Debug: list int = const $40 (used reg = )
33009 9846           B8                   0040  mov	ax,*$40
33010 9849           50                         push	ax
33011                                           ! Debug: func () void = write_byte+0 (used reg = )
33012 984A           E8         6DD1            call	_write_byte
33013 984D           83C4                   06  add	sp,*6
33014                                           !BCC_EOS
33015                                           ! 4734         write_byte(0x0040, 0x0045, return_status[3]);
33016                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33017 9850           8A46         EC            mov	al,-$14[bp]
33018 9853           30E4                       xor	ah,ah
33019 9855           50                         push	ax
33020                                           ! Debug: list int = const $45 (used reg = )
33021 9856           B8                   0045  mov	ax,*$45
33022 9859           50                         push	ax
33023                                           ! Debug: list int = const $40 (used reg = )
33024 985A           B8                   0040  mov	ax,*$40
33025 985D           50                         push	ax
33026                                           ! Debug: func () void = write_byte+0 (used reg = )
33027 985E           E8         6DBD            call	_write_byte
33028 9861           83C4                   06  add	sp,*6
33029                                           !BCC_EOS
33030                                           ! 4735         write_byte(0x0040, 0x0046, return_status[4]);
33031                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33032 9864           8A46         ED            mov	al,-$13[bp]
33033 9867           30E4                       xor	ah,ah
33034 9869           50                         push	ax
33035                                           ! Debug: list int = const $46 (used reg = )
33036 986A           B8                   0046  mov	ax,*$46
33037 986D           50                         push	ax
33038                                           ! Debug: list int = const $40 (used reg = )
33039 986E           B8                   0040  mov	ax,*$40
33040 9871           50                         push	ax
33041                                           ! Debug: func () void = write_byte+0 (used reg = )
33042 9872           E8         6DA9            call	_write_byte
33043 9875           83C4                   06  add	sp,*6
33044                                           !BCC_EOS
33045                                           ! 4736         write_byte(0x0040, 0x0047, return_status[5]);
33046                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33047 9878           8A46         EE            mov	al,-$12[bp]
33048 987B           30E4                       xor	ah,ah
33049 987D           50                         push	ax
33050                                           ! Debug: list int = const $47 (used reg = )
33051 987E           B8                   0047  mov	ax,*$47
33052 9881           50                         push	ax
33053                                           ! Debug: list int = const $40 (used reg = )
33054 9882           B8                   0040  mov	ax,*$40
33055 9885           50                         push	ax
33056                                           ! Debug: func () void = write_byte+0 (used reg = )
33057 9886           E8         6D95            call	_write_byte
33058 9889           83C4                   06  add	sp,*6
33059                                           !BCC_EOS
33060                                           ! 4737         write_byte(0x0040, 0x0048, return_status[6]);
33061                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33062 988C           8A46         EF            mov	al,-$11[bp]
33063 988F           30E4                       xor	ah,ah
33064 9891           50                         push	ax
33065                                           ! Debug: list int = const $48 (used reg = )
33066 9892           B8                   0048  mov	ax,*$48
33067 9895           50                         push	ax
33068                                           ! Debug: list int = const $40 (used reg = )
33069 9896           B8                   0040  mov	ax,*$40
33070 9899           50                         push	ax
33071                                           ! Debug: func () void = write_byte+0 (used reg = )
33072 989A           E8         6D81            call	_write_byte
33073 989D           83C4                   06  add	sp,*6
33074                                           !BCC_EOS
33075                                           ! 4738         if ( (return_status[0] & 0xc0) != 0 ) {
33076                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33077 98A0           8A46         E9            mov	al,-$17[bp]
33078 98A3           24                     C0  and	al,#$C0
33079                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33080 98A5           84C0                       test	al,al
33081 98A7           74           2A            je  	.6C4
33082                       000098A9            .6C5:
33083                                           ! 4739           AX = ((AX & 0x00ff) | ((0x20) << 8));
33084                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33085 98A9           8A46         16            mov	al,$16[bp]
33086                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
33087 98AC           30E4                       xor	ah,ah
33088 98AE           0D                   2000  or	ax,#$2000
33089                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33090 98B1           8946         16            mov	$16[bp],ax
33091                                           !BCC_EOS
33092                                           ! 4740           set_diskette_ret_status(0x20);
33093                                           ! Debug: list int = const $20 (used reg = )
33094 98B4           B8                   0020  mov	ax,*$20
33095 98B7           50                         push	ax
33096                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33097 98B8           E8         0B9E            call	_set_diskette_ret_status
33098 98BB           44                         inc	sp
33099 98BC           44                         inc	sp
33100                                           !BCC_EOS
33101                                           ! 4741           AX = ((AX & 0xff00) | (0));
33102                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33103 98BD           8B46         16            mov	ax,$16[bp]
33104 98C0           30C0                       xor	al,al
33105                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33106 98C2           0C                     00  or	al,*0
33107                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33108 98C4           8946         16            mov	$16[bp],ax
33109                                           !BCC_EOS
33110                                           ! 4742           FLAGS |= 0x0001;
33111                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33112 98C7           8B46         1C            mov	ax,$1C[bp]
33113 98CA           0C                     01  or	al,*1
33114 98CC           8946         1C            mov	$1C[bp],ax
33115                                           !BCC_EOS
33116                                           ! 4743           return;
33117 98CF           89EC                       mov	sp,bp
33118 98D1           5D                         pop	bp
33119 98D2           C3                         ret
33120                                           !BCC_EOS
33121                                           ! 4744         }
33122                                           ! 4745         set_diskette_current_cyl(drive, track);
33123                       000098D3            .6C4:
33124                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33125 98D3           8A46         FD            mov	al,-3[bp]
33126 98D6           30E4                       xor	ah,ah
33127 98D8           50                         push	ax
33128                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33129 98D9           8A46         FF            mov	al,-1[bp]
33130 98DC           30E4                       xor	ah,ah
33131 98DE           50                         push	ax
33132                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33133 98DF           E8         0B8F            call	_set_diskette_current_cyl
33134 98E2           83C4                   04  add	sp,*4
33135                                           !BCC_EOS
33136                                           ! 4746         AX = ((AX & 0x00ff) | ((0x00) << 8));
33137                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33138 98E5           8A46         16            mov	al,$16[bp]
33139                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33140 98E8           0C                     00  or	al,*0
33141                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33142 98EA           30E4                       xor	ah,ah
33143 98EC           8946         16            mov	$16[bp],ax
33144                                           !BCC_EOS
33145                                           ! 4747         FLAGS &= 0xfffe;
33146                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33147 98EF           8B46         1C            mov	ax,$1C[bp]
33148 98F2           24                     FE  and	al,#$FE
33149 98F4           8946         1C            mov	$1C[bp],ax
33150                                           !BCC_EOS
33151                                           ! 4748         return;
33152 98F7           89EC                       mov	sp,bp
33153 98F9           5D                         pop	bp
33154 98FA           C3                         ret
33155                                           !BCC_EOS
33156                                           ! 4749       } else if (ah == 0x03) {
33157 98FB           E9         03D7            br 	.6C6
33158                       000098FE            .6B5:
33159                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
33160 98FE           8A46         E6            mov	al,-$1A[bp]
33161 9901           3C                     03  cmp	al,*3
33162 9903         0F85         03A6            bne 	.6C7
33163                       00009907            .6C8:
33164                                           ! 4750         page = (ES >> 12);
33165                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
33166 9907           8B46         06            mov	ax,6[bp]
33167 990A           88E0                       mov	al,ah
33168 990C           30E4                       xor	ah,ah
33169 990E           B1                     04  mov	cl,*4
33170 9910           D3E8                       shr	ax,cl
33171                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
33172 9912           8846         F3            mov	-$D[bp],al
33173                                           !BCC_EOS
33174                                           ! 4751         base_es = (ES << 4);
33175                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
33176 9915           8B46         06            mov	ax,6[bp]
33177 9918           B1                     04  mov	cl,*4
33178 991A           D3E0                       shl	ax,cl
33179                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
33180 991C           8946         F4            mov	-$C[bp],ax
33181                                           !BCC_EOS
33182                                           ! 4752         base_address = base_es + BX;
33183                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
33184 991F           8B46         F4            mov	ax,-$C[bp]
33185 9922           0346         10            add	ax,$10[bp]
33186                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33187 9925           8946         F8            mov	-8[bp],ax
33188                                           !BCC_EOS
33189                                           ! 4753         if ( base_address < base_es ) {
33190                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33191 9928           8B46         F8            mov	ax,-8[bp]
33192 992B           3B46         F4            cmp	ax,-$C[bp]
33193 992E           73           07            jae 	.6C9
33194                       00009930            .6CA:
33195                                           ! 4754           page++;
33196                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33197 9930           8A46         F3            mov	al,-$D[bp]
33198 9933           40                         inc	ax
33199 9934           8846         F3            mov	-$D[bp],al
33200                                           !BCC_EOS
33201                                           ! 4755         }
33202                                           ! 4756         base_count = (num_sectors * 512) - 1;
33203                       00009937            .6C9:
33204                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
33205 9937           8A46         FE            mov	al,-2[bp]
33206 993A           30E4                       xor	ah,ah
33207 993C           B9                   0200  mov	cx,#$200
33208 993F           F7E9                       imul	cx
33209                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33210                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33211 9941           48                         dec	ax
33212 9942           8946         F6            mov	-$A[bp],ax
33213                                           !BCC_EOS
33214                                           ! 4757         last_addr = base_address + base_count;
33215                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33216 9945           8B46         F8            mov	ax,-8[bp]
33217 9948           0346         F6            add	ax,-$A[bp]
33218                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33219 994B           8946         E2            mov	-$1E[bp],ax
33220                                           !BCC_EOS
33221                                           ! 4758         if (last_addr < base_address) {
33222                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33223 994E           8B46         E2            mov	ax,-$1E[bp]
33224 9951           3B46         F8            cmp	ax,-8[bp]
33225 9954           73           2A            jae 	.6CB
33226                       00009956            .6CC:
33227                                           ! 4759           AX = ((AX & 0x00ff) | ((0x09) << 8));
33228                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33229 9956           8A46         16            mov	al,$16[bp]
33230                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33231 9959           30E4                       xor	ah,ah
33232 995B           0D                   0900  or	ax,#$900
33233                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33234 995E           8946         16            mov	$16[bp],ax
33235                                           !BCC_EOS
33236                                           ! 4760           set_diskette_ret_status(0x09);
33237                                           ! Debug: list int = const 9 (used reg = )
33238 9961           B8                   0009  mov	ax,*9
33239 9964           50                         push	ax
33240                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33241 9965           E8         0AF1            call	_set_diskette_ret_status
33242 9968           44                         inc	sp
33243 9969           44                         inc	sp
33244                                           !BCC_EOS
33245                                           ! 4761           AX = ((AX & 0xff00) | (0));
33246                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33247 996A           8B46         16            mov	ax,$16[bp]
33248 996D           30C0                       xor	al,al
33249                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33250 996F           0C                     00  or	al,*0
33251                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33252 9971           8946         16            mov	$16[bp],ax
33253                                           !BCC_EOS
33254                                           ! 4762           FLAGS |= 0x0001;
33255                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33256 9974           8B46         1C            mov	ax,$1C[bp]
33257 9977           0C                     01  or	al,*1
33258 9979           8946         1C            mov	$1C[bp],ax
33259                                           !BCC_EOS
33260                                           ! 4763           return;
33261 997C           89EC                       mov	sp,bp
33262 997E           5D                         pop	bp
33263 997F           C3                         ret
33264                                           !BCC_EOS
33265                                           ! 4764         }
33266                                           ! 4765         ;
33267                       00009980            .6CB:
33268                                           !BCC_EOS
33269                                           ! 4766         outb(0x000a, 0x06);
33270                                           ! Debug: list int = const 6 (used reg = )
33271 9980           B8                   0006  mov	ax,*6
33272 9983           50                         push	ax
33273                                           ! Debug: list int = const $A (used reg = )
33274 9984           B8                   000A  mov	ax,*$A
33275 9987           50                         push	ax
33276                                           ! Debug: func () void = outb+0 (used reg = )
33277 9988           E8         6BCD            call	_outb
33278 998B           83C4                   04  add	sp,*4
33279                                           !BCC_EOS
33280                                           ! 4767         outb(0x000c, 0x00);
33281                                           ! Debug: list int = const 0 (used reg = )
33282 998E           31C0                       xor	ax,ax
33283 9990           50                         push	ax
33284                                           ! Debug: list int = const $C (used reg = )
33285 9991           B8                   000C  mov	ax,*$C
33286 9994           50                         push	ax
33287                                           ! Debug: func () void = outb+0 (used reg = )
33288 9995           E8         6BC0            call	_outb
33289 9998           83C4                   04  add	sp,*4
33290                                           !BCC_EOS
33291                                           ! 4768         outb(0x0004, base_address);
33292                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33293 999B           FF76         F8            push	-8[bp]
33294                                           ! Debug: list int = const 4 (used reg = )
33295 999E           B8                   0004  mov	ax,*4
33296 99A1           50                         push	ax
33297                                           ! Debug: func () void = outb+0 (used reg = )
33298 99A2           E8         6BB3            call	_outb
33299 99A5           83C4                   04  add	sp,*4
33300                                           !BCC_EOS
33301                                           ! 4769         outb(0x0004, base_address>>8);
33302                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33303 99A8           8B46         F8            mov	ax,-8[bp]
33304 99AB           88E0                       mov	al,ah
33305 99AD           30E4                       xor	ah,ah
33306                                           ! Debug: list unsigned int = ax+0 (used reg = )
33307 99AF           50                         push	ax
33308                                           ! Debug: list int = const 4 (used reg = )
33309 99B0           B8                   0004  mov	ax,*4
33310 99B3           50                         push	ax
33311                                           ! Debug: func () void = outb+0 (used reg = )
33312 99B4           E8         6BA1            call	_outb
33313 99B7           83C4                   04  add	sp,*4
33314                                           !BCC_EOS
33315                                           ! 4770         outb(0x000c, 0x00);
33316                                           ! Debug: list int = const 0 (used reg = )
33317 99BA           31C0                       xor	ax,ax
33318 99BC           50                         push	ax
33319                                           ! Debug: list int = const $C (used reg = )
33320 99BD           B8                   000C  mov	ax,*$C
33321 99C0           50                         push	ax
33322                                           ! Debug: func () void = outb+0 (used reg = )
33323 99C1           E8         6B94            call	_outb
33324 99C4           83C4                   04  add	sp,*4
33325                                           !BCC_EOS
33326                                           ! 4771         outb(0x0005, base_count);
33327                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33328 99C7           FF76         F6            push	-$A[bp]
33329                                           ! Debug: list int = const 5 (used reg = )
33330 99CA           B8                   0005  mov	ax,*5
33331 99CD           50                         push	ax
33332                                           ! Debug: func () void = outb+0 (used reg = )
33333 99CE           E8         6B87            call	_outb
33334 99D1           83C4                   04  add	sp,*4
33335                                           !BCC_EOS
33336                                           ! 4772         outb(0x0005, base_count>>8);
33337                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33338 99D4           8B46         F6            mov	ax,-$A[bp]
33339 99D7           88E0                       mov	al,ah
33340 99D9           30E4                       xor	ah,ah
33341                                           ! Debug: list unsigned int = ax+0 (used reg = )
33342 99DB           50                         push	ax
33343                                           ! Debug: list int = const 5 (used reg = )
33344 99DC           B8                   0005  mov	ax,*5
33345 99DF           50                         push	ax
33346                                           ! Debug: func () void = outb+0 (used reg = )
33347 99E0           E8         6B75            call	_outb
33348 99E3           83C4                   04  add	sp,*4
33349                                           !BCC_EOS
33350                                           ! 4773         mode_register = 0x4a;
33351                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33352 99E6           B0                     4A  mov	al,*$4A
33353 99E8           8846         F2            mov	-$E[bp],al
33354                                           !BCC_EOS
33355                                           ! 4774         outb(0x000b, mode_register
33356                                           ! 4774 );
33357                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33358 99EB           8A46         F2            mov	al,-$E[bp]
33359 99EE           30E4                       xor	ah,ah
33360 99F0           50                         push	ax
33361                                           ! Debug: list int = const $B (used reg = )
33362 99F1           B8                   000B  mov	ax,*$B
33363 99F4           50                         push	ax
33364                                           ! Debug: func () void = outb+0 (used reg = )
33365 99F5           E8         6B60            call	_outb
33366 99F8           83C4                   04  add	sp,*4
33367                                           !BCC_EOS
33368                                           ! 4775         outb(0x0081, page);
33369                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33370 99FB           8A46         F3            mov	al,-$D[bp]
33371 99FE           30E4                       xor	ah,ah
33372 9A00           50                         push	ax
33373                                           ! Debug: list int = const $81 (used reg = )
33374 9A01           B8                   0081  mov	ax,#$81
33375 9A04           50                         push	ax
33376                                           ! Debug: func () void = outb+0 (used reg = )
33377 9A05           E8         6B50            call	_outb
33378 9A08           83C4                   04  add	sp,*4
33379                                           !BCC_EOS
33380                                           ! 4776         ;
33381                                           !BCC_EOS
33382                                           ! 4777         outb(0x000a, 0x02);
33383                                           ! Debug: list int = const 2 (used reg = )
33384 9A0B           B8                   0002  mov	ax,*2
33385 9A0E           50                         push	ax
33386                                           ! Debug: list int = const $A (used reg = )
33387 9A0F           B8                   000A  mov	ax,*$A
33388 9A12           50                         push	ax
33389                                           ! Debug: func () void = outb+0 (used reg = )
33390 9A13           E8         6B42            call	_outb
33391 9A16           83C4                   04  add	sp,*4
33392                                           !BCC_EOS
33393                                           ! 4778         floppy_prepare_controller(drive);
33394                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33395 9A19           8A46         FF            mov	al,-1[bp]
33396 9A1C           30E4                       xor	ah,ah
33397 9A1E           50                         push	ax
33398                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33399 9A1F           E8         F55F            call	_floppy_prepare_controller
33400 9A22           44                         inc	sp
33401 9A23           44                         inc	sp
33402                                           !BCC_EOS
33403                                           ! 4779         outb(0x03f5, 0xc5);
33404                                           ! Debug: list int = const $C5 (used reg = )
33405 9A24           B8                   00C5  mov	ax,#$C5
33406 9A27           50                         push	ax
33407                                           ! Debug: list int = const $3F5 (used reg = )
33408 9A28           B8                   03F5  mov	ax,#$3F5
33409 9A2B           50                         push	ax
33410                                           ! Debug: func () void = outb+0 (used reg = )
33411 9A2C           E8         6B29            call	_outb
33412 9A2F           83C4                   04  add	sp,*4
33413                                           !BCC_EOS
33414                                           ! 4780         outb(0x03f5, (head << 2) | drive);
33415                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33416 9A32           8A46         FB            mov	al,-5[bp]
33417 9A35           30E4                       xor	ah,ah
33418 9A37           D1E0                       shl	ax,*1
33419 9A39           D1E0                       shl	ax,*1
33420                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33421 9A3B           0A46         FF            or	al,-1[bp]
33422                                           ! Debug: list unsigned int = ax+0 (used reg = )
33423 9A3E           50                         push	ax
33424                                           ! Debug: list int = const $3F5 (used reg = )
33425 9A3F           B8                   03F5  mov	ax,#$3F5
33426 9A42           50                         push	ax
33427                                           ! Debug: func () void = outb+0 (used reg = )
33428 9A43           E8         6B12            call	_outb
33429 9A46           83C4                   04  add	sp,*4
33430                                           !BCC_EOS
33431                                           ! 4781         outb(0x03f5, track);
33432                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33433 9A49           8A46         FD            mov	al,-3[bp]
33434 9A4C           30E4                       xor	ah,ah
33435 9A4E           50                         push	ax
33436                                           ! Debug: list int = const $3F5 (used reg = )
33437 9A4F           B8                   03F5  mov	ax,#$3F5
33438 9A52           50                         push	ax
33439                                           ! Debug: func () void = outb+0 (used reg = )
33440 9A53           E8         6B02            call	_outb
33441 9A56           83C4                   04  add	sp,*4
33442                                           !BCC_EOS
33443                                           ! 4782         outb(0x03f5, head);
33444                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
33445 9A59           8A46         FB            mov	al,-5[bp]
33446 9A5C           30E4                       xor	ah,ah
33447 9A5E           50                         push	ax
33448                                           ! Debug: list int = const $3F5 (used reg = )
33449 9A5F           B8                   03F5  mov	ax,#$3F5
33450 9A62           50                         push	ax
33451                                           ! Debug: func () void = outb+0 (used reg = )
33452 9A63           E8         6AF2            call	_outb
33453 9A66           83C4                   04  add	sp,*4
33454                                           !BCC_EOS
33455                                           ! 4783         outb(0x03f5, sector);
33456                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
33457 9A69           8A46         FC            mov	al,-4[bp]
33458 9A6C           30E4                       xor	ah,ah
33459 9A6E           50                         push	ax
33460                                           ! Debug: list int = const $3F5 (used reg = )
33461 9A6F           B8                   03F5  mov	ax,#$3F5
33462 9A72           50                         push	ax
33463                                           ! Debug: func () void = outb+0 (used reg = )
33464 9A73           E8         6AE2            call	_outb
33465 9A76           83C4                   04  add	sp,*4
33466                                           !BCC_EOS
33467                                           ! 4784         outb(0x03f5, 2);
33468                                           ! Debug: list int = const 2 (used reg = )
33469 9A79           B8                   0002  mov	ax,*2
33470 9A7C           50                         push	ax
33471                                           ! Debug: list int = const $3F5 (used reg = )
33472 9A7D           B8                   03F5  mov	ax,#$3F5
33473 9A80           50                         push	ax
33474                                           ! Debug: func () void = outb+0 (used reg = )
33475 9A81           E8         6AD4            call	_outb
33476 9A84           83C4                   04  add	sp,*4
33477                                           !BCC_EOS
33478                                           ! 4785         outb(0x03f5, sector + num_sectors - 1);
33479                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
33480 9A87           8A46         FC            mov	al,-4[bp]
33481 9A8A           30E4                       xor	ah,ah
33482 9A8C           0246         FE            add	al,-2[bp]
33483 9A8F           80D4                   00  adc	ah,*0
33484                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33485                                           ! Debug: list unsigned int = ax-1 (used reg = )
33486 9A92           48                         dec	ax
33487 9A93           50                         push	ax
33488                                           ! Debug: list int = const $3F5 (used reg = )
33489 9A94           B8                   03F5  mov	ax,#$3F5
33490 9A97           50                         push	ax
33491                                           ! Debug: func () void = outb+0 (used reg = )
33492 9A98           E8         6ABD            call	_outb
33493 9A9B           83C4                   04  add	sp,*4
33494                                           !BCC_EOS
33495                                           ! 4786         outb(0x03f5, 0);
33496                                           ! Debug: list int = const 0 (used reg = )
33497 9A9E           31C0                       xor	ax,ax
33498 9AA0           50                         push	ax
33499                                           ! Debug: list int = const $3F5 (used reg = )
33500 9AA1           B8                   03F5  mov	ax,#$3F5
33501 9AA4           50                         push	ax
33502                                           ! Debug: func () void = outb+0 (used reg = )
33503 9AA5           E8         6AB0            call	_outb
33504 9AA8           83C4                   04  add	sp,*4
33505                                           !BCC_EOS
33506                                           ! 4787         outb(0x03f5, 0xff);
33507                                           ! Debug: list int = const $FF (used reg = )
33508 9AAB           B8                   00FF  mov	ax,#$FF
33509 9AAE           50                         push	ax
33510                                           ! Debug: list int = const $3F5 (used reg = )
33511 9AAF           B8                   03F5  mov	ax,#$3F5
33512 9AB2           50                         push	ax
33513                                           ! Debug: func () void = outb+0 (used reg = )
33514 9AB3           E8         6AA2            call	_outb
33515 9AB6           83C4                   04  add	sp,*4
33516                                           !BCC_EOS
33517                                           ! 4788 #asm
33518                                           !BCC_EOS
33519                                           !BCC_ASM
33520                       0000002A            _int13_diskette_function.BP	set	$2A
33521                       0000000C            .int13_diskette_function.BP	set	$C
33522                       00000038            _int13_diskette_function.CS	set	$38
33523                       0000001A            .int13_diskette_function.CS	set	$1A
33524                       00000032            _int13_diskette_function.CX	set	$32
33525                       00000014            .int13_diskette_function.CX	set	$14
33526                       00000016            _int13_diskette_function.base_address	set	$16
33527                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33528                       00000026            _int13_diskette_function.DI	set	$26
33529                       00000008            .int13_diskette_function.DI	set	8
33530                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33531                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33532                       00000014            _int13_diskette_function.base_count	set	$14
33533                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33534                       0000001A            _int13_diskette_function.sector	set	$1A
33535                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33536                       00000022            _int13_diskette_function.DS	set	$22
33537                       00000004            .int13_diskette_function.DS	set	4
33538                       00000019            _int13_diskette_function.head	set	$19
33539                       FFFFFFFB            .int13_diskette_function.head	set	-5
33540                       0000002C            _int13_diskette_function.ELDX	set	$2C
33541                       0000000E            .int13_diskette_function.ELDX	set	$E
33542                       0000000E            _int13_diskette_function.dor	set	$E
33543                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33544                       00000030            _int13_diskette_function.DX	set	$30
33545                       00000012            .int13_diskette_function.DX	set	$12
33546                       00000007            _int13_diskette_function.return_status	set	7
33547                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33548                       00000002            _int13_diskette_function.es	set	2
33549                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33550                       00000010            _int13_diskette_function.mode_register	set	$10
33551                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33552                       00000024            _int13_diskette_function.ES	set	$24
33553                       00000006            .int13_diskette_function.ES	set	6
33554                       00000012            _int13_diskette_function.base_es	set	$12
33555                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33556                       0000001B            _int13_diskette_function.track	set	$1B
33557                       FFFFFFFD            .int13_diskette_function.track	set	-3
33558                       00000028            _int13_diskette_function.SI	set	$28
33559                       0000000A            .int13_diskette_function.SI	set	$A
33560                       00000006            _int13_diskette_function.drive_type	set	6
33561                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33562                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33563                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33564                       00000036            _int13_diskette_function.IP	set	$36
33565                       00000018            .int13_diskette_function.IP	set	$18
33566                       00000018            _int13_diskette_function.status	set	$18
33567                       FFFFFFFA            .int13_diskette_function.status	set	-6
33568                       00000034            _int13_diskette_function.AX	set	$34
33569                       00000016            .int13_diskette_function.AX	set	$16
33570                       0000000F            _int13_diskette_function.val8	set	$F
33571                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33572                       00000000            _int13_diskette_function.last_addr	set	0
33573                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33574                       00000011            _int13_diskette_function.page	set	$11
33575                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33576                       00000004            _int13_diskette_function.ah	set	4
33577                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33578                       0000001D            _int13_diskette_function.drive	set	$1D
33579                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33580                       00000005            _int13_diskette_function.num_floppies	set	5
33581                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33582                       0000002E            _int13_diskette_function.BX	set	$2E
33583                       00000010            .int13_diskette_function.BX	set	$10
33584 9AB9           FB                                 sti
33585                                           ! 4790 endasm
33586                                           !BCC_ENDASM
33587                                           !BCC_EOS
33588                                           ! 4791         do {
33589                       00009ABA            .6CF:
33590                                           ! 4792           val8 = read_byte(0x0040, 0x0040);
33591                                           ! Debug: list int = const $40 (used reg = )
33592 9ABA           B8                   0040  mov	ax,*$40
33593 9ABD           50                         push	ax
33594                                           ! Debug: list int = const $40 (used reg = )
33595 9ABE           B8                   0040  mov	ax,*$40
33596 9AC1           50                         push	ax
33597                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33598 9AC2           E8         6B33            call	_read_byte
33599 9AC5           83C4                   04  add	sp,*4
33600                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33601 9AC8           8846         F1            mov	-$F[bp],al
33602                                           !BCC_EOS
33603                                           ! 4793           if (val8 == 0) {
33604                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33605 9ACB           8A46         F1            mov	al,-$F[bp]
33606 9ACE           84C0                       test	al,al
33607 9AD0           75           2D            jne 	.6D0
33608                       00009AD2            .6D1:
33609                                           ! 4794             floppy_reset_controller();
33610                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33611 9AD2           E8         F45E            call	_floppy_reset_controller
33612                                           !BCC_EOS
33613                                           ! 4795             AX = ((AX & 0x00ff) | ((0x80) << 8));
33614                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33615 9AD5           8A46         16            mov	al,$16[bp]
33616                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33617 9AD8           30E4                       xor	ah,ah
33618 9ADA           0D                   8000  or	ax,#-$8000
33619                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33620 9ADD           8946         16            mov	$16[bp],ax
33621                                           !BCC_EOS
33622                                           ! 4796             set_diskette_ret_status(0x80);
33623                                           ! Debug: list int = const $80 (used reg = )
33624 9AE0           B8                   0080  mov	ax,#$80
33625 9AE3           50                         push	ax
33626                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33627 9AE4           E8         0972            call	_set_diskette_ret_status
33628 9AE7           44                         inc	sp
33629 9AE8           44                         inc	sp
33630                                           !BCC_EOS
33631                                           ! 4797             AX = ((AX & 0xff00) | (0));
33632                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33633 9AE9           8B46         16            mov	ax,$16[bp]
33634 9AEC           30C0                       xor	al,al
33635                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33636 9AEE           0C                     00  or	al,*0
33637                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33638 9AF0           8946         16            mov	$16[bp],ax
33639                                           !BCC_EOS
33640                                           ! 4798             FLAGS |= 0x0001;
33641                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33642 9AF3           8B46         1C            mov	ax,$1C[bp]
33643 9AF6           0C                     01  or	al,*1
33644 9AF8           8946         1C            mov	$1C[bp],ax
33645                                           !BCC_EOS
33646                                           ! 4799             return;
33647 9AFB           89EC                       mov	sp,bp
33648 9AFD           5D                         pop	bp
33649 9AFE           C3                         ret
33650                                           !BCC_EOS
33651                                           ! 4800           }
33652                                           ! 4801           val8 = (read_byte(0x0040, 0x003e) & 0x80);
33653                       00009AFF            .6D0:
33654                                           ! Debug: list int = const $3E (used reg = )
33655 9AFF           B8                   003E  mov	ax,*$3E
33656 9B02           50                         push	ax
33657                                           ! Debug: list int = const $40 (used reg = )
33658 9B03           B8                   0040  mov	ax,*$40
33659 9B06           50                         push	ax
33660                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33661 9B07           E8         6AEE            call	_read_byte
33662 9B0A           83C4                   04  add	sp,*4
33663                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33664 9B0D           24                     80  and	al,#$80
33665                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33666 9B0F           8846         F1            mov	-$F[bp],al
33667                                           !BCC_EOS
33668                                           ! 4802         } while ( val8 == 0 );
33669                       00009B12            .6CE:
33670                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33671 9B12           8A46         F1            mov	al,-$F[bp]
33672 9B15           84C0                       test	al,al
33673 9B17           74           A1            je 	.6CF
33674                       00009B19            .6D2:
33675                                           !BCC_EOS
33676                                           ! 4803         val8 = 0;
33677                       00009B19            .6CD:
33678                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33679 9B19           30C0                       xor	al,al
33680 9B1B           8846         F1            mov	-$F[bp],al
33681                                           !BCC_EOS
33682                                           ! 4804 #asm
33683                                           !BCC_EOS
33684                                           !BCC_ASM
33685                       0000002A            _int13_diskette_function.BP	set	$2A
33686                       0000000C            .int13_diskette_function.BP	set	$C
33687                       00000038            _int13_diskette_function.CS	set	$38
33688                       0000001A            .int13_diskette_function.CS	set	$1A
33689                       00000032            _int13_diskette_function.CX	set	$32
33690                       00000014            .int13_diskette_function.CX	set	$14
33691                       00000016            _int13_diskette_function.base_address	set	$16
33692                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33693                       00000026            _int13_diskette_function.DI	set	$26
33694                       00000008            .int13_diskette_function.DI	set	8
33695                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33696                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33697                       00000014            _int13_diskette_function.base_count	set	$14
33698                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33699                       0000001A            _int13_diskette_function.sector	set	$1A
33700                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33701                       00000022            _int13_diskette_function.DS	set	$22
33702                       00000004            .int13_diskette_function.DS	set	4
33703                       00000019            _int13_diskette_function.head	set	$19
33704                       FFFFFFFB            .int13_diskette_function.head	set	-5
33705                       0000002C            _int13_diskette_function.ELDX	set	$2C
33706                       0000000E            .int13_diskette_function.ELDX	set	$E
33707                       0000000E            _int13_diskette_function.dor	set	$E
33708                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33709                       00000030            _int13_diskette_function.DX	set	$30
33710                       00000012            .int13_diskette_function.DX	set	$12
33711                       00000007            _int13_diskette_function.return_status	set	7
33712                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33713                       00000002            _int13_diskette_function.es	set	2
33714                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33715                       00000010            _int13_diskette_function.mode_register	set	$10
33716                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33717                       00000024            _int13_diskette_function.ES	set	$24
33718                       00000006            .int13_diskette_function.ES	set	6
33719                       00000012            _int13_diskette_function.base_es	set	$12
33720                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33721                       0000001B            _int13_diskette_function.track	set	$1B
33722                       FFFFFFFD            .int13_diskette_function.track	set	-3
33723                       00000028            _int13_diskette_function.SI	set	$28
33724                       0000000A            .int13_diskette_function.SI	set	$A
33725                       00000006            _int13_diskette_function.drive_type	set	6
33726                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33727                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33728                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33729                       00000036            _int13_diskette_function.IP	set	$36
33730                       00000018            .int13_diskette_function.IP	set	$18
33731                       00000018            _int13_diskette_function.status	set	$18
33732                       FFFFFFFA            .int13_diskette_function.status	set	-6
33733                       00000034            _int13_diskette_function.AX	set	$34
33734                       00000016            .int13_diskette_function.AX	set	$16
33735                       0000000F            _int13_diskette_function.val8	set	$F
33736                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33737                       00000000            _int13_diskette_function.last_addr	set	0
33738                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33739                       00000011            _int13_diskette_function.page	set	$11
33740                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33741                       00000004            _int13_diskette_function.ah	set	4
33742                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33743                       0000001D            _int13_diskette_function.drive	set	$1D
33744                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33745                       00000005            _int13_diskette_function.num_floppies	set	5
33746                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33747                       0000002E            _int13_diskette_function.BX	set	$2E
33748                       00000010            .int13_diskette_function.BX	set	$10
33749 9B1E           FA                                 cli
33750                                           ! 4806 endasm
33751                                           !BCC_ENDASM
33752                                           !BCC_EOS
33753                                           ! 4807         val8 = read_byte(0x0040, 0x003e);
33754                                           ! Debug: list int = const $3E (used reg = )
33755 9B1F           B8                   003E  mov	ax,*$3E
33756 9B22           50                         push	ax
33757                                           ! Debug: list int = const $40 (used reg = )
33758 9B23           B8                   0040  mov	ax,*$40
33759 9B26           50                         push	ax
33760                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33761 9B27           E8         6ACE            call	_read_byte
33762 9B2A           83C4                   04  add	sp,*4
33763                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33764 9B2D           8846         F1            mov	-$F[bp],al
33765                                           !BCC_EOS
33766                                           ! 4808         val8 &= 0x7f;
33767                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33768 9B30           8A46         F1            mov	al,-$F[bp]
33769 9B33           24                     7F  and	al,*$7F
33770 9B35           8846         F1            mov	-$F[bp],al
33771                                           !BCC_EOS
33772                                           ! 4809         write_byte(0x0040, 0x003e, val8);
33773                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33774 9B38           8A46         F1            mov	al,-$F[bp]
33775 9B3B           30E4                       xor	ah,ah
33776 9B3D           50                         push	ax
33777                                           ! Debug: list int = const $3E (used reg = )
33778 9B3E           B8                   003E  mov	ax,*$3E
33779 9B41           50                         push	ax
33780                                           ! Debug: list int = const $40 (used reg = )
33781 9B42           B8                   0040  mov	ax,*$40
33782 9B45           50                         push	ax
33783                                           ! Debug: func () void = write_byte+0 (used reg = )
33784 9B46           E8         6AD5            call	_write_byte
33785 9B49           83C4                   06  add	sp,*6
33786                                           !BCC_EOS
33787                                           ! 4810         val8 = inb(0x3f4);
33788                                           ! Debug: list int = const $3F4 (used reg = )
33789 9B4C           B8                   03F4  mov	ax,#$3F4
33790 9B4F           50                         push	ax
33791                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33792 9B50           E8         69EF            call	_inb
33793 9B53           44                         inc	sp
33794 9B54           44                         inc	sp
33795                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33796 9B55           8846         F1            mov	-$F[bp],al
33797                                           !BCC_EOS
33798                                           ! 4811         if ( (val8 & 0xc0) != 0xc0 )
33799                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
33800 9B58           8A46         F1            mov	al,-$F[bp]
33801 9B5B           24                     C0  and	al,#$C0
33802                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
33803 9B5D           3C                     C0  cmp	al,#$C0
33804 9B5F           74           0E            je  	.6D3
33805                       00009B61            .6D4:
33806                                           ! 4812           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
33807                                           ! Debug: list * char = .6D5+0 (used reg = )
33808 9B61           BB                   CDDD  mov	bx,#.6D5
33809 9B64           53                         push	bx
33810                                           ! Debug: list int = const 7 (used reg = )
33811 9B65           B8                   0007  mov	ax,*7
33812 9B68           50                         push	ax
33813                                           ! Debug: func () void = bios_printf+0 (used reg = )
33814 9B69           E8         6E3B            call	_bios_printf
33815 9B6C           83C4                   04  add	sp,*4
33816                                           !BCC_EOS
33817                                           ! 4813         return_status[0] = inb(0x3f5);
33818                       00009B6F            .6D3:
33819                                           ! Debug: list int = const $3F5 (used reg = )
33820 9B6F           B8                   03F5  mov	ax,#$3F5
33821 9B72           50                         push	ax
33822                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33823 9B73           E8         69CC            call	_inb
33824 9B76           44                         inc	sp
33825 9B77           44                         inc	sp
33826                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
33827 9B78           8846         E9            mov	-$17[bp],al
33828                                           !BCC_EOS
33829                                           ! 4814         return_status[1] = inb(0x3f5);
33830                                           ! Debug: list int = const $3F5 (used reg = )
33831 9B7B           B8                   03F5  mov	ax,#$3F5
33832 9B7E           50                         push	ax
33833                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33834 9B7F           E8         69C0            call	_inb
33835 9B82           44                         inc	sp
33836 9B83           44                         inc	sp
33837                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
33838 9B84           8846         EA            mov	-$16[bp],al
33839                                           !BCC_EOS
33840                                           ! 4815         return_status[2] = inb(0x3f5);
33841                                           ! Debug: list int = const $3F5 (used reg = )
33842 9B87           B8                   03F5  mov	ax,#$3F5
33843 9B8A           50                         push	ax
33844                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33845 9B8B           E8         69B4            call	_inb
33846 9B8E           44                         inc	sp
33847 9B8F           44                         inc	sp
33848                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
33849 9B90           8846         EB            mov	-$15[bp],al
33850                                           !BCC_EOS
33851                                           ! 4816         return_status[3] = inb(0x3f5);
33852                                           ! Debug: list int = const $3F5 (used reg = )
33853 9B93           B8                   03F5  mov	ax,#$3F5
33854 9B96           50                         push	ax
33855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33856 9B97           E8         69A8            call	_inb
33857 9B9A           44                         inc	sp
33858 9B9B           44                         inc	sp
33859                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
33860 9B9C           8846         EC            mov	-$14[bp],al
33861                                           !BCC_EOS
33862                                           ! 4817         return_status[4] = inb(0x3f5);
33863                                           ! Debug: list int = const $3F5 (used reg = )
33864 9B9F           B8                   03F5  mov	ax,#$3F5
33865 9BA2           50                         push	ax
33866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33867 9BA3           E8         699C            call	_inb
33868 9BA6           44                         inc	sp
33869 9BA7           44                         inc	sp
33870                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
33871 9BA8           8846         ED            mov	-$13[bp],al
33872                                           !BCC_EOS
33873                                           ! 4818         return_status[5] = inb(0x3f5);
33874                                           ! Debug: list int = const $3F5 (used reg = )
33875 9BAB           B8                   03F5  mov	ax,#$3F5
33876 9BAE           50                         push	ax
33877                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33878 9BAF           E8         6990            call	_inb
33879 9BB2           44                         inc	sp
33880 9BB3           44                         inc	sp
33881                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33882 9BB4           8846         EE            mov	-$12[bp],al
33883                                           !BCC_EOS
33884                                           ! 4819         return_status[6] = inb(0x3f5);
33885                                           ! Debug: list int = const $3F5 (used reg = )
33886 9BB7           B8                   03F5  mov	ax,#$3F5
33887 9BBA           50                         push	ax
33888                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33889 9BBB           E8         6984            call	_inb
33890 9BBE           44                         inc	sp
33891 9BBF           44                         inc	sp
33892                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33893 9BC0           8846         EF            mov	-$11[bp],al
33894                                           !BCC_EOS
33895                                           ! 4820         write_byte(0x0040, 0x0042, return_status[0]);
33896                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33897 9BC3           8A46         E9            mov	al,-$17[bp]
33898 9BC6           30E4                       xor	ah,ah
33899 9BC8           50                         push	ax
33900                                           ! Debug: list int = const $42 (used reg = )
33901 9BC9           B8                   0042  mov	ax,*$42
33902 9BCC           50                         push	ax
33903                                           ! Debug: list int = const $40 (used reg = )
33904 9BCD           B8                   0040  mov	ax,*$40
33905 9BD0           50                         push	ax
33906                                           ! Debug: func () void = write_byte+0 (used reg = )
33907 9BD1           E8         6A4A            call	_write_byte
33908 9BD4           83C4                   06  add	sp,*6
33909                                           !BCC_EOS
33910                                           ! 4821         write_byte(0x0040, 0x0043, return_status[1]);
33911                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33912 9BD7           8A46         EA            mov	al,-$16[bp]
33913 9BDA           30E4                       xor	ah,ah
33914 9BDC           50                         push	ax
33915                                           ! Debug: list int = const $43 (used reg = )
33916 9BDD           B8                   0043  mov	ax,*$43
33917 9BE0           50                         push	ax
33918                                           ! Debug: list int = const $40 (used reg = )
33919 9BE1           B8                   0040  mov	ax,*$40
33920 9BE4           50                         push	ax
33921                                           ! Debug: func () void = write_byte+0 (used reg = )
33922 9BE5           E8         6A36            call	_write_byte
33923 9BE8           83C4                   06  add	sp,*6
33924                                           !BCC_EOS
33925                                           ! 4822         write_byte(0x0040, 0x0044, return_status[2]);
33926                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33927 9BEB           8A46         EB            mov	al,-$15[bp]
33928 9BEE           30E4                       xor	ah,ah
33929 9BF0           50                         push	ax
33930                                           ! Debug: list int = const $44 (used reg = )
33931 9BF1           B8                   0044  mov	ax,*$44
33932 9BF4           50                         push	ax
33933                                           ! Debug: list int = const $40 (used reg = )
33934 9BF5           B8                   0040  mov	ax,*$40
33935 9BF8           50                         push	ax
33936                                           ! Debug: func () void = write_byte+0 (used reg = )
33937 9BF9           E8         6A22            call	_write_byte
33938 9BFC           83C4                   06  add	sp,*6
33939                                           !BCC_EOS
33940                                           ! 4823         write_byte(0x0040, 0x0045, return_status[3]);
33941                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33942 9BFF           8A46         EC            mov	al,-$14[bp]
33943 9C02           30E4                       xor	ah,ah
33944 9C04           50                         push	ax
33945                                           ! Debug: list int = const $45 (used reg = )
33946 9C05           B8                   0045  mov	ax,*$45
33947 9C08           50                         push	ax
33948                                           ! Debug: list int = const $40 (used reg = )
33949 9C09           B8                   0040  mov	ax,*$40
33950 9C0C           50                         push	ax
33951                                           ! Debug: func () void = write_byte+0 (used reg = )
33952 9C0D           E8         6A0E            call	_write_byte
33953 9C10           83C4                   06  add	sp,*6
33954                                           !BCC_EOS
33955                                           ! 4824         write_byte(0x0040, 0x0046, return_status[4]);
33956                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33957 9C13           8A46         ED            mov	al,-$13[bp]
33958 9C16           30E4                       xor	ah,ah
33959 9C18           50                         push	ax
33960                                           ! Debug: list int = const $46 (used reg = )
33961 9C19           B8                   0046  mov	ax,*$46
33962 9C1C           50                         push	ax
33963                                           ! Debug: list int = const $40 (used reg = )
33964 9C1D           B8                   0040  mov	ax,*$40
33965 9C20           50                         push	ax
33966                                           ! Debug: func () void = write_byte+0 (used reg = )
33967 9C21           E8         69FA            call	_write_byte
33968 9C24           83C4                   06  add	sp,*6
33969                                           !BCC_EOS
33970                                           ! 4825         write_byte(0x0040, 0x0047, return_status[5]);
33971                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33972 9C27           8A46         EE            mov	al,-$12[bp]
33973 9C2A           30E4                       xor	ah,ah
33974 9C2C           50                         push	ax
33975                                           ! Debug: list int = const $47 (used reg = )
33976 9C2D           B8                   0047  mov	ax,*$47
33977 9C30           50                         push	ax
33978                                           ! Debug: list int = const $40 (used reg = )
33979 9C31           B8                   0040  mov	ax,*$40
33980 9C34           50                         push	ax
33981                                           ! Debug: func () void = write_byte+0 (used reg = )
33982 9C35           E8         69E6            call	_write_byte
33983 9C38           83C4                   06  add	sp,*6
33984                                           !BCC_EOS
33985                                           ! 4826         write_byte(0x0040, 0x0048, return_status[6]);
33986                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33987 9C3B           8A46         EF            mov	al,-$11[bp]
33988 9C3E           30E4                       xor	ah,ah
33989 9C40           50                         push	ax
33990                                           ! Debug: list int = const $48 (used reg = )
33991 9C41           B8                   0048  mov	ax,*$48
33992 9C44           50                         push	ax
33993                                           ! Debug: list int = const $40 (used reg = )
33994 9C45           B8                   0040  mov	ax,*$40
33995 9C48           50                         push	ax
33996                                           ! Debug: func () void = write_byte+0 (used reg = )
33997 9C49           E8         69D2            call	_write_byte
33998 9C4C           83C4                   06  add	sp,*6
33999                                           !BCC_EOS
34000                                           ! 4827         if ( (return_status[0] & 0xc0) != 0 ) {
34001                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
34002 9C4F           8A46         E9            mov	al,-$17[bp]
34003 9C52           24                     C0  and	al,#$C0
34004                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34005 9C54           84C0                       test	al,al
34006 9C56           74           2B            je  	.6D6
34007                       00009C58            .6D7:
34008                                           ! 4828           if ( (return_status[1] & 0x02) != 0 ) {
34009                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
34010 9C58           8A46         EA            mov	al,-$16[bp]
34011 9C5B           24                     02  and	al,*2
34012                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34013 9C5D           84C0                       test	al,al
34014 9C5F           74           14            je  	.6D8
34015                       00009C61            .6D9:
34016                                           ! 4829             AX = 0x0300;
34017                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34018 9C61           B8                   0300  mov	ax,#$300
34019 9C64           8946         16            mov	$16[bp],ax
34020                                           !BCC_EOS
34021                                           ! 4830             FLAGS |= 0x0001;
34022                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34023 9C67           8B46         1C            mov	ax,$1C[bp]
34024 9C6A           0C                     01  or	al,*1
34025 9C6C           8946         1C            mov	$1C[bp],ax
34026                                           !BCC_EOS
34027                                           ! 4831             return;
34028 9C6F           89EC                       mov	sp,bp
34029 9C71           5D                         pop	bp
34030 9C72           C3                         ret
34031                                           !BCC_EOS
34032                                           ! 4832           } else {
34033 9C73           EB           0E            jmp .6DA
34034                       00009C75            .6D8:
34035                                           ! 4833             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
34036                                           ! Debug: list * char = .6DB+0 (used reg = )
34037 9C75           BB                   CDB8  mov	bx,#.6DB
34038 9C78           53                         push	bx
34039                                           ! Debug: list int = const 7 (used reg = )
34040 9C79           B8                   0007  mov	ax,*7
34041 9C7C           50                         push	ax
34042                                           ! Debug: func () void = bios_printf+0 (used reg = )
34043 9C7D           E8         6D27            call	_bios_printf
34044 9C80           83C4                   04  add	sp,*4
34045                                           !BCC_EOS
34046                                           ! 4834           }
34047                                           ! 4835         }
34048                                           ! 4835 
34049                       00009C83            .6DA:
34050                                           ! 4836         set_diskette_current_cyl(drive, track);
34051                       00009C83            .6D6:
34052                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
34053 9C83           8A46         FD            mov	al,-3[bp]
34054 9C86           30E4                       xor	ah,ah
34055 9C88           50                         push	ax
34056                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34057 9C89           8A46         FF            mov	al,-1[bp]
34058 9C8C           30E4                       xor	ah,ah
34059 9C8E           50                         push	ax
34060                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34061 9C8F           E8         07DF            call	_set_diskette_current_cyl
34062 9C92           83C4                   04  add	sp,*4
34063                                           !BCC_EOS
34064                                           ! 4837         AX = ((AX & 0x00ff) | ((0x00) << 8));
34065                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34066 9C95           8A46         16            mov	al,$16[bp]
34067                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34068 9C98           0C                     00  or	al,*0
34069                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34070 9C9A           30E4                       xor	ah,ah
34071 9C9C           8946         16            mov	$16[bp],ax
34072                                           !BCC_EOS
34073                                           ! 4838         FLAGS &= 0xfffe;
34074                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34075 9C9F           8B46         1C            mov	ax,$1C[bp]
34076 9CA2           24                     FE  and	al,#$FE
34077 9CA4           8946         1C            mov	$1C[bp],ax
34078                                           !BCC_EOS
34079                                           ! 4839         return;
34080 9CA7           89EC                       mov	sp,bp
34081 9CA9           5D                         pop	bp
34082 9CAA           C3                         ret
34083                                           !BCC_EOS
34084                                           ! 4840       } else {
34085 9CAB           EB           28            jmp .6DC
34086                       00009CAD            .6C7:
34087                                           ! 4841         set_diskette_current_cyl(drive, track);
34088                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
34089 9CAD           8A46         FD            mov	al,-3[bp]
34090 9CB0           30E4                       xor	ah,ah
34091 9CB2           50                         push	ax
34092                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34093 9CB3           8A46         FF            mov	al,-1[bp]
34094 9CB6           30E4                       xor	ah,ah
34095 9CB8           50                         push	ax
34096                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34097 9CB9           E8         07B5            call	_set_diskette_current_cyl
34098 9CBC           83C4                   04  add	sp,*4
34099                                           !BCC_EOS
34100                                           ! 4842         FLAGS &= 0xfffe;
34101                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34102 9CBF           8B46         1C            mov	ax,$1C[bp]
34103 9CC2           24                     FE  and	al,#$FE
34104 9CC4           8946         1C            mov	$1C[bp],ax
34105                                           !BCC_EOS
34106                                           ! 4843         AX = ((AX & 0x00ff) | ((0x00) << 8));
34107                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34108 9CC7           8A46         16            mov	al,$16[bp]
34109                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34110 9CCA           0C                     00  or	al,*0
34111                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34112 9CCC           30E4                       xor	ah,ah
34113 9CCE           8946         16            mov	$16[bp],ax
34114                                           !BCC_EOS
34115                                           ! 4844         return;
34116 9CD1           89EC                       mov	sp,bp
34117 9CD3           5D                         pop	bp
34118 9CD4           C3                         ret
34119                                           !BCC_EOS
34120                                           ! 4845       }
34121                                           ! 4846       break;
34122                       00009CD5            .6DC:
34123                       00009CD5            .6C6:
34124 9CD5           E9         077D            br 	.697
34125                                           !BCC_EOS
34126                                           ! 4847     case 0x05:
34127                                           ! 4848 ;
34128                       00009CD8            .6DD:
34129                                           !BCC_EOS
34130                                           ! 4849       num_sectors = ( AX & 0x00ff );
34131                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34132 9CD8           8A46         16            mov	al,$16[bp]
34133                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
34134 9CDB           8846         FE            mov	-2[bp],al
34135                                           !BCC_EOS
34136                                           ! 4850       track = ( CX >> 8 );
34137                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
34138 9CDE           8B46         14            mov	ax,$14[bp]
34139 9CE1           88E0                       mov	al,ah
34140 9CE3           30E4                       xor	ah,ah
34141                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
34142 9CE5           8846         FD            mov	-3[bp],al
34143                                           !BCC_EOS
34144                                           ! 4851       head = ( DX >> 8 );
34145                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
34146 9CE8           8B46         12            mov	ax,$12[bp]
34147 9CEB           88E0                       mov	al,ah
34148 9CED           30E4                       xor	ah,ah
34149                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
34150 9CEF           8846         FB            mov	-5[bp],al
34151                                           !BCC_EOS
34152                                           ! 4852       drive = ( ELDX & 0x00ff );
34153                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34154 9CF2           8A46         0E            mov	al,$E[bp]
34155                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34156 9CF5           8846         FF            mov	-1[bp],al
34157                                           !BCC_EOS
34158                                           ! 4853       if ((drive > 1) || (head > 1) || (track > 79) ||
34159                                           ! 4854           (num_sectors == 0) || (num_sectors > 18)) {
34160                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34161 9CF8           8A46         FF            mov	al,-1[bp]
34162 9CFB           3C                     01  cmp	al,*1
34163 9CFD           77           1C            ja  	.6DF
34164                       00009CFF            .6E3:
34165                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
34166 9CFF           8A46         FB            mov	al,-5[bp]
34167 9D02           3C                     01  cmp	al,*1
34168 9D04           77           15            ja  	.6DF
34169                       00009D06            .6E2:
34170                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
34171 9D06           8A46         FD            mov	al,-3[bp]
34172 9D09           3C                     4F  cmp	al,*$4F
34173 9D0B           77           0E            ja  	.6DF
34174                       00009D0D            .6E1:
34175                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
34176 9D0D           8A46         FE            mov	al,-2[bp]
34177 9D10           84C0                       test	al,al
34178 9D12           74           07            je  	.6DF
34179                       00009D14            .6E0:
34180                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
34181 9D14           8A46         FE            mov	al,-2[bp]
34182 9D17           3C                     12  cmp	al,*$12
34183 9D19           76           1C            jbe 	.6DE
34184                       00009D1B            .6DF:
34185                                           ! 4855         AX = ((AX & 0x00ff) | ((1) << 8));
34186                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34187 9D1B           8A46         16            mov	al,$16[bp]
34188                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34189 9D1E           30E4                       xor	ah,ah
34190 9D20           0D                   0100  or	ax,#$100
34191                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34192 9D23           8946         16            mov	$16[bp],ax
34193                                           !BCC_EOS
34194                                           ! 4856         set_diskette_ret_status(1);
34195                                           ! Debug: list int = const 1 (used reg = )
34196 9D26           B8                   0001  mov	ax,*1
34197 9D29           50                         push	ax
34198                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34199 9D2A           E8         072C            call	_set_diskette_ret_status
34200 9D2D           44                         inc	sp
34201 9D2E           44                         inc	sp
34202                                           !BCC_EOS
34203                                           ! 4857         FLAGS |= 0x0001;
34204                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34205 9D2F           8B46         1C            mov	ax,$1C[bp]
34206 9D32           0C                     01  or	al,*1
34207 9D34           8946         1C            mov	$1C[bp],ax
34208                                           !BCC_EOS
34209                                           ! 4858       }
34210                                           ! 4859       if (floppy_drive_exists(drive) == 0) {
34211                       00009D37            .6DE:
34212                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34213 9D37           8A46         FF            mov	al,-1[bp]
34214 9D3A           30E4                       xor	ah,ah
34215 9D3C           50                         push	ax
34216                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
34217 9D3D           E8         F5B5            call	_floppy_drive_exists
34218 9D40           44                         inc	sp
34219 9D41           44                         inc	sp
34220                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34221 9D42           85C0                       test	ax,ax
34222 9D44           75           20            jne 	.6E4
34223                       00009D46            .6E5:
34224                                           ! 4860         AX = ((AX & 0x00ff) | ((0x80) << 8));
34225                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34226 9D46           8A46         16            mov	al,$16[bp]
34227                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34228 9D49           30E4                       xor	ah,ah
34229 9D4B           0D                   8000  or	ax,#-$8000
34230                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34231 9D4E           8946         16            mov	$16[bp],ax
34232                                           !BCC_EOS
34233                                           ! 4861         set_diskette_ret_status(0x80);
34234                                           ! Debug: list int = const $80 (used reg = )
34235 9D51           B8                   0080  mov	ax,#$80
34236 9D54           50                         push	ax
34237                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34238 9D55           E8         0701            call	_set_diskette_ret_status
34239 9D58           44                         inc	sp
34240 9D59           44                         inc	sp
34241                                           !BCC_EOS
34242                                           ! 4862         FLAGS |= 0x0001;
34243                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34244 9D5A           8B46         1C            mov	ax,$1C[bp]
34245 9D5D           0C                     01  or	al,*1
34246 9D5F           8946         1C            mov	$1C[bp],ax
34247                                           !BCC_EOS
34248                                           ! 4863         return;
34249 9D62           89EC                       mov	sp,bp
34250 9D64           5D                         pop	bp
34251 9D65           C3                         ret
34252                                           !BCC_EOS
34253                                           ! 4864       }
34254                                           ! 4865       if (floppy_media_known(drive) == 0) {
34255                       00009D66            .6E4:
34256                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34257 9D66           8A46         FF            mov	al,-1[bp]
34258 9D69           30E4                       xor	ah,ah
34259 9D6B           50                         push	ax
34260                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
34261 9D6C           E8         F2F1            call	_floppy_media_known
34262 9D6F           44                         inc	sp
34263 9D70           44                         inc	sp
34264                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34265 9D71           85C0                       test	ax,ax
34266 9D73           75           39            jne 	.6E6
34267                       00009D75            .6E7:
34268                                           ! 4866         if (floppy_media_sense(drive) == 0) {
34269                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34270 9D75           8A46         FF            mov	al,-1[bp]
34271 9D78           30E4                       xor	ah,ah
34272 9D7A           50                         push	ax
34273                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
34274 9D7B           E8         F365            call	_floppy_media_sense
34275 9D7E           44                         inc	sp
34276 9D7F           44                         inc	sp
34277                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34278 9D80           85C0                       test	ax,ax
34279 9D82           75           2A            jne 	.6E8
34280                       00009D84            .6E9:
34281                                           ! 4867           AX = ((AX & 0x00ff) | ((0x0C) << 8));
34282                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34283 9D84           8A46         16            mov	al,$16[bp]
34284                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
34285 9D87           30E4                       xor	ah,ah
34286 9D89           0D                   0C00  or	ax,#$C00
34287                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34288 9D8C           8946         16            mov	$16[bp],ax
34289                                           !BCC_EOS
34290                                           ! 4868           set_diskette_ret_status(0x0C);
34291                                           ! Debug: list int = const $C (used reg = )
34292 9D8F           B8                   000C  mov	ax,*$C
34293 9D92           50                         push	ax
34294                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34295 9D93           E8         06C3            call	_set_diskette_ret_status
34296 9D96           44                         inc	sp
34297 9D97           44                         inc	sp
34298                                           !BCC_EOS
34299                                           ! 4869           AX = ((AX & 0xff00) | (0));
34300                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34301 9D98           8B46         16            mov	ax,$16[bp]
34302 9D9B           30C0                       xor	al,al
34303                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34304 9D9D           0C                     00  or	al,*0
34305                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34306 9D9F           8946         16            mov	$16[bp],ax
34307                                           !BCC_EOS
34308                                           ! 4870           FLAGS |= 0x0001;
34309                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34310 9DA2           8B46         1C            mov	ax,$1C[bp]
34311 9DA5           0C                     01  or	al,*1
34312 9DA7           8946         1C            mov	$1C[bp],ax
34313                                           !BCC_EOS
34314                                           ! 4871           return;
34315 9DAA           89EC                       mov	sp,bp
34316 9DAC           5D                         pop	bp
34317 9DAD           C3                         ret
34318                                           !BCC_EOS
34319                                           ! 4872         }
34320                                           ! 4873       }
34321                       00009DAE            .6E8:
34322                                           ! 4874       page = (ES >> 12);
34323                       00009DAE            .6E6:
34324                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
34325 9DAE           8B46         06            mov	ax,6[bp]
34326 9DB1           88E0                       mov	al,ah
34327 9DB3           30E4                       xor	ah,ah
34328 9DB5           B1                     04  mov	cl,*4
34329 9DB7           D3E8                       shr	ax,cl
34330                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
34331 9DB9           8846         F3            mov	-$D[bp],al
34332                                           !BCC_EOS
34333                                           ! 4875       base_es = (ES << 4);
34334                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
34335 9DBC           8B46         06            mov	ax,6[bp]
34336 9DBF           B1                     04  mov	cl,*4
34337 9DC1           D3E0                       shl	ax,cl
34338                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
34339 9DC3           8946         F4            mov	-$C[bp],ax
34340                                           !BCC_EOS
34341                                           ! 4876       base_address = base_es + BX;
34342                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
34343 9DC6           8B46         F4            mov	ax,-$C[bp]
34344 9DC9           0346         10            add	ax,$10[bp]
34345                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
34346 9DCC           8946         F8            mov	-8[bp],ax
34347                                           !BCC_EOS
34348                                           ! 4877       if ( base_address < base_es ) {
34349                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
34350 9DCF           8B46         F8            mov	ax,-8[bp]
34351 9DD2           3B46         F4            cmp	ax,-$C[bp]
34352 9DD5           73           07            jae 	.6EA
34353                       00009DD7            .6EB:
34354                                           ! 4878         page++;
34355                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
34356 9DD7           8A46         F3            mov	al,-$D[bp]
34357 9DDA           40                         inc	ax
34358 9DDB           8846         F3            mov	-$D[bp],al
34359                                           !BCC_EOS
34360                                           ! 4879       }
34361                                           ! 4880       base_count = (num_sectors * 4) - 1;
34362                       00009DDE            .6EA:
34363                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
34364 9DDE           8A46         FE            mov	al,-2[bp]
34365 9DE1           30E4                       xor	ah,ah
34366 9DE3           D1E0                       shl	ax,*1
34367 9DE5           D1E0                       shl	ax,*1
34368                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
34369                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
34370 9DE7           48                         dec	ax
34371 9DE8           8946         F6            mov	-$A[bp],ax
34372                                           !BCC_EOS
34373                                           ! 4881       last_addr = base_address + base_count;
34374                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
34375 9DEB           8B46         F8            mov	ax,-8[bp]
34376 9DEE           0346         F6            add	ax,-$A[bp]
34377                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
34378 9DF1           8946         E2            mov	-$1E[bp],ax
34379                                           !BCC_EOS
34380                                           ! 4882       if (last_addr < base_address) {
34381                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
34382 9DF4           8B46         E2            mov	ax,-$1E[bp]
34383 9DF7           3B46         F8            cmp	ax,-8[bp]
34384 9DFA           73           2A            jae 	.6EC
34385                       00009DFC            .6ED:
34386                                           ! 4883         AX = ((AX & 0x00ff) | ((0x09) << 8));
34387                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34388 9DFC           8A46         16            mov	al,$16[bp]
34389                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
34390 9DFF           30E4                       xor	ah,ah
34391 9E01           0D                   0900  or	ax,#$900
34392                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34393 9E04           8946         16            mov	$16[bp],ax
34394                                           !BCC_EOS
34395                                           ! 4884         set_diskette_ret_status(0x09);
34396                                           ! Debug: list int = const 9 (used reg = )
34397 9E07           B8                   0009  mov	ax,*9
34398 9E0A           50                         push	ax
34399                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34400 9E0B           E8         064B            call	_set_diskette_ret_status
34401 9E0E           44                         inc	sp
34402 9E0F           44                         inc	sp
34403                                           !BCC_EOS
34404                                           ! 4885         AX = ((AX & 0xff00) | (0));
34405                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34406 9E10           8B46         16            mov	ax,$16[bp]
34407 9E13           30C0                       xor	al,al
34408                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34409 9E15           0C                     00  or	al,*0
34410                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34411 9E17           8946         16            mov	$16[bp],ax
34412                                           !BCC_EOS
34413                                           ! 4886         FLAGS |= 0x0001;
34414                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34415 9E1A           8B46         1C            mov	ax,$1C[bp]
34416 9E1D           0C                     01  or	al,*1
34417 9E1F           8946         1C            mov	$1C[bp],ax
34418                                           !BCC_EOS
34419                                           ! 4887         return;
34420 9E22           89EC                       mov	sp,bp
34421 9E24           5D                         pop	bp
34422 9E25           C3                         ret
34423                                           !BCC_EOS
34424                                           ! 4888       }
34425                                           ! 4889       outb(0x000a, 0x06);
34426                       00009E26            .6EC:
34427                                           ! Debug: list int = const 6 (used reg = )
34428 9E26           B8                   0006  mov	ax,*6
34429 9E29           50                         push	ax
34430                                           ! Debug: list int = const $A (used reg = )
34431 9E2A           B8                   000A  mov	ax,*$A
34432 9E2D           50                         push	ax
34433                                           ! Debug: func () void = outb+0 (used reg = )
34434 9E2E           E8         6727            call	_outb
34435 9E31           83C4                   04  add	sp,*4
34436                                           !BCC_EOS
34437                                           ! 4890       outb(0x000c, 0x00);
34438                                           ! Debug: list int = const 0 (used reg = )
34439 9E34           31C0                       xor	ax,ax
34440 9E36           50                         push	ax
34441                                           ! Debug: list int = const $C (used reg = )
34442 9E37           B8                   000C  mov	ax,*$C
34443 9E3A           50                         push	ax
34444                                           ! Debug: func () void = outb+0 (used reg = )
34445 9E3B           E8         671A            call	_outb
34446 9E3E           83C4                   04  add	sp,*4
34447                                           !BCC_EOS
34448                                           ! 4891       outb(0x0004, base_address);
34449                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
34450 9E41           FF76         F8            push	-8[bp]
34451                                           ! Debug: list int = const 4 (used reg = )
34452 9E44           B8                   0004  mov	ax,*4
34453 9E47           50                         push	ax
34454                                           ! Debug: func () void = outb+0 (used reg = )
34455 9E48           E8         670D            call	_outb
34456 9E4B           83C4                   04  add	sp,*4
34457                                           !BCC_EOS
34458                                           ! 4892       outb(0x0004, base_address>>8);
34459                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
34460 9E4E           8B46         F8            mov	ax,-8[bp]
34461 9E51           88E0                       mov	al,ah
34462 9E53           30E4                       xor	ah,ah
34463                                           ! Debug: list unsigned int = ax+0 (used reg = )
34464 9E55           50                         push	ax
34465                                           ! Debug: list int = const 4 (used reg = )
34466 9E56           B8                   0004  mov	ax,*4
34467 9E59           50                         push	ax
34468                                           ! Debug: func () void = outb+0 (used reg = )
34469 9E5A           E8         66FB            call	_outb
34470 9E5D           83C4                   04  add	sp,*4
34471                                           !BCC_EOS
34472                                           ! 4893       outb(0x000c, 0x00);
34473                                           ! Debug: list int = const 0 (used reg = )
34474 9E60           31C0                       xor	ax,ax
34475 9E62           50                         push	ax
34476                                           ! Debug: list int = const $C (used reg = )
34477 9E63           B8                   000C  mov	ax,*$C
34478 9E66           50                         push	ax
34479                                           ! Debug: func () void = outb+0 (used reg = )
34480 9E67           E8         66EE            call	_outb
34481 9E6A           83C4                   04  add	sp,*4
34482                                           !BCC_EOS
34483                                           ! 4894       outb(0x0005, base_count);
34484                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
34485 9E6D           FF76         F6            push	-$A[bp]
34486                                           ! Debug: list int = const 5 (used reg = )
34487 9E70           B8                   0005  mov	ax,*5
34488 9E73           50                         push	ax
34489                                           ! Debug: func () void = outb+0 (used reg = )
34490 9E74           E8         66E1            call	_outb
34491 9E77           83C4                   04  add	sp,*4
34492                                           !BCC_EOS
34493                                           ! 4895       outb(0x0005, base_count>>8);
34494                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
34495 9E7A           8B46         F6            mov	ax,-$A[bp]
34496 9E7D           88E0                       mov	al,ah
34497 9E7F           30E4                       xor	ah,ah
34498                                           ! Debug: list unsigned int = ax+0 (used reg = )
34499 9E81           50                         push	ax
34500                                           ! Debug: list int = const 5 (used reg = )
34501 9E82           B8                   0005  mov	ax,*5
34502 9E85           50                         push	ax
34503                                           ! Debug: func () void = outb+0 (used reg = )
34504 9E86           E8         66CF            call	_outb
34505 9E89           83C4                   04  add	sp,*4
34506                                           !BCC_EOS
34507                                           ! 4896       mode_register = 0x4a;
34508                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
34509 9E8C           B0                     4A  mov	al,*$4A
34510 9E8E           8846         F2            mov	-$E[bp],al
34511                                           !BCC_EOS
34512                                           ! 4897       outb(0x000b, mode_register);
34513                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
34514 9E91           8A46         F2            mov	al,-$E[bp]
34515 9E94           30E4                       xor	ah,ah
34516 9E96           50                         push	ax
34517                                           ! Debug: list int = const $B (used reg = )
34518 9E97           B8                   000B  mov	ax,*$B
34519 9E9A           50                         push	ax
34520                                           ! Debug: func () void = outb+0 (used reg = )
34521 9E9B           E8         66BA            call	_outb
34522 9E9E           83C4                   04  add	sp,*4
34523                                           !BCC_EOS
34524                                           ! 4898       outb(0x0081, page);
34525                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
34526 9EA1           8A46         F3            mov	al,-$D[bp]
34527 9EA4           30E4                       xor	ah,ah
34528 9EA6           50                         push	ax
34529                                           ! Debug: list int = const $81 (used reg = )
34530 9EA7           B8                   0081  mov	ax,#$81
34531 9EAA           50                         push	ax
34532                                           ! Debug: func () void = outb+0 (used reg = )
34533 9EAB           E8         66AA            call	_outb
34534 9EAE           83C4                   04  add	sp,*4
34535                                           !BCC_EOS
34536                                           ! 4899       outb(0x000a, 0x02);
34537                                           ! Debug: list int = const 2 (used reg = )
34538 9EB1           B8                   0002  mov	ax,*2
34539 9EB4           50                         push	ax
34540                                           ! Debug: list int = const $A (used reg = )
34541 9EB5           B8                   000A  mov	ax,*$A
34542 9EB8           50                         push	ax
34543                                           ! Debug: func () void = outb+0 (used reg = )
34544 9EB9           E8         669C            call	_outb
34545 9EBC           83C4                   04  add	sp,*4
34546                                           !BCC_EOS
34547                                           ! 4900       floppy_prepare_controller(drive);
34548                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34549 9EBF           8A46         FF            mov	al,-1[bp]
34550 9EC2           30E4                       xor	ah,ah
34551 9EC4           50                         push	ax
34552                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
34553 9EC5           E8         F0B9            call	_floppy_prepare_controller
34554 9EC8           44                         inc	sp
34555 9EC9           44                         inc	sp
34556                                           !BCC_EOS
34557                                           ! 4901       outb(0x03f5, 0x4d);
34558                                           ! Debug: list int = const $4D (used reg = )
34559 9ECA           B8                   004D  mov	ax,*$4D
34560 9ECD           50                         push	ax
34561                                           ! Debug: list int = const $3F5 (used reg = )
34562 9ECE           B8                   03F5  mov	ax,#$3F5
34563 9ED1           50                         push	ax
34564                                           ! Debug: func () void = outb+0 (used reg = )
34565 9ED2           E8         6683            call	_outb
34566 9ED5           83C4                   04  add	sp,*4
34567                                           !BCC_EOS
34568                                           ! 4902       outb(0x03f5, (head << 2) | drive);
34569                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
34570 9ED8           8A46         FB            mov	al,-5[bp]
34571 9EDB           30E4                       xor	ah,ah
34572 9EDD           D1E0                       shl	ax,*1
34573 9EDF           D1E0                       shl	ax,*1
34574                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
34575 9EE1           0A46         FF            or	al,-1[bp]
34576                                           ! Debug: list unsigned int = ax+0 (used reg = )
34577 9EE4           50                         push	ax
34578                                           ! Debug: list int = const $3F5 (used reg = )
34579 9EE5           B8                   03F5  mov	ax,#$3F5
34580 9EE8           50                         push	ax
34581                                           ! Debug: func () void = outb+0 (used reg = )
34582 9EE9           E8         666C            call	_outb
34583 9EEC           83C4                   04  add	sp,*4
34584                                           !BCC_EOS
34585                                           ! 4903       outb(0x03f5, 2);
34586                                           ! Debug: list int = const 2 (used reg = )
34587 9EEF           B8                   0002  mov	ax,*2
34588 9EF2           50                         push	ax
34589                                           ! Debug: list int = const $3F5 (used reg = )
34590 9EF3           B8                   03F5  mov	ax,#$3F5
34591 9EF6           50                         push	ax
34592                                           ! Debug: func () void = outb+0 (used reg = )
34593 9EF7           E8         665E            call	_outb
34594 9EFA           83C4                   04  add	sp,*4
34595                                           !BCC_EOS
34596                                           ! 4904       outb(0x03f
34597                                           ! 4904 5, num_sectors);
34598                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
34599 9EFD           8A46         FE            mov	al,-2[bp]
34600 9F00           30E4                       xor	ah,ah
34601 9F02           50                         push	ax
34602                                           ! Debug: list int = const $3F5 (used reg = )
34603 9F03           B8                   03F5  mov	ax,#$3F5
34604 9F06           50                         push	ax
34605                                           ! Debug: func () void = outb+0 (used reg = )
34606 9F07           E8         664E            call	_outb
34607 9F0A           83C4                   04  add	sp,*4
34608                                           !BCC_EOS
34609                                           ! 4905       outb(0x03f5, 0);
34610                                           ! Debug: list int = const 0 (used reg = )
34611 9F0D           31C0                       xor	ax,ax
34612 9F0F           50                         push	ax
34613                                           ! Debug: list int = const $3F5 (used reg = )
34614 9F10           B8                   03F5  mov	ax,#$3F5
34615 9F13           50                         push	ax
34616                                           ! Debug: func () void = outb+0 (used reg = )
34617 9F14           E8         6641            call	_outb
34618 9F17           83C4                   04  add	sp,*4
34619                                           !BCC_EOS
34620                                           ! 4906       outb(0x03f5, 0xf6);
34621                                           ! Debug: list int = const $F6 (used reg = )
34622 9F1A           B8                   00F6  mov	ax,#$F6
34623 9F1D           50                         push	ax
34624                                           ! Debug: list int = const $3F5 (used reg = )
34625 9F1E           B8                   03F5  mov	ax,#$3F5
34626 9F21           50                         push	ax
34627                                           ! Debug: func () void = outb+0 (used reg = )
34628 9F22           E8         6633            call	_outb
34629 9F25           83C4                   04  add	sp,*4
34630                                           !BCC_EOS
34631                                           ! 4907 #asm
34632                                           !BCC_EOS
34633                                           !BCC_ASM
34634                       0000002A            _int13_diskette_function.BP	set	$2A
34635                       0000000C            .int13_diskette_function.BP	set	$C
34636                       00000038            _int13_diskette_function.CS	set	$38
34637                       0000001A            .int13_diskette_function.CS	set	$1A
34638                       00000032            _int13_diskette_function.CX	set	$32
34639                       00000014            .int13_diskette_function.CX	set	$14
34640                       00000016            _int13_diskette_function.base_address	set	$16
34641                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34642                       00000026            _int13_diskette_function.DI	set	$26
34643                       00000008            .int13_diskette_function.DI	set	8
34644                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34645                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34646                       00000014            _int13_diskette_function.base_count	set	$14
34647                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34648                       0000001A            _int13_diskette_function.sector	set	$1A
34649                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34650                       00000022            _int13_diskette_function.DS	set	$22
34651                       00000004            .int13_diskette_function.DS	set	4
34652                       00000019            _int13_diskette_function.head	set	$19
34653                       FFFFFFFB            .int13_diskette_function.head	set	-5
34654                       0000002C            _int13_diskette_function.ELDX	set	$2C
34655                       0000000E            .int13_diskette_function.ELDX	set	$E
34656                       0000000E            _int13_diskette_function.dor	set	$E
34657                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34658                       00000030            _int13_diskette_function.DX	set	$30
34659                       00000012            .int13_diskette_function.DX	set	$12
34660                       00000007            _int13_diskette_function.return_status	set	7
34661                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34662                       00000002            _int13_diskette_function.es	set	2
34663                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34664                       00000010            _int13_diskette_function.mode_register	set	$10
34665                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34666                       00000024            _int13_diskette_function.ES	set	$24
34667                       00000006            .int13_diskette_function.ES	set	6
34668                       00000012            _int13_diskette_function.base_es	set	$12
34669                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34670                       0000001B            _int13_diskette_function.track	set	$1B
34671                       FFFFFFFD            .int13_diskette_function.track	set	-3
34672                       00000028            _int13_diskette_function.SI	set	$28
34673                       0000000A            .int13_diskette_function.SI	set	$A
34674                       00000006            _int13_diskette_function.drive_type	set	6
34675                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34676                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34677                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34678                       00000036            _int13_diskette_function.IP	set	$36
34679                       00000018            .int13_diskette_function.IP	set	$18
34680                       00000018            _int13_diskette_function.status	set	$18
34681                       FFFFFFFA            .int13_diskette_function.status	set	-6
34682                       00000034            _int13_diskette_function.AX	set	$34
34683                       00000016            .int13_diskette_function.AX	set	$16
34684                       0000000F            _int13_diskette_function.val8	set	$F
34685                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34686                       00000000            _int13_diskette_function.last_addr	set	0
34687                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34688                       00000011            _int13_diskette_function.page	set	$11
34689                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34690                       00000004            _int13_diskette_function.ah	set	4
34691                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34692                       0000001D            _int13_diskette_function.drive	set	$1D
34693                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34694                       00000005            _int13_diskette_function.num_floppies	set	5
34695                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34696                       0000002E            _int13_diskette_function.BX	set	$2E
34697                       00000010            .int13_diskette_function.BX	set	$10
34698 9F28           FB                               sti
34699                                           ! 4909 endasm
34700                                           !BCC_ENDASM
34701                                           !BCC_EOS
34702                                           ! 4910       do {
34703                       00009F29            .6F0:
34704                                           ! 4911         val8 = read_byte(0x0040, 0x0040);
34705                                           ! Debug: list int = const $40 (used reg = )
34706 9F29           B8                   0040  mov	ax,*$40
34707 9F2C           50                         push	ax
34708                                           ! Debug: list int = const $40 (used reg = )
34709 9F2D           B8                   0040  mov	ax,*$40
34710 9F30           50                         push	ax
34711                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34712 9F31           E8         66C4            call	_read_byte
34713 9F34           83C4                   04  add	sp,*4
34714                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34715 9F37           8846         F1            mov	-$F[bp],al
34716                                           !BCC_EOS
34717                                           ! 4912         if (val8 == 0) {
34718                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34719 9F3A           8A46         F1            mov	al,-$F[bp]
34720 9F3D           84C0                       test	al,al
34721 9F3F           75           23            jne 	.6F1
34722                       00009F41            .6F2:
34723                                           ! 4913           floppy_reset_controller();
34724                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
34725 9F41           E8         EFEF            call	_floppy_reset_controller
34726                                           !BCC_EOS
34727                                           ! 4914           AX = ((AX & 0x00ff) | ((0x80) << 8));
34728                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34729 9F44           8A46         16            mov	al,$16[bp]
34730                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34731 9F47           30E4                       xor	ah,ah
34732 9F49           0D                   8000  or	ax,#-$8000
34733                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34734 9F4C           8946         16            mov	$16[bp],ax
34735                                           !BCC_EOS
34736                                           ! 4915           set_diskette_ret_status(0x80);
34737                                           ! Debug: list int = const $80 (used reg = )
34738 9F4F           B8                   0080  mov	ax,#$80
34739 9F52           50                         push	ax
34740                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34741 9F53           E8         0503            call	_set_diskette_ret_status
34742 9F56           44                         inc	sp
34743 9F57           44                         inc	sp
34744                                           !BCC_EOS
34745                                           ! 4916           FLAGS |= 0x0001;
34746                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34747 9F58           8B46         1C            mov	ax,$1C[bp]
34748 9F5B           0C                     01  or	al,*1
34749 9F5D           8946         1C            mov	$1C[bp],ax
34750                                           !BCC_EOS
34751                                           ! 4917           return;
34752 9F60           89EC                       mov	sp,bp
34753 9F62           5D                         pop	bp
34754 9F63           C3                         ret
34755                                           !BCC_EOS
34756                                           ! 4918         }
34757                                           ! 4919         val8 = (read_byte(0x0040, 0x003e) & 0x80);
34758                       00009F64            .6F1:
34759                                           ! Debug: list int = const $3E (used reg = )
34760 9F64           B8                   003E  mov	ax,*$3E
34761 9F67           50                         push	ax
34762                                           ! Debug: list int = const $40 (used reg = )
34763 9F68           B8                   0040  mov	ax,*$40
34764 9F6B           50                         push	ax
34765                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34766 9F6C           E8         6689            call	_read_byte
34767 9F6F           83C4                   04  add	sp,*4
34768                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
34769 9F72           24                     80  and	al,#$80
34770                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34771 9F74           8846         F1            mov	-$F[bp],al
34772                                           !BCC_EOS
34773                                           ! 4920       } while ( val8 == 0 );
34774                       00009F77            .6EF:
34775                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34776 9F77           8A46         F1            mov	al,-$F[bp]
34777 9F7A           84C0                       test	al,al
34778 9F7C           74           AB            je 	.6F0
34779                       00009F7E            .6F3:
34780                                           !BCC_EOS
34781                                           ! 4921       val8 = 0;
34782                       00009F7E            .6EE:
34783                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34784 9F7E           30C0                       xor	al,al
34785 9F80           8846         F1            mov	-$F[bp],al
34786                                           !BCC_EOS
34787                                           ! 4922 #asm
34788                                           !BCC_EOS
34789                                           !BCC_ASM
34790                       0000002A            _int13_diskette_function.BP	set	$2A
34791                       0000000C            .int13_diskette_function.BP	set	$C
34792                       00000038            _int13_diskette_function.CS	set	$38
34793                       0000001A            .int13_diskette_function.CS	set	$1A
34794                       00000032            _int13_diskette_function.CX	set	$32
34795                       00000014            .int13_diskette_function.CX	set	$14
34796                       00000016            _int13_diskette_function.base_address	set	$16
34797                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34798                       00000026            _int13_diskette_function.DI	set	$26
34799                       00000008            .int13_diskette_function.DI	set	8
34800                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34801                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34802                       00000014            _int13_diskette_function.base_count	set	$14
34803                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34804                       0000001A            _int13_diskette_function.sector	set	$1A
34805                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34806                       00000022            _int13_diskette_function.DS	set	$22
34807                       00000004            .int13_diskette_function.DS	set	4
34808                       00000019            _int13_diskette_function.head	set	$19
34809                       FFFFFFFB            .int13_diskette_function.head	set	-5
34810                       0000002C            _int13_diskette_function.ELDX	set	$2C
34811                       0000000E            .int13_diskette_function.ELDX	set	$E
34812                       0000000E            _int13_diskette_function.dor	set	$E
34813                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34814                       00000030            _int13_diskette_function.DX	set	$30
34815                       00000012            .int13_diskette_function.DX	set	$12
34816                       00000007            _int13_diskette_function.return_status	set	7
34817                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34818                       00000002            _int13_diskette_function.es	set	2
34819                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34820                       00000010            _int13_diskette_function.mode_register	set	$10
34821                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34822                       00000024            _int13_diskette_function.ES	set	$24
34823                       00000006            .int13_diskette_function.ES	set	6
34824                       00000012            _int13_diskette_function.base_es	set	$12
34825                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34826                       0000001B            _int13_diskette_function.track	set	$1B
34827                       FFFFFFFD            .int13_diskette_function.track	set	-3
34828                       00000028            _int13_diskette_function.SI	set	$28
34829                       0000000A            .int13_diskette_function.SI	set	$A
34830                       00000006            _int13_diskette_function.drive_type	set	6
34831                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34832                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34833                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34834                       00000036            _int13_diskette_function.IP	set	$36
34835                       00000018            .int13_diskette_function.IP	set	$18
34836                       00000018            _int13_diskette_function.status	set	$18
34837                       FFFFFFFA            .int13_diskette_function.status	set	-6
34838                       00000034            _int13_diskette_function.AX	set	$34
34839                       00000016            .int13_diskette_function.AX	set	$16
34840                       0000000F            _int13_diskette_function.val8	set	$F
34841                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34842                       00000000            _int13_diskette_function.last_addr	set	0
34843                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34844                       00000011            _int13_diskette_function.page	set	$11
34845                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34846                       00000004            _int13_diskette_function.ah	set	4
34847                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34848                       0000001D            _int13_diskette_function.drive	set	$1D
34849                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34850                       00000005            _int13_diskette_function.num_floppies	set	5
34851                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34852                       0000002E            _int13_diskette_function.BX	set	$2E
34853                       00000010            .int13_diskette_function.BX	set	$10
34854 9F83           FA                               cli
34855                                           ! 4924 endasm
34856                                           !BCC_ENDASM
34857                                           !BCC_EOS
34858                                           ! 4925       val8 = read_byte(0x0040, 0x003e);
34859                                           ! Debug: list int = const $3E (used reg = )
34860 9F84           B8                   003E  mov	ax,*$3E
34861 9F87           50                         push	ax
34862                                           ! Debug: list int = const $40 (used reg = )
34863 9F88           B8                   0040  mov	ax,*$40
34864 9F8B           50                         push	ax
34865                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34866 9F8C           E8         6669            call	_read_byte
34867 9F8F           83C4                   04  add	sp,*4
34868                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34869 9F92           8846         F1            mov	-$F[bp],al
34870                                           !BCC_EOS
34871                                           ! 4926       val8 &= 0x7f;
34872                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
34873 9F95           8A46         F1            mov	al,-$F[bp]
34874 9F98           24                     7F  and	al,*$7F
34875 9F9A           8846         F1            mov	-$F[bp],al
34876                                           !BCC_EOS
34877                                           ! 4927       write_byte(0x0040, 0x003e, val8);
34878                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
34879 9F9D           8A46         F1            mov	al,-$F[bp]
34880 9FA0           30E4                       xor	ah,ah
34881 9FA2           50                         push	ax
34882                                           ! Debug: list int = const $3E (used reg = )
34883 9FA3           B8                   003E  mov	ax,*$3E
34884 9FA6           50                         push	ax
34885                                           ! Debug: list int = const $40 (used reg = )
34886 9FA7           B8                   0040  mov	ax,*$40
34887 9FAA           50                         push	ax
34888                                           ! Debug: func () void = write_byte+0 (used reg = )
34889 9FAB           E8         6670            call	_write_byte
34890 9FAE           83C4                   06  add	sp,*6
34891                                           !BCC_EOS
34892                                           ! 4928       val8 = inb(0x3f4);
34893                                           ! Debug: list int = const $3F4 (used reg = )
34894 9FB1           B8                   03F4  mov	ax,#$3F4
34895 9FB4           50                         push	ax
34896                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34897 9FB5           E8         658A            call	_inb
34898 9FB8           44                         inc	sp
34899 9FB9           44                         inc	sp
34900                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34901 9FBA           8846         F1            mov	-$F[bp],al
34902                                           !BCC_EOS
34903                                           ! 4929       if ( (val8 & 0xc0) != 0xc0 )
34904                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
34905 9FBD           8A46         F1            mov	al,-$F[bp]
34906 9FC0           24                     C0  and	al,#$C0
34907                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
34908 9FC2           3C                     C0  cmp	al,#$C0
34909 9FC4           74           0E            je  	.6F4
34910                       00009FC6            .6F5:
34911                                           ! 4930         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
34912                                           ! Debug: list * char = .6F6+0 (used reg = )
34913 9FC6           BB                   CD98  mov	bx,#.6F6
34914 9FC9           53                         push	bx
34915                                           ! Debug: list int = const 7 (used reg = )
34916 9FCA           B8                   0007  mov	ax,*7
34917 9FCD           50                         push	ax
34918                                           ! Debug: func () void = bios_printf+0 (used reg = )
34919 9FCE           E8         69D6            call	_bios_printf
34920 9FD1           83C4                   04  add	sp,*4
34921                                           !BCC_EOS
34922                                           ! 4931       return_status[0] = inb(0x3f5);
34923                       00009FD4            .6F4:
34924                                           ! Debug: list int = const $3F5 (used reg = )
34925 9FD4           B8                   03F5  mov	ax,#$3F5
34926 9FD7           50                         push	ax
34927                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34928 9FD8           E8         6567            call	_inb
34929 9FDB           44                         inc	sp
34930 9FDC           44                         inc	sp
34931                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
34932 9FDD           8846         E9            mov	-$17[bp],al
34933                                           !BCC_EOS
34934                                           ! 4932       return_status[1] = inb(0x3f5);
34935                                           ! Debug: list int = const $3F5 (used reg = )
34936 9FE0           B8                   03F5  mov	ax,#$3F5
34937 9FE3           50                         push	ax
34938                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34939 9FE4           E8         655B            call	_inb
34940 9FE7           44                         inc	sp
34941 9FE8           44                         inc	sp
34942                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
34943 9FE9           8846         EA            mov	-$16[bp],al
34944                                           !BCC_EOS
34945                                           ! 4933       return_status[2] = inb(0x3f5);
34946                                           ! Debug: list int = const $3F5 (used reg = )
34947 9FEC           B8                   03F5  mov	ax,#$3F5
34948 9FEF           50                         push	ax
34949                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34950 9FF0           E8         654F            call	_inb
34951 9FF3           44                         inc	sp
34952 9FF4           44                         inc	sp
34953                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
34954 9FF5           8846         EB            mov	-$15[bp],al
34955                                           !BCC_EOS
34956                                           ! 4934       return_status[3] = inb(0x3f5);
34957                                           ! Debug: list int = const $3F5 (used reg = )
34958 9FF8           B8                   03F5  mov	ax,#$3F5
34959 9FFB           50                         push	ax
34960                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34961 9FFC           E8         6543            call	_inb
34962 9FFF           44                         inc	sp
34963 A000           44                         inc	sp
34964                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
34965 A001           8846         EC            mov	-$14[bp],al
34966                                           !BCC_EOS
34967                                           ! 4935       return_status[4] = inb(0x3f5);
34968                                           ! Debug: list int = const $3F5 (used reg = )
34969 A004           B8                   03F5  mov	ax,#$3F5
34970 A007           50                         push	ax
34971                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34972 A008           E8         6537            call	_inb
34973 A00B           44                         inc	sp
34974 A00C           44                         inc	sp
34975                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
34976 A00D           8846         ED            mov	-$13[bp],al
34977                                           !BCC_EOS
34978                                           ! 4936       return_status[5] = inb(0x3f5);
34979                                           ! Debug: list int = const $3F5 (used reg = )
34980 A010           B8                   03F5  mov	ax,#$3F5
34981 A013           50                         push	ax
34982                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34983 A014           E8         652B            call	_inb
34984 A017           44                         inc	sp
34985 A018           44                         inc	sp
34986                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
34987 A019           8846         EE            mov	-$12[bp],al
34988                                           !BCC_EOS
34989                                           ! 4937       return_status[6] = inb(0x3f5);
34990                                           ! Debug: list int = const $3F5 (used reg = )
34991 A01C           B8                   03F5  mov	ax,#$3F5
34992 A01F           50                         push	ax
34993                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34994 A020           E8         651F            call	_inb
34995 A023           44                         inc	sp
34996 A024           44                         inc	sp
34997                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
34998 A025           8846         EF            mov	-$11[bp],al
34999                                           !BCC_EOS
35000                                           ! 4938       write_byte(0x0040, 0x0042, return_status[0]);
35001                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
35002 A028           8A46         E9            mov	al,-$17[bp]
35003 A02B           30E4                       xor	ah,ah
35004 A02D           50                         push	ax
35005                                           ! Debug: list int = const $42 (used reg = )
35006 A02E           B8                   0042  mov	ax,*$42
35007 A031           50                         push	ax
35008                                           ! Debug: list int = const $40 (used reg = )
35009 A032           B8                   0040  mov	ax,*$40
35010 A035           50                         push	ax
35011                                           ! Debug: func () void = write_byte+0 (used reg = )
35012 A036           E8         65E5            call	_write_byte
35013 A039           83C4                   06  add	sp,*6
35014                                           !BCC_EOS
35015                                           ! 4939       write_byte(0x0040, 0x0043, return_status[1]);
35016                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
35017 A03C           8A46         EA            mov	al,-$16[bp]
35018 A03F           30E4                       xor	ah,ah
35019 A041           50                         push	ax
35020                                           ! Debug: list int = const $43 (used reg = )
35021 A042           B8                   0043  mov	ax,*$43
35022 A045           50                         push	ax
35023                                           ! Debug: list int = const $40 (used reg = )
35024 A046           B8                   0040  mov	ax,*$40
35025 A049           50                         push	ax
35026                                           ! Debug: func () void = write_byte+0 (used reg = )
35027 A04A           E8         65D1            call	_write_byte
35028 A04D           83C4                   06  add	sp,*6
35029                                           !BCC_EOS
35030                                           ! 4940       write_byte(0x0040, 0x0044, return_status[2]);
35031                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
35032 A050           8A46         EB            mov	al,-$15[bp]
35033 A053           30E4                       xor	ah,ah
35034 A055           50                         push	ax
35035                                           ! Debug: list int = const $44 (used reg = )
35036 A056           B8                   0044  mov	ax,*$44
35037 A059           50                         push	ax
35038                                           ! Debug: list int = const $40 (used reg = )
35039 A05A           B8                   0040  mov	ax,*$40
35040 A05D           50                         push	ax
35041                                           ! Debug: func () void = write_byte+0 (used reg = )
35042 A05E           E8         65BD            call	_write_byte
35043 A061           83C4                   06  add	sp,*6
35044                                           !BCC_EOS
35045                                           ! 4941       write_byte(0x0040, 0x0045, return_status[3]);
35046                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
35047 A064           8A46         EC            mov	al,-$14[bp]
35048 A067           30E4                       xor	ah,ah
35049 A069           50                         push	ax
35050                                           ! Debug: list int = const $45 (used reg = )
35051 A06A           B8                   0045  mov	ax,*$45
35052 A06D           50                         push	ax
35053                                           ! Debug: list int = const $40 (used reg = )
35054 A06E           B8                   0040  mov	ax,*$40
35055 A071           50                         push	ax
35056                                           ! Debug: func () void = write_byte+0 (used reg = )
35057 A072           E8         65A9            call	_write_byte
35058 A075           83C4                   06  add	sp,*6
35059                                           !BCC_EOS
35060                                           ! 4942       write_byte(0x0040, 0x0046, return_status[4]);
35061                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
35062 A078           8A46         ED            mov	al,-$13[bp]
35063 A07B           30E4                       xor	ah,ah
35064 A07D           50                         push	ax
35065                                           ! Debug: list int = const $46 (used reg = )
35066 A07E           B8                   0046  mov	ax,*$46
35067 A081           50                         push	ax
35068                                           ! Debug: list int = const $40 (used reg = )
35069 A082           B8                   0040  mov	ax,*$40
35070 A085           50                         push	ax
35071                                           ! Debug: func () void = write_byte+0 (used reg = )
35072 A086           E8         6595            call	_write_byte
35073 A089           83C4                   06  add	sp,*6
35074                                           !BCC_EOS
35075                                           ! 4943       write_byte(0x0040, 0x0047, return_status[5]);
35076                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
35077 A08C           8A46         EE            mov	al,-$12[bp]
35078 A08F           30E4                       xor	ah,ah
35079 A091           50                         push	ax
35080                                           ! Debug: list int = const $47 (used reg = )
35081 A092           B8                   0047  mov	ax,*$47
35082 A095           50                         push	ax
35083                                           ! Debug: list int = const $40 (used reg = )
35084 A096           B8                   0040  mov	ax,*$40
35085 A099           50                         push	ax
35086                                           ! Debug: func () void = write_byte+0 (used reg = )
35087 A09A           E8         6581            call	_write_byte
35088 A09D           83C4                   06  add	sp,*6
35089                                           !BCC_EOS
35090                                           ! 4944       write_byte(0x0040, 0x0048, return_status[6]);
35091                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
35092 A0A0           8A46         EF            mov	al,-$11[bp]
35093 A0A3           30E4                       xor	ah,ah
35094 A0A5           50                         push	ax
35095                                           ! Debug: list int = const $48 (used reg = )
35096 A0A6           B8                   0048  mov	ax,*$48
35097 A0A9           50                         push	ax
35098                                           ! Debug: list int = const $40 (used reg = )
35099 A0AA           B8                   0040  mov	ax,*$40
35100 A0AD           50                         push	ax
35101                                           ! Debug: func () void = write_byte+0 (used reg = )
35102 A0AE           E8         656D            call	_write_byte
35103 A0B1           83C4                   06  add	sp,*6
35104                                           !BCC_EOS
35105                                           ! 4945       if ( (return_status[0] & 0xc0) != 0 ) {
35106                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
35107 A0B4           8A46         E9            mov	al,-$17[bp]
35108 A0B7           24                     C0  and	al,#$C0
35109                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35110 A0B9           84C0                       test	al,al
35111 A0BB           74           2B            je  	.6F7
35112                       0000A0BD            .6F8:
35113                                           ! 4946         if ( (return_status[1] & 0x02) != 0 ) {
35114                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
35115 A0BD           8A46         EA            mov	al,-$16[bp]
35116 A0C0           24                     02  and	al,*2
35117                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35118 A0C2           84C0                       test	al,al
35119 A0C4           74           14            je  	.6F9
35120                       0000A0C6            .6FA:
35121                                           ! 4947           AX = 0x0300;
35122                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
35123 A0C6           B8                   0300  mov	ax,#$300
35124 A0C9           8946         16            mov	$16[bp],ax
35125                                           !BCC_EOS
35126                                           ! 4948           FLAGS |= 0x0001;
35127                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35128 A0CC           8B46         1C            mov	ax,$1C[bp]
35129 A0CF           0C                     01  or	al,*1
35130 A0D1           8946         1C            mov	$1C[bp],ax
35131                                           !BCC_EOS
35132                                           ! 4949           return;
35133 A0D4           89EC                       mov	sp,bp
35134 A0D6           5D                         pop	bp
35135 A0D7           C3                         ret
35136                                           !BCC_EOS
35137                                           ! 4950         } else {
35138 A0D8           EB           0E            jmp .6FB
35139                       0000A0DA            .6F9:
35140                                           ! 4951           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
35141                                           ! Debug: list * char = .6FC+0 (used reg = )
35142 A0DA           BB                   CD72  mov	bx,#.6FC
35143 A0DD           53                         push	bx
35144                                           ! Debug: list int = const 7 (used reg = )
35145 A0DE           B8                   0007  mov	ax,*7
35146 A0E1           50                         push	ax
35147                                           ! Debug: func () void = bios_printf+0 (used reg = )
35148 A0E2           E8         68C2            call	_bios_printf
35149 A0E5           83C4                   04  add	sp,*4
35150                                           !BCC_EOS
35151                                           ! 4952         }
35152                                           ! 4953       }
35153                       0000A0E8            .6FB:
35154                                           ! 4954       AX = ((AX & 0x00ff) | ((0) << 8));
35155                       0000A0E8            .6F7:
35156                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35157 A0E8           8A46         16            mov	al,$16[bp]
35158                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35159 A0EB           0C                     00  or	al,*0
35160                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35161 A0ED           30E4                       xor	ah,ah
35162 A0EF           8946         16            mov	$16[bp],ax
35163                                           !BCC_EOS
35164                                           ! 4955       set_diskette_ret_status(0);
35165                                           ! Debug: list int = const 0 (used reg = )
35166 A0F2           31C0                       xor	ax,ax
35167 A0F4           50                         push	ax
35168                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35169 A0F5           E8         0361            call	_set_diskette_ret_status
35170 A0F8           44                         inc	sp
35171 A0F9           44                         inc	sp
35172                                           !BCC_EOS
35173                                           ! 4956       set_diskette_current_cyl(drive, 0);
35174                                           ! Debug: list int = const 0 (used reg = )
35175 A0FA           31C0                       xor	ax,ax
35176 A0FC           50                         push	ax
35177                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
35178 A0FD           8A46         FF            mov	al,-1[bp]
35179 A100           30E4                       xor	ah,ah
35180 A102           50                         push	ax
35181                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
35182 A103           E8         036B            call	_set_diskette_current_cyl
35183 A106           83C4                   04  add	sp,*4
35184                                           !BCC_EOS
35185                                           ! 4957       FLAGS &= 0xfffe;
35186                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35187 A109           8B46         1C            mov	ax,$1C[bp]
35188 A10C           24                     FE  and	al,#$FE
35189 A10E           8946         1C            mov	$1C[bp],ax
35190                                           !BCC_EOS
35191                                           ! 4958       return;
35192 A111           89EC                       mov	sp,bp
35193 A113           5D                         pop	bp
35194 A114           C3                         ret
35195                                           !BCC_EOS
35196                                           ! 4959     case 0x08:
35197                                           ! 4960 ;
35198                       0000A115            .6FD:
35199                                           !BCC_EOS
35200                                           ! 4961       drive = ( ELDX & 0x00ff );
35201                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35202 A115           8A46         0E            mov	al,$E[bp]
35203                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35204 A118           8846         FF            mov	-1[bp],al
35205                                           !BCC_EOS
35206                                           ! 4962       if (drive > 1) {
35207                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35208 A11B           8A46         FF            mov	al,-1[bp]
35209 A11E           3C                     01  cmp	al,*1
35210 A120           76           35            jbe 	.6FE
35211                       0000A122            .6FF:
35212                                           ! 4963         AX = 0;
35213                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
35214 A122           31C0                       xor	ax,ax
35215 A124           8946         16            mov	$16[bp],ax
35216                                           !BCC_EOS
35217                                           ! 4964         BX = 0;
35218                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
35219 A127           31C0                       xor	ax,ax
35220 A129           8946         10            mov	$10[bp],ax
35221                                           !BCC_EOS
35222                                           ! 4965         CX = 0;
35223                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35224 A12C           31C0                       xor	ax,ax
35225 A12E           8946         14            mov	$14[bp],ax
35226                                           !BCC_EOS
35227                                           ! 4966         DX = 0;
35228                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
35229 A131           31C0                       xor	ax,ax
35230 A133           8946         12            mov	$12[bp],ax
35231                                           !BCC_EOS
35232                                           ! 4967         ES = 0;
35233                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
35234 A136           31C0                       xor	ax,ax
35235 A138           8946         06            mov	6[bp],ax
35236                                           !BCC_EOS
35237                                           ! 4968         DI = 0;
35238                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
35239 A13B           31C0                       xor	ax,ax
35240 A13D           8946         08            mov	8[bp],ax
35241                                           !BCC_EOS
35242                                           ! 4969         DX = ((DX & 0xff00) | (num_floppies));
35243                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35244 A140           8B46         12            mov	ax,$12[bp]
35245 A143           30C0                       xor	al,al
35246                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35247 A145           0A46         E7            or	al,-$19[bp]
35248                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35249 A148           8946         12            mov	$12[bp],ax
35250                                           !BCC_EOS
35251                                           ! 4970         FLAGS |= 0x0001;
35252                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35253 A14B           8B46         1C            mov	ax,$1C[bp]
35254 A14E           0C                     01  or	al,*1
35255 A150           8946         1C            mov	$1C[bp],ax
35256                                           !BCC_EOS
35257                                           ! 4971         return;
35258 A153           89EC                       mov	sp,bp
35259 A155           5D                         pop	bp
35260 A156           C3                         ret
35261                                           !BCC_EOS
35262                                           ! 4972       }
35263                                           ! 4973       drive_type = inb_cmos(0x10);
35264                       0000A157            .6FE:
35265                                           ! 4973 
35266                                           ! Debug: list int = const $10 (used reg = )
35267 A157           B8                   0010  mov	ax,*$10
35268 A15A           50                         push	ax
35269                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35270 A15B           E8         6429            call	_inb_cmos
35271 A15E           44                         inc	sp
35272 A15F           44                         inc	sp
35273                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35274 A160           8846         E8            mov	-$18[bp],al
35275                                           !BCC_EOS
35276                                           ! 4974       num_floppies = 0;
35277                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
35278 A163           30C0                       xor	al,al
35279 A165           8846         E7            mov	-$19[bp],al
35280                                           !BCC_EOS
35281                                           ! 4975       if (drive_type & 0xf0)
35282                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35283 A168           8A46         E8            mov	al,-$18[bp]
35284 A16B           24                     F0  and	al,#$F0
35285 A16D           84C0                       test	al,al
35286 A16F           74           07            je  	.700
35287                       0000A171            .701:
35288                                           ! 4976         num_floppies++;
35289                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35290 A171           8A46         E7            mov	al,-$19[bp]
35291 A174           40                         inc	ax
35292 A175           8846         E7            mov	-$19[bp],al
35293                                           !BCC_EOS
35294                                           ! 4977       if (drive_type & 0x0f)
35295                       0000A178            .700:
35296                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35297 A178           8A46         E8            mov	al,-$18[bp]
35298 A17B           24                     0F  and	al,*$F
35299 A17D           84C0                       test	al,al
35300 A17F           74           07            je  	.702
35301                       0000A181            .703:
35302                                           ! 4978         num_floppies++;
35303                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35304 A181           8A46         E7            mov	al,-$19[bp]
35305 A184           40                         inc	ax
35306 A185           8846         E7            mov	-$19[bp],al
35307                                           !BCC_EOS
35308                                           ! 4979       if (drive == 0)
35309                       0000A188            .702:
35310                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35311 A188           8A46         FF            mov	al,-1[bp]
35312 A18B           84C0                       test	al,al
35313 A18D           75           0E            jne 	.704
35314                       0000A18F            .705:
35315                                           ! 4980         drive_type >>= 4;
35316                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35317 A18F           8A46         E8            mov	al,-$18[bp]
35318 A192           30E4                       xor	ah,ah
35319 A194           B1                     04  mov	cl,*4
35320 A196           D3E8                       shr	ax,cl
35321 A198           8846         E8            mov	-$18[bp],al
35322                                           !BCC_EOS
35323                                           ! 4981       else
35324                                           ! 4982         drive_type &= 0x0f;
35325 A19B           EB           08            jmp .706
35326                       0000A19D            .704:
35327                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35328 A19D           8A46         E8            mov	al,-$18[bp]
35329 A1A0           24                     0F  and	al,*$F
35330 A1A2           8846         E8            mov	-$18[bp],al
35331                                           !BCC_EOS
35332                                           ! 4983       BX = ((BX & 0x00ff) | ((0) << 8));
35333                       0000A1A5            .706:
35334                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
35335 A1A5           8A46         10            mov	al,$10[bp]
35336                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35337 A1A8           0C                     00  or	al,*0
35338                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
35339 A1AA           30E4                       xor	ah,ah
35340 A1AC           8946         10            mov	$10[bp],ax
35341                                           !BCC_EOS
35342                                           ! 4984       BX = ((BX & 0xff00) | (drive_type));
35343                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
35344 A1AF           8B46         10            mov	ax,$10[bp]
35345 A1B2           30C0                       xor	al,al
35346                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
35347 A1B4           0A46         E8            or	al,-$18[bp]
35348                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
35349 A1B7           8946         10            mov	$10[bp],ax
35350                                           !BCC_EOS
35351                                           ! 4985       AX = ((AX & 0x00ff) | ((0) << 8));
35352                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35353 A1BA           8A46         16            mov	al,$16[bp]
35354                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35355 A1BD           0C                     00  or	al,*0
35356                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35357 A1BF           30E4                       xor	ah,ah
35358 A1C1           8946         16            mov	$16[bp],ax
35359                                           !BCC_EOS
35360                                           ! 4986       AX = ((AX & 0xff00) | (0));
35361                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
35362 A1C4           8B46         16            mov	ax,$16[bp]
35363 A1C7           30C0                       xor	al,al
35364                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
35365 A1C9           0C                     00  or	al,*0
35366                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35367 A1CB           8946         16            mov	$16[bp],ax
35368                                           !BCC_EOS
35369                                           ! 4987       DX = ((DX & 0xff00) | (num_floppies));
35370                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35371 A1CE           8B46         12            mov	ax,$12[bp]
35372 A1D1           30C0                       xor	al,al
35373                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35374 A1D3           0A46         E7            or	al,-$19[bp]
35375                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35376 A1D6           8946         12            mov	$12[bp],ax
35377                                           !BCC_EOS
35378                                           ! 4988       switch (drive_type) {
35379 A1D9           8A46         E8            mov	al,-$18[bp]
35380 A1DC           E9         00BC            br 	.709
35381                                           ! 4989         case 0:
35382                                           ! 4990           CX = 0;
35383                       0000A1DF            .70A:
35384                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35385 A1DF           31C0                       xor	ax,ax
35386 A1E1           8946         14            mov	$14[bp],ax
35387                                           !BCC_EOS
35388                                           ! 4991           DX = ((DX & 0x00ff) | ((0) << 8));
35389                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35390 A1E4           8A46         12            mov	al,$12[bp]
35391                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35392 A1E7           0C                     00  or	al,*0
35393                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35394 A1E9           30E4                       xor	ah,ah
35395 A1EB           8946         12            mov	$12[bp],ax
35396                                           !BCC_EOS
35397                                           ! 4992           break;
35398 A1EE           E9         00D1            br 	.707
35399                                           !BCC_EOS
35400                                           ! 4993         case 1:
35401                                           ! 4994           CX = 0x2709;
35402                       0000A1F1            .70B:
35403                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35404 A1F1           B8                   2709  mov	ax,#$2709
35405 A1F4           8946         14            mov	$14[bp],ax
35406                                           !BCC_EOS
35407                                           ! 4995           DX = ((DX & 0x00ff) | ((1) << 8));
35408                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35409 A1F7           8A46         12            mov	al,$12[bp]
35410                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35411 A1FA           30E4                       xor	ah,ah
35412 A1FC           0D                   0100  or	ax,#$100
35413                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35414 A1FF           8946         12            mov	$12[bp],ax
35415                                           !BCC_EOS
35416                                           ! 4996           break;
35417 A202           E9         00BD            br 	.707
35418                                           !BCC_EOS
35419                                           ! 4997         case 2:
35420                                           ! 4998           CX = 0x4f0f;
35421                       0000A205            .70C:
35422                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
35423 A205           B8                   4F0F  mov	ax,#$4F0F
35424 A208           8946         14            mov	$14[bp],ax
35425                                           !BCC_EOS
35426                                           ! 4999           DX = ((DX & 0x00ff) | ((1) << 8));
35427                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35428 A20B           8A46         12            mov	al,$12[bp]
35429                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35430 A20E           30E4                       xor	ah,ah
35431 A210           0D                   0100  or	ax,#$100
35432                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35433 A213           8946         12            mov	$12[bp],ax
35434                                           !BCC_EOS
35435                                           ! 5000           break;
35436 A216           E9         00A9            br 	.707
35437                                           !BCC_EOS
35438                                           ! 5001         case 3:
35439                                           ! 5002           CX = 0x4f09;
35440                       0000A219            .70D:
35441                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
35442 A219           B8                   4F09  mov	ax,#$4F09
35443 A21C           8946         14            mov	$14[bp],ax
35444                                           !BCC_EOS
35445                                           ! 5003           DX = ((DX & 0x00ff) | ((1) << 8));
35446                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35447 A21F           8A46         12            mov	al,$12[bp]
35448                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35449 A222           30E4                       xor	ah,ah
35450 A224           0D                   0100  or	ax,#$100
35451                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35452 A227           8946         12            mov	$12[bp],ax
35453                                           !BCC_EOS
35454                                           ! 5004           break;
35455 A22A           E9         0095            br 	.707
35456                                           !BCC_EOS
35457                                           ! 5005         case 4:
35458                                           ! 5006           CX = 0x4f12;
35459                       0000A22D            .70E:
35460                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
35461 A22D           B8                   4F12  mov	ax,#$4F12
35462 A230           8946         14            mov	$14[bp],ax
35463                                           !BCC_EOS
35464                                           ! 5007           DX = ((DX & 0x00ff) | ((1) << 8));
35465                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35466 A233           8A46         12            mov	al,$12[bp]
35467                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35468 A236           30E4                       xor	ah,ah
35469 A238           0D                   0100  or	ax,#$100
35470                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35471 A23B           8946         12            mov	$12[bp],ax
35472                                           !BCC_EOS
35473                                           ! 5008           break;
35474 A23E           E9         0081            br 	.707
35475                                           !BCC_EOS
35476                                           ! 5009         case 5:
35477                                           ! 5010           CX = 0x4f24;
35478                       0000A241            .70F:
35479                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
35480 A241           B8                   4F24  mov	ax,#$4F24
35481 A244           8946         14            mov	$14[bp],ax
35482                                           !BCC_EOS
35483                                           ! 5011           DX = ((DX & 0x00ff) | ((1) << 8));
35484                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35485 A247           8A46         12            mov	al,$12[bp]
35486                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35487 A24A           30E4                       xor	ah,ah
35488 A24C           0D                   0100  or	ax,#$100
35489                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35490 A24F           8946         12            mov	$12[bp],ax
35491                                           !BCC_EOS
35492                                           ! 5012           break;
35493 A252           EB           6E            jmp .707
35494                                           !BCC_EOS
35495                                           ! 5013         case 6:
35496                                           ! 5014           CX = 0x2708;
35497                       0000A254            .710:
35498                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35499 A254           B8                   2708  mov	ax,#$2708
35500 A257           8946         14            mov	$14[bp],ax
35501                                           !BCC_EOS
35502                                           ! 5015           DX = ((DX & 0x00ff) | ((0) << 8));
35503                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35504 A25A           8A46         12            mov	al,$12[bp]
35505                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35506 A25D           0C                     00  or	al,*0
35507                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35508 A25F           30E4                       xor	ah,ah
35509 A261           8946         12            mov	$12[bp],ax
35510                                           !BCC_EOS
35511                                           ! 5016           break;
35512 A264           EB           5C            jmp .707
35513                                           !BCC_EOS
35514                                           ! 5017         case 7:
35515                                           ! 5018           CX = 0x2709;
35516                       0000A266            .711:
35517                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35518 A266           B8                   2709  mov	ax,#$2709
35519 A269           8946         14            mov	$14[bp],ax
35520                                           !BCC_EOS
35521                                           ! 5019           DX = ((DX & 0x00ff) | ((0) << 8));
35522                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35523 A26C           8A46         12            mov	al,$12[bp]
35524                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35525 A26F           0C                     00  or	al,*0
35526                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35527 A271           30E4                       xor	ah,ah
35528 A273           8946         12            mov	$12[bp],ax
35529                                           !BCC_EOS
35530                                           ! 5020           break;
35531 A276           EB           4A            jmp .707
35532                                           !BCC_EOS
35533                                           ! 5021         case 8:
35534                                           ! 5022           CX = 0x2708;
35535                       0000A278            .712:
35536                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35537 A278           B8                   2708  mov	ax,#$2708
35538 A27B           8946         14            mov	$14[bp],ax
35539                                           !BCC_EOS
35540                                           ! 5023           DX = ((DX & 0x00ff) | ((1) << 8));
35541                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35542 A27E           8A46         12            mov	al,$12[bp]
35543                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35544 A281           30E4                       xor	ah,ah
35545 A283           0D                   0100  or	ax,#$100
35546                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35547 A286           8946         12            mov	$12[bp],ax
35548                                           !BCC_EOS
35549                                           ! 5024           break;
35550 A289           EB           37            jmp .707
35551                                           !BCC_EOS
35552                                           ! 5025         default:
35553                                           ! 5026           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
35554                       0000A28B            .713:
35555                                           ! Debug: list * char = .714+0 (used reg = )
35556 A28B           BB                   CD52  mov	bx,#.714
35557 A28E           53                         push	bx
35558                                           ! Debug: list int = const 7 (used reg = )
35559 A28F           B8                   0007  mov	ax,*7
35560 A292           50                         push	ax
35561                                           ! Debug: func () void = bios_printf+0 (used reg = )
35562 A293           E8         6711            call	_bios_printf
35563 A296           83C4                   04  add	sp,*4
35564                                           !BCC_EOS
35565                                           ! 5027         }
35566                                           ! 5028 #asm
35567 A299           EB           27            jmp .707
35568                       0000A29B            .709:
35569 A29B           2C                     00  sub	al,*0
35570 A29D           72           EC            jb 	.713
35571 A29F           3C                     08  cmp	al,*8
35572 A2A1           77           1D            ja  	.715
35573 A2A3           30E4                       xor	ah,ah
35574 A2A5           D1E0                       shl	ax,*1
35575 A2A7           89C3                       mov	bx,ax
35576 A2A9           2E                         seg	cs
35577 A2AA           FFA7       A2AE            br	.716[bx]
35578                       0000A2AE            .716:
35579 A2AE                      A1DF            .word	.70A
35580 A2B0                      A1F1            .word	.70B
35581 A2B2                      A205            .word	.70C
35582 A2B4                      A219            .word	.70D
35583 A2B6                      A22D            .word	.70E
35584 A2B8                      A241            .word	.70F
35585 A2BA                      A254            .word	.710
35586 A2BC                      A266            .word	.711
35587 A2BE                      A278            .word	.712
35588                       0000A2C0            .715:
35589 A2C0           EB           C9            jmp	.713
35590                       0000A2C2            .707:
35591                                           !BCC_EOS
35592                                           !BCC_ASM
35593                       0000002A            _int13_diskette_function.BP	set	$2A
35594                       0000000C            .int13_diskette_function.BP	set	$C
35595                       00000038            _int13_diskette_function.CS	set	$38
35596                       0000001A            .int13_diskette_function.CS	set	$1A
35597                       00000032            _int13_diskette_function.CX	set	$32
35598                       00000014            .int13_diskette_function.CX	set	$14
35599                       00000016            _int13_diskette_function.base_address	set	$16
35600                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
35601                       00000026            _int13_diskette_function.DI	set	$26
35602                       00000008            .int13_diskette_function.DI	set	8
35603                       0000003A            _int13_diskette_function.FLAGS	set	$3A
35604                       0000001C            .int13_diskette_function.FLAGS	set	$1C
35605                       00000014            _int13_diskette_function.base_count	set	$14
35606                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
35607                       0000001A            _int13_diskette_function.sector	set	$1A
35608                       FFFFFFFC            .int13_diskette_function.sector	set	-4
35609                       00000022            _int13_diskette_function.DS	set	$22
35610                       00000004            .int13_diskette_function.DS	set	4
35611                       00000019            _int13_diskette_function.head	set	$19
35612                       FFFFFFFB            .int13_diskette_function.head	set	-5
35613                       0000002C            _int13_diskette_function.ELDX	set	$2C
35614                       0000000E            .int13_diskette_function.ELDX	set	$E
35615                       0000000E            _int13_diskette_function.dor	set	$E
35616                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
35617                       00000030            _int13_diskette_function.DX	set	$30
35618                       00000012            .int13_diskette_function.DX	set	$12
35619                       00000007            _int13_diskette_function.return_status	set	7
35620                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
35621                       00000002            _int13_diskette_function.es	set	2
35622                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
35623                       00000010            _int13_diskette_function.mode_register	set	$10
35624                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
35625                       00000024            _int13_diskette_function.ES	set	$24
35626                       00000006            .int13_diskette_function.ES	set	6
35627                       00000012            _int13_diskette_function.base_es	set	$12
35628                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
35629                       0000001B            _int13_diskette_function.track	set	$1B
35630                       FFFFFFFD            .int13_diskette_function.track	set	-3
35631                       00000028            _int13_diskette_function.SI	set	$28
35632                       0000000A            .int13_diskette_function.SI	set	$A
35633                       00000006            _int13_diskette_function.drive_type	set	6
35634                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
35635                       0000001C            _int13_diskette_function.num_sectors	set	$1C
35636                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
35637                       00000036            _int13_diskette_function.IP	set	$36
35638                       00000018            .int13_diskette_function.IP	set	$18
35639                       00000018            _int13_diskette_function.status	set	$18
35640                       FFFFFFFA            .int13_diskette_function.status	set	-6
35641                       00000034            _int13_diskette_function.AX	set	$34
35642                       00000016            .int13_diskette_function.AX	set	$16
35643                       0000000F            _int13_diskette_function.val8	set	$F
35644                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
35645                       00000000            _int13_diskette_function.last_addr	set	0
35646                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
35647                       00000011            _int13_diskette_function.page	set	$11
35648                       FFFFFFF3            .int13_diskette_function.page	set	-$D
35649                       00000004            _int13_diskette_function.ah	set	4
35650                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
35651                       0000001D            _int13_diskette_function.drive	set	$1D
35652                       FFFFFFFF            .int13_diskette_function.drive	set	-1
35653                       00000005            _int13_diskette_function.num_floppies	set	5
35654                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
35655                       0000002E            _int13_diskette_function.BX	set	$2E
35656                       00000010            .int13_diskette_function.BX	set	$10
35657 A2C2           55                               push bp
35658 A2C3           89E5                             mov bp, sp
35659 A2C5           B8                   EFDE        mov ax, #diskette_param_table2
35660 A2C8           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
35661 A2CB           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
35662 A2CE           5D                               pop bp
35663                                           ! 5035 endasm
35664                                           !BCC_ENDASM
35665                                           !BCC_EOS
35666                                           ! 5036       FLAGS &= 0xfffe;
35667                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35668 A2CF           8B46         1C            mov	ax,$1C[bp]
35669 A2D2           24                     FE  and	al,#$FE
35670 A2D4           8946         1C            mov	$1C[bp],ax
35671                                           !BCC_EOS
35672                                           ! 5037       return;
35673 A2D7           89EC                       mov	sp,bp
35674 A2D9           5D                         pop	bp
35675 A2DA           C3                         ret
35676                                           !BCC_EOS
35677                                           ! 5038     case 0x15:
35678                                           ! 5039 ;
35679                       0000A2DB            .717:
35680                                           !BCC_EOS
35681                                           ! 5040       drive = ( ELDX & 0x00ff );
35682                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35683 A2DB           8A46         0E            mov	al,$E[bp]
35684                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35685 A2DE           8846         FF            mov	-1[bp],al
35686                                           !BCC_EOS
35687                                           ! 5041       if (drive > 1) {
35688                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35689 A2E1           8A46         FF            mov	al,-1[bp]
35690 A2E4           3C                     01  cmp	al,*1
35691 A2E6           76           16            jbe 	.718
35692                       0000A2E8            .719:
35693                                           ! 5042         AX = ((AX & 0x00ff) | ((0) << 8));
35694                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35695 A2E8           8A46         16            mov	al,$16[bp]
35696                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35697 A2EB           0C                     00  or	al,*0
35698                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35699 A2ED           30E4                       xor	ah,ah
35700 A2EF           8946         16            mov	$16[bp],ax
35701                                           !BCC_EOS
35702                                           ! 5043         FLAGS |= 0x0001;
35703                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35704 A2F2           8B46         1C            mov	ax,$1C[bp]
35705 A2F5           0C                     01  or	al,*1
35706 A2F7           8946         1C            mov	$1C[bp],ax
35707                                           !BCC_EOS
35708                                           ! 5044         return;
35709 A2FA           89EC                       mov	sp,bp
35710 A2FC           5D                         pop	bp
35711 A2FD           C3                         ret
35712                                           !BCC_EOS
35713                                           ! 5045       }
35714                                           ! 5046       drive_type = inb_cmos(0x10);
35715                       0000A2FE            .718:
35716                                           ! Debug: list int = const $10 (used reg = )
35717 A2FE           B8                   0010  mov	ax,*$10
35718 A301           50                         push	ax
35719                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35720 A302           E8         6282            call	_inb_cmos
35721 A305           44                         inc	sp
35722 A306           44                         inc	sp
35723                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35724 A307           8846         E8            mov	-$18[bp],al
35725                                           !BCC_EOS
35726                                           ! 5047       if (drive == 0)
35727                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35728 A30A           8A46         FF            mov	al,-1[bp]
35729 A30D           84C0                       test	al,al
35730 A30F           75           0E            jne 	.71A
35731                       0000A311            .71B:
35732                                           ! 5048         drive_type >>= 4;
35733                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35734 A311           8A46         E8            mov	al,-$18[bp]
35735 A314           30E4                       xor	ah,ah
35736 A316           B1                     04  mov	cl,*4
35737 A318           D3E8                       shr	ax,cl
35738 A31A           8846         E8            mov	-$18[bp],al
35739                                           !BCC_EOS
35740                                           ! 5049       else
35741                                           ! 5050         drive_type &= 0x0f;
35742 A31D           EB           08            jmp .71C
35743                       0000A31F            .71A:
35744                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35745 A31F           8A46         E8            mov	al,-$18[bp]
35746 A322           24                     0F  and	al,*$F
35747 A324           8846         E8            mov	-$18[bp],al
35748                                           !BCC_EOS
35749                                           ! 5051       FLAGS &= 0xfffe;
35750                       0000A327            .71C:
35751                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35752 A327           8B46         1C            mov	ax,$1C[bp]
35753 A32A           24                     FE  and	al,#$FE
35754 A32C           8946         1C            mov	$1C[bp],ax
35755                                           !BCC_EOS
35756                                           ! 5052       if (drive_type==0) {
35757                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35758 A32F           8A46         E8            mov	al,-$18[bp]
35759 A332           84C0                       test	al,al
35760 A334           75           0C            jne 	.71D
35761                       0000A336            .71E:
35762                                           ! 5053         AX = ((AX & 0x00ff) | (
35763                                           ! 5053 (0) << 8));
35764                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35765 A336           8A46         16            mov	al,$16[bp]
35766                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35767 A339           0C                     00  or	al,*0
35768                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35769 A33B           30E4                       xor	ah,ah
35770 A33D           8946         16            mov	$16[bp],ax
35771                                           !BCC_EOS
35772                                           ! 5054       }
35773                                           ! 5055       else {
35774 A340           EB           0B            jmp .71F
35775                       0000A342            .71D:
35776                                           ! 5056         AX = ((AX & 0x00ff) | ((1) << 8));
35777                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35778 A342           8A46         16            mov	al,$16[bp]
35779                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35780 A345           30E4                       xor	ah,ah
35781 A347           0D                   0100  or	ax,#$100
35782                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35783 A34A           8946         16            mov	$16[bp],ax
35784                                           !BCC_EOS
35785                                           ! 5057       }
35786                                           ! 5058       return;
35787                       0000A34D            .71F:
35788 A34D           89EC                       mov	sp,bp
35789 A34F           5D                         pop	bp
35790 A350           C3                         ret
35791                                           !BCC_EOS
35792                                           ! 5059     case 0x16:
35793                                           ! 5060 ;
35794                       0000A351            .720:
35795                                           !BCC_EOS
35796                                           ! 5061       drive = ( ELDX & 0x00ff );
35797                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35798 A351           8A46         0E            mov	al,$E[bp]
35799                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35800 A354           8846         FF            mov	-1[bp],al
35801                                           !BCC_EOS
35802                                           ! 5062       if (drive > 1) {
35803                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35804 A357           8A46         FF            mov	al,-1[bp]
35805 A35A           3C                     01  cmp	al,*1
35806 A35C           76           20            jbe 	.721
35807                       0000A35E            .722:
35808                                           ! 5063         AX = ((AX & 0x00ff) | ((0x01) << 8));
35809                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35810 A35E           8A46         16            mov	al,$16[bp]
35811                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35812 A361           30E4                       xor	ah,ah
35813 A363           0D                   0100  or	ax,#$100
35814                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35815 A366           8946         16            mov	$16[bp],ax
35816                                           !BCC_EOS
35817                                           ! 5064         set_diskette_ret_status(0x01);
35818                                           ! Debug: list int = const 1 (used reg = )
35819 A369           B8                   0001  mov	ax,*1
35820 A36C           50                         push	ax
35821                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35822 A36D           E8         00E9            call	_set_diskette_ret_status
35823 A370           44                         inc	sp
35824 A371           44                         inc	sp
35825                                           !BCC_EOS
35826                                           ! 5065         FLAGS |= 0x0001;
35827                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35828 A372           8B46         1C            mov	ax,$1C[bp]
35829 A375           0C                     01  or	al,*1
35830 A377           8946         1C            mov	$1C[bp],ax
35831                                           !BCC_EOS
35832                                           ! 5066         return;
35833 A37A           89EC                       mov	sp,bp
35834 A37C           5D                         pop	bp
35835 A37D           C3                         ret
35836                                           !BCC_EOS
35837                                           ! 5067       }
35838                                           ! 5068       AX = ((AX & 0x00ff) | ((0x06) << 8));
35839                       0000A37E            .721:
35840                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35841 A37E           8A46         16            mov	al,$16[bp]
35842                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
35843 A381           30E4                       xor	ah,ah
35844 A383           0D                   0600  or	ax,#$600
35845                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35846 A386           8946         16            mov	$16[bp],ax
35847                                           !BCC_EOS
35848                                           ! 5069       set_diskette_ret_status(0x06);
35849                                           ! Debug: list int = const 6 (used reg = )
35850 A389           B8                   0006  mov	ax,*6
35851 A38C           50                         push	ax
35852                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35853 A38D           E8         00C9            call	_set_diskette_ret_status
35854 A390           44                         inc	sp
35855 A391           44                         inc	sp
35856                                           !BCC_EOS
35857                                           ! 5070       FLAGS |= 0x0001;
35858                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35859 A392           8B46         1C            mov	ax,$1C[bp]
35860 A395           0C                     01  or	al,*1
35861 A397           8946         1C            mov	$1C[bp],ax
35862                                           !BCC_EOS
35863                                           ! 5071       return;
35864 A39A           89EC                       mov	sp,bp
35865 A39C           5D                         pop	bp
35866 A39D           C3                         ret
35867                                           !BCC_EOS
35868                                           ! 5072     case 0x17:
35869                                           ! 5073 ;
35870                       0000A39E            .723:
35871                                           !BCC_EOS
35872                                           ! 5074       AX = ((AX & 0x00ff) | ((0x01) << 8));
35873                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35874 A39E           8A46         16            mov	al,$16[bp]
35875                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35876 A3A1           30E4                       xor	ah,ah
35877 A3A3           0D                   0100  or	ax,#$100
35878                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35879 A3A6           8946         16            mov	$16[bp],ax
35880                                           !BCC_EOS
35881                                           ! 5075       set_diskette_ret_status(1);
35882                                           ! Debug: list int = const 1 (used reg = )
35883 A3A9           B8                   0001  mov	ax,*1
35884 A3AC           50                         push	ax
35885                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35886 A3AD           E8         00A9            call	_set_diskette_ret_status
35887 A3B0           44                         inc	sp
35888 A3B1           44                         inc	sp
35889                                           !BCC_EOS
35890                                           ! 5076       FLAGS |= 0x0001;
35891                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35892 A3B2           8B46         1C            mov	ax,$1C[bp]
35893 A3B5           0C                     01  or	al,*1
35894 A3B7           8946         1C            mov	$1C[bp],ax
35895                                           !BCC_EOS
35896                                           ! 5077       return;
35897 A3BA           89EC                       mov	sp,bp
35898 A3BC           5D                         pop	bp
35899 A3BD           C3                         ret
35900                                           !BCC_EOS
35901                                           ! 5078     case 0x18:
35902                                           ! 5079 ;
35903                       0000A3BE            .724:
35904                                           !BCC_EOS
35905                                           ! 5080       AX = ((AX & 0x00ff) | ((0x01) << 8));
35906                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35907 A3BE           8A46         16            mov	al,$16[bp]
35908                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35909 A3C1           30E4                       xor	ah,ah
35910 A3C3           0D                   0100  or	ax,#$100
35911                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35912 A3C6           8946         16            mov	$16[bp],ax
35913                                           !BCC_EOS
35914                                           ! 5081       set_diskette_ret_status(1);
35915                                           ! Debug: list int = const 1 (used reg = )
35916 A3C9           B8                   0001  mov	ax,*1
35917 A3CC           50                         push	ax
35918                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35919 A3CD           E8         0089            call	_set_diskette_ret_status
35920 A3D0           44                         inc	sp
35921 A3D1           44                         inc	sp
35922                                           !BCC_EOS
35923                                           ! 5082       FLAGS |= 0x0001;
35924                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35925 A3D2           8B46         1C            mov	ax,$1C[bp]
35926 A3D5           0C                     01  or	al,*1
35927 A3D7           8946         1C            mov	$1C[bp],ax
35928                                           !BCC_EOS
35929                                           ! 5083       return;
35930 A3DA           89EC                       mov	sp,bp
35931 A3DC           5D                         pop	bp
35932 A3DD           C3                         ret
35933                                           !BCC_EOS
35934                                           ! 5084     default:
35935                                           ! 5085         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
35936                       0000A3DE            .725:
35937                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
35938 A3DE           8B46         16            mov	ax,$16[bp]
35939 A3E1           88E0                       mov	al,ah
35940 A3E3           30E4                       xor	ah,ah
35941                                           ! Debug: list unsigned int = ax+0 (used reg = )
35942 A3E5           50                         push	ax
35943                                           ! Debug: list * char = .726+0 (used reg = )
35944 A3E6           BB                   CD2D  mov	bx,#.726
35945 A3E9           53                         push	bx
35946                                           ! Debug: list int = const 4 (used reg = )
35947 A3EA           B8                   0004  mov	ax,*4
35948 A3ED           50                         push	ax
35949                                           ! Debug: func () void = bios_printf+0 (used reg = )
35950 A3EE           E8         65B6            call	_bios_printf
35951 A3F1           83C4                   06  add	sp,*6
35952                                           !BCC_EOS
35953                                           ! 5086         AX = ((AX & 0x00ff) | ((0x01) << 8));
35954                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35955 A3F4           8A46         16            mov	al,$16[bp]
35956                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35957 A3F7           30E4                       xor	ah,ah
35958 A3F9           0D                   0100  or	ax,#$100
35959                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35960 A3FC           8946         16            mov	$16[bp],ax
35961                                           !BCC_EOS
35962                                           ! 5087         set_diskette_ret_status(1);
35963                                           ! Debug: list int = const 1 (used reg = )
35964 A3FF           B8                   0001  mov	ax,*1
35965 A402           50                         push	ax
35966                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35967 A403           E8         0053            call	_set_diskette_ret_status
35968 A406           44                         inc	sp
35969 A407           44                         inc	sp
35970                                           !BCC_EOS
35971                                           ! 5088         FLAGS |= 0x0001;
35972                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35973 A408           8B46         1C            mov	ax,$1C[bp]
35974 A40B           0C                     01  or	al,*1
35975 A40D           8946         1C            mov	$1C[bp],ax
35976                                           !BCC_EOS
35977                                           ! 5089         return;
35978 A410           89EC                       mov	sp,bp
35979 A412           5D                         pop	bp
35980 A413           C3                         ret
35981                                           !BCC_EOS
35982                                           ! 5090     }
35983                                           ! 5091 }
35984 A414           EB           3F            jmp .697
35985                       0000A416            .699:
35986 A416           2C                     00  sub	al,*0
35987 A418           72           C4            jb 	.725
35988 A41A           3C                     08  cmp	al,*8
35989 A41C           77           1D            ja  	.727
35990 A41E           30E4                       xor	ah,ah
35991 A420           D1E0                       shl	ax,*1
35992 A422           89C3                       mov	bx,ax
35993 A424           2E                         seg	cs
35994 A425           FFA7       A429            br	.728[bx]
35995                       0000A429            .728:
35996 A429                      9353            .word	.69A
35997 A42B                      93FD            .word	.6A2
35998 A42D                      943F            .word	.6A5
35999 A42F                      943F            .word	.6A6
36000 A431                      943F            .word	.6A7
36001 A433                      9CD8            .word	.6DD
36002 A435                      A3DE            .word	.725
36003 A437                      A3DE            .word	.725
36004 A439                      A115            .word	.6FD
36005                       0000A43B            .727:
36006 A43B           2C                     15  sub	al,*$15
36007 A43D         0F84         FE9A            beq 	.717
36008 A441           2C                     01  sub	al,*1
36009 A443         0F84         FF0A            beq 	.720
36010 A447           2C                     01  sub	al,*1
36011 A449         0F84         FF51            beq 	.723
36012 A44D           2C                     01  sub	al,*1
36013 A44F         0F84         FF6B            beq 	.724
36014 A453           EB           89            jmp	.725
36015                       0000A455            .697:
36016                       FFFFFFE0            ..FFDC	=	-$20
36017 A455           89EC                       mov	sp,bp
36018 A457           5D                         pop	bp
36019 A458           C3                         ret
36020                                           ! 5092  void
36021                                           ! Register BX used in function int13_diskette_function
36022                                           ! 5093 set_diskette_ret_status(value)
36023                                           ! 5094   Bit8u value;
36024                                           export	_set_diskette_ret_status
36025                       0000A459            _set_diskette_ret_status:
36026                                           !BCC_EOS
36027                                           ! 5095 {
36028                                           ! 5096   write_byte(0x0040, 0x0041, value);
36029 A459           55                         push	bp
36030 A45A           89E5                       mov	bp,sp
36031                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
36032 A45C           8A46         04            mov	al,4[bp]
36033 A45F           30E4                       xor	ah,ah
36034 A461           50                         push	ax
36035                                           ! Debug: list int = const $41 (used reg = )
36036 A462           B8                   0041  mov	ax,*$41
36037 A465           50                         push	ax
36038                                           ! Debug: list int = const $40 (used reg = )
36039 A466           B8                   0040  mov	ax,*$40
36040 A469           50                         push	ax
36041                                           ! Debug: func () void = write_byte+0 (used reg = )
36042 A46A           E8         61B1            call	_write_byte
36043 A46D           89EC                       mov	sp,bp
36044                                           !BCC_EOS
36045                                           ! 5097 }
36046 A46F           5D                         pop	bp
36047 A470           C3                         ret
36048                                           ! 5098   void
36049                                           ! 5099 set_diskette_current_cyl(drive, cyl)
36050                                           ! 5100   Bit8u drive;
36051                                           export	_set_diskette_current_cyl
36052                       0000A471            _set_diskette_current_cyl:
36053                                           !BCC_EOS
36054                                           ! 5101   Bit8u cyl;
36055                                           !BCC_EOS
36056                                           ! 5102 {
36057                                           ! 5103   if (drive > 1)
36058 A471           55                         push	bp
36059 A472           89E5                       mov	bp,sp
36060                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
36061 A474           8A46         04            mov	al,4[bp]
36062 A477           3C                     01  cmp	al,*1
36063 A479           76           0D            jbe 	.729
36064                       0000A47B            .72A:
36065                                           ! 5104     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
36066                                           ! Debug: list * char = .72B+0 (used reg = )
36067 A47B           BB                   CD06  mov	bx,#.72B
36068 A47E           53                         push	bx
36069                                           ! Debug: list int = const 7 (used reg = )
36070 A47F           B8                   0007  mov	ax,*7
36071 A482           50                         push	ax
36072                                           ! Debug: func () void = bios_printf+0 (used reg = )
36073 A483           E8         6521            call	_bios_printf
36074 A486           89EC                       mov	sp,bp
36075                                           !BCC_EOS
36076                                           ! 5105   write_byte(0x0040, 0x0094+drive, cyl);
36077                       0000A488            .729:
36078                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
36079 A488           8A46         06            mov	al,6[bp]
36080 A48B           30E4                       xor	ah,ah
36081 A48D           50                         push	ax
36082                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
36083                                           ! Debug: expression subtree swapping
36084 A48E           8A46         04            mov	al,4[bp]
36085 A491           30E4                       xor	ah,ah
36086                                           ! Debug: list unsigned int = ax+$94 (used reg = )
36087 A493           05                   0094  add	ax,#$94
36088 A496           50                         push	ax
36089                                           ! Debug: list int = const $40 (used reg = )
36090 A497           B8                   0040  mov	ax,*$40
36091 A49A           50                         push	ax
36092                                           ! Debug: func () void = write_byte+0 (used reg = )
36093 A49B           E8         6180            call	_write_byte
36094 A49E           89EC                       mov	sp,bp
36095                                           !BCC_EOS
36096                                           ! 5106 }
36097 A4A0           5D                         pop	bp
36098 A4A1           C3                         ret
36099                                           ! 5107   void
36100                                           ! Register BX used in function set_diskette_current_cyl
36101                                           ! 5108 determine_floppy_media(drive)
36102                                           ! 5109   Bit16u drive;
36103                                           export	_determine_floppy_media
36104                       0000A4A2            _determine_floppy_media:
36105                                           !BCC_EOS
36106                                           ! 5110 {
36107                                           ! 5111 }
36108 A4A2           C3                         ret
36109                                           ! 5112   void
36110                                           ! 5113 int17_function(regs, ds, iret_addr)
36111                                           ! 5114   pusha_regs_t regs;
36112                                           export	_int17_function
36113                       0000A4A3            _int17_function:
36114                                           !BCC_EOS
36115                                           ! 5115   Bit16u ds;
36116                                           !BCC_EOS
36117                                           ! 5116   iret_addr_t iret_addr;
36118                                           !BCC_EOS
36119                                           ! 5117 {
36120                                           ! 5118   Bit16u addr,timeout;
36121                                           !BCC_EOS
36122                                           ! 5119   Bit8u val8;
36123                                           !BCC_EOS
36124                                           ! 5120 #asm
36125 A4A3           55                         push	bp
36126 A4A4           89E5                       mov	bp,sp
36127 A4A6           83C4                   FA  add	sp,*-6
36128                                           !BCC_EOS
36129                                           !BCC_ASM
36130                       0000001A            _int17_function.ds	set	$1A
36131                       00000014            .int17_function.ds	set	$14
36132                       00000002            _int17_function.timeout	set	2
36133                       FFFFFFFC            .int17_function.timeout	set	-4
36134                       00000001            _int17_function.val8	set	1
36135                       FFFFFFFB            .int17_function.val8	set	-5
36136                       0000001C            _int17_function.iret_addr	set	$1C
36137                       00000016            .int17_function.iret_addr	set	$16
36138                       00000004            _int17_function.addr	set	4
36139                       FFFFFFFE            .int17_function.addr	set	-2
36140                       0000000A            _int17_function.regs	set	$A
36141                       00000004            .int17_function.regs	set	4
36142 A4A9           FB                           sti
36143                                           ! 5122 endasm
36144                                           !BCC_ENDASM
36145                                           !BCC_EOS
36146                                           ! 5123   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
36147                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
36148 A4AA           8B46         0E            mov	ax,$E[bp]
36149 A4AD           D1E0                       shl	ax,*1
36150                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
36151                                           ! Debug: list unsigned int = ax+8 (used reg = )
36152 A4AF           05                   0008  add	ax,*8
36153 A4B2           50                         push	ax
36154                                           ! Debug: list int = const $40 (used reg = )
36155 A4B3           B8                   0040  mov	ax,*$40
36156 A4B6           50                         push	ax
36157                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36158 A4B7           E8         6151            call	_read_word
36159 A4BA           83C4                   04  add	sp,*4
36160                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
36161 A4BD           8946         FE            mov	-2[bp],ax
36162                                           !BCC_EOS
36163                                           ! 5124   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
36164                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
36165 A4C0           8A46         13            mov	al,$13[bp]
36166 A4C3           3C                     03  cmp	al,*3
36167 A4C5         0F83         0106            bhis	.72C
36168                       0000A4C9            .72F:
36169                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
36170 A4C9           8B46         0E            mov	ax,$E[bp]
36171 A4CC           3D                   0003  cmp	ax,*3
36172 A4CF         0F83         00FC            bhis	.72C
36173                       0000A4D3            .72E:
36174                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
36175 A4D3           8B46         FE            mov	ax,-2[bp]
36176 A4D6           85C0                       test	ax,ax
36177 A4D8         0F84         00F3            beq 	.72C
36178                       0000A4DC            .72D:
36179                                           ! 5125     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
36180                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
36181                                           ! Debug: expression subtree swapping
36182 A4DC           8B46         0E            mov	ax,$E[bp]
36183                                           ! Debug: list unsigned int = ax+$78 (used reg = )
36184 A4DF           05                   0078  add	ax,*$78
36185 A4E2           50                         push	ax
36186                                           ! Debug: list int = const $40 (used reg = )
36187 A4E3           B8                   0040  mov	ax,*$40
36188 A4E6           50                         push	ax
36189                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
36190 A4E7           E8         610E            call	_read_byte
36191 A4EA           83C4                   04  add	sp,*4
36192                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
36193 A4ED           30E4                       xor	ah,ah
36194 A4EF           88C4                       mov	ah,al
36195 A4F1           30C0                       xor	al,al
36196                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
36197 A4F3           8946         FC            mov	-4[bp],ax
36198                                           !BCC_EOS
36199                                           ! 5126     if (regs.u.r8.ah == 0) {
36200                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
36201 A4F6           8A46         13            mov	al,$13[bp]
36202 A4F9           84C0                       test	al,al
36203 A4FB           75           66            jne 	.730
36204                       0000A4FD            .731:
36205                                           ! 5127       outb(addr, regs.u.r8.al);
36206                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
36207 A4FD           8A46         12            mov	al,$12[bp]
36208 A500           30E4                       xor	ah,ah
36209 A502           50                         push	ax
36210                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
36211 A503           FF76         FE            push	-2[bp]
36212                                           ! Debug: func () void = outb+0 (used reg = )
36213 A506           E8         604F            call	_outb
36214 A509           83C4                   04  add	sp,*4
36215                                           !BCC_EOS
36216                                           ! 5128       val8 = inb(addr+2);
36217                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36218 A50C           8B46         FE            mov	ax,-2[bp]
36219                                           ! Debug: list unsigned int = ax+2 (used reg = )
36220 A50F           40                         inc	ax
36221 A510           40                         inc	ax
36222 A511           50                         push	ax
36223                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36224 A512           E8         602D            call	_inb
36225 A515           44                         inc	sp
36226 A516           44                         inc	sp
36227                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36228 A517           8846         FB            mov	-5[bp],al
36229                                           !BCC_EOS
36230                                           ! 5129       outb(addr+2, val8 | 0x01);
36231                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
36232 A51A           8A46         FB            mov	al,-5[bp]
36233 A51D           0C                     01  or	al,*1
36234                                           ! Debug: list unsigned char = al+0 (used reg = )
36235 A51F           30E4                       xor	ah,ah
36236 A521           50                         push	ax
36237                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36238 A522           8B46         FE            mov	ax,-2[bp]
36239                                           ! Debug: list unsigned int = ax+2 (used reg = )
36240 A525           40                         inc	ax
36241 A526           40                         inc	ax
36242 A527           50                         push	ax
36243                                           ! Debug: func () void = outb+0 (used reg = )
36244 A528           E8         602D            call	_outb
36245 A52B           83C4                   04  add	sp,*4
36246                                           !BCC_EOS
36247                                           ! 5130 #asm
36248                                           !BCC_EOS
36249                                           !BCC_ASM
36250                       0000001A            _int17_function.ds	set	$1A
36251                       00000014            .int17_function.ds	set	$14
36252                       00000002            _int17_function.timeout	set	2
36253                       FFFFFFFC            .int17_function.timeout	set	-4
36254                       00000001            _int17_function.val8	set	1
36255                       FFFFFFFB            .int17_function.val8	set	-5
36256                       0000001C            _int17_function.iret_addr	set	$1C
36257                       00000016            .int17_function.iret_addr	set	$16
36258                       00000004            _int17_function.addr	set	4
36259                       FFFFFFFE            .int17_function.addr	set	-2
36260                       0000000A            _int17_function.regs	set	$A
36261                       00000004            .int17_function.regs	set	4
36262 A52E           90                               nop
36263                                           ! 5132 endasm
36264                                           !BCC_ENDASM
36265                                           !BCC_EOS
36266                                           ! 5133       outb(addr+2, val8 & ~0x01);
36267                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
36268 A52F           8A46         FB            mov	al,-5[bp]
36269 A532           24                     FE  and	al,#$FE
36270                                           ! Debug: list unsigned char = al+0 (used reg = )
36271 A534           30E4                       xor	ah,ah
36272 A536           50                         push	ax
36273                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36274 A537           8B46         FE            mov	ax,-2[bp]
36275                                           ! Debug: list unsigned int = ax+2 (used reg = )
36276 A53A           40                         inc	ax
36277 A53B           40                         inc	ax
36278 A53C           50                         push	ax
36279                                           ! Debug: func () void = outb+0 (used reg = )
36280 A53D           E8         6018            call	_outb
36281 A540           83C4                   04  add	sp,*4
36282                                           !BCC_EOS
36283                                           ! 5134       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
36284 A543           EB           07            jmp .733
36285                       0000A545            .734:
36286                                           ! 5135         timeout--;
36287                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
36288 A545           8B46         FC            mov	ax,-4[bp]
36289 A548           48                         dec	ax
36290 A549           8946         FC            mov	-4[bp],ax
36291                                           !BCC_EOS
36292                                           ! 5136       }
36293                                           ! 5137     }
36294                       0000A54C            .733:
36295                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36296 A54C           8B46         FE            mov	ax,-2[bp]
36297                                           ! Debug: list unsigned int = ax+1 (used reg = )
36298 A54F           40                         inc	ax
36299 A550           50                         push	ax
36300                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36301 A551           E8         5FEE            call	_inb
36302 A554           44                         inc	sp
36303 A555           44                         inc	sp
36304                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
36305 A556           24                     40  and	al,*$40
36306                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
36307 A558           3C                     40  cmp	al,*$40
36308 A55A           75           07            jne 	.735
36309                       0000A55C            .736:
36310 A55C           8B46         FC            mov	ax,-4[bp]
36311 A55F           85C0                       test	ax,ax
36312 A561           75           E2            jne	.734
36313                       0000A563            .735:
36314                       0000A563            .732:
36315                                           ! 5138     if (regs.u.r8.ah == 1) {
36316                       0000A563            .730:
36317                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36318 A563           8A46         13            mov	al,$13[bp]
36319 A566           3C                     01  cmp	al,*1
36320 A568           75           37            jne 	.737
36321                       0000A56A            .738:
36322                                           ! 5139       val8 = inb(addr+2);
36323                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36324 A56A           8B46         FE            mov	ax,-2[bp]
36325                                           ! Debug: list unsigned int = ax+2 (used reg = )
36326 A56D           40                         inc	ax
36327 A56E           40                         inc	ax
36328 A56F           50                         push	ax
36329                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36330 A570           E8         5FCF            call	_inb
36331 A573           44                         inc	sp
36332 A574           44                         inc	sp
36333                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36334 A575           8846         FB            mov	-5[bp],al
36335                                           !BCC_EOS
36336                                           ! 5140       outb(addr+2, val8 & ~0x04);
36337                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
36338 A578           8A46         FB            mov	al,-5[bp]
36339 A57B           24                     FB  and	al,#$FB
36340                                           ! Debug: list unsigned char = al+0 (used reg = )
36341 A57D           30E4                       xor	ah,ah
36342 A57F           50                         push	ax
36343                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36344 A580           8B46         FE            mov	ax,-2[bp]
36345                                           ! Debug: list unsigned int = ax+2 (used reg = )
36346 A583           40                         inc	ax
36347 A584           40                         inc	ax
36348 A585           50                         push	ax
36349                                           ! Debug: func () void = outb+0 (used reg = )
36350 A586           E8         5FCF            call	_outb
36351 A589           83C4                   04  add	sp,*4
36352                                           !BCC_EOS
36353                                           ! 5141 #asm
36354                                           !BCC_EOS
36355                                           !BCC_ASM
36356                       0000001A            _int17_function.ds	set	$1A
36357                       00000014            .int17_function.ds	set	$14
36358                       00000002            _int17_function.timeout	set	2
36359                       FFFFFFFC            .int17_function.timeout	set	-4
36360                       00000001            _int17_function.val8	set	1
36361                       FFFFFFFB            .int17_function.val8	set	-5
36362                       0000001C            _int17_function.iret_addr	set	$1C
36363                       00000016            .int17_function.iret_addr	set	$16
36364                       00000004            _int17_function.addr	set	4
36365                       FFFFFFFE            .int17_function.addr	set	-2
36366                       0000000A            _int17_function.regs	set	$A
36367                       00000004            .int17_function.regs	set	4
36368 A58C           90                               nop
36369                                           ! 5143 endasm
36370                                           !BCC_ENDASM
36371                                           !BCC_EOS
36372                                           ! 5144       outb(addr+2, val8 | 0x04);
36373                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
36374 A58D           8A46         FB            mov	al,-5[bp]
36375 A590           0C                     04  or	al,*4
36376                                           ! Debug: list unsigned char = al+0 (used reg = )
36377 A592           30E4                       xor	ah,ah
36378 A594           50                         push	ax
36379                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36380 A595           8B46         FE            mov	ax,-2[bp]
36381                                           ! Debug: list unsigned int = ax+2 (used reg = )
36382 A598           40                         inc	ax
36383 A599           40                         inc	ax
36384 A59A           50                         push	ax
36385                                           ! Debug: func () void = outb+0 (used reg = )
36386 A59B           E8         5FBA            call	_outb
36387 A59E           83C4                   04  add	sp,*4
36388                                           !BCC_EOS
36389                                           ! 5145     }
36390                                           ! 5146     val8 = inb(addr+
36391                       0000A5A1            .737:
36392                                           ! 5146 1);
36393                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36394 A5A1           8B46         FE            mov	ax,-2[bp]
36395                                           ! Debug: list unsigned int = ax+1 (used reg = )
36396 A5A4           40                         inc	ax
36397 A5A5           50                         push	ax
36398                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36399 A5A6           E8         5F99            call	_inb
36400 A5A9           44                         inc	sp
36401 A5AA           44                         inc	sp
36402                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36403 A5AB           8846         FB            mov	-5[bp],al
36404                                           !BCC_EOS
36405                                           ! 5147     regs.u.r8.ah = (val8 ^ 0x48);
36406                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
36407 A5AE           8A46         FB            mov	al,-5[bp]
36408 A5B1           34                     48  xor	al,*$48
36409                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
36410 A5B3           8846         13            mov	$13[bp],al
36411                                           !BCC_EOS
36412                                           ! 5148     if (!timeout) regs.u.r8.ah |= 0x01;
36413 A5B6           8B46         FC            mov	ax,-4[bp]
36414 A5B9           85C0                       test	ax,ax
36415 A5BB           75           08            jne 	.739
36416                       0000A5BD            .73A:
36417                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36418 A5BD           8A46         13            mov	al,$13[bp]
36419 A5C0           0C                     01  or	al,*1
36420 A5C2           8846         13            mov	$13[bp],al
36421                                           !BCC_EOS
36422                                           ! 5149     iret_addr.flags.u.r8.flagsl &= 0xfe;
36423                       0000A5C5            .739:
36424                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
36425 A5C5           8A46         1A            mov	al,$1A[bp]
36426 A5C8           24                     FE  and	al,#$FE
36427 A5CA           8846         1A            mov	$1A[bp],al
36428                                           !BCC_EOS
36429                                           ! 5150   } else {
36430 A5CD           EB           08            jmp .73B
36431                       0000A5CF            .72C:
36432                                           ! 5151     iret_addr.flags.u.r8.flagsl |= 0x01;
36433                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
36434 A5CF           8A46         1A            mov	al,$1A[bp]
36435 A5D2           0C                     01  or	al,*1
36436 A5D4           8846         1A            mov	$1A[bp],al
36437                                           !BCC_EOS
36438                                           ! 5152   }
36439                                           ! 5153 }
36440                       0000A5D7            .73B:
36441 A5D7           89EC                       mov	sp,bp
36442 A5D9           5D                         pop	bp
36443 A5DA           C3                         ret
36444                                           ! 5154 void
36445                                           ! 5155 int19_function(seq_nr)
36446                                           ! 5156 Bit16u seq_nr;
36447                                           export	_int19_function
36448                       0000A5DB            _int19_function:
36449                                           !BCC_EOS
36450                                           ! 5157 {
36451                                           ! 5158   Bit16u ebda_seg=read_word(0x0040,0x000E);
36452 A5DB           55                         push	bp
36453 A5DC           89E5                       mov	bp,sp
36454 A5DE           4C                         dec	sp
36455 A5DF           4C                         dec	sp
36456                                           ! Debug: list int = const $E (used reg = )
36457 A5E0           B8                   000E  mov	ax,*$E
36458 A5E3           50                         push	ax
36459                                           ! Debug: list int = const $40 (used reg = )
36460 A5E4           B8                   0040  mov	ax,*$40
36461 A5E7           50                         push	ax
36462                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36463 A5E8           E8         6020            call	_read_word
36464 A5EB           83C4                   04  add	sp,*4
36465                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36466 A5EE           8946         FE            mov	-2[bp],ax
36467                                           !BCC_EOS
36468                                           ! 5159   Bit16u bootdev;
36469                                           !BCC_EOS
36470                                           ! 5160   Bit8u bootdrv;
36471                                           !BCC_EOS
36472                                           ! 5161   Bit8u bootchk;
36473                                           !BCC_EOS
36474                                           ! 5162   Bit16u bootseg;
36475                                           !BCC_EOS
36476                                           ! 5163   Bit16u bootip;
36477                                           !BCC_EOS
36478                                           ! 5164   Bit16u status;
36479                                           !BCC_EOS
36480                                           ! 5165   Bit16u bootfirst;
36481                                           !BCC_EOS
36482                                           ! 5166   ipl_entry_t e;
36483                                           !BCC_EOS
36484                                           ! 5167   bootdev = inb_cmos(0x3d);
36485 A5F1           83C4                   E4  add	sp,*-$1C
36486                                           ! Debug: list int = const $3D (used reg = )
36487 A5F4           B8                   003D  mov	ax,*$3D
36488 A5F7           50                         push	ax
36489                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36490 A5F8           E8         5F8C            call	_inb_cmos
36491 A5FB           44                         inc	sp
36492 A5FC           44                         inc	sp
36493                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36494 A5FD           30E4                       xor	ah,ah
36495 A5FF           8946         FC            mov	-4[bp],ax
36496                                           !BCC_EOS
36497                                           ! 5168   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
36498                                           ! Debug: list int = const $38 (used reg = )
36499 A602           B8                   0038  mov	ax,*$38
36500 A605           50                         push	ax
36501                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36502 A606           E8         5F7E            call	_inb_cmos
36503 A609           44                         inc	sp
36504 A60A           44                         inc	sp
36505                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
36506 A60B           24                     F0  and	al,#$F0
36507                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
36508 A60D           30E4                       xor	ah,ah
36509 A60F           B1                     04  mov	cl,*4
36510 A611           D3E0                       shl	ax,cl
36511                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36512 A613           0B46         FC            or	ax,-4[bp]
36513 A616           8946         FC            mov	-4[bp],ax
36514                                           !BCC_EOS
36515                                           ! 5169   bootdev >>= 4 * seq_nr;
36516                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
36517                                           ! Debug: expression subtree swapping
36518 A619           8B46         04            mov	ax,4[bp]
36519 A61C           D1E0                       shl	ax,*1
36520 A61E           D1E0                       shl	ax,*1
36521                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36522 A620           89C3                       mov	bx,ax
36523 A622           8B46         FC            mov	ax,-4[bp]
36524 A625           89D9                       mov	cx,bx
36525 A627           D3E8                       shr	ax,cl
36526 A629           8946         FC            mov	-4[bp],ax
36527                                           !BCC_EOS
36528                                           ! 5170   bootdev &= 0xf;
36529                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
36530 A62C           8A46         FC            mov	al,-4[bp]
36531 A62F           24                     0F  and	al,*$F
36532 A631           30E4                       xor	ah,ah
36533 A633           8946         FC            mov	-4[bp],ax
36534                                           !BCC_EOS
36535                                           ! 5171   bootfirst = read_word(0x9ff0, 0x0084);
36536                                           ! Debug: list int = const $84 (used reg = )
36537 A636           B8                   0084  mov	ax,#$84
36538 A639           50                         push	ax
36539                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36540 A63A           B8                   9FF0  mov	ax,#$9FF0
36541 A63D           50                         push	ax
36542                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36543 A63E           E8         5FCA            call	_read_word
36544 A641           83C4                   04  add	sp,*4
36545                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
36546 A644           8946         F2            mov	-$E[bp],ax
36547                                           !BCC_EOS
36548                                           ! 5172   if (bootfirst != 0xFFFF) {
36549                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
36550 A647           8B46         F2            mov	ax,-$E[bp]
36551 A64A           3D                   FFFF  cmp	ax,#$FFFF
36552 A64D           74           2C            je  	.73C
36553                       0000A64F            .73D:
36554                                           ! 5173     bootdev = bootfirst;
36555                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
36556 A64F           8B46         F2            mov	ax,-$E[bp]
36557 A652           8946         FC            mov	-4[bp],ax
36558                                           !BCC_EOS
36559                                           ! 5174     write_word(0x9ff0, 0x0084, 0xFFFF);
36560                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36561 A655           B8                   FFFF  mov	ax,#$FFFF
36562 A658           50                         push	ax
36563                                           ! Debug: list int = const $84 (used reg = )
36564 A659           B8                   0084  mov	ax,#$84
36565 A65C           50                         push	ax
36566                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36567 A65D           B8                   9FF0  mov	ax,#$9FF0
36568 A660           50                         push	ax
36569                                           ! Debug: func () void = write_word+0 (used reg = )
36570 A661           E8         5FD2            call	_write_word
36571 A664           83C4                   06  add	sp,*6
36572                                           !BCC_EOS
36573                                           ! 5175     write_word(0x9ff0, 0x0082, 0xFFFF);
36574                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36575 A667           B8                   FFFF  mov	ax,#$FFFF
36576 A66A           50                         push	ax
36577                                           ! Debug: list int = const $82 (used reg = )
36578 A66B           B8                   0082  mov	ax,#$82
36579 A66E           50                         push	ax
36580                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36581 A66F           B8                   9FF0  mov	ax,#$9FF0
36582 A672           50                         push	ax
36583                                           ! Debug: func () void = write_word+0 (used reg = )
36584 A673           E8         5FC0            call	_write_word
36585 A676           83C4                   06  add	sp,*6
36586                                           !BCC_EOS
36587                                           ! 5176   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
36588 A679           EB           15            jmp .73E
36589                       0000A67B            .73C:
36590                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
36591 A67B           8B46         FC            mov	ax,-4[bp]
36592 A67E           85C0                       test	ax,ax
36593 A680           75           0E            jne 	.73F
36594                       0000A682            .740:
36595                                           ! Debug: list * char = .741+0 (used reg = )
36596 A682           BB                   CCF1  mov	bx,#.741
36597 A685           53                         push	bx
36598                                           ! Debug: list int = const 7 (used reg = )
36599 A686           B8                   0007  mov	ax,*7
36600 A689           50                         push	ax
36601                                           ! Debug: func () void = bios_printf+0 (used reg = )
36602 A68A           E8         631A            call	_bios_printf
36603 A68D           83C4                   04  add	sp,*4
36604                                           !BCC_EOS
36605                                           ! 5177   bootdev -= 1;
36606                       0000A690            .73F:
36607                       0000A690            .73E:
36608                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
36609 A690           8B46         FC            mov	ax,-4[bp]
36610 A693           48                         dec	ax
36611 A694           8946         FC            mov	-4[bp],ax
36612                                           !BCC_EOS
36613                                           ! 5178   if (get_boot_vector(bootdev, &e) == 0) {
36614                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
36615 A697           8D5E         E2            lea	bx,-$1E[bp]
36616 A69A           53                         push	bx
36617                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
36618 A69B           FF76         FC            push	-4[bp]
36619                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
36620 A69E           E8         6D7A            call	_get_boot_vector
36621 A6A1           83C4                   04  add	sp,*4
36622                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
36623 A6A4           84C0                       test	al,al
36624 A6A6           75           15            jne 	.742
36625                       0000A6A8            .743:
36626                                           ! 5179     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
36627                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
36628 A6A8           FF76         FC            push	-4[bp]
36629                                           ! Debug: list * char = .744+0 (used reg = )
36630 A6AB           BB                   CCD5  mov	bx,#.744
36631 A6AE           53                         push	bx
36632                                           ! Debug: list int = const 4 (used reg = )
36633 A6AF           B8                   0004  mov	ax,*4
36634 A6B2           50                         push	ax
36635                                           ! Debug: func () void = bios_printf+0 (used reg = )
36636 A6B3           E8         62F1            call	_bios_printf
36637 A6B6           83C4                   06  add	sp,*6
36638                                           !BCC_EOS
36639                                           ! 5180     return;
36640 A6B9           89EC                       mov	sp,bp
36641 A6BB           5D                         pop	bp
36642 A6BC           C3                         ret
36643                                           !BCC_EOS
36644                                           ! 5181   }
36645                                           ! 5182   print_boot_device(&e);
36646                       0000A6BD            .742:
36647                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
36648 A6BD           8D5E         E2            lea	bx,-$1E[bp]
36649 A6C0           53                         push	bx
36650                                           ! Debug: func () void = print_boot_device+0 (used reg = )
36651 A6C1           E8         6F9D            call	_print_boot_device
36652 A6C4           44                         inc	sp
36653 A6C5           44                         inc	sp
36654                                           !BCC_EOS
36655                                           ! 5183   switch(e.type) {
36656 A6C6           8B46         E2            mov	ax,-$1E[bp]
36657 A6C9           E9         0119            br 	.747
36658                                           ! 5184   case 0x01:
36659                                           ! 5185   case 0x02:
36660                       0000A6CC            .748:
36661                                           ! 5186     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
36662                       0000A6CC            .749:
36663                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
36664 A6CC           8B46         E2            mov	ax,-$1E[bp]
36665 A6CF           3D                   0002  cmp	ax,*2
36666 A6D2           75           04            jne 	.74A
36667                       0000A6D4            .74B:
36668 A6D4           B0                     80  mov	al,#$80
36669 A6D6           EB           02            jmp .74C
36670                       0000A6D8            .74A:
36671 A6D8           30C0                       xor	al,al
36672                       0000A6DA            .74C:
36673                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36674 A6DA           8846         FB            mov	-5[bp],al
36675                                           !BCC_EOS
36676                                           ! 5187     bootseg = 0x07c0;
36677                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36678 A6DD           B8                   07C0  mov	ax,#$7C0
36679 A6E0           8946         F8            mov	-8[bp],ax
36680                                           !BCC_EOS
36681                                           ! 5188     status = 0;
36682                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36683 A6E3           31C0                       xor	ax,ax
36684 A6E5           8946         F4            mov	-$C[bp],ax
36685                                           !BCC_EOS
36686                                           ! 5189 #asm
36687                                           !BCC_EOS
36688                                           !BCC_ASM
36689                       00000014            _int19_function.bootip	set	$14
36690                       FFFFFFF6            .int19_function.bootip	set	-$A
36691                       00000022            _int19_function.seq_nr	set	$22
36692                       00000004            .int19_function.seq_nr	set	4
36693                       00000018            _int19_function.bootchk	set	$18
36694                       FFFFFFFA            .int19_function.bootchk	set	-6
36695                       00000016            _int19_function.bootseg	set	$16
36696                       FFFFFFF8            .int19_function.bootseg	set	-8
36697                       0000001C            _int19_function.ebda_seg	set	$1C
36698                       FFFFFFFE            .int19_function.ebda_seg	set	-2
36699                       00000012            _int19_function.status	set	$12
36700                       FFFFFFF4            .int19_function.status	set	-$C
36701                       00000010            _int19_function.bootfirst	set	$10
36702                       FFFFFFF2            .int19_function.bootfirst	set	-$E
36703                       00000019            _int19_function.bootdrv	set	$19
36704                       FFFFFFFB            .int19_function.bootdrv	set	-5
36705                       0000001A            _int19_function.bootdev	set	$1A
36706                       FFFFFFFC            .int19_function.bootdev	set	-4
36707                       00000000            _int19_function.e	set	0
36708                       FFFFFFE2            .int19_function.e	set	-$1E
36709 A6E8           55                             push bp
36710 A6E9           89E5                           mov bp, sp
36711 A6EB           50                             push ax
36712 A6EC           53                             push bx
36713 A6ED           51                             push cx
36714 A6EE           52                             push dx
36715 A6EF           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
36716 A6F2           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
36717 A6F5           8EC0                           mov es, ax ;; segment
36718 A6F7           31DB                           xor bx, bx ;; offset
36719 A6F9           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
36720 A6FB           B0                     01      mov al, #0x01 ;; read 1 sector
36721 A6FD           B5                     00      mov ch, #0x00 ;; track 0
36722 A6FF           B1                     01      mov cl, #0x01 ;; sector 1
36723 A701           B6                     00      mov dh, #0x00 ;; head 0
36724 A703           CD                     13      int #0x13 ;; read sector
36725 A705           73           06                jnc int19_load_done
36726 A707           B8                   0001      mov ax, #0x0001
36727 A70A           8946         14                mov _int19_function.status + 2[bp], ax
36728                       0000A70D            int19_load_done:
36729 A70D           5A                             pop dx
36730 A70E           59                             pop cx
36731 A70F           5B                             pop bx
36732 A710           58                             pop ax
36733 A711           5D                             pop bp
36734                                           ! 5215 endasm
36735                                           !BCC_ENDASM
36736                                           !BCC_EOS
36737                                           ! 5216     if (status != 0) {
36738                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36739 A712           8B46         F4            mov	ax,-$C[bp]
36740 A715           85C0                       test	ax,ax
36741 A717           74           11            je  	.74D
36742                       0000A719            .74E:
36743                                           ! 5217       print_boot_failure(e.type, 1);
36744                                           ! Debug: list int = const 1 (used reg = )
36745 A719           B8                   0001  mov	ax,*1
36746 A71C           50                         push	ax
36747                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36748 A71D           FF76         E2            push	-$1E[bp]
36749                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36750 A720           E8         7021            call	_print_boot_failure
36751 A723           83C4                   04  add	sp,*4
36752                                           !BCC_EOS
36753                                           ! 5218       return;
36754 A726           89EC                       mov	sp,bp
36755 A728           5D                         pop	bp
36756 A729           C3                         ret
36757                                           !BCC_EOS
36758                                           ! 5219     }
36759                                           ! 5220     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
36760                       0000A72A            .74D:
36761                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
36762 A72A           8B46         E2            mov	ax,-$1E[bp]
36763 A72D           3D                   0001  cmp	ax,*1
36764 A730           75           0F            jne 	.750
36765                       0000A732            .751:
36766                                           ! Debug: list int = const $38 (used reg = )
36767 A732           B8                   0038  mov	ax,*$38
36768 A735           50                         push	ax
36769                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36770 A736           E8         5E4E            call	_inb_cmos
36771 A739           44                         inc	sp
36772 A73A           44                         inc	sp
36773                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36774 A73B           24                     01  and	al,*1
36775 A73D           84C0                       test	al,al
36776 A73F           75           22            jne 	.74F
36777                       0000A741            .750:
36778                                           ! 5221       if (read_word(bootseg,0x1fe) != 0xaa55) {
36779                                           ! Debug: list int = const $1FE (used reg = )
36780 A741           B8                   01FE  mov	ax,#$1FE
36781 A744           50                         push	ax
36782                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36783 A745           FF76         F8            push	-8[bp]
36784                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36785 A748           E8         5EC0            call	_read_word
36786 A74B           83C4                   04  add	sp,*4
36787                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
36788 A74E           3D                   AA55  cmp	ax,#$AA55
36789 A751           74           10            je  	.752
36790                       0000A753            .753:
36791                                           ! 5222         print_boot_failure(e.type, 0);
36792                                           ! Debug: list int = const 0 (used reg = )
36793 A753           31C0                       xor	ax,ax
36794 A755           50                         push	ax
36795                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36796 A756           FF76         E2            push	-$1E[bp]
36797                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36798 A759           E8         6FE8            call	_print_boot_failure
36799 A75C           83C4                   04  add	sp,*4
36800                                           !BCC_EOS
36801                                           ! 5223         return;
36802 A75F           89EC                       mov	sp,bp
36803 A761           5D                         pop	bp
36804 A762           C3                         ret
36805                                           !BCC_EOS
36806                                           ! 5224       }
36807                                           ! 5225     }
36808                       0000A763            .752:
36809                                           ! 5226     bootip = (bootseg & 0x0fff) << 4;
36810                       0000A763            .74F:
36811                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36812 A763           8B46         F8            mov	ax,-8[bp]
36813 A766           25                   0FFF  and	ax,#$FFF
36814                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36815 A769           B1                     04  mov	cl,*4
36816 A76B           D3E0                       shl	ax,cl
36817                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36818 A76D           8946         F6            mov	-$A[bp],ax
36819                                           !BCC_EOS
36820                                           ! 5227     bootseg &= 0xf000;
36821                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36822 A770           8B46         F8            mov	ax,-8[bp]
36823 A773           25                   F000  and	ax,#$F000
36824 A776           8946         F8            mov	-8[bp],ax
36825                                           !BCC_EOS
36826                                           ! 5228   break;
36827 A779           E9         0085            br 	.745
36828                                           !BCC_EOS
36829                                           ! 5229   case 0x03:
36830                                           ! 5230     status = cdrom_boot();
36831                       0000A77C            .754:
36832                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
36833 A77C           E8         97BC            call	_cdrom_boot
36834                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
36835 A77F           8946         F4            mov	-$C[bp],ax
36836                                           !BCC_EOS
36837                                           ! 5231     if ( (status & 0x00ff
36838                                           ! 5231 ) !=0 ) {
36839                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
36840 A782           8A46         F4            mov	al,-$C[bp]
36841                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36842 A785           84C0                       test	al,al
36843 A787           74           19            je  	.755
36844                       0000A789            .756:
36845                                           ! 5232       print_cdromboot_failure(status);
36846                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
36847 A789           FF76         F4            push	-$C[bp]
36848                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
36849 A78C           E8         701B            call	_print_cdromboot_failure
36850 A78F           44                         inc	sp
36851 A790           44                         inc	sp
36852                                           !BCC_EOS
36853                                           ! 5233       print_boot_failure(e.type, 1);
36854                                           ! Debug: list int = const 1 (used reg = )
36855 A791           B8                   0001  mov	ax,*1
36856 A794           50                         push	ax
36857                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36858 A795           FF76         E2            push	-$1E[bp]
36859                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36860 A798           E8         6FA9            call	_print_boot_failure
36861 A79B           83C4                   04  add	sp,*4
36862                                           !BCC_EOS
36863                                           ! 5234       return;
36864 A79E           89EC                       mov	sp,bp
36865 A7A0           5D                         pop	bp
36866 A7A1           C3                         ret
36867                                           !BCC_EOS
36868                                           ! 5235     }
36869                                           ! 5236     bootdrv = (Bit8u)(status>>8);
36870                       0000A7A2            .755:
36871                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
36872 A7A2           8B46         F4            mov	ax,-$C[bp]
36873 A7A5           88E0                       mov	al,ah
36874 A7A7           30E4                       xor	ah,ah
36875                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
36876                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36877 A7A9           8846         FB            mov	-5[bp],al
36878                                           !BCC_EOS
36879                                           ! 5237     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
36880                                           ! Debug: list * unsigned short = const $266 (used reg = )
36881 A7AC           B8                   0266  mov	ax,#$266
36882 A7AF           50                         push	ax
36883                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36884 A7B0           FF76         FE            push	-2[bp]
36885                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36886 A7B3           E8         5E55            call	_read_word
36887 A7B6           83C4                   04  add	sp,*4
36888                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36889 A7B9           8946         F8            mov	-8[bp],ax
36890                                           !BCC_EOS
36891                                           ! 5238     bootip = 0;
36892                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
36893 A7BC           31C0                       xor	ax,ax
36894 A7BE           8946         F6            mov	-$A[bp],ax
36895                                           !BCC_EOS
36896                                           ! 5239     break;
36897 A7C1           EB           3E            jmp .745
36898                                           !BCC_EOS
36899                                           ! 5240   case 0x80:
36900                                           ! 5241     bootseg = e.vector >> 16;
36901                       0000A7C3            .757:
36902                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
36903 A7C3           8B46         E6            mov	ax,-$1A[bp]
36904 A7C6           8B5E         E8            mov	bx,-$18[bp]
36905 A7C9           93                         xchg	bx,ax
36906 A7CA           31DB                       xor	bx,bx
36907                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36908 A7CC           8946         F8            mov	-8[bp],ax
36909                                           !BCC_EOS
36910                                           ! 5242     bootip = e.vector & 0xffff;
36911                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
36912                                           ! Debug: expression subtree swapping
36913 A7CF           B8                   FFFF  mov	ax,#$FFFF
36914 A7D2           31DB                       xor	bx,bx
36915 A7D4           8D7E         E6            lea	di,-$1A[bp]
36916 A7D7           E8         58E1            call	landul
36917                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36918 A7DA           8946         F6            mov	-$A[bp],ax
36919                                           !BCC_EOS
36920                                           ! 5243     break;
36921 A7DD           EB           22            jmp .745
36922                                           !BCC_EOS
36923                                           ! 5244   default: return;
36924                       0000A7DF            .758:
36925 A7DF           89EC                       mov	sp,bp
36926 A7E1           5D                         pop	bp
36927 A7E2           C3                         ret
36928                                           !BCC_EOS
36929                                           ! 5245   }
36930                                           ! 5246   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
36931 A7E3           EB           1C            jmp .745
36932                       0000A7E5            .747:
36933 A7E5           2D                   0001  sub	ax,*1
36934 A7E8         0F84         FEE0            beq 	.748
36935 A7EC           2D                   0001  sub	ax,*1
36936 A7EF         0F84         FED9            beq 	.749
36937 A7F3           2D                   0001  sub	ax,*1
36938 A7F6         0F84         FF82            beq 	.754
36939 A7FA           2D                   007D  sub	ax,*$7D
36940 A7FD           74           C4            je 	.757
36941 A7FF           EB           DE            jmp	.758
36942                       0000A801            .745:
36943                       FFFFFFE0            ..FFDB	=	-$20
36944                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
36945 A801           FF76         F6            push	-$A[bp]
36946                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36947 A804           FF76         F8            push	-8[bp]
36948                                           ! Debug: list * char = .759+0 (used reg = )
36949 A807           BB                   CCC1  mov	bx,#.759
36950 A80A           53                         push	bx
36951                                           ! Debug: list int = const 4 (used reg = )
36952 A80B           B8                   0004  mov	ax,*4
36953 A80E           50                         push	ax
36954                                           ! Debug: func () void = bios_printf+0 (used reg = )
36955 A80F           E8         6195            call	_bios_printf
36956 A812           83C4                   08  add	sp,*8
36957                                           !BCC_EOS
36958                                           ! 5247 #asm
36959                                           !BCC_EOS
36960                                           !BCC_ASM
36961                       00000014            _int19_function.bootip	set	$14
36962                       FFFFFFF6            .int19_function.bootip	set	-$A
36963                       00000022            _int19_function.seq_nr	set	$22
36964                       00000004            .int19_function.seq_nr	set	4
36965                       00000018            _int19_function.bootchk	set	$18
36966                       FFFFFFFA            .int19_function.bootchk	set	-6
36967                       00000016            _int19_function.bootseg	set	$16
36968                       FFFFFFF8            .int19_function.bootseg	set	-8
36969                       0000001C            _int19_function.ebda_seg	set	$1C
36970                       FFFFFFFE            .int19_function.ebda_seg	set	-2
36971                       00000012            _int19_function.status	set	$12
36972                       FFFFFFF4            .int19_function.status	set	-$C
36973                       00000010            _int19_function.bootfirst	set	$10
36974                       FFFFFFF2            .int19_function.bootfirst	set	-$E
36975                       00000019            _int19_function.bootdrv	set	$19
36976                       FFFFFFFB            .int19_function.bootdrv	set	-5
36977                       0000001A            _int19_function.bootdev	set	$1A
36978                       FFFFFFFC            .int19_function.bootdev	set	-4
36979                       00000000            _int19_function.e	set	0
36980                       FFFFFFE2            .int19_function.e	set	-$1E
36981 A815           89E5                           mov bp, sp
36982 A817           0E                             push cs
36983 A818           68                   ADD3      push #int18_handler
36984                                               ;; Build an iret stack frame that will take us to the boot vector.
36985                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
36986 A81B           9C                             pushf
36987 A81C           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
36988 A81F           50                             push ax
36989 A820           8B46         14                mov ax, _int19_function.bootip + 0[bp]
36990 A823           50                             push ax
36991                                               ;; Set the magic number in ax and the boot drive in dl.
36992 A824           B8                   AA55      mov ax, #0xaa55
36993 A827           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
36994                                               ;; Zero some of the other registers.
36995 A82A           31DB                           xor bx, bx
36996 A82C           8EDB                           mov ds, bx
36997 A82E           8EC3                           mov es, bx
36998 A830           89DD                           mov bp, bx
36999                                               ;; Go!
37000 A832           CF                             iret
37001                                           ! 5268 endasm
37002                                           !BCC_ENDASM
37003                                           !BCC_EOS
37004                                           ! 5269 }
37005 A833           89EC                       mov	sp,bp
37006 A835           5D                         pop	bp
37007 A836           C3                         ret
37008                                           ! 5270   void
37009                                           ! Register BX used in function int19_function
37010                                           ! 5271 int1a_function(regs, ds, iret_addr)
37011                                           ! 5272   pusha_regs_t regs;
37012                                           export	_int1a_function
37013                       0000A837            _int1a_function:
37014                                           !BCC_EOS
37015                                           ! 5273   Bit16u ds;
37016                                           !BCC_EOS
37017                                           ! 5274   iret_addr_t iret_addr;
37018                                           !BCC_EOS
37019                                           ! 5275 {
37020                                           ! 5276   Bit8u val8;
37021                                           !BCC_EOS
37022                                           ! 5277   ;
37023 A837           55                         push	bp
37024 A838           89E5                       mov	bp,sp
37025 A83A           4C                         dec	sp
37026 A83B           4C                         dec	sp
37027                                           !BCC_EOS
37028                                           ! 5278 #asm
37029                                           !BCC_EOS
37030                                           !BCC_ASM
37031                       00000016            _int1a_function.ds	set	$16
37032                       00000014            .int1a_function.ds	set	$14
37033                       00000001            _int1a_function.val8	set	1
37034                       FFFFFFFF            .int1a_function.val8	set	-1
37035                       00000018            _int1a_function.iret_addr	set	$18
37036                       00000016            .int1a_function.iret_addr	set	$16
37037                       00000006            _int1a_function.regs	set	6
37038                       00000004            .int1a_function.regs	set	4
37039 A83C           FB                           sti
37040                                           ! 5280 endasm
37041                                           !BCC_ENDASM
37042                                           !BCC_EOS
37043                                           ! 5281   switch (regs.u.r8.ah) {
37044 A83D           8A46         13            mov	al,$13[bp]
37045 A840           E9         0371            br 	.75C
37046                                           ! 5282     case 0:
37047                                           ! 5283 #asm
37048                       0000A843            .75D:
37049                                           !BCC_EOS
37050                                           !BCC_ASM
37051                       00000016            _int1a_function.ds	set	$16
37052                       00000014            .int1a_function.ds	set	$14
37053                       00000001            _int1a_function.val8	set	1
37054                       FFFFFFFF            .int1a_function.val8	set	-1
37055                       00000018            _int1a_function.iret_addr	set	$18
37056                       00000016            .int1a_function.iret_addr	set	$16
37057                       00000006            _int1a_function.regs	set	6
37058                       00000004            .int1a_function.regs	set	4
37059 A843           FA                               cli
37060                                           ! 5285 endasm
37061                                           !BCC_ENDASM
37062                                           !BCC_EOS
37063                                           ! 5286       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
37064                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
37065 A844           A1         046E            mov	ax,[$46E]
37066 A847           8946         10            mov	$10[bp],ax
37067                                           !BCC_EOS
37068                                           ! 5287       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
37069                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
37070 A84A           A1         046C            mov	ax,[$46C]
37071 A84D           8946         0E            mov	$E[bp],ax
37072                                           !BCC_EOS
37073                                           ! 5288       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
37074                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
37075 A850           A0         0470            mov	al,[$470]
37076 A853           8846         12            mov	$12[bp],al
37077                                           !BCC_EOS
37078                                           ! 5289       ((bios_data_t *) 0)->midnight_flag = 0;
37079                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
37080 A856           30C0                       xor	al,al
37081 A858           A2         0470            mov	[$470],al
37082                                           !BCC_EOS
37083                                           ! 5290 #asm
37084                                           !BCC_EOS
37085                                           !BCC_ASM
37086                       00000016            _int1a_function.ds	set	$16
37087                       00000014            .int1a_function.ds	set	$14
37088                       00000001            _int1a_function.val8	set	1
37089                       FFFFFFFF            .int1a_function.val8	set	-1
37090                       00000018            _int1a_function.iret_addr	set	$18
37091                       00000016            .int1a_function.iret_addr	set	$16
37092                       00000006            _int1a_function.regs	set	6
37093                       00000004            .int1a_function.regs	set	4
37094 A85B           FB                               sti
37095                                           ! 5292 endasm
37096                                           !BCC_ENDASM
37097                                           !BCC_EOS
37098                                           ! 5293       iret_addr.flags.u.r8.flagsl &= 0xfe;
37099                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37100 A85C           8A46         1A            mov	al,$1A[bp]
37101 A85F           24                     FE  and	al,#$FE
37102 A861           8846         1A            mov	$1A[bp],al
37103                                           !BCC_EOS
37104                                           ! 5294       break;
37105 A864           E9         0378            br 	.75A
37106                                           !BCC_EOS
37107                                           ! 5295     case 1:
37108                                           ! 5296 #asm
37109                       0000A867            .75E:
37110                                           !BCC_EOS
37111                                           !BCC_ASM
37112                       00000016            _int1a_function.ds	set	$16
37113                       00000014            .int1a_function.ds	set	$14
37114                       00000001            _int1a_function.val8	set	1
37115                       FFFFFFFF            .int1a_function.val8	set	-1
37116                       00000018            _int1a_function.iret_addr	set	$18
37117                       00000016            .int1a_function.iret_addr	set	$16
37118                       00000006            _int1a_function.regs	set	6
37119                       00000004            .int1a_function.regs	set	4
37120 A867           FA                               cli
37121                                           ! 5298 endasm
37122                                           !BCC_ENDASM
37123                                           !BCC_EOS
37124                                           ! 5299       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
37125                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
37126 A868           8B46         10            mov	ax,$10[bp]
37127 A86B           A3         046E            mov	[$46E],ax
37128                                           !BCC_EOS
37129                                           ! 5300       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
37130                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
37131 A86E           8B46         0E            mov	ax,$E[bp]
37132 A871           A3         046C            mov	[$46C],ax
37133                                           !BCC_EOS
37134                                           ! 5301       ((bios_data_t *) 0)->midnight_flag = 0;
37135                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
37136 A874           30C0                       xor	al,al
37137 A876           A2         0470            mov	[$470],al
37138                                           !BCC_EOS
37139                                           ! 5302 #asm
37140                                           !BCC_EOS
37141                                           !BCC_ASM
37142                       00000016            _int1a_function.ds	set	$16
37143                       00000014            .int1a_function.ds	set	$14
37144                       00000001            _int1a_function.val8	set	1
37145                       FFFFFFFF            .int1a_function.val8	set	-1
37146                       00000018            _int1a_function.iret_addr	set	$18
37147                       00000016            .int1a_function.iret_addr	set	$16
37148                       00000006            _int1a_function.regs	set	6
37149                       00000004            .int1a_function.regs	set	4
37150 A879           FB                               sti
37151                                           ! 5304 endasm
37152                                           !BCC_ENDASM
37153                                           !BCC_EOS
37154                                           ! 5305       regs.u.r8.ah = 0;
37155                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37156 A87A           30C0                       xor	al,al
37157 A87C           8846         13            mov	$13[bp],al
37158                                           !BCC_EOS
37159                                           ! 5306       iret_addr.flags.u.r8.flagsl &= 0xfe;
37160                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37161 A87F           8A46         1A            mov	al,$1A[bp]
37162 A882           24                     FE  and	al,#$FE
37163 A884           8846         1A            mov	$1A[bp],al
37164                                           !BCC_EOS
37165                                           ! 5307       break;
37166 A887           E9         0355            br 	.75A
37167                                           !BCC_EOS
37168                                           ! 5308     case 2:
37169                                           ! 5309       if (rtc_updating()) {
37170                       0000A88A            .75F:
37171                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37172 A88A           E8         5D37            call	_rtc_updating
37173 A88D           85C0                       test	ax,ax
37174 A88F           74           0B            je  	.760
37175                       0000A891            .761:
37176                                           ! 5310         iret_addr.flags.u.r8.flagsl |= 0x01;
37177                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37178 A891           8A46         1A            mov	al,$1A[bp]
37179 A894           0C                     01  or	al,*1
37180 A896           8846         1A            mov	$1A[bp],al
37181                                           !BCC_EOS
37182                                           ! 5311         break;
37183 A899           E9         0343            br 	.75A
37184                                           !BCC_EOS
37185                                           ! 5312       }
37186                                           ! 5313       regs.u.r8.dh = inb_cmos(0x00);
37187                       0000A89C            .760:
37188                                           ! Debug: list int = const 0 (used reg = )
37189 A89C           31C0                       xor	ax,ax
37190 A89E           50                         push	ax
37191                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37192 A89F           E8         5CE5            call	_inb_cmos
37193 A8A2           44                         inc	sp
37194 A8A3           44                         inc	sp
37195                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37196 A8A4           8846         0F            mov	$F[bp],al
37197                                           !BCC_EOS
37198                                           ! 5314       regs.u.r8.cl = inb_cmos(0x02);
37199                                           ! Debug: list int = const 2 (used reg = )
37200 A8A7           B8                   0002  mov	ax,*2
37201 A8AA           50                         push	ax
37202                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37203 A8AB           E8         5CD9            call	_inb_cmos
37204 A8AE           44                         inc	sp
37205 A8AF           44                         inc	sp
37206                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37207 A8B0           8846         10            mov	$10[bp],al
37208                                           !BCC_EOS
37209                                           ! 5315       regs.u.r8.ch = inb_cmos(0x04);
37210                                           ! Debug: list int = const 4 (used reg = )
37211 A8B3           B8                   0004  mov	ax,*4
37212 A8B6           50                         push	ax
37213                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37214 A8B7           E8         5CCD            call	_inb_cmos
37215 A8BA           44                         inc	sp
37216 A8BB           44                         inc	sp
37217                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37218 A8BC           8846         11            mov	$11[bp],al
37219                                           !BCC_EOS
37220                                           ! 5316       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
37221                                           ! Debug: list int = const $B (used reg = )
37222 A8BF           B8                   000B  mov	ax,*$B
37223 A8C2           50                         push	ax
37224                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37225 A8C3           E8         5CC1            call	_inb_cmos
37226 A8C6           44                         inc	sp
37227 A8C7           44                         inc	sp
37228                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
37229 A8C8           24                     01  and	al,*1
37230                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37231 A8CA           8846         0E            mov	$E[bp],al
37232                                           !BCC_EOS
37233                                           ! 5317       r
37234                                           ! 5317 egs.u.r8.ah = 0;
37235                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37236 A8CD           30C0                       xor	al,al
37237 A8CF           8846         13            mov	$13[bp],al
37238                                           !BCC_EOS
37239                                           ! 5318       regs.u.r8.al = regs.u.r8.ch;
37240                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37241 A8D2           8A46         11            mov	al,$11[bp]
37242 A8D5           8846         12            mov	$12[bp],al
37243                                           !BCC_EOS
37244                                           ! 5319       iret_addr.flags.u.r8.flagsl &= 0xfe;
37245                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37246 A8D8           8A46         1A            mov	al,$1A[bp]
37247 A8DB           24                     FE  and	al,#$FE
37248 A8DD           8846         1A            mov	$1A[bp],al
37249                                           !BCC_EOS
37250                                           ! 5320       break;
37251 A8E0           E9         02FC            br 	.75A
37252                                           !BCC_EOS
37253                                           ! 5321     case 3:
37254                                           ! 5322       if (rtc_updating()) {
37255                       0000A8E3            .762:
37256                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37257 A8E3           E8         5CDE            call	_rtc_updating
37258 A8E6           85C0                       test	ax,ax
37259 A8E8           74           03            je  	.763
37260                       0000A8EA            .764:
37261                                           ! 5323         init_rtc();
37262                                           ! Debug: func () void = init_rtc+0 (used reg = )
37263 A8EA           E8         5CA6            call	_init_rtc
37264                                           !BCC_EOS
37265                                           ! 5324       }
37266                                           ! 5325       outb_cmos(0x00, regs.u.r8.dh);
37267                       0000A8ED            .763:
37268                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37269 A8ED           8A46         0F            mov	al,$F[bp]
37270 A8F0           30E4                       xor	ah,ah
37271 A8F2           50                         push	ax
37272                                           ! Debug: list int = const 0 (used reg = )
37273 A8F3           31C0                       xor	ax,ax
37274 A8F5           50                         push	ax
37275                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37276 A8F6           E8         5C7F            call	_outb_cmos
37277 A8F9           83C4                   04  add	sp,*4
37278                                           !BCC_EOS
37279                                           ! 5326       outb_cmos(0x02, regs.u.r8.cl);
37280                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37281 A8FC           8A46         10            mov	al,$10[bp]
37282 A8FF           30E4                       xor	ah,ah
37283 A901           50                         push	ax
37284                                           ! Debug: list int = const 2 (used reg = )
37285 A902           B8                   0002  mov	ax,*2
37286 A905           50                         push	ax
37287                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37288 A906           E8         5C6F            call	_outb_cmos
37289 A909           83C4                   04  add	sp,*4
37290                                           !BCC_EOS
37291                                           ! 5327       outb_cmos(0x04, regs.u.r8.ch);
37292                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37293 A90C           8A46         11            mov	al,$11[bp]
37294 A90F           30E4                       xor	ah,ah
37295 A911           50                         push	ax
37296                                           ! Debug: list int = const 4 (used reg = )
37297 A912           B8                   0004  mov	ax,*4
37298 A915           50                         push	ax
37299                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37300 A916           E8         5C5F            call	_outb_cmos
37301 A919           83C4                   04  add	sp,*4
37302                                           !BCC_EOS
37303                                           ! 5328       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
37304                                           ! Debug: expression subtree swapping
37305                                           ! Debug: list int = const $B (used reg = )
37306 A91C           B8                   000B  mov	ax,*$B
37307 A91F           50                         push	ax
37308                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37309 A920           E8         5C64            call	_inb_cmos
37310 A923           44                         inc	sp
37311 A924           44                         inc	sp
37312                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
37313 A925           24                     60  and	al,*$60
37314                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
37315 A927           0C                     02  or	al,*2
37316 A929           50                         push	ax
37317                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
37318 A92A           8A46         0E            mov	al,$E[bp]
37319 A92D           24                     01  and	al,*1
37320                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
37321 A92F           0A46         FC            or	al,0+..FFDA[bp]
37322 A932           44                         inc	sp
37323 A933           44                         inc	sp
37324                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37325 A934           8846         FF            mov	-1[bp],al
37326                                           !BCC_EOS
37327                                           ! 5329       outb_cmos(0x0b, val8);
37328                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37329 A937           8A46         FF            mov	al,-1[bp]
37330 A93A           30E4                       xor	ah,ah
37331 A93C           50                         push	ax
37332                                           ! Debug: list int = const $B (used reg = )
37333 A93D           B8                   000B  mov	ax,*$B
37334 A940           50                         push	ax
37335                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37336 A941           E8         5C34            call	_outb_cmos
37337 A944           83C4                   04  add	sp,*4
37338                                           !BCC_EOS
37339                                           ! 5330       regs.u.r8.ah = 0;
37340                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37341 A947           30C0                       xor	al,al
37342 A949           8846         13            mov	$13[bp],al
37343                                           !BCC_EOS
37344                                           ! 5331       regs.u.r8.al = val8;
37345                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37346 A94C           8A46         FF            mov	al,-1[bp]
37347 A94F           8846         12            mov	$12[bp],al
37348                                           !BCC_EOS
37349                                           ! 5332       iret_addr.flags.u.r8.flagsl &= 0xfe;
37350                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37351 A952           8A46         1A            mov	al,$1A[bp]
37352 A955           24                     FE  and	al,#$FE
37353 A957           8846         1A            mov	$1A[bp],al
37354                                           !BCC_EOS
37355                                           ! 5333       break;
37356 A95A           E9         0282            br 	.75A
37357                                           !BCC_EOS
37358                                           ! 5334     case 4:
37359                                           ! 5335       regs.u.r8.ah = 0;
37360                       0000A95D            .765:
37361                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37362 A95D           30C0                       xor	al,al
37363 A95F           8846         13            mov	$13[bp],al
37364                                           !BCC_EOS
37365                                           ! 5336       if (rtc_updating()) {
37366                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37367 A962           E8         5C5F            call	_rtc_updating
37368 A965           85C0                       test	ax,ax
37369 A967           74           0B            je  	.766
37370                       0000A969            .767:
37371                                           ! 5337         iret_addr.flags.u.r8.flagsl |= 0x01;
37372                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37373 A969           8A46         1A            mov	al,$1A[bp]
37374 A96C           0C                     01  or	al,*1
37375 A96E           8846         1A            mov	$1A[bp],al
37376                                           !BCC_EOS
37377                                           ! 5338         break;
37378 A971           E9         026B            br 	.75A
37379                                           !BCC_EOS
37380                                           ! 5339       }
37381                                           ! 5340       regs.u.r8.cl = inb_cmos(0x09);
37382                       0000A974            .766:
37383                                           ! Debug: list int = const 9 (used reg = )
37384 A974           B8                   0009  mov	ax,*9
37385 A977           50                         push	ax
37386                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37387 A978           E8         5C0C            call	_inb_cmos
37388 A97B           44                         inc	sp
37389 A97C           44                         inc	sp
37390                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37391 A97D           8846         10            mov	$10[bp],al
37392                                           !BCC_EOS
37393                                           ! 5341       regs.u.r8.dh = inb_cmos(0x08);
37394                                           ! Debug: list int = const 8 (used reg = )
37395 A980           B8                   0008  mov	ax,*8
37396 A983           50                         push	ax
37397                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37398 A984           E8         5C00            call	_inb_cmos
37399 A987           44                         inc	sp
37400 A988           44                         inc	sp
37401                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37402 A989           8846         0F            mov	$F[bp],al
37403                                           !BCC_EOS
37404                                           ! 5342       regs.u.r8.dl = inb_cmos(0x07);
37405                                           ! Debug: list int = const 7 (used reg = )
37406 A98C           B8                   0007  mov	ax,*7
37407 A98F           50                         push	ax
37408                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37409 A990           E8         5BF4            call	_inb_cmos
37410 A993           44                         inc	sp
37411 A994           44                         inc	sp
37412                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37413 A995           8846         0E            mov	$E[bp],al
37414                                           !BCC_EOS
37415                                           ! 5343       regs.u.r8.ch = inb_cmos(0x32);
37416                                           ! Debug: list int = const $32 (used reg = )
37417 A998           B8                   0032  mov	ax,*$32
37418 A99B           50                         push	ax
37419                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37420 A99C           E8         5BE8            call	_inb_cmos
37421 A99F           44                         inc	sp
37422 A9A0           44                         inc	sp
37423                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37424 A9A1           8846         11            mov	$11[bp],al
37425                                           !BCC_EOS
37426                                           ! 5344       regs.u.r8.al = regs.u.r8.ch;
37427                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37428 A9A4           8A46         11            mov	al,$11[bp]
37429 A9A7           8846         12            mov	$12[bp],al
37430                                           !BCC_EOS
37431                                           ! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
37432                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37433 A9AA           8A46         1A            mov	al,$1A[bp]
37434 A9AD           24                     FE  and	al,#$FE
37435 A9AF           8846         1A            mov	$1A[bp],al
37436                                           !BCC_EOS
37437                                           ! 5346       break;
37438 A9B2           E9         022A            br 	.75A
37439                                           !BCC_EOS
37440                                           ! 5347     case 5:
37441                                           ! 5348       if (rtc_updating()) {
37442                       0000A9B5            .768:
37443                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37444 A9B5           E8         5C0C            call	_rtc_updating
37445 A9B8           85C0                       test	ax,ax
37446 A9BA           74           0E            je  	.769
37447                       0000A9BC            .76A:
37448                                           ! 5349         init_rtc();
37449                                           ! Debug: func () void = init_rtc+0 (used reg = )
37450 A9BC           E8         5BD4            call	_init_rtc
37451                                           !BCC_EOS
37452                                           ! 5350         iret_addr.flags.u.r8.flagsl |= 0x01;
37453                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37454 A9BF           8A46         1A            mov	al,$1A[bp]
37455 A9C2           0C                     01  or	al,*1
37456 A9C4           8846         1A            mov	$1A[bp],al
37457                                           !BCC_EOS
37458                                           ! 5351         break;
37459 A9C7           E9         0215            br 	.75A
37460                                           !BCC_EOS
37461                                           ! 5352         }
37462                                           ! 5353       outb_cmos(0x09, regs.u.r8.cl);
37463                       0000A9CA            .769:
37464                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37465 A9CA           8A46         10            mov	al,$10[bp]
37466 A9CD           30E4                       xor	ah,ah
37467 A9CF           50                         push	ax
37468                                           ! Debug: list int = const 9 (used reg = )
37469 A9D0           B8                   0009  mov	ax,*9
37470 A9D3           50                         push	ax
37471                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37472 A9D4           E8         5BA1            call	_outb_cmos
37473 A9D7           83C4                   04  add	sp,*4
37474                                           !BCC_EOS
37475                                           ! 5354       outb_cmos(0x08, regs.u.r8.dh);
37476                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37477 A9DA           8A46         0F            mov	al,$F[bp]
37478 A9DD           30E4                       xor	ah,ah
37479 A9DF           50                         push	ax
37480                                           ! Debug: list int = const 8 (used reg = )
37481 A9E0           B8                   0008  mov	ax,*8
37482 A9E3           50                         push	ax
37483                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37484 A9E4           E8         5B91            call	_outb_cmos
37485 A9E7           83C4                   04  add	sp,*4
37486                                           !BCC_EOS
37487                                           ! 5355       outb_cmos(0x07, regs.u.r8.dl);
37488                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
37489 A9EA           8A46         0E            mov	al,$E[bp]
37490 A9ED           30E4                       xor	ah,ah
37491 A9EF           50                         push	ax
37492                                           ! Debug: list int = const 7 (used reg = )
37493 A9F0           B8                   0007  mov	ax,*7
37494 A9F3           50                         push	ax
37495                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37496 A9F4           E8         5B81            call	_outb_cmos
37497 A9F7           83C4                   04  add	sp,*4
37498                                           !BCC_EOS
37499                                           ! 5356       outb_cmos(0x32, regs.u.r8.ch);
37500                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37501 A9FA           8A46         11            mov	al,$11[bp]
37502 A9FD           30E4                       xor	ah,ah
37503 A9FF           50                         push	ax
37504                                           ! Debug: list int = const $32 (used reg = )
37505 AA00           B8                   0032  mov	ax,*$32
37506 AA03           50                         push	ax
37507                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37508 AA04           E8         5B71            call	_outb_cmos
37509 AA07           83C4                   04  add	sp,*4
37510                                           !BCC_EOS
37511                                           ! 5357       val8 = inb_cmos(0x0b) & 0x7f;
37512                                           ! Debug: list int = const $B (used reg = )
37513 AA0A           B8                   000B  mov	ax,*$B
37514 AA0D           50                         push	ax
37515                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37516 AA0E           E8         5B76            call	_inb_cmos
37517 AA11           44                         inc	sp
37518 AA12           44                         inc	sp
37519                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
37520 AA13           24                     7F  and	al,*$7F
37521                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37522 AA15           8846         FF            mov	-1[bp],al
37523                                           !BCC_EOS
37524                                           ! 5358       outb_cmos(0x0b, val8);
37525                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37526 AA18           8A46         FF            mov	al,-1[bp]
37527 AA1B           30E4                       xor	ah,ah
37528 AA1D           50                         push	ax
37529                                           ! Debug: list int = const $B (used reg = )
37530 AA1E           B8                   000B  mov	ax,*$B
37531 AA21           50                         push	ax
37532                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37533 AA22           E8         5B53            call	_outb_cmos
37534 AA25           83C4                   04  add	sp,*4
37535                                           !BCC_EOS
37536                                           ! 5359       regs.u.r8.ah = 0;
37537                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37538 AA28           30C0                       xor	al,al
37539 AA2A           8846         13            mov	$13[bp],al
37540                                           !BCC_EOS
37541                                           ! 5360       regs.u.r8.al = val8;
37542                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37543 AA2D           8A46         FF            mov	al,-1[bp]
37544 AA30           8846         12            mov	$12[bp],al
37545                                           !BCC_EOS
37546                                           ! 5361       iret_addr.flags.u.r8.flagsl &= 0xfe;
37547                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37548 AA33           8A46         1A            mov	al,$1A[bp]
37549 AA36           24                     FE  and	al,#$FE
37550 AA38           8846         1A            mov	$1A[bp],al
37551                                           !BCC_EOS
37552                                           ! 5362       break;
37553 AA3B           E9         01A1            br 	.75A
37554                                           !BCC_EOS
37555                                           ! 5363     case 6:
37556                                           ! 5364       val8 = inb_cmos(0x0b);
37557                       0000AA3E            .76B:
37558                                           ! Debug: list int = const $B (used reg = )
37559 AA3E           B8                   000B  mov	ax,*$B
37560 AA41           50                         push	ax
37561                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37562 AA42           E8         5B42            call	_inb_cmos
37563 AA45           44                         inc	sp
37564 AA46           44                         inc	sp
37565                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37566 AA47           8846         FF            mov	-1[bp],al
37567                                           !BCC_EOS
37568                                           ! 5365       regs.u.r16.ax = 0;
37569                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
37570 AA4A           31C0                       xor	ax,ax
37571 AA4C           8946         12            mov	$12[bp],ax
37572                                           !BCC_EOS
37573                                           ! 5366       if (val8 & 0x20) {
37574                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
37575 AA4F           8A46         FF            mov	al,-1[bp]
37576 AA52           24                     20  and	al,*$20
37577 AA54           84C0                       test	al,al
37578 AA56           74           0B            je  	.76C
37579                       0000AA58            .76D:
37580                                           ! 5367         iret_addr.flags.u.r8.flagsl |= 0x01;
37581                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37582 AA58           8A46         1A            mov	al,$1A[bp]
37583 AA5B           0C                     01  or	al,*1
37584 AA5D           8846         1A            mov	$1A[bp],al
37585                                           !BCC_EOS
37586                                           ! 5368         break;
37587 AA60           E9         017C            br 	.75A
37588                                           !BCC_EOS
37589                                           ! 5369       }
37590                                           ! 5370       if (rtc_updating()) {
37591                       0000AA63            .76C:
37592                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37593 AA63           E8         5B5E            call	_rtc_updating
37594 AA66           85C0                       test	ax,ax
37595 AA68           74           03            je  	.76E
37596                       0000AA6A            .76F:
37597                                           ! 5371         init_rtc();
37598                                           ! Debug: func () void = init_rtc+0 (used reg = )
37599 AA6A           E8         5B26            call	_init_rtc
37600                                           !BCC_EOS
37601                                           ! 5372       }
37602                                           ! 5373       outb_cmos(0x01, regs.u.r8.dh);
37603                       0000AA6D            .76E:
37604                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37605 AA6D           8A46         0F            mov	al,$F[bp]
37606 AA70           30E4                       xor	ah,ah
37607 AA72           50                         push	ax
37608                                           ! Debug: list int = const 1 (used reg = )
37609 AA73           B8                   0001  mov	ax,*1
37610 AA76           50                         push	ax
37611                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37612 AA77           E8         5AFE            call	_outb_cmos
37613 AA7A           83C4                   04  add	sp,*4
37614                                           !BCC_EOS
37615                                           ! 5374       outb_cmos(0x03, regs.u.r8.cl);
37616                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37617 AA7D           8A46         10            mov	al,$10[bp]
37618 AA80           30E4                       xor	ah,ah
37619 AA82           50                         push	ax
37620                                           ! Debug: list int = const 3 (used reg = )
37621 AA83           B8                   0003  mov	ax,*3
37622 AA86           50                         push	ax
37623                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37624 AA87           E8         5AEE            call	_outb_cmos
37625 AA8A           83C4                   04  add	sp,*4
37626                                           !BCC_EOS
37627                                           ! 5375       outb_cmos(0x05, regs.u.r8.ch);
37628                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37629 AA8D           8A46         11            mov	al,$11[bp]
37630 AA90           30E4                       xor	ah,ah
37631 AA92           50                         push	ax
37632                                           ! Debug: list int = const 5 (used reg = )
37633 AA93           B8                   0005  mov	ax,*5
37634 AA96           50                         push	ax
37635                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37636 AA97           E8         5ADE            call	_outb_cmos
37637 AA9A           83C4                   04  add	sp,*4
37638                                           !BCC_EOS
37639                                           ! 5376       outb(0xa1, inb(0xa1) & 0xfe);
37640                                           ! Debug: list int = const $A1 (used reg = )
37641 AA9D           B8                   00A1  mov	ax,#$A1
37642 AAA0           50                         push	ax
37643                                           ! Debug: func () unsigned char = inb+0 (used reg = )
37644 AAA1           E8         5A9E            call	_inb
37645 AAA4           44                         inc	sp
37646 AAA5           44                         inc	sp
37647                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
37648 AAA6           24                     FE  and	al,#$FE
37649                                           ! Debug: list unsigned char = al+0 (used reg = )
37650 AAA8           30E4                       xor	ah,ah
37651 AAAA           50                         push	ax
37652                                           ! Debug: list int = const $A1 (used reg = )
37653 AAAB           B8                   00A1  mov	ax,#$A1
37654 AAAE           50                         push	ax
37655                                           ! Debug: func () void = outb+0 (used reg = )
37656 AAAF           E8         5AA6            call	_outb
37657 AAB2           83C4                   04  add	sp,*4
37658                                           !BCC_EOS
37659                                           ! 5377       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
37660                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
37661 AAB5           8A46         FF            mov	al,-1[bp]
37662 AAB8           24                     7F  and	al,*$7F
37663                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
37664 AABA           0C                     20  or	al,*$20
37665                                           ! Debug: list unsigned char = al+0 (used reg = )
37666 AABC           30E4                       xor	ah,ah
37667 AABE           50                         push	ax
37668                                           ! Debug: list int = const $B (used reg = )
37669 AABF           B8                   000B  mov	ax,*$B
37670 AAC2           50                         push	ax
37671                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37672 AAC3           E8         5AB2            call	_outb_cmos
37673 AAC6           83C4                   04  add	sp,*4
37674                                           !BCC_EOS
37675                                           ! 5378       iret_addr.flags.u.r8.flagsl &= 0xfe;
37676                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37677 AAC9           8A46         1A            mov	al,$1A[bp]
37678 AACC           24                     FE  and	al,#$FE
37679 AACE           8846         1A            mov	$1A[bp],al
37680                                           !BCC_EOS
37681                                           ! 5379       break;
37682 AAD1           E9         010B            br 	.75A
37683                                           !BCC_EOS
37684                                           ! 5380     case 7:
37685                                           ! 5381       val8 = inb_cmos(0x0b);
37686                       0000AAD4            .770:
37687                                           ! Debug: list int = const $B (used reg = )
37688 AAD4           B8                   000B  mov	ax,*$B
37689 AAD7           50                         push	ax
37690                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37691 AAD8           E8         5AAC            call	_inb_cmos
37692 AADB           44                         inc	sp
37693 AADC           44                         inc	sp
37694                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37695 AADD           8846         FF            mov	-1[bp],al
37696                                           !BCC_EOS
37697                                           ! 5382       outb_cmos(0x0b, val8 & 0x57);
37698                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
37699 AAE0           8A46         FF            mov	al,-1[bp]
37700 AAE3           24                     57  and	al,*$57
37701                                           ! Debug: list unsigned char = al+0 (used reg = )
37702 AAE5           30E4                       xor	ah,ah
37703 AAE7           50                         push	ax
37704                                           ! Debug: list int = const $B (used reg = )
37705 AAE8           B8                   000B  mov	ax,*$B
37706 AAEB           50                         push	ax
37707                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37708 AAEC           E8         5A89            call	_outb_cmos
37709 AAEF           83C4                   04  add	sp,*4
37710                                           !BCC_EOS
37711                                           ! 5383       regs.u.r8.ah = 0;
37712                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37713 AAF2           30C0                       xor	al,al
37714 AAF4           8846         13            mov	$13[bp],al
37715                                           !BCC_EOS
37716                                           ! 5384       regs.u.r8.al = val8;
37717                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37718 AAF7           8A46         FF            mov	al,-1[bp]
37719 AAFA           8846         12            mov	$12[bp],al
37720                                           !BCC_EOS
37721                                           ! 5385       iret_addr.flags.u.r8.flagsl &= 0xfe;
37722                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37723 AAFD           8A46         1A            mov	al,$1A[bp]
37724 AB00           24                     FE  and	al,#$FE
37725 AB02           8846         1A            mov	$1A[bp],al
37726                                           !BCC_EOS
37727                                           ! 5386       break;
37728 AB05           E9         00D7            br 	.75A
37729                                           !BCC_EOS
37730                                           ! 5387     case 0xb1:
37731                                           ! 5388       if (regs.u.r8.bl == 0xff) {
37732                       0000AB08            .771:
37733                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
37734 AB08           8A46         0C            mov	al,$C[bp]
37735 AB0B           3C                     FF  cmp	al,#$FF
37736 AB0D           75           11            jne 	.772
37737                       0000AB0F            .773:
37738                                           ! 5389         bios_printf(4, "PCI BIOS: PCI n
37739                                           ! 5389 ot present\n");
37740                                           ! Debug: list * char = .774+0 (used reg = )
37741 AB0F           BB                   CCA6  mov	bx,#.774
37742 AB12           53                         push	bx
37743                                           ! Debug: list int = const 4 (used reg = )
37744 AB13           B8                   0004  mov	ax,*4
37745 AB16           50                         push	ax
37746                                           ! Debug: func () void = bios_printf+0 (used reg = )
37747 AB17           E8         5E8D            call	_bios_printf
37748 AB1A           83C4                   04  add	sp,*4
37749                                           !BCC_EOS
37750                                           ! 5390       } else if (regs.u.r8.bl == 0x81) {
37751 AB1D           E9         007A            br 	.775
37752                       0000AB20            .772:
37753                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
37754 AB20           8A46         0C            mov	al,$C[bp]
37755 AB23           3C                     81  cmp	al,#$81
37756 AB25         0F85         0016            bne 	.776
37757                       0000AB29            .777:
37758                                           ! 5391         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
37759                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
37760 AB29           8A46         12            mov	al,$12[bp]
37761 AB2C           30E4                       xor	ah,ah
37762 AB2E           50                         push	ax
37763                                           ! Debug: list * char = .778+0 (used reg = )
37764 AB2F           BB                   CC80  mov	bx,#.778
37765 AB32           53                         push	bx
37766                                           ! Debug: list int = const 4 (used reg = )
37767 AB33           B8                   0004  mov	ax,*4
37768 AB36           50                         push	ax
37769                                           ! Debug: func () void = bios_printf+0 (used reg = )
37770 AB37           E8         5E6D            call	_bios_printf
37771 AB3A           83C4                   06  add	sp,*6
37772                                           !BCC_EOS
37773                                           ! 5392       } else if (regs.u.r8.bl == 0x83) {
37774 AB3D           EB           5B            jmp .779
37775                       0000AB3F            .776:
37776                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
37777 AB3F           8A46         0C            mov	al,$C[bp]
37778 AB42           3C                     83  cmp	al,#$83
37779 AB44           75           13            jne 	.77A
37780                       0000AB46            .77B:
37781                                           ! 5393         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
37782                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
37783 AB46           FF76         0E            push	$E[bp]
37784                                           ! Debug: list * char = .77C+0 (used reg = )
37785 AB49           BB                   CC68  mov	bx,#.77C
37786 AB4C           53                         push	bx
37787                                           ! Debug: list int = const 4 (used reg = )
37788 AB4D           B8                   0004  mov	ax,*4
37789 AB50           50                         push	ax
37790                                           ! Debug: func () void = bios_printf+0 (used reg = )
37791 AB51           E8         5E53            call	_bios_printf
37792 AB54           83C4                   06  add	sp,*6
37793                                           !BCC_EOS
37794                                           ! 5394       } else if (regs.u.r8.bl == 0x86) {
37795 AB57           EB           41            jmp .77D
37796                       0000AB59            .77A:
37797                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
37798 AB59           8A46         0C            mov	al,$C[bp]
37799 AB5C           3C                     86  cmp	al,#$86
37800 AB5E           75           3A            jne 	.77E
37801                       0000AB60            .77F:
37802                                           ! 5395         if (regs.u.r8.al == 0x02) {
37803                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
37804 AB60           8A46         12            mov	al,$12[bp]
37805 AB63           3C                     02  cmp	al,*2
37806 AB65           75           19            jne 	.780
37807                       0000AB67            .781:
37808                                           ! 5396           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
37809                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37810 AB67           FF76         06            push	6[bp]
37811                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
37812 AB6A           FF76         10            push	$10[bp]
37813                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
37814 AB6D           FF76         0E            push	$E[bp]
37815                                           ! Debug: list * char = .782+0 (used reg = )
37816 AB70           BB                   CC3C  mov	bx,#.782
37817 AB73           53                         push	bx
37818                                           ! Debug: list int = const 4 (used reg = )
37819 AB74           B8                   0004  mov	ax,*4
37820 AB77           50                         push	ax
37821                                           ! Debug: func () void = bios_printf+0 (used reg = )
37822 AB78           E8         5E2C            call	_bios_printf
37823 AB7B           83C4                   0A  add	sp,*$A
37824                                           !BCC_EOS
37825                                           ! 5397         } else {
37826 AB7E           EB           1A            jmp .783
37827                       0000AB80            .780:
37828                                           ! 5398           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
37829                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37830 AB80           FF76         06            push	6[bp]
37831                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
37832 AB83           FF76         0E            push	$E[bp]
37833                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
37834 AB86           8A46         10            mov	al,$10[bp]
37835 AB89           30E4                       xor	ah,ah
37836 AB8B           50                         push	ax
37837                                           ! Debug: list * char = .784+0 (used reg = )
37838 AB8C           BB                   CC00  mov	bx,#.784
37839 AB8F           53                         push	bx
37840                                           ! Debug: list int = const 4 (used reg = )
37841 AB90           B8                   0004  mov	ax,*4
37842 AB93           50                         push	ax
37843                                           ! Debug: func () void = bios_printf+0 (used reg = )
37844 AB94           E8         5E10            call	_bios_printf
37845 AB97           83C4                   0A  add	sp,*$A
37846                                           !BCC_EOS
37847                                           ! 5399         }
37848                                           ! 5400       }
37849                       0000AB9A            .783:
37850                                           ! 5401       regs.u.r8.ah = regs.u.r8.bl;
37851                       0000AB9A            .77E:
37852                       0000AB9A            .77D:
37853                       0000AB9A            .779:
37854                       0000AB9A            .775:
37855                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
37856 AB9A           8A46         0C            mov	al,$C[bp]
37857 AB9D           8846         13            mov	$13[bp],al
37858                                           !BCC_EOS
37859                                           ! 5402       iret_addr.flags.u.r8.flagsl |= 0x01;
37860                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37861 ABA0           8A46         1A            mov	al,$1A[bp]
37862 ABA3           0C                     01  or	al,*1
37863 ABA5           8846         1A            mov	$1A[bp],al
37864                                           !BCC_EOS
37865                                           ! 5403       break;
37866 ABA8           EB           35            jmp .75A
37867                                           !BCC_EOS
37868                                           ! 5404     default:
37869                                           ! 5405       iret_addr.flags.u.r8.flagsl |= 0x01;
37870                       0000ABAA            .785:
37871                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37872 ABAA           8A46         1A            mov	al,$1A[bp]
37873 ABAD           0C                     01  or	al,*1
37874 ABAF           8846         1A            mov	$1A[bp],al
37875                                           !BCC_EOS
37876                                           ! 5406   }
37877                                           ! 5407 }
37878 ABB2           EB           2B            jmp .75A
37879                       0000ABB4            .75C:
37880 ABB4           2C                     00  sub	al,*0
37881 ABB6           72           F2            jb 	.785
37882 ABB8           3C                     07  cmp	al,*7
37883 ABBA           77           1B            ja  	.786
37884 ABBC           30E4                       xor	ah,ah
37885 ABBE           D1E0                       shl	ax,*1
37886 ABC0           89C3                       mov	bx,ax
37887 ABC2           2E                         seg	cs
37888 ABC3           FFA7       ABC7            br	.787[bx]
37889                       0000ABC7            .787:
37890 ABC7                      A843            .word	.75D
37891 ABC9                      A867            .word	.75E
37892 ABCB                      A88A            .word	.75F
37893 ABCD                      A8E3            .word	.762
37894 ABCF                      A95D            .word	.765
37895 ABD1                      A9B5            .word	.768
37896 ABD3                      AA3E            .word	.76B
37897 ABD5                      AAD4            .word	.770
37898                       0000ABD7            .786:
37899 ABD7           2C                     B1  sub	al,#$B1
37900 ABD9         0F84         FF2B            beq 	.771
37901 ABDD           EB           CB            jmp	.785
37902                       0000ABDF            .75A:
37903                       FFFFFFFC            ..FFDA	=	-4
37904 ABDF           89EC                       mov	sp,bp
37905 ABE1           5D                         pop	bp
37906 ABE2           C3                         ret
37907                                           ! 5408   void
37908                                           ! Register BX used in function int1a_function
37909                                           ! 5409 int70_function(regs, ds, iret_addr)
37910                                           ! 5410   pusha_regs_t regs;
37911                                           export	_int70_function
37912                       0000ABE3            _int70_function:
37913                                           !BCC_EOS
37914                                           ! 5411   Bit16u ds;
37915                                           !BCC_EOS
37916                                           ! 5412   iret_addr_t iret_addr;
37917                                           !BCC_EOS
37918                                           ! 5413 {
37919                                           ! 5414   Bit8u registerB = 0, registerC = 0;
37920 ABE3           55                         push	bp
37921 ABE4           89E5                       mov	bp,sp
37922 ABE6           4C                         dec	sp
37923                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
37924 ABE7           30C0                       xor	al,al
37925 ABE9           8846         FF            mov	-1[bp],al
37926 ABEC           4C                         dec	sp
37927                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
37928 ABED           30C0                       xor	al,al
37929 ABEF           8846         FE            mov	-2[bp],al
37930                                           !BCC_EOS
37931                                           ! 5415   registerB = inb_cmos( 0xB );
37932                                           ! Debug: list int = const $B (used reg = )
37933 ABF2           B8                   000B  mov	ax,*$B
37934 ABF5           50                         push	ax
37935                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37936 ABF6           E8         598E            call	_inb_cmos
37937 ABF9           44                         inc	sp
37938 ABFA           44                         inc	sp
37939                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
37940 ABFB           8846         FF            mov	-1[bp],al
37941                                           !BCC_EOS
37942                                           ! 5416   registerC = inb_cmos( 0xC );
37943                                           ! Debug: list int = const $C (used reg = )
37944 ABFE           B8                   000C  mov	ax,*$C
37945 AC01           50                         push	ax
37946                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37947 AC02           E8         5982            call	_inb_cmos
37948 AC05           44                         inc	sp
37949 AC06           44                         inc	sp
37950                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
37951 AC07           8846         FE            mov	-2[bp],al
37952                                           !BCC_EOS
37953                                           ! 5417   if( ( registerB & 0x60 ) != 0 ) {
37954                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
37955 AC0A           8A46         FF            mov	al,-1[bp]
37956 AC0D           24                     60  and	al,*$60
37957                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37958 AC0F           84C0                       test	al,al
37959 AC11         0F84         00EF            beq 	.788
37960                       0000AC15            .789:
37961                                           ! 5418     if( ( registerC & 0x20 ) != 0 ) {
37962                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
37963 AC15           8A46         FE            mov	al,-2[bp]
37964 AC18           24                     20  and	al,*$20
37965                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37966 AC1A           84C0                       test	al,al
37967 AC1C           74           04            je  	.78A
37968                       0000AC1E            .78B:
37969                                           ! 5419 #asm
37970                                           !BCC_EOS
37971                                           !BCC_ASM
37972                       00000000            _int70_function.registerC	set	0
37973                       FFFFFFFE            .int70_function.registerC	set	-2
37974                       00000016            _int70_function.ds	set	$16
37975                       00000014            .int70_function.ds	set	$14
37976                       00000001            _int70_function.registerB	set	1
37977                       FFFFFFFF            .int70_function.registerB	set	-1
37978                       00000018            _int70_function.iret_addr	set	$18
37979                       00000016            .int70_function.iret_addr	set	$16
37980                       00000006            _int70_function.regs	set	6
37981                       00000004            .int70_function.regs	set	4
37982 AC1E           FB                               sti
37983 AC1F           CD                     4A        int #0x4a
37984 AC21           FA                               cli
37985                                           ! 5423 endasm
37986                                           !BCC_ENDASM
37987                                           !BCC_EOS
37988                                           ! 5424     }
37989                                           ! 5425     if( ( registerC & 0x40 ) != 0 ) {
37990                       0000AC22            .78A:
37991                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
37992 AC22           8A46         FE            mov	al,-2[bp]
37993 AC25           24                     40  and	al,*$40
37994                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37995 AC27           84C0                       test	al,al
37996 AC29         0F84         00D7            beq 	.78C
37997                       0000AC2D            .78D:
37998                                           ! 5426       if( read_byte( 0x40, 0xA0 ) != 0 ) {
37999                                           ! Debug: list int = const $A0 (used reg = )
38000 AC2D           B8                   00A0  mov	ax,#$A0
38001 AC30           50                         push	ax
38002                                           ! Debug: list int = const $40 (used reg = )
38003 AC31           B8                   0040  mov	ax,*$40
38004 AC34           50                         push	ax
38005                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
38006 AC35           E8         59C0            call	_read_byte
38007 AC38           83C4                   04  add	sp,*4
38008                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
38009 AC3B           84C0                       test	al,al
38010 AC3D         0F84         00C3            beq 	.78E
38011                       0000AC41            .78F:
38012                                           ! 5427         Bit32u time, toggle;
38013                                           !BCC_EOS
38014                                           ! 5428         time = read_dword( 0x40, 0x9C );
38015 AC41           83C4                   F8  add	sp,*-8
38016                                           ! Debug: list int = const $9C (used reg = )
38017 AC44           B8                   009C  mov	ax,#$9C
38018 AC47           50                         push	ax
38019                                           ! Debug: list int = const $40 (used reg = )
38020 AC48           B8                   0040  mov	ax,*$40
38021 AC4B           50                         push	ax
38022                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
38023 AC4C           E8         5434            call	_read_dword
38024 AC4F           89D3                       mov	bx,dx
38025 AC51           83C4                   04  add	sp,*4
38026                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
38027 AC54           8946         FA            mov	-6[bp],ax
38028 AC57           895E         FC            mov	-4[bp],bx
38029                                           !BCC_EOS
38030                                           ! 5429         if( time < 0x3D1 ) {
38031                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
38032 AC5A           B8                   03D1  mov	ax,#$3D1
38033 AC5D           31DB                       xor	bx,bx
38034 AC5F           8D7E         FA            lea	di,-6[bp]
38035 AC62           E8         5466            call	lcmpul
38036 AC65           76           6A            jbe 	.790
38037                       0000AC67            .791:
38038                                           ! 5430           Bit16u segment, offset;
38039                                           !BCC_EOS
38040                                           ! 5431           segment = read_word( 0x40, 0x98 );
38041 AC67           83C4                   FC  add	sp,*-4
38042                                           ! Debug: list int = const $98 (used reg = )
38043 AC6A           B8                   0098  mov	ax,#$98
38044 AC6D           50                         push	ax
38045                                           ! Debug: list int = const $40 (used reg = )
38046 AC6E           B8                   0040  mov	ax,*$40
38047 AC71           50                         push	ax
38048                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
38049 AC72           E8         5996            call	_read_word
38050 AC75           83C4                   04  add	sp,*4
38051                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
38052 AC78           8946         F4            mov	-$C[bp],ax
38053                                           !BCC_EOS
38054                                           ! 5432           offset = read_word( 0x40, 0x9A );
38055                                           ! Debug: list int = const $9A (used reg = )
38056 AC7B           B8                   009A  mov	ax,#$9A
38057 AC7E           50                         push	ax
38058                                           ! Debug: list int = const $40 (used reg = )
38059 AC7F           B8                   0040  mov	ax,*$40
38060 AC82           50                         push	ax
38061                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
38062 AC83           E8         5985            call	_read_word
38063 AC86           83C4                   04  add	sp,*4
38064                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
38065 AC89           8946         F2            mov	-$E[bp],ax
38066                                           !BCC_EOS
38067                                           ! 5433           write_byte( 0x40, 0xA0, 0 );
38068                                           ! Debug: list int = const 0 (used reg = )
38069 AC8C           31C0                       xor	ax,ax
38070 AC8E           50                         push	ax
38071                                           ! Debug: list int = const $A0 (used reg = )
38072 AC8F           B8                   00A0  mov	ax,#$A0
38073 AC92           50                         push	ax
38074                                           ! Debug: list int = const $40 (used reg = )
38075 AC93           B8                   0040  mov	ax,*$40
38076 AC96           50                         push	ax
38077                                           ! Debug: func () void = write_byte+0 (used reg = )
38078 AC97           E8         5984            call	_write_byte
38079 AC9A           83C4                   06  add	sp,*6
38080                                           !BCC_EOS
38081                                           ! 5434           outb_cmos( 0xB, registerB & 0x37 );
38082                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
38083 AC9D           8A46         FF            mov	al,-1[bp]
38084 ACA0           24                     37  and	al,*$37
38085                                           ! Debug: list unsigned char = al+0 (used reg = )
38086 ACA2           30E4                       xor	ah,ah
38087 ACA4           50                         push	ax
38088                                           ! Debug: list int = const $B (used reg = )
38089 ACA5           B8                   000B  mov	ax,*$B
38090 ACA8           50                         push	ax
38091                                           ! Debug: func () void = outb_cmos+0 (used reg = )
38092 ACA9           E8         58CC            call	_outb_cmos
38093 ACAC           83C4                   04  add	sp,*4
38094                                           !BCC_EOS
38095                                           ! 5435           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
38096                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
38097 ACAF           FF76         F2            push	-$E[bp]
38098                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
38099 ACB2           FF76         F4            push	-$C[bp]
38100                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
38101 ACB5           E8         5940            call	_read_byte
38102 ACB8           83C4                   04  add	sp,*4
38103                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
38104 ACBB           0C                     80  or	al,#$80
38105                                           ! Debug: list unsigned char = al+0 (used reg = )
38106 ACBD           30E4                       xor	ah,ah
38107 ACBF           50                         push	ax
38108                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
38109 ACC0           FF76         F2            push	-$E[bp]
38110                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
38111 ACC3           FF76         F4            push	-$C[bp]
38112                                           ! Debug: func () void = write_byte+0 (used reg = )
38113 ACC6           E8         5955            call	_write_byte
38114 ACC9           83C4                   06  add	sp,*6
38115                                           !BCC_EOS
38116                                           ! 5436         } else {
38117 ACCC           83C4                   04  add	sp,*4
38118 ACCF           EB           30            jmp .792
38119                       0000ACD1            .790:
38120                                           ! 5437           time -= 0x3D1;
38121                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
38122 ACD1           B8                   03D1  mov	ax,#$3D1
38123 ACD4           31DB                       xor	bx,bx
38124 ACD6           53                         push	bx
38125 ACD7           50                         push	ax
38126 ACD8           8B46         FA            mov	ax,-6[bp]
38127 ACDB           8B5E         FC            mov	bx,-4[bp]
38128 ACDE           8D7E         F2            lea	di,-$E[bp]
38129 ACE1           E8         53FD            call	lsubul
38130 ACE4           8946         FA            mov	-6[bp],ax
38131 ACE7           895E         FC            mov	-4[bp],bx
38132 ACEA           83C4                   04  add	sp,*4
38133                                           !BCC_EOS
38134                                           ! 5438           write_dword( 0x40, 0x9C, time );
38135                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
38136 ACED           FF76         FC            push	-4[bp]
38137 ACF0           FF76         FA            push	-6[bp]
38138                                           ! Debug: list int = const $9C (used reg = )
38139 ACF3           B8                   009C  mov	ax,#$9C
38140 ACF6           50                         push	ax
38141                                           ! Debug: list int = const $40 (used reg = )
38142 ACF7           B8                   0040  mov	ax,*$40
38143 ACFA           50                         push	ax
38144                                           ! Debug: func () void = write_dword+0 (used reg = )
38145 ACFB           E8         539D            call	_write_dword
38146 ACFE           83C4                   08  add	sp,*8
38147                                           !BCC_EOS
38148                                           ! 5439         }
38149                                           ! 5440       }
38150                       0000AD01            .792:
38151 AD01           83C4                   08  add	sp,*8
38152                                           ! 5441     }
38153                       0000AD04            .78E:
38154                                           ! 5442   }
38155                       0000AD04            .78C:
38156                                           ! 5443 #asm
38157                       0000AD04            .788:
38158                                           !BCC_EOS
38159                                           !BCC_ASM
38160                       00000000            _int70_function.registerC	set	0
38161                       FFFFFFFE            .int70_function.registerC	set	-2
38162                       00000016            _int70_function.ds	set	$16
38163                       00000014            .int70_function.ds	set	$14
38164                       00000001            _int70_function.registerB	set	1
38165                       FFFFFFFF            .int70_function.registerB	set	-1
38166                       00000018            _int70_function.iret_addr	set	$18
38167                       00000016            .int70_function.iret_addr	set	$16
38168                       00000006            _int70_function.regs	set	6
38169                       00000004            .int70_function.regs	set	4
38170 AD04           E8         0400              call eoi_both_pics
38171                                           ! 5445 endasm
38172                                           !BCC_ENDASM
38173                                           !BCC_EOS
38174                                           ! 5446 }
38175 AD07           89EC                       mov	sp,bp
38176 AD09           5D                         pop	bp
38177 AD0A           C3                         ret
38178                                           ! 5447 #asm
38179                                           !BCC_ASM
38180                       00000012            _int70_function.ds	set	$12
38181                       00000014            _int70_function.iret_addr	set	$14
38182                       00000002            _int70_function.regs	set	2
38183                                           ;------------------------------------------
38184                                           ;- INT74h : PS/2 mouse hardware interrupt -
38185                                           ;------------------------------------------
38186                       0000AD0B            int74_handler:
38187 AD0B           FB                           sti
38188 AD0C           60                           pusha
38189 AD0D           1E                           push ds ;; save DS
38190 AD0E           6A                     00    push #0x00 ;; placeholder for status
38191 AD10           6A                     00    push #0x00 ;; placeholder for X
38192 AD12           6A                     00    push #0x00 ;; placeholder for Y
38193 AD14           6A                     00    push #0x00 ;; placeholder for Z
38194 AD16           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
38195 AD18           E8         BD36              call _int74_function
38196 AD1B           59                           pop cx ;; remove make_far_call from stack
38197 AD1C           E3           0C              jcxz int74_done
38198                                             ;; make far call to EBDA:0022
38199 AD1E           6A                     00    push #0x00
38200 AD20           1F                           pop ds
38201 AD21           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
38202 AD25           1F                           pop ds
38203 AD26           FF1E       0022              call far ptr[0x22]
38204                       0000AD2A            int74_done:
38205 AD2A           FA                           cli
38206 AD2B           E8         03D9              call eoi_both_pics
38207 AD2E           83C4                   08    add sp, #8 ;; pop status, x, y, z
38208 AD31           1F                           pop ds ;; restore DS
38209 AD32           61                           popa
38210 AD33           CF                           iret
38211                                           ;; This will perform an IRET, but will retain value of current CF
38212                                           ;; by altering flags on stack. Better than RETF #02.
38213                       0000AD34            iret_modify_cf:
38214 AD34           72           09              jc carry_set
38215 AD36           55                           push bp
38216 AD37           89E5                         mov bp, sp
38217 AD39           8066         06        FE    and BYTE [bp + 0x06], #0xfe
38218 AD3D           5D                           pop bp
38219 AD3E           CF                           iret
38220                       0000AD3F            carry_set:
38221 AD3F           55                           push bp
38222 AD40           89E5                         mov bp, sp
38223 AD42           804E         06        01    or BYTE [bp + 0x06], #0x01
38224 AD46           5D                           pop bp
38225 AD47           CF                           iret
38226                                           ;----------------------
38227                                           ;- INT13h (relocated) -
38228                                           ;----------------------
38229                                           ;
38230                                           ; int13_relocated is a little bit messed up since I played with it
38231                                           ; I have to rewrite it:
38232                                           ; - call a function that detect which function to call
38233                                           ; - make all called C function get the same parameters list
38234                                           ;
38235                       0000AD48            int13_relocated:
38236                                             ;; check for an eltorito function
38237 AD48           80FC                   4A    cmp ah,#0x4a
38238 AD4B           72           10              jb int13_not_eltorito
38239 AD4D           80FC                   4D    cmp ah,#0x4d
38240 AD50           77           0B              ja int13_not_eltorito
38241 AD52           60                           pusha
38242 AD53           06                           push es
38243 AD54           1E                           push ds
38244 AD55           16                           push ss
38245 AD56           1F                           pop ds
38246 AD57           68                   ADCF    push #int13_out
38247 AD5A           E9         D92D              jmp _int13_eltorito ;; ELDX not used
38248                       0000AD5D            int13_not_eltorito:
38249 AD5D           50                           push ax
38250 AD5E           53                           push bx
38251 AD5F           51                           push cx
38252 AD60           52                           push dx
38253                                             ;; check if emulation active
38254 AD61           E8         916B              call _cdemu_isactive
38255 AD64           3C                     00    cmp al,#0x00
38256 AD66           74           2B              je int13_cdemu_inactive
38257                                             ;; check if access to the emulated drive
38258 AD68           E8         918B              call _cdemu_emulated_drive
38259 AD6B           5A                           pop dx
38260 AD6C           52                           push dx
38261 AD6D           38D0                         cmp al,dl ;; int13 on emulated drive
38262 AD6F           75           0F              jne int13_nocdemu
38263 AD71           5A                           pop dx
38264 AD72           59                           pop cx
38265 AD73           5B                           pop bx
38266 AD74           58                           pop ax
38267 AD75           60                           pusha
38268 AD76           06                           push es
38269 AD77           1E                           push ds
38270 AD78           16                           push ss
38271 AD79           1F                           pop ds
38272 AD7A           68                   ADCF    push #int13_out
38273 AD7D           E9         DB5A              jmp _int13_cdemu ;; ELDX not used
38274                       0000AD80            int13_nocdemu:
38275 AD80           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
38276 AD83           38D0                         cmp al,dl ;; al is 0x00 or 0x80
38277 AD85           75           0C              jne int13_cdemu_inactive ;; inactive for device class
38278 AD87           5A                           pop dx
38279 AD88           59                           pop cx
38280 AD89           5B                           pop bx
38281 AD8A           58                           pop ax
38282 AD8B           50                           push ax
38283 AD8C           51                           push cx
38284 AD8D           52                           push dx
38285 AD8E           53                           push bx
38286 AD8F           FECA                         dec dl ;; real drive is dl - 1
38287 AD91           EB           08              jmp int13_legacy
38288                       0000AD93            int13_cdemu_inactive:
38289 AD93           5A                           pop dx
38290 AD94           59                           pop cx
38291 AD95           5B                           pop bx
38292 AD96           58                           pop ax
38293                       0000AD97            int13_noeltorito:
38294 AD97           50                           push ax
38295 AD98           51                           push cx
38296 AD99           52                           push dx
38297 AD9A           53                           push bx
38298                       0000AD9B            int13_legacy:
38299 AD9B           52                           push dx ;; push eltorito value of dx instead of sp
38300 AD9C           55                           push bp
38301 AD9D           56                           push si
38302 AD9E           57                           push di
38303 AD9F           06                           push es
38304 ADA0           1E                           push ds
38305 ADA1           16                           push ss
38306 ADA2           1F                           pop ds
38307                                             ;; now the 16-bit registers can be restored with:
38308                                             ;; pop ds; pop es; popa; iret
38309                                             ;; arguments passed to functions should be
38310                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
38311 ADA3           F6C2                   80    test dl, #0x80
38312 ADA6           75           06              jnz int13_notfloppy
38313 ADA8           68                   ADCF    push #int13_out
38314 ADAB           E9         E58F              jmp _int13_diskette_function
38315                       0000ADAE            int13_notfloppy:
38316 ADAE           80FA                   E0    cmp dl, #0xE0
38317 ADB1           72           0F              jb int13_notcdrom
38318 ADB3     66    C1EB                   10    shr ebx, #16
38319 ADB7           53                           push bx
38320 ADB8           E8         CDA0              call _int13_cdrom
38321 ADBB           5B                           pop bx
38322 ADBC     66    C1E3                   10    shl ebx, #16
38323 ADC0           EB           0D              jmp int13_out
38324                       0000ADC2            int13_notcdrom:
38325                       0000ADC2            int13_disk:
38326                                             ;; int13_harddisk modifies high word of EAX
38327 ADC2     66    C1E8                   10    shr eax, #16
38328 ADC6           50                           push ax
38329 ADC7           E8         BDA2              call _int13_harddisk
38330 ADCA           58                           pop ax
38331 ADCB     66    C1E0                   10    shl eax, #16
38332                       0000ADCF            int13_out:
38333 ADCF           1F                           pop ds
38334 ADD0           07                           pop es
38335 ADD1           61                           popa
38336 ADD2           CF                           iret
38337                                           ;----------
38338                                           ;- INT18h -
38339                                           ;----------
38340                       0000ADD3            int18_handler: ;; Boot Failure recovery: try the next device.
38341                                             ;; Reset SP and SS
38342 ADD3           B8                   FFFE    mov ax, #0xfffe
38343 ADD6           89C4                         mov sp, ax
38344 ADD8           31C0                         xor ax, ax
38345 ADDA           8ED0                         mov ss, ax
38346                                             ;; Get the boot sequence number out of the IPL memory
38347 ADDC           BB                   9FF0    mov bx, #0x9ff0
38348 ADDF           8EDB                         mov ds, bx ;; Set segment
38349 ADE1           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
38350 ADE5           43                           inc bx ;; ++
38351 ADE6           891E       0082              mov 0x0082, bx ;; Write it back
38352 ADEA           8ED8                         mov ds, ax ;; and reset the segment to zero.
38353                                             ;; Carry on in the INT 19h handler, using the new sequence number
38354 ADEC           53                           push bx
38355 ADED           EB           17              jmp int19_next_boot
38356                                           ;----------
38357                                           ;- INT19h -
38358                                           ;----------
38359                       0000ADEF            int19_relocated: ;; Boot function, relocated
38360                                             ;; int19 was beginning to be really complex, so now it
38361                                             ;; just calls a C function that does the work
38362 ADEF           55                           push bp
38363 ADF0           89E5                         mov bp, sp
38364                                             ;; Reset SS and SP
38365 ADF2           B8                   FFFE    mov ax, #0xfffe
38366 ADF5           89C4                         mov sp, ax
38367 ADF7           31C0                         xor ax, ax
38368 ADF9           8ED0                         mov ss, ax
38369                                             ;; Start from the first boot device (0, in AX)
38370 ADFB           BB                   9FF0    mov bx, #0x9ff0
38371 ADFE           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
38372 AE00           A3         0082              mov 0x0082, ax ;; Save the sequence number
38373 AE03           8ED8                         mov ds, ax ;; and reset the segment.
38374 AE05           50                           push ax
38375                       0000AE06            int19_next_boot:
38376                                             ;; Call the C code for the next boot device
38377 AE06           E8         F7D2              call _int19_function
38378                                             ;; Boot failed: invoke the boot recovery function
38379 AE09           CD                     18    int #0x18
38380                                           ;----------
38381                                           ;- INT1Ch -
38382                                           ;----------
38383                       0000AE0B            int1c_handler: ;; User Timer Tick
38384 AE0B           CF                           iret
38385                                           ;----------------------
38386                                           ;- POST: Floppy Drive -
38387                                           ;----------------------
38388                       0000AE0C            floppy_drive_post:
38389 AE0C           31C0                         xor ax, ax
38390 AE0E           8ED8                         mov ds, ax
38391 AE10           B0                     00    mov al, #0x00
38392 AE12           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
38393 AE15           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
38394 AE18           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
38395 AE1B           A2         0441              mov 0x0441, al ;; diskette controller status return code
38396 AE1E           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
38397 AE21           A2         0443              mov 0x0443, al ;; diskette controller status register 1
38398 AE24           A2         0444              mov 0x0444, al ;; diskette controller status register 2
38399 AE27           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
38400 AE2A           A2         0446              mov 0x0446, al ;; diskette controller head number
38401 AE2D           A2         0447              mov 0x0447, al ;; diskette controller sector number
38402 AE30           A2         0448              mov 0x0448, al ;; diskette controller bytes written
38403 AE33           A2         048B              mov 0x048b, al ;; diskette configuration data
38404                                             ;; -----------------------------------------------------------------
38405                                             ;; (048F) diskette controller information
38406                                             ;;
38407 AE36           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
38408 AE38           E6                     70    out 0x70, AL
38409 AE3A           E4                     71    in AL, 0x71
38410 AE3C           88C4                         mov ah, al ;; save byte to AH
38411                       0000AE3E            look_drive0:
38412 AE3E           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
38413 AE41           74           04              jz f0_missing ;; jump if no drive0
38414 AE43           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
38415 AE45           EB           02              jmp look_drive1
38416                       0000AE47            f0_missing:
38417 AE47           B3                     00    mov bl, #0x00 ;; no drive0
38418                       0000AE49            look_drive1:
38419 AE49           88E0                         mov al, ah ;; restore from AH
38420 AE4B           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
38421 AE4D           74           03              jz f1_missing ;; jump if no drive1
38422 AE4F           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
38423                       0000AE52            f1_missing:
38424                                                              ;; leave high bits in BL zerod
38425 AE52           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
38426                                             ;; -----------------------------------------------------------------
38427 AE56           B0                     00    mov al, #0x00
38428 AE58           A2         0490              mov 0x0490, al ;; diskette 0 media state
38429 AE5B           A2         0491              mov 0x0491, al ;; diskette 1 media state
38430                                                              ;; diskette 0,1 operational starting state
38431                                                              ;; drive type has not been determined,
38432                                                              ;; has no changed detection line
38433 AE5E           A2         0492              mov 0x0492, al
38434 AE61           A2         0493              mov 0x0493, al
38435 AE64           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
38436 AE67           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
38437 AE6A           B0                     02    mov al, #0x02
38438 AE6C           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
38439                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   AE6E           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   AE71           A3         0078              mov 0x1E*4, ax
 +a   AE74           B8                   F000    mov ax,  #0xF000
 +a   AE77           A3         007A              mov 0x1E*4+2, ax
38440                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   AE7A           B8                   EC59    mov ax,  #int13_diskette
 +a   AE7D           A3         0100              mov 0x40*4, ax
 +a   AE80           B8                   F000    mov ax,  #0xF000
 +a   AE83           A3         0102              mov 0x40*4+2, ax
38441                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   AE86           B8                   EF57    mov ax,  #int0e_handler
 +a   AE89           A3         0038              mov 0x0E*4, ax
 +a   AE8C           B8                   F000    mov ax,  #0xF000
 +a   AE8F           A3         003A              mov 0x0E*4+2, ax
38442 AE92           C3                           ret
38443                                           ;--------------------
38444                                           ;- POST: HARD DRIVE -
38445                                           ;--------------------
38446                                           ; relocated here because the primary POST area isnt big enough.
38447                       0000AE93            hard_drive_post:
38448 AE93           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
38449 AE95           BA                   03F6    mov dx, #0x03f6
38450 AE98           EE                           out dx, al
38451 AE99           31C0                         xor ax, ax
38452 AE9B           8ED8                         mov ds, ax
38453 AE9D           A2         0474              mov 0x0474, al
38454 AEA0           A2         0477              mov 0x0477, al
38455 AEA3           A2         048C              mov 0x048c, al
38456 AEA6           A2         048D              mov 0x048d, al
38457 AEA9           A2         048E              mov 0x048e, al
38458 AEAC           B0                     01    mov al, #0x01
38459 AEAE           A2         0475              mov 0x0475, al
38460 AEB1           B0                     C0    mov al, #0xc0
38461 AEB3           A2         0476              mov 0x0476, al
38462                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   AEB6           B8                   E3FE    mov ax,  #int13_handler
 +a   AEB9           A3         004C              mov 0x13*4, ax
 +a   AEBC           B8                   F000    mov ax,  #0xF000
 +a   AEBF           A3         004E              mov 0x13*4+2, ax
38463                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   AEC2           B8                   B196    mov ax,  #int76_handler
 +a   AEC5           A3         01D8              mov 0x76*4, ax
 +a   AEC8           B8                   F000    mov ax,  #0xF000
 +a   AECB           A3         01DA              mov 0x76*4+2, ax
38464                                             ;; INT 41h: hard disk 0 configuration pointer
38465                                             ;; INT 46h: hard disk 1 configuration pointer
38466                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   AECE           B8                   003D    mov ax,  #0x003D
 +a   AED1           A3         0104              mov 0x41*4, ax
 +a   AED4           B8                   9FC0    mov ax,  #0x9FC0
 +a   AED7           A3         0106              mov 0x41*4+2, ax
38467                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   AEDA           B8                   004D    mov ax,  #0x004D
 +a   AEDD           A3         0118              mov 0x46*4, ax
 +a   AEE0           B8                   9FC0    mov ax,  #0x9FC0
 +a   AEE3           A3         011A              mov 0x46*4+2, ax
38468                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
38469 AEE6           B0                     12    mov al, #0x12
38470 AEE8           E6                     70    out #0x70, al
38471 AEEA           E4                     71    in al, #0x71
38472 AEEC           24                     F0    and al, #0xf0
38473 AEEE           3C                     F0    cmp al, #0xf0
38474 AEF0           74           03              je post_d0_extended
38475 AEF2           E9         00D4              jmp check_for_hd1
38476                       0000AEF5            post_d0_extended:
38477 AEF5           B0                     19    mov al, #0x19
38478 AEF7           E6                     70    out #0x70, al
38479 AEF9           E4                     71    in al, #0x71
38480 AEFB           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38481 AEFD           74           07              je post_d0_type47
38482                                             HALT(8886)
 +a   AEFF           BA                   0400    mov dx,#0x400
 +a   AF02           B8                   22B6    mov ax,#8886
 +a   AF05           EF                           out dx,ax
38483                       0000AF06            post_d0_type47:
38484                                             ;; CMOS purpose param table offset
38485                                             ;; 1b cylinders low 0
38486                                             ;; 1c cylinders high 1
38487                                             ;; 1d heads 2
38488                                             ;; 1e write pre-comp low 5
38489                                             ;; 1f write pre-comp high 6
38490                                             ;; 20 retries/bad map/heads>8 8
38491                                             ;; 21 landing zone low C
38492                                             ;; 22 landing zone high D
38493                                             ;; 23 sectors/track E
38494 AF06           B8                   9FC0    mov ax, #0x9FC0
38495 AF09           8ED8                         mov ds, ax
38496                                             ;;; Filling EBDA table for hard disk 0.
38497 AF0B           B0                     1F    mov al, #0x1f
38498 AF0D           E6                     70    out #0x70, al
38499 AF0F           E4                     71    in al, #0x71
38500 AF11           88C4                         mov ah, al
38501 AF13           B0                     1E    mov al, #0x1e
38502 AF15           E6                     70    out #0x70, al
38503 AF17           E4                     71    in al, #0x71
38504 AF19           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
38505 AF1C           B0                     20    mov al, #0x20
38506 AF1E           E6                     70    out #0x70, al
38507 AF20           E4                     71    in al, #0x71
38508 AF22           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
38509 AF25           B0                     22    mov al, #0x22
38510 AF27           E6                     70    out #0x70, al
38511 AF29           E4                     71    in al, #0x71
38512 AF2B           88C4                         mov ah, al
38513 AF2D           B0                     21    mov al, #0x21
38514 AF2F           E6                     70    out #0x70, al
38515 AF31           E4                     71    in al, #0x71
38516 AF33           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
38517 AF36           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
38518 AF38           E6                     70    out #0x70, al
38519 AF3A           E4                     71    in al, #0x71 ;; high byte
38520 AF3C           88C4                         mov ah, al
38521 AF3E           B0                     1B    mov al, #0x1b
38522 AF40           E6                     70    out #0x70, al
38523 AF42           E4                     71    in al, #0x71 ;; low byte
38524 AF44           89C3                         mov bx, ax ;; BX = cylinders
38525 AF46           B0                     1D    mov al, #0x1d
38526 AF48           E6                     70    out #0x70, al
38527 AF4A           E4                     71    in al, #0x71
38528 AF4C           88C1                         mov cl, al ;; CL = heads
38529 AF4E           B0                     23    mov al, #0x23
38530 AF50           E6                     70    out #0x70, al
38531 AF52           E4                     71    in al, #0x71
38532 AF54           88C2                         mov dl, al ;; DL = sectors
38533 AF56           81FB                 0400    cmp bx, #1024
38534 AF5A           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38535                       0000AF5C            hd0_post_physical_chs:
38536                                             ;; no logical CHS mapping used, just physical CHS
38537                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38538 AF5C           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38539 AF60           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38540 AF64           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
38541 AF68           EB           5F              jmp check_for_hd1
38542                       0000AF6A            hd0_post_logical_chs:
38543                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38544 AF6A           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
38545 AF6E           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
38546 AF72           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
38547 AF76           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
38548 AF7A           B0                     A0    mov al, #0xa0
38549 AF7C           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
38550 AF7F           81FB                 0800    cmp bx, #2048
38551 AF83           77           06              jnbe hd0_post_above_2048
38552                                             ;; 1024 < c <= 2048 cylinders
38553 AF85           D1EB                         shr bx, #0x01
38554 AF87           D0E1                         shl cl, #0x01
38555 AF89           EB           22              jmp hd0_post_store_logical
38556                       0000AF8B            hd0_post_above_2048:
38557 AF8B           81FB                 1000    cmp bx, #4096
38558 AF8F           77           08              jnbe hd0_post_above_4096
38559                                             ;; 2048 < c <= 4096 cylinders
38560 AF91           C1EB                   02    shr bx, #0x02
38561 AF94           C0E1                   02    shl cl, #0x02
38562 AF97           EB           14              jmp hd0_post_store_logical
38563                       0000AF99            hd0_post_above_4096:
38564 AF99           81FB                 2000    cmp bx, #8192
38565 AF9D           77           08              jnbe hd0_post_above_8192
38566                                             ;; 4096 < c <= 8192 cylinders
38567 AF9F           C1EB                   03    shr bx, #0x03
38568 AFA2           C0E1                   03    shl cl, #0x03
38569 AFA5           EB           06              jmp hd0_post_store_logical
38570                       0000AFA7            hd0_post_above_8192:
38571                                             ;; 8192 < c <= 16384 cylinders
38572 AFA7           C1EB                   04    shr bx, #0x04
38573 AFAA           C0E1                   04    shl cl, #0x04
38574                       0000AFAD            hd0_post_store_logical:
38575 AFAD           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38576 AFB1           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38577                                             ;; checksum
38578 AFB5           B1                     0F    mov cl, #0x0f ;; repeat count
38579 AFB7           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
38580 AFBA           B0                     00    mov al, #0x00 ;; sum
38581                       0000AFBC            hd0_post_checksum_loop:
38582 AFBC           0204                         add al, [si]
38583 AFBE           46                           inc si
38584 AFBF           FEC9                         dec cl
38585 AFC1           75           F9              jnz hd0_post_checksum_loop
38586 AFC3           F6D0                         not al ;; now take 2s complement
38587 AFC5           FEC0                         inc al
38588 AFC7           8804                         mov [si], al
38589                                           ;;; Done filling EBDA table for hard disk 0.
38590                       0000AFC9            check_for_hd1:
38591                                             ;; is there really a second hard disk? if not, return now
38592 AFC9           B0                     12    mov al, #0x12
38593 AFCB           E6                     70    out #0x70, al
38594 AFCD           E4                     71    in al, #0x71
38595 AFCF           24                     0F    and al, #0x0f
38596 AFD1           75           01              jnz post_d1_exists
38597 AFD3           C3                           ret
38598                       0000AFD4            post_d1_exists:
38599                                             ;; check that the hd type is really 0x0f.
38600 AFD4           3C                     0F    cmp al, #0x0f
38601 AFD6           74           07              jz post_d1_extended
38602                                             HALT(9023)
 +a   AFD8           BA                   0400    mov dx,#0x400
 +a   AFDB           B8                   233F    mov ax,#9023
 +a   AFDE           EF                           out dx,ax
38603                       0000AFDF            post_d1_extended:
38604                                             ;; check that the extended type is 47 - user definable
38605 AFDF           B0                     1A    mov al, #0x1a
38606 AFE1           E6                     70    out #0x70, al
38607 AFE3           E4                     71    in al, #0x71
38608 AFE5           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38609 AFE7           74           07              je post_d1_type47
38610                                             HALT(9031)
 +a   AFE9           BA                   0400    mov dx,#0x400
 +a   AFEC           B8                   2347    mov ax,#9031
 +a   AFEF           EF                           out dx,ax
38611                       0000AFF0            post_d1_type47:
38612                                             ;; Table for disk1.
38613                                             ;; CMOS purpose param table offset
38614                                             ;; 0x24 cylinders low 0
38615                                             ;; 0x25 cylinders high 1
38616                                             ;; 0x26 heads 2
38617                                             ;; 0x27 write pre-comp low 5
38618                                             ;; 0x28 write pre-comp high 6
38619                                             ;; 0x29 heads>8 8
38620                                             ;; 0x2a landing zone low C
38621                                             ;; 0x2b landing zone high D
38622                                             ;; 0x2c sectors/track E
38623                                           ;;; Fill EBDA table for hard disk 1.
38624 AFF0           B8                   9FC0    mov ax, #0x9FC0
38625 AFF3           8ED8                         mov ds, ax
38626 AFF5           B0                     28    mov al, #0x28
38627 AFF7           E6                     70    out #0x70, al
38628 AFF9           E4                     71    in al, #0x71
38629 AFFB           88C4                         mov ah, al
38630 AFFD           B0                     27    mov al, #0x27
38631 AFFF           E6                     70    out #0x70, al
38632 B001           E4                     71    in al, #0x71
38633 B003           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
38634 B006           B0                     29    mov al, #0x29
38635 B008           E6                     70    out #0x70, al
38636 B00A           E4                     71    in al, #0x71
38637 B00C           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
38638 B00F           B0                     2B    mov al, #0x2b
38639 B011           E6                     70    out #0x70, al
38640 B013           E4                     71    in al, #0x71
38641 B015           88C4                         mov ah, al
38642 B017           B0                     2A    mov al, #0x2a
38643 B019           E6                     70    out #0x70, al
38644 B01B           E4                     71    in al, #0x71
38645 B01D           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
38646 B020           B0                     25    mov al, #0x25 ;; get cylinders word in AX
38647 B022           E6                     70    out #0x70, al
38648 B024           E4                     71    in al, #0x71 ;; high byte
38649 B026           88C4                         mov ah, al
38650 B028           B0                     24    mov al, #0x24
38651 B02A           E6                     70    out #0x70, al
38652 B02C           E4                     71    in al, #0x71 ;; low byte
38653 B02E           89C3                         mov bx, ax ;; BX = cylinders
38654 B030           B0                     26    mov al, #0x26
38655 B032           E6                     70    out #0x70, al
38656 B034           E4                     71    in al, #0x71
38657 B036           88C1                         mov cl, al ;; CL = heads
38658 B038           B0                     2C    mov al, #0x2c
38659 B03A           E6                     70    out #0x70, al
38660 B03C           E4                     71    in al, #0x71
38661 B03E           88C2                         mov dl, al ;; DL = sectors
38662 B040           81FB                 0400    cmp bx, #1024
38663 B044           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38664                       0000B046            hd1_post_physical_chs:
38665                                             ;; no logical CHS mapping used, just physical CHS
38666                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38667 B046           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38668 B04A           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38669 B04E           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
38670 B052           C3                           ret
38671                       0000B053            hd1_post_logical_chs:
38672                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38673 B053           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
38674 B057           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
38675 B05B           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
38676 B05F           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
38677 B063           B0                     A0    mov al, #0xa0
38678 B065           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
38679 B068           81FB                 0800    cmp bx, #2048
38680 B06C           77           06              jnbe hd1_post_above_2048
38681                                             ;; 1024 < c <= 2048 cylinders
38682 B06E           D1EB                         shr bx, #0x01
38683 B070           D0E1                         shl cl, #0x01
38684 B072           EB           22              jmp hd1_post_store_logical
38685                       0000B074            hd1_post_above_2048:
38686 B074           81FB                 1000    cmp bx, #4096
38687 B078           77           08              jnbe hd1_post_above_4096
38688                                             ;; 2048 < c <= 4096 cylinders
38689 B07A           C1EB                   02    shr bx, #0x02
38690 B07D           C0E1                   02    shl cl, #0x02
38691 B080           EB           14              jmp hd1_post_store_logical
38692                       0000B082            hd1_post_above_4096:
38693 B082           81FB                 2000    cmp bx, #8192
38694 B086           77           08              jnbe hd1_post_above_8192
38695                                             ;; 4096 < c <= 8192 cylinders
38696 B088           C1EB                   03    shr bx, #0x03
38697 B08B           C0E1                   03    shl cl, #0x03
38698 B08E           EB           06              jmp hd1_post_store_logical
38699                       0000B090            hd1_post_above_8192:
38700                                             ;; 8192 < c <= 16384 cylinders
38701 B090           C1EB                   04    shr bx, #0x04
38702 B093           C0E1                   04    shl cl, #0x04
38703                       0000B096            hd1_post_store_logical:
38704 B096           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38705 B09A           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38706                                             ;; checksum
38707 B09E           B1                     0F    mov cl, #0x0f ;; repeat count
38708 B0A0           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
38709 B0A3           B0                     00    mov al, #0x00 ;; sum
38710                       0000B0A5            hd1_post_checksum_loop:
38711 B0A5           0204                         add al, [si]
38712 B0A7           46                           inc si
38713 B0A8           FEC9                         dec cl
38714 B0AA           75           F9              jnz hd1_post_checksum_loop
38715 B0AC           F6D0                         not al ;; now take 2s complement
38716 B0AE           FEC0                         inc al
38717 B0B0           8804                         mov [si], al
38718                                           ;;; Done filling EBDA table for hard disk 1.
38719 B0B2           C3                           ret
38720                                           ;--------------------
38721                                           ;- POST: EBDA segment
38722                                           ;--------------------
38723                                           ; relocated here because the primary POST area isnt big enough.
38724                       0000B0B3            ebda_post:
38725 B0B3           B8                   9FC0    mov ax, #0x9FC0
38726 B0B6           8ED8                         mov ds, ax
38727 B0B8           C606       0000        01    mov byte ptr [0x0], #1
38728 B0BD           31C0                         xor ax, ax ; mov EBDA seg into 40E
38729 B0BF           8ED8                         mov ds, ax
38730 B0C1           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
38731 B0C7           C3                           ret;;
38732                                           ;--------------------
38733                                           ;- POST: EOI + jmp via [0x40:67)
38734                                           ;--------------------
38735                                           ; relocated here because the primary POST area isnt big enough.
38736                       0000B0C8            eoi_jmp_post:
38737 B0C8           B0                     20    mov al, #0x20
38738 B0CA           E6                     A0    out #0xA0, al ;; slave PIC EOI
38739 B0CC           B0                     20    mov al, #0x20
38740 B0CE           E6                     20    out #0x20, al ;; master PIC EOI
38741                       0000B0D0            jmp_post_0x467:
38742 B0D0           31C0                         xor ax, ax
38743 B0D2           8ED8                         mov ds, ax
38744 B0D4           FF2E       0467              jmp far ptr [0x467]
38745                       0000B0D8            iret_post_0x467:
38746 B0D8           31C0                         xor ax, ax
38747 B0DA           8ED8                         mov ds, ax
38748 B0DC           8B26       0467              mov sp, [0x467]
38749 B0E0           8E16       0469              mov ss, [0x469]
38750 B0E4           CF                           iret
38751                       0000B0E5            retf_post_0x467:
38752 B0E5           31C0                         xor ax, ax
38753 B0E7           8ED8                         mov ds, ax
38754 B0E9           8B26       0467              mov sp, [0x467]
38755 B0ED           8E16       0469              mov ss, [0x469]
38756 B0F1           CB                           retf
38757                       0000B0F2            s3_post:
38758 B0F2           BC                   0FFE    mov sp, #0xffe
38759 B0F5           E8         0748              call rombios32_init
38760 B0F8           E8         6774              call _s3_resume
38761 B0FB           B3                     00    mov bl, #0x00
38762 B0FD           21C0                         and ax, ax
38763 B0FF   7503    E9         2F9F              jz normal_post
38764 B104           E8         6162              call _s3_resume_panic
38765                                           ;--------------------
38766                       0000B107            eoi_both_pics:
38767 B107           B0                     20    mov al, #0x20
38768 B109           E6                     A0    out #0xA0, al ;; slave PIC EOI
38769                       0000B10B            eoi_master_pic:
38770 B10B           B0                     20    mov al, #0x20
38771 B10D           E6                     20    out #0x20, al ;; master PIC EOI
38772 B10F           C3                           ret
38773                                           ;--------------------
38774                       0000B110            BcdToBin:
38775                                             ;; in: AL in BCD format
38776                                             ;; out: AL in binary format, AH will always be 0
38777                                             ;; trashes BX
38778 B110           88C3                         mov bl, al
38779 B112           80E3                   0F    and bl, #0x0f ;; bl has low digit
38780 B115           C0E8                   04    shr al, #4 ;; al has high digit
38781 B118           B7                     0A    mov bh, #10
38782 B11A           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
38783 B11C           00D8                         add al, bl ;; then add low digit
38784 B11E           C3                           ret
38785                                           ;--------------------
38786                       0000B11F            timer_tick_post:
38787                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
38788                                             ;; Timer Ticks Roller Flag (0x470:byte)
38789                                             ;; The Timer Ticks Count needs to be set according to
38790                                             ;; the current CMOS time, as if ticks have been occurring
38791                                             ;; at 18.2hz since midnight up to this point. Calculating
38792                                             ;; this is a little complicated. Here are the factors I gather
38793                                             ;; regarding this. 14,318,180 hz was the original clock speed,
38794                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
38795                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
38796                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
38797                                             ;; the timer. With a maximum 16bit timer count, this is again
38798                                             ;; divided down by 65536 to 18.2hz.
38799                                             ;;
38800                                             ;; 14,318,180 Hz clock
38801                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
38802                                             ;; /4 = 1,193,181 Hz fed to timer
38803                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
38804                                             ;; 1 second = 18.20650736 ticks
38805                                             ;; 1 minute = 1092.390442 ticks
38806                                             ;; 1 hour = 65543.42651 ticks
38807                                             ;;
38808                                             ;; Given the values in the CMOS clock, one could calculate
38809                                             ;; the number of ticks by the following:
38810                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
38811                                             ;; (BcdToBin(minutes) * 1092.3904)
38812                                             ;; (BcdToBin(hours) * 65543.427)
38813                                             ;; To get a little more accuracy, since Im using integer
38814                                             ;; arithmatic, I use:
38815                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
38816                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
38817                                             ;; (BcdToBin(hours) * 65543427) / 1000
38818                                             ;; assuming DS=0000
38819                                             ;; get CMOS seconds
38820 B11F     66    31C0                         xor eax, eax ;; clear EAX
38821 B122           B0                     00    mov al, #0x00
38822 B124           E6                     70    out #0x70, al
38823 B126           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
38824 B128           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
38825 B12B     66    BA               0115CF2B    mov edx, #18206507
38826 B131     66    F7E2                         mul eax, edx
38827 B134     66    BB               000F4240    mov ebx, #1000000
38828 B13A     66    31D2                         xor edx, edx
38829 B13D     66    F7F3                         div eax, ebx
38830 B140     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
38831                                             ;; get CMOS minutes
38832 B143     66    31C0                         xor eax, eax ;; clear EAX
38833 B146           B0                     02    mov al, #0x02
38834 B148           E6                     70    out #0x70, al
38835 B14A           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
38836 B14C           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
38837 B14F     66    BA               00A6AF80    mov edx, #10923904
38838 B155     66    F7E2                         mul eax, edx
38839 B158     66    BB               00002710    mov ebx, #10000
38840 B15E     66    31D2                         xor edx, edx
38841 B161     66    F7F3                         div eax, ebx
38842 B164     66    01C1                         add ecx, eax ;; add to total ticks
38843                                             ;; get CMOS hours
38844 B167     66    31C0                         xor eax, eax ;; clear EAX
38845 B16A           B0                     04    mov al, #0x04
38846 B16C           E6                     70    out #0x70, al
38847 B16E           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
38848 B170           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
38849 B173     66    BA               03E81D03    mov edx, #65543427
38850 B179     66    F7E2                         mul eax, edx
38851 B17C     66    BB               000003E8    mov ebx, #1000
38852 B182     66    31D2                         xor edx, edx
38853 B185     66    F7F3                         div eax, ebx
38854 B188     66    01C1                         add ecx, eax ;; add to total ticks
38855 B18B     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
38856 B190           30C0                         xor al, al
38857 B192           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
38858 B195           C3                           ret
38859                                           ;--------------------
38860                       0000B196            int76_handler:
38861                                             ;; record completion in BIOS task complete flag
38862 B196           50                           push ax
38863 B197           1E                           push ds
38864 B198           B8                   0040    mov ax, #0x0040
38865 B19B           8ED8                         mov ds, ax
38866 B19D           C706       008E      00FF    mov 0x008E, #0xff
38867 B1A3           E8         FF61              call eoi_both_pics
38868 B1A6           1F                           pop ds
38869 B1A7           58                           pop ax
38870 B1A8           CF                           iret
38871                                           ;--------------------
38872                                           use32 386
38873                       0000B1A9            apm32_out_str:
38874 B1A9           50                           push eax
38875 B1AA           53                           push ebx
38876 B1AB           89C3                         mov ebx, eax
38877                       0000B1AD            apm32_out_str1:
38878 B1AD           2E                           SEG CS
38879 B1AE   67      8A07                         mov al, byte ptr [bx]
38880 B1B1           3C                     00    cmp al, #0
38881 B1B3           74           04              je apm32_out_str2
38882 B1B5           EE                           outb dx, al
38883 B1B6           43                           inc ebx
38884 B1B7           EB           F4              jmp apm32_out_str1
38885                       0000B1B9            apm32_out_str2:
38886 B1B9           5B                           pop ebx
38887 B1BA           58                           pop eax
38888 B1BB           C3                           ret
38889                       0000B1BC            apm32_07_poweroff_str:
38890 B1BC                        53              .ascii "Shutdown"
38891 B1C4                        00              db 0
38892                       0000B1C5            apm32_07_suspend_str:
38893 B1C5                        53              .ascii "Suspend"
38894 B1CC                        00              db 0
38895                       0000B1CD            apm32_07_standby_str:
38896 B1CD                        53              .ascii "Standby"
38897 B1D4                        00              db 0
38898                       0000B1D5            _apm32_entry:
38899 B1D5     66    9C                           pushf
38900                                           ;-----------------
38901                                           ; APM interface disconnect
38902                       0000B1D7            apm32_04:
38903 B1D7           3C                     04    cmp al, #0x04
38904 B1D9           75           05              jne apm32_05
38905 B1DB           E9     000000A1              jmp apm32_ok
38906                                           ;-----------------
38907                                           ; APM cpu idle
38908                       0000B1E0            apm32_05:
38909 B1E0           3C                     05    cmp al, #0x05
38910 B1E2           75           07              jne apm32_07
38911 B1E4           FB                           sti
38912 B1E5           F4                           hlt
38913 B1E6           E9     00000096              jmp apm32_ok
38914                                           ;-----------------
38915                                           ; APM Set Power State
38916                       0000B1EB            apm32_07:
38917 B1EB           3C                     07    cmp al, #0x07
38918 B1ED           75           52              jne apm32_08
38919 B1EF     66    83FB                   01    cmp bx, #1
38920 B1F3   7405    E9     00000087              jne apm32_ok
38921 B1FA     66    83F9                   03    cmp cx, #3
38922 B1FE           74           0E              je apm32_07_poweroff
38923 B200     66    83F9                   02    cmp cx, #2
38924 B204           74           19              je apm32_07_suspend
38925 B206     66    83F9                   01    cmp cx, #1
38926 B20A           74           24              je apm32_07_standby
38927 B20C           75           73              jne apm32_ok
38928                       0000B20E            apm32_07_poweroff:
38929 B20E           FA                           cli
38930 B20F     66    BA                   8900    mov dx, #0x8900
38931 B213     66    B8                   B1BC    mov ax, #apm32_07_poweroff_str
38932 B217           E8     FFFFFF8D              call apm32_out_str
38933                       0000B21C            apm32_07_1:
38934 B21C           F4                           hlt
38935 B21D           EB           FD              jmp apm32_07_1
38936                       0000B21F            apm32_07_suspend:
38937 B21F           52                           push edx
38938 B220     66    BA                   8900    mov dx, #0x8900
38939 B224     66    B8                   B1C5    mov ax, #apm32_07_suspend_str
38940 B228           E8     FFFFFF7C              call apm32_out_str
38941 B22D           5A                           pop edx
38942 B22E           EB           51              jmp apm32_ok
38943                       0000B230            apm32_07_standby:
38944 B230           52                           push edx
38945 B231     66    BA                   8900    mov dx, #0x8900
38946 B235     66    B8                   B1CD    mov ax, #apm32_07_standby_str
38947 B239           E8     FFFFFF6B              call apm32_out_str
38948 B23E           5A                           pop edx
38949 B23F           EB           40              jmp apm32_ok
38950                                           ;-----------------
38951                                           ; APM Enable / Disable
38952                       0000B241            apm32_08:
38953 B241           3C                     08    cmp al, #0x08
38954 B243           75           02              jne apm32_0a
38955 B245           EB           3A              jmp apm32_ok
38956                                           ;-----------------
38957                                           ; Get Power Status
38958                       0000B247            apm32_0a:
38959 B247           3C                     0A    cmp al, #0x0a
38960 B249           75           12              jne apm32_0b
38961 B24B           B7                     01    mov bh, #0x01
38962 B24D           B3                     FF    mov bl, #0xff
38963 B24F           B5                     80    mov ch, #0x80
38964 B251           B1                     FF    mov cl, #0xff
38965 B253     66    BA                   FFFF    mov dx, #0xffff
38966 B257     66    BE                   0000    mov si, #0
38967 B25B           EB           24              jmp apm32_ok
38968                                           ;-----------------
38969                                           ; Get PM Event
38970                       0000B25D            apm32_0b:
38971 B25D           3C                     0B    cmp al, #0x0b
38972 B25F           75           04              jne apm32_0e
38973 B261           B4                     80    mov ah, #0x80
38974 B263           EB           20              jmp apm32_error
38975                                           ;-----------------
38976                                           ; APM Driver Version
38977                       0000B265            apm32_0e:
38978 B265           3C                     0E    cmp al, #0x0e
38979 B267           75           06              jne apm32_0f
38980 B269           B4                     01    mov ah, #1
38981 B26B           B0                     02    mov al, #2
38982 B26D           EB           12              jmp apm32_ok
38983                                           ;-----------------
38984                                           ; APM Engage / Disengage
38985                       0000B26F            apm32_0f:
38986 B26F           3C                     0F    cmp al, #0x0f
38987 B271           75           02              jne apm32_10
38988 B273           EB           0C              jmp apm32_ok
38989                                           ;-----------------
38990                                           ; APM Get Capabilities
38991                       0000B275            apm32_10:
38992 B275           3C                     10    cmp al, #0x10
38993 B277           75           0C              jne apm32_unimplemented
38994 B279           B3                     00    mov bl, #0
38995 B27B     66    B9                   0000    mov cx, #0
38996 B27F           EB           00              jmp apm32_ok
38997                                           ;-----------------
38998                       0000B281            apm32_ok:
38999 B281     66    9D                           popf
39000 B283           F8                           clc
39001 B284           CB                           retf
39002                       0000B285            apm32_unimplemented:
39003                       0000B285            apm32_error:
39004 B285     66    9D                           popf
39005 B287           F9                           stc
39006 B288           CB                           retf
39007                                           use16 386
39008                       0000B289            apm16_out_str:
39009 B289     66    50                           push eax
39010 B28B     66    53                           push ebx
39011 B28D     66    89C3                         mov ebx, eax
39012                       0000B290            apm16_out_str1:
39013 B290           2E                           SEG CS
39014 B291           8A07                         mov al, byte ptr [bx]
39015 B293           3C                     00    cmp al, #0
39016 B295           74           05              je apm16_out_str2
39017 B297           EE                           outb dx, al
39018 B298     66    43                           inc ebx
39019 B29A           EB           F4              jmp apm16_out_str1
39020                       0000B29C            apm16_out_str2:
39021 B29C     66    5B                           pop ebx
39022 B29E     66    58                           pop eax
39023 B2A0           C3                           ret
39024                       0000B2A1            apm16_07_poweroff_str:
39025 B2A1                        53              .ascii "Shutdown"
39026 B2A9                        00              db 0
39027                       0000B2AA            apm16_07_suspend_str:
39028 B2AA                        53              .ascii "Suspend"
39029 B2B1                        00              db 0
39030                       0000B2B2            apm16_07_standby_str:
39031 B2B2                        53              .ascii "Standby"
39032 B2B9                        00              db 0
39033                       0000B2BA            _apm16_entry:
39034 B2BA           9C                           pushf
39035                                           ;-----------------
39036                                           ; APM interface disconnect
39037                       0000B2BB            apm16_04:
39038 B2BB           3C                     04    cmp al, #0x04
39039 B2BD           75           03              jne apm16_05
39040 B2BF           E9         008B              jmp apm16_ok
39041                                           ;-----------------
39042                                           ; APM cpu idle
39043                       0000B2C2            apm16_05:
39044 B2C2           3C                     05    cmp al, #0x05
39045 B2C4           75           05              jne apm16_07
39046 B2C6           FB                           sti
39047 B2C7           F4                           hlt
39048 B2C8           E9         0082              jmp apm16_ok
39049                                           ;-----------------
39050                                           ; APM Set Power State
39051                       0000B2CB            apm16_07:
39052 B2CB           3C                     07    cmp al, #0x07
39053 B2CD           75           41              jne apm16_08
39054 B2CF           83FB                   01    cmp bx, #1
39055 B2D2           75           79              jne apm16_ok
39056 B2D4           83F9                   03    cmp cx, #3
39057 B2D7           74           0C              je apm16_07_poweroff
39058 B2D9           83F9                   02    cmp cx, #2
39059 B2DC           74           14              je apm16_07_suspend
39060 B2DE           83F9                   01    cmp cx, #1
39061 B2E1           74           1E              je apm16_07_standby
39062 B2E3           75           68              jne apm16_ok
39063                       0000B2E5            apm16_07_poweroff:
39064 B2E5           FA                           cli
39065 B2E6           BA                   8900    mov dx, #0x8900
39066 B2E9           B8                   B2A1    mov ax, #apm16_07_poweroff_str
39067 B2EC           E8         FF9A              call apm16_out_str
39068                       0000B2EF            apm16_07_1:
39069 B2EF           F4                           hlt
39070 B2F0           EB           FD              jmp apm16_07_1
39071                       0000B2F2            apm16_07_suspend:
39072 B2F2     66    52                           push edx
39073 B2F4           BA                   8900    mov dx, #0x8900
39074 B2F7           B8                   B2AA    mov ax, #apm16_07_suspend_str
39075 B2FA           E8         FF8C              call apm16_out_str
39076 B2FD     66    5A                           pop edx
39077 B2FF           EB           4C              jmp apm16_ok
39078                       0000B301            apm16_07_standby:
39079 B301     66    52                           push edx
39080 B303           BA                   8900    mov dx, #0x8900
39081 B306           B8                   B2B2    mov ax, #apm16_07_standby_str
39082 B309           E8         FF7D              call apm16_out_str
39083 B30C     66    5A                           pop edx
39084 B30E           EB           3D              jmp apm16_ok
39085                                           ;-----------------
39086                                           ; APM Enable / Disable
39087                       0000B310            apm16_08:
39088 B310           3C                     08    cmp al, #0x08
39089 B312           75           02              jne apm16_0a
39090 B314           EB           37              jmp apm16_ok
39091                                           ;-----------------
39092                                           ; Get Power Status
39093                       0000B316            apm16_0a:
39094 B316           3C                     0A    cmp al, #0x0a
39095 B318           75           10              jne apm16_0b
39096 B31A           B7                     01    mov bh, #0x01
39097 B31C           B3                     FF    mov bl, #0xff
39098 B31E           B5                     80    mov ch, #0x80
39099 B320           B1                     FF    mov cl, #0xff
39100 B322           BA                   FFFF    mov dx, #0xffff
39101 B325           BE                   0000    mov si, #0
39102 B328           EB           23              jmp apm16_ok
39103                                           ;-----------------
39104                                           ; Get PM Event
39105                       0000B32A            apm16_0b:
39106 B32A           3C                     0B    cmp al, #0x0b
39107 B32C           75           04              jne apm16_0e
39108 B32E           B4                     80    mov ah, #0x80
39109 B330           EB           1E              jmp apm16_error
39110                                           ;-----------------
39111                                           ; APM Driver Version
39112                       0000B332            apm16_0e:
39113 B332           3C                     0E    cmp al, #0x0e
39114 B334           75           06              jne apm16_0f
39115 B336           B4                     01    mov ah, #1
39116 B338           B0                     02    mov al, #2
39117 B33A           EB           11              jmp apm16_ok
39118                                           ;-----------------
39119                                           ; APM Engage / Disengage
39120                       0000B33C            apm16_0f:
39121 B33C           3C                     0F    cmp al, #0x0f
39122 B33E           75           02              jne apm16_10
39123 B340           EB           0B              jmp apm16_ok
39124                                           ;-----------------
39125                                           ; APM Get Capabilities
39126                       0000B342            apm16_10:
39127 B342           3C                     10    cmp al, #0x10
39128 B344           75           0A              jne apm16_unimplemented
39129 B346           B3                     00    mov bl, #0
39130 B348           B9                   0000    mov cx, #0
39131 B34B           EB           00              jmp apm16_ok
39132                                           ;-----------------
39133                       0000B34D            apm16_ok:
39134 B34D           9D                           popf
39135 B34E           F8                           clc
39136 B34F           CB                           retf
39137                       0000B350            apm16_unimplemented:
39138                       0000B350            apm16_error:
39139 B350           9D                           popf
39140 B351           F9                           stc
39141 B352           CB                           retf
39142                       0000B353            apmreal_out_str:
39143 B353     66    50                           push eax
39144 B355     66    53                           push ebx
39145 B357     66    89C3                         mov ebx, eax
39146                       0000B35A            apmreal_out_str1:
39147 B35A           2E                           SEG CS
39148 B35B           8A07                         mov al, byte ptr [bx]
39149 B35D           3C                     00    cmp al, #0
39150 B35F           74           05              je apmreal_out_str2
39151 B361           EE                           outb dx, al
39152 B362     66    43                           inc ebx
39153 B364           EB           F4              jmp apmreal_out_str1
39154                       0000B366            apmreal_out_str2:
39155 B366     66    5B                           pop ebx
39156 B368     66    58                           pop eax
39157 B36A           C3                           ret
39158                       0000B36B            apmreal_07_poweroff_str:
39159 B36B                        53              .ascii "Shutdown"
39160 B373                        00              db 0
39161                       0000B374            apmreal_07_suspend_str:
39162 B374                        53              .ascii "Suspend"
39163 B37B                        00              db 0
39164                       0000B37C            apmreal_07_standby_str:
39165 B37C                        53              .ascii "Standby"
39166 B383                        00              db 0
39167 B384           9C                           pushf
39168                       0000B385            _apmreal_entry:
39169                                           ;-----------------
39170                                           ; APM installation check
39171                       0000B385            apmreal_00:
39172 B385           3C                     00    cmp al, #0x00
39173 B387           75           0E              jne apmreal_01
39174 B389           B4                     01    mov ah, #1
39175 B38B           B0                     02    mov al, #2
39176 B38D           B7                     50    mov bh, #0x50
39177 B38F           B3                     4D    mov bl, #0x4d
39178 B391           B9                   0003    mov cx, #0x3
39179 B394           E9         00CE              jmp apmreal_ok
39180                                           ;-----------------
39181                                           ; APM real mode interface connect
39182                       0000B397            apmreal_01:
39183 B397           3C                     01    cmp al, #0x01
39184 B399           75           03              jne apmreal_02
39185 B39B           E9         00C7              jmp apmreal_ok
39186                                           ;-----------------
39187                                           ; APM 16 bit protected mode interface connect
39188                       0000B39E            apmreal_02:
39189 B39E           3C                     02    cmp al, #0x02
39190 B3A0           75           12              jne apmreal_03
39191 B3A2           BB                   B2BA    mov bx, #_apm16_entry
39192 B3A5           B8                   F000    mov ax, #0xf000
39193 B3A8           BE                   FFF0    mov si, #0xfff0
39194 B3AB           B9                   F000    mov cx, #0xf000
39195 B3AE           BF                   FFF0    mov di, #0xfff0
39196 B3B1           E9         00B1              jmp apmreal_ok
39197                                           ;-----------------
39198                                           ; APM 32 bit protected mode interface connect
39199                       0000B3B4            apmreal_03:
39200 B3B4           3C                     03    cmp al, #0x03
39201 B3B6           75           1B              jne apmreal_04
39202 B3B8           B8                   F000    mov ax, #0xf000
39203 B3BB     66    BB               0000B1D5    mov ebx, #_apm32_entry
39204 B3C1           B9                   F000    mov cx, #0xf000
39205 B3C4     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
39206 B3CA           BA                   F000    mov dx, #0xf000
39207 B3CD           BF                   FFF0    mov di, #0xfff0
39208 B3D0           E9         0092              jmp apmreal_ok
39209                                           ;-----------------
39210                                           ; APM interface disconnect
39211                       0000B3D3            apmreal_04:
39212 B3D3           3C                     04    cmp al, #0x04
39213 B3D5           75           03              jne apmreal_05
39214 B3D7           E9         008B              jmp apmreal_ok
39215                                           ;-----------------
39216                                           ; APM cpu idle
39217                       0000B3DA            apmreal_05:
39218 B3DA           3C                     05    cmp al, #0x05
39219 B3DC           75           05              jne apmreal_07
39220 B3DE           FB                           sti
39221 B3DF           F4                           hlt
39222 B3E0           E9         0082              jmp apmreal_ok
39223                                           ;-----------------
39224                                           ; APM Set Power State
39225                       0000B3E3            apmreal_07:
39226 B3E3           3C                     07    cmp al, #0x07
39227 B3E5           75           41              jne apmreal_08
39228 B3E7           83FB                   01    cmp bx, #1
39229 B3EA           75           79              jne apmreal_ok
39230 B3EC           83F9                   03    cmp cx, #3
39231 B3EF           74           0C              je apmreal_07_poweroff
39232 B3F1           83F9                   02    cmp cx, #2
39233 B3F4           74           14              je apmreal_07_suspend
39234 B3F6           83F9                   01    cmp cx, #1
39235 B3F9           74           1E              je apmreal_07_standby
39236 B3FB           75           68              jne apmreal_ok
39237                       0000B3FD            apmreal_07_poweroff:
39238 B3FD           FA                           cli
39239 B3FE           BA                   8900    mov dx, #0x8900
39240 B401           B8                   B36B    mov ax, #apmreal_07_poweroff_str
39241 B404           E8         FF4C              call apmreal_out_str
39242                       0000B407            apmreal_07_1:
39243 B407           F4                           hlt
39244 B408           EB           FD              jmp apmreal_07_1
39245                       0000B40A            apmreal_07_suspend:
39246 B40A     66    52                           push edx
39247 B40C           BA                   8900    mov dx, #0x8900
39248 B40F           B8                   B374    mov ax, #apmreal_07_suspend_str
39249 B412           E8         FF3E              call apmreal_out_str
39250 B415     66    5A                           pop edx
39251 B417           EB           4C              jmp apmreal_ok
39252                       0000B419            apmreal_07_standby:
39253 B419     66    52                           push edx
39254 B41B           BA                   8900    mov dx, #0x8900
39255 B41E           B8                   B37C    mov ax, #apmreal_07_standby_str
39256 B421           E8         FF2F              call apmreal_out_str
39257 B424     66    5A                           pop edx
39258 B426           EB           3D              jmp apmreal_ok
39259                                           ;-----------------
39260                                           ; APM Enable / Disable
39261                       0000B428            apmreal_08:
39262 B428           3C                     08    cmp al, #0x08
39263 B42A           75           02              jne apmreal_0a
39264 B42C           EB           37              jmp apmreal_ok
39265                                           ;-----------------
39266                                           ; Get Power Status
39267                       0000B42E            apmreal_0a:
39268 B42E           3C                     0A    cmp al, #0x0a
39269 B430           75           10              jne apmreal_0b
39270 B432           B7                     01    mov bh, #0x01
39271 B434           B3                     FF    mov bl, #0xff
39272 B436           B5                     80    mov ch, #0x80
39273 B438           B1                     FF    mov cl, #0xff
39274 B43A           BA                   FFFF    mov dx, #0xffff
39275 B43D           BE                   0000    mov si, #0
39276 B440           EB           23              jmp apmreal_ok
39277                                           ;-----------------
39278                                           ; Get PM Event
39279                       0000B442            apmreal_0b:
39280 B442           3C                     0B    cmp al, #0x0b
39281 B444           75           04              jne apmreal_0e
39282 B446           B4                     80    mov ah, #0x80
39283 B448           EB           20              jmp apmreal_error
39284                                           ;-----------------
39285                                           ; APM Driver Version
39286                       0000B44A            apmreal_0e:
39287 B44A           3C                     0E    cmp al, #0x0e
39288 B44C           75           06              jne apmreal_0f
39289 B44E           B4                     01    mov ah, #1
39290 B450           B0                     02    mov al, #2
39291 B452           EB           11              jmp apmreal_ok
39292                                           ;-----------------
39293                                           ; APM Engage / Disengage
39294                       0000B454            apmreal_0f:
39295 B454           3C                     0F    cmp al, #0x0f
39296 B456           75           02              jne apmreal_10
39297 B458           EB           0B              jmp apmreal_ok
39298                                           ;-----------------
39299                                           ; APM Get Capabilities
39300                       0000B45A            apmreal_10:
39301 B45A           3C                     10    cmp al, #0x10
39302 B45C           75           0C              jne apmreal_unimplemented
39303 B45E           B3                     00    mov bl, #0
39304 B460           B9                   0000    mov cx, #0
39305 B463           EB           00              jmp apmreal_ok
39306                                           ;-----------------
39307                       0000B465            apmreal_ok:
39308 B465           9D                           popf
39309 B466           F8                           clc
39310 B467           E9         F8CA              jmp iret_modify_cf
39311                       0000B46A            apmreal_unimplemented:
39312                       0000B46A            apmreal_error:
39313 B46A           9D                           popf
39314 B46B           F9                           stc
39315 B46C           E9         F8C5              jmp iret_modify_cf
39316                                           ;--------------------
39317                                           use32 386
39318 B46F                  00000010            .align 16
39319                       0000B470            bios32_structure:
39320 B470                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
39321 B474                      B480              dw bios32_entry_point, 0xf ;; 32 bit physical address
39322 B478                        00              db 0 ;; revision level
39323                                             ;; length in paragraphs and checksum stored in a word to prevent errors
39324 B479                      9901              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
39325 B47B                        00              db 0,0,0,0,0 ;; reserved
39326 B480                  00000010            .align 16
39327                       0000B480            bios32_entry_point:
39328 B480           9C                           pushfd
39329 B481           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
39330 B486           75           29              jne unknown_service
39331 B488           B8               80000000    mov eax, #0x80000000
39332 B48D     66    BA                   0CF8    mov dx, #0x0cf8
39333 B491           EF                           out dx, eax
39334 B492     66    BA                   0CFC    mov dx, #0x0cfc
39335 B496           ED                           in eax, dx
39336 B497           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39337 B49C           75           13              jne unknown_service
39338 B49E           BB               000F0000    mov ebx, #0x000f0000
39339 B4A3           B9               00000000    mov ecx, #0
39340 B4A8           BA               0000B4C0    mov edx, #pcibios_protected
39341 B4AD           30C0                         xor al, al
39342 B4AF           EB           02              jmp bios32_end
39343                       0000B4B1            unknown_service:
39344 B4B1           B0                     80    mov al, #0x80
39345                       0000B4B3            bios32_end:
39346 B4B3           9D                           popfd
39347 B4B4           CB                           retf
39348 B4B5                  00000010            .align 16
39349                       0000B4C0            pcibios_protected:
39350 B4C0           9C                           pushfd
39351 B4C1           FA                           cli
39352 B4C2           56                           push esi
39353 B4C3           57                           push edi
39354 B4C4           3C                     01    cmp al, #0x01 ;; installation check
39355 B4C6           75           14              jne pci_pro_f02
39356 B4C8     66    BB                   0210    mov bx, #0x0210
39357 B4CC     66    B9                   0000    mov cx, #0
39358 B4D0           BA               20494350    mov edx, #0x20494350 ;; "PCI "
39359 B4D5           B0                     01    mov al, #0x01
39360 B4D7           E9     0000011B              jmp pci_pro_ok
39361                       0000B4DC            pci_pro_f02: ;; find pci device
39362 B4DC           3C                     02    cmp al, #0x02
39363 B4DE           75           38              jne pci_pro_f03
39364 B4E0           C1E1                   10    shl ecx, #16
39365 B4E3     66    89D1                         mov cx, dx
39366 B4E6     66    31DB                         xor bx, bx
39367 B4E9     66    BF                   0000    mov di, #0x00
39368                       0000B4ED            pci_pro_devloop:
39369 B4ED           E8     0000010C              call pci_pro_select_reg
39370 B4F2     66    BA                   0CFC    mov dx, #0x0cfc
39371 B4F6           ED                           in eax, dx
39372 B4F7           39C8                         cmp eax, ecx
39373 B4F9           75           0D              jne pci_pro_nextdev
39374 B4FB     66    83FE                   00    cmp si, #0
39375 B4FF   7505    E9     000000F1              je pci_pro_ok
39376 B506     66    4E                           dec si
39377                       0000B508            pci_pro_nextdev:
39378 B508     66    43                           inc bx
39379 B50A     66    81FB                 0100    cmp bx, #0x0100
39380 B50F           75           DC              jne pci_pro_devloop
39381 B511           B4                     86    mov ah, #0x86
39382 B513           E9     000000DA              jmp pci_pro_fail
39383                       0000B518            pci_pro_f03: ;; find class code
39384 B518           3C                     03    cmp al, #0x03
39385 B51A           75           35              jne pci_pro_f08
39386 B51C     66    31DB                         xor bx, bx
39387 B51F     66    BF                   0008    mov di, #0x08
39388                       0000B523            pci_pro_devloop2:
39389 B523           E8     000000D6              call pci_pro_select_reg
39390 B528     66    BA                   0CFC    mov dx, #0x0cfc
39391 B52C           ED                           in eax, dx
39392 B52D           C1E8                   08    shr eax, #8
39393 B530           39C8                         cmp eax, ecx
39394 B532           75           0D              jne pci_pro_nextdev2
39395 B534     66    83FE                   00    cmp si, #0
39396 B538   7505    E9     000000B8              je pci_pro_ok
39397 B53F     66    4E                           dec si
39398                       0000B541            pci_pro_nextdev2:
39399 B541     66    43                           inc bx
39400 B543     66    81FB                 0100    cmp bx, #0x0100
39401 B548           75           D9              jne pci_pro_devloop2
39402 B54A           B4                     86    mov ah, #0x86
39403 B54C           E9     000000A1              jmp pci_pro_fail
39404                       0000B551            pci_pro_f08: ;; read configuration byte
39405 B551           3C                     08    cmp al, #0x08
39406 B553           75           1B              jne pci_pro_f09
39407 B555           E8     000000A4              call pci_pro_select_reg
39408 B55A           52                           push edx
39409 B55B     66    89FA                         mov dx, di
39410 B55E     66    83E2                   03    and dx, #0x03
39411 B562     66    81C2                 0CFC    add dx, #0x0cfc
39412 B567           EC                           in al, dx
39413 B568           5A                           pop edx
39414 B569           88C1                         mov cl, al
39415 B56B           E9     00000087              jmp pci_pro_ok
39416                       0000B570            pci_pro_f09: ;; read configuration word
39417 B570           3C                     09    cmp al, #0x09
39418 B572           75           1A              jne pci_pro_f0a
39419 B574           E8     00000085              call pci_pro_select_reg
39420 B579           52                           push edx
39421 B57A     66    89FA                         mov dx, di
39422 B57D     66    83E2                   02    and dx, #0x02
39423 B581     66    81C2                 0CFC    add dx, #0x0cfc
39424 B586     66    ED                           in ax, dx
39425 B588           5A                           pop edx
39426 B589     66    89C1                         mov cx, ax
39427 B58C           EB           69              jmp pci_pro_ok
39428                       0000B58E            pci_pro_f0a: ;; read configuration dword
39429 B58E           3C                     0A    cmp al, #0x0a
39430 B590           75           10              jne pci_pro_f0b
39431 B592           E8     00000067              call pci_pro_select_reg
39432 B597           52                           push edx
39433 B598     66    BA                   0CFC    mov dx, #0x0cfc
39434 B59C           ED                           in eax, dx
39435 B59D           5A                           pop edx
39436 B59E           89C1                         mov ecx, eax
39437 B5A0           EB           55              jmp pci_pro_ok
39438                       0000B5A2            pci_pro_f0b: ;; write configuration byte
39439 B5A2           3C                     0B    cmp al, #0x0b
39440 B5A4           75           18              jne pci_pro_f0c
39441 B5A6           E8     00000053              call pci_pro_select_reg
39442 B5AB           52                           push edx
39443 B5AC     66    89FA                         mov dx, di
39444 B5AF     66    83E2                   03    and dx, #0x03
39445 B5B3     66    81C2                 0CFC    add dx, #0x0cfc
39446 B5B8           88C8                         mov al, cl
39447 B5BA           EE                           out dx, al
39448 B5BB           5A                           pop edx
39449 B5BC           EB           39              jmp pci_pro_ok
39450                       0000B5BE            pci_pro_f0c: ;; write configuration word
39451 B5BE           3C                     0C    cmp al, #0x0c
39452 B5C0           75           1A              jne pci_pro_f0d
39453 B5C2           E8     00000037              call pci_pro_select_reg
39454 B5C7           52                           push edx
39455 B5C8     66    89FA                         mov dx, di
39456 B5CB     66    83E2                   02    and dx, #0x02
39457 B5CF     66    81C2                 0CFC    add dx, #0x0cfc
39458 B5D4     66    89C8                         mov ax, cx
39459 B5D7     66    EF                           out dx, ax
39460 B5D9           5A                           pop edx
39461 B5DA           EB           1B              jmp pci_pro_ok
39462                       0000B5DC            pci_pro_f0d: ;; write configuration dword
39463 B5DC           3C                     0D    cmp al, #0x0d
39464 B5DE           75           10              jne pci_pro_unknown
39465 B5E0           E8     00000019              call pci_pro_select_reg
39466 B5E5           52                           push edx
39467 B5E6     66    BA                   0CFC    mov dx, #0x0cfc
39468 B5EA           89C8                         mov eax, ecx
39469 B5EC           EF                           out dx, eax
39470 B5ED           5A                           pop edx
39471 B5EE           EB           07              jmp pci_pro_ok
39472                       0000B5F0            pci_pro_unknown:
39473 B5F0           B4                     81    mov ah, #0x81
39474                       0000B5F2            pci_pro_fail:
39475 B5F2           5F                           pop edi
39476 B5F3           5E                           pop esi
39477 B5F4           9D                           popfd
39478 B5F5           F9                           stc
39479 B5F6           CB                           retf
39480                       0000B5F7            pci_pro_ok:
39481 B5F7           30E4                         xor ah, ah
39482 B5F9           5F                           pop edi
39483 B5FA           5E                           pop esi
39484 B5FB           9D                           popfd
39485 B5FC           F8                           clc
39486 B5FD           CB                           retf
39487                       0000B5FE            pci_pro_select_reg:
39488 B5FE           52                           push edx
39489 B5FF           B8               00800000    mov eax, #0x800000
39490 B604     66    89D8                         mov ax, bx
39491 B607           C1E0                   08    shl eax, #8
39492 B60A     66    81E7                 00FF    and di, #0xff
39493 B60F     66    09F8                         or ax, di
39494 B612           24                     FC    and al, #0xfc
39495 B614     66    BA                   0CF8    mov dx, #0x0cf8
39496 B618           EF                           out dx, eax
39497 B619           5A                           pop edx
39498 B61A           C3                           ret
39499                                           use16 386
39500                       0000B61B            pcibios_real:
39501 B61B     66    50                           push eax
39502 B61D           52                           push dx
39503 B61E     66    B8               80000000    mov eax, #0x80000000
39504 B624           BA                   0CF8    mov dx, #0x0cf8
39505 B627     66    EF                           out dx, eax
39506 B629           BA                   0CFC    mov dx, #0x0cfc
39507 B62C     66    ED                           in eax, dx
39508 B62E     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39509 B634           74           07              je pci_present
39510 B636           5A                           pop dx
39511 B637     66    58                           pop eax
39512 B639           B4                     FF    mov ah, #0xff
39513 B63B           F9                           stc
39514 B63C           C3                           ret
39515                       0000B63D            pci_present:
39516 B63D           5A                           pop dx
39517 B63E     66    58                           pop eax
39518 B640           3C                     01    cmp al, #0x01 ;; installation check
39519 B642           75           1A              jne pci_real_f02
39520 B644           B8                   0001    mov ax, #0x0001
39521 B647           BB                   0210    mov bx, #0x0210
39522 B64A           B9                   0000    mov cx, #0
39523 B64D     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
39524 B653     66    BF               000F0000    mov edi, #0xf0000
39525 B659           BF                   B4C0    mov di, #pcibios_protected
39526 B65C           F8                           clc
39527 B65D           C3                           ret
39528                       0000B65E            pci_real_f02: ;; find pci device
39529 B65E     66    56                           push esi
39530 B660     66    57                           push edi
39531 B662           3C                     02    cmp al, #0x02
39532 B664           75           34              jne pci_real_f03
39533 B666     66    C1E1                   10    shl ecx, #16
39534 B66A           89D1                         mov cx, dx
39535 B66C           31DB                         xor bx, bx
39536 B66E           BF                   0000    mov di, #0x00
39537                       0000B671            pci_real_devloop:
39538 B671           E8         012F              call pci_real_select_reg
39539 B674           BA                   0CFC    mov dx, #0x0cfc
39540 B677     66    ED                           in eax, dx
39541 B679     66    39C8                         cmp eax, ecx
39542 B67C           75           09              jne pci_real_nextdev
39543 B67E           83FE                   00    cmp si, #0
39544 B681   7503    E9         0115              je pci_real_ok
39545 B686           4E                           dec si
39546                       0000B687            pci_real_nextdev:
39547 B687           43                           inc bx
39548 B688           81FB                 0100    cmp bx, #0x0100
39549 B68C           75           E3              jne pci_real_devloop
39550 B68E           89CA                         mov dx, cx
39551 B690     66    C1E9                   10    shr ecx, #16
39552 B694           B8                   8602    mov ax, #0x8602
39553 B697           E9         00FB              jmp pci_real_fail
39554                       0000B69A            pci_real_f03: ;; find class code
39555 B69A           3C                     03    cmp al, #0x03
39556 B69C           75           32              jne pci_real_f08
39557 B69E           31DB                         xor bx, bx
39558 B6A0           BF                   0008    mov di, #0x08
39559                       0000B6A3            pci_real_devloop2:
39560 B6A3           E8         00FD              call pci_real_select_reg
39561 B6A6           BA                   0CFC    mov dx, #0x0cfc
39562 B6A9     66    ED                           in eax, dx
39563 B6AB     66    C1E8                   08    shr eax, #8
39564 B6AF     66    39C8                         cmp eax, ecx
39565 B6B2           75           09              jne pci_real_nextdev2
39566 B6B4           83FE                   00    cmp si, #0
39567 B6B7   7503    E9         00DF              je pci_real_ok
39568 B6BC           4E                           dec si
39569                       0000B6BD            pci_real_nextdev2:
39570 B6BD           43                           inc bx
39571 B6BE           81FB                 0100    cmp bx, #0x0100
39572 B6C2           75           DF              jne pci_real_devloop2
39573 B6C4           89CA                         mov dx, cx
39574 B6C6     66    C1E9                   10    shr ecx, #16
39575 B6CA           B8                   8603    mov ax, #0x8603
39576 B6CD           E9         00C5              jmp pci_real_fail
39577                       0000B6D0            pci_real_f08: ;; read configuration byte
39578 B6D0           3C                     08    cmp al, #0x08
39579 B6D2           75           14              jne pci_real_f09
39580 B6D4           E8         00CC              call pci_real_select_reg
39581 B6D7           52                           push dx
39582 B6D8           89FA                         mov dx, di
39583 B6DA           83E2                   03    and dx, #0x03
39584 B6DD           81C2                 0CFC    add dx, #0x0cfc
39585 B6E1           EC                           in al, dx
39586 B6E2           5A                           pop dx
39587 B6E3           88C1                         mov cl, al
39588 B6E5           E9         00B3              jmp pci_real_ok
39589                       0000B6E8            pci_real_f09: ;; read configuration word
39590 B6E8           3C                     09    cmp al, #0x09
39591 B6EA           75           14              jne pci_real_f0a
39592 B6EC           E8         00B4              call pci_real_select_reg
39593 B6EF           52                           push dx
39594 B6F0           89FA                         mov dx, di
39595 B6F2           83E2                   02    and dx, #0x02
39596 B6F5           81C2                 0CFC    add dx, #0x0cfc
39597 B6F9           ED                           in ax, dx
39598 B6FA           5A                           pop dx
39599 B6FB           89C1                         mov cx, ax
39600 B6FD           E9         009B              jmp pci_real_ok
39601                       0000B700            pci_real_f0a: ;; read configuration dword
39602 B700           3C                     0A    cmp al, #0x0a
39603 B702           75           10              jne pci_real_f0b
39604 B704           E8         009C              call pci_real_select_reg
39605 B707           52                           push dx
39606 B708           BA                   0CFC    mov dx, #0x0cfc
39607 B70B     66    ED                           in eax, dx
39608 B70D           5A                           pop dx
39609 B70E     66    89C1                         mov ecx, eax
39610 B711           E9         0087              jmp pci_real_ok
39611                       0000B714            pci_real_f0b: ;; write configuration byte
39612 B714           3C                     0B    cmp al, #0x0b
39613 B716           75           13              jne pci_real_f0c
39614 B718           E8         0088              call pci_real_select_reg
39615 B71B           52                           push dx
39616 B71C           89FA                         mov dx, di
39617 B71E           83E2                   03    and dx, #0x03
39618 B721           81C2                 0CFC    add dx, #0x0cfc
39619 B725           88C8                         mov al, cl
39620 B727           EE                           out dx, al
39621 B728           5A                           pop dx
39622 B729           EB           70              jmp pci_real_ok
39623                       0000B72B            pci_real_f0c: ;; write configuration word
39624 B72B           3C                     0C    cmp al, #0x0c
39625 B72D           75           13              jne pci_real_f0d
39626 B72F           E8         0071              call pci_real_select_reg
39627 B732           52                           push dx
39628 B733           89FA                         mov dx, di
39629 B735           83E2                   02    and dx, #0x02
39630 B738           81C2                 0CFC    add dx, #0x0cfc
39631 B73C           89C8                         mov ax, cx
39632 B73E           EF                           out dx, ax
39633 B73F           5A                           pop dx
39634 B740           EB           59              jmp pci_real_ok
39635                       0000B742            pci_real_f0d: ;; write configuration dword
39636 B742           3C                     0D    cmp al, #0x0d
39637 B744           75           0F              jne pci_real_f0e
39638 B746           E8         005A              call pci_real_select_reg
39639 B749           52                           push dx
39640 B74A           BA                   0CFC    mov dx, #0x0cfc
39641 B74D     66    89C8                         mov eax, ecx
39642 B750     66    EF                           out dx, eax
39643 B752           5A                           pop dx
39644 B753           EB           46              jmp pci_real_ok
39645                       0000B755            pci_real_f0e: ;; get irq routing options
39646 B755           3C                     0E    cmp al, #0x0e
39647 B757           75           3A              jne pci_real_unknown
39648 B759           26                           SEG ES
39649 B75A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39650 B75D           72           2B              jb pci_real_too_small
39651 B75F           26                           SEG ES
39652 B760           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39653 B764           9C                           pushf
39654 B765           1E                           push ds
39655 B766           06                           push es
39656 B767           51                           push cx
39657 B768           56                           push si
39658 B769           57                           push di
39659 B76A           FC                           cld
39660 B76B           BE                   B7E0    mov si, #pci_routing_table_structure_start
39661 B76E           0E                           push cs
39662 B76F           1F                           pop ds
39663 B770           26                           SEG ES
39664 B771           8B4D         02              mov cx, [di+2]
39665 B774           26                           SEG ES
39666 B775           8E45         04              mov es, [di+4]
39667 B778           89CF                         mov di, cx
39668 B77A           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
39669 B77D           F3                           rep
39670 B77E           A4                               movsb
39671 B77F           5F                           pop di
39672 B780           5E                           pop si
39673 B781           59                           pop cx
39674 B782           07                           pop es
39675 B783           1F                           pop ds
39676 B784           9D                           popf
39677 B785           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
39678 B788           EB           11              jmp pci_real_ok
39679                       0000B78A            pci_real_too_small:
39680 B78A           26                           SEG ES
39681 B78B           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39682 B78F           B4                     89    mov ah, #0x89
39683 B791           EB           02              jmp pci_real_fail
39684                       0000B793            pci_real_unknown:
39685 B793           B4                     81    mov ah, #0x81
39686                       0000B795            pci_real_fail:
39687 B795     66    5F                           pop edi
39688 B797     66    5E                           pop esi
39689 B799           F9                           stc
39690 B79A           C3                           ret
39691                       0000B79B            pci_real_ok:
39692 B79B           30E4                         xor ah, ah
39693 B79D     66    5F                           pop edi
39694 B79F     66    5E                           pop esi
39695 B7A1           F8                           clc
39696 B7A2           C3                           ret
39697                       0000B7A3            pci_real_select_reg:
39698 B7A3           52                           push dx
39699 B7A4     66    B8               00800000    mov eax, #0x800000
39700 B7AA           89D8                         mov ax, bx
39701 B7AC     66    C1E0                   08    shl eax, #8
39702 B7B0           81E7                 00FF    and di, #0xff
39703 B7B4           09F8                         or ax, di
39704 B7B6           24                     FC    and al, #0xfc
39705 B7B8           BA                   0CF8    mov dx, #0x0cf8
39706 B7BB     66    EF                           out dx, eax
39707 B7BD           5A                           pop dx
39708 B7BE           C3                           ret
39709 B7BF                  00000010            .align 16
39710                       0000B7C0            pci_routing_table_structure:
39711 B7C0                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39712 B7C4                        00              db 0, 1 ;; version
39713 B7C6                      0080              dw 32 + (6 * 16) ;; table size
39714 B7C8                        00              db 0 ;; PCI interrupt router bus
39715 B7C9                        08              db 0x08 ;; PCI interrupt router DevFunc
39716 B7CA                      0000              dw 0x0000 ;; PCI exclusive IRQs
39717 B7CC                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39718 B7CE                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39719 B7D0                      0000              dw 0,0 ;; Miniport data
39720 B7D4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39721 B7DF                        37              db 0x37 ;; checksum
39722                       0000B7E0            pci_routing_table_structure_start:
39723                                             ;; first slot entry PCI-to-ISA (embedded)
39724 B7E0                        00              db 0 ;; pci bus number
39725 B7E1                        08              db 0x08 ;; pci device number (bit 7-3)
39726 B7E2                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
39727 B7E3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39728 B7E5                        61              db 0x61 ;; link value INTB#
39729 B7E6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39730 B7E8                        62              db 0x62 ;; link value INTC#
39731 B7E9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39732 B7EB                        63              db 0x63 ;; link value INTD#
39733 B7EC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39734 B7EE                        00              db 0 ;; physical slot (0 = embedded)
39735 B7EF                        00              db 0 ;; reserved
39736                                             ;; second slot entry: 1st PCI slot
39737 B7F0                        00              db 0 ;; pci bus number
39738 B7F1                        10              db 0x10 ;; pci device number (bit 7-3)
39739 B7F2                        61              db 0x61 ;; link value INTA#
39740 B7F3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39741 B7F5                        62              db 0x62 ;; link value INTB#
39742 B7F6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39743 B7F8                        63              db 0x63 ;; link value INTC#
39744 B7F9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39745 B7FB                        60              db 0x60 ;; link value INTD#
39746 B7FC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39747 B7FE                        01              db 1 ;; physical slot (0 = embedded)
39748 B7FF                        00              db 0 ;; reserved
39749                                             ;; third slot entry: 2nd PCI slot
39750 B800                        00              db 0 ;; pci bus number
39751 B801                        18              db 0x18 ;; pci device number (bit 7-3)
39752 B802                        62              db 0x62 ;; link value INTA#
39753 B803                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39754 B805                        63              db 0x63 ;; link value INTB#
39755 B806                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39756 B808                        60              db 0x60 ;; link value INTC#
39757 B809                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39758 B80B                        61              db 0x61 ;; link value INTD#
39759 B80C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39760 B80E                        02              db 2 ;; physical slot (0 = embedded)
39761 B80F                        00              db 0 ;; reserved
39762                                             ;; 4th slot entry: 3rd PCI slot
39763 B810                        00              db 0 ;; pci bus number
39764 B811                        20              db 0x20 ;; pci device number (bit 7-3)
39765 B812                        63              db 0x63 ;; link value INTA#
39766 B813                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39767 B815                        60              db 0x60 ;; link value INTB#
39768 B816                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39769 B818                        61              db 0x61 ;; link value INTC#
39770 B819                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39771 B81B                        62              db 0x62 ;; link value INTD#
39772 B81C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39773 B81E                        03              db 3 ;; physical slot (0 = embedded)
39774 B81F                        00              db 0 ;; reserved
39775                                             ;; 5th slot entry: 4rd PCI slot
39776 B820                        00              db 0 ;; pci bus number
39777 B821                        28              db 0x28 ;; pci device number (bit 7-3)
39778 B822                        60              db 0x60 ;; link value INTA#
39779 B823                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39780 B825                        61              db 0x61 ;; link value INTB#
39781 B826                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39782 B828                        62              db 0x62 ;; link value INTC#
39783 B829                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39784 B82B                        63              db 0x63 ;; link value INTD#
39785 B82C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39786 B82E                        04              db 4 ;; physical slot (0 = embedded)
39787 B82F                        00              db 0 ;; reserved
39788                                             ;; 6th slot entry: 5rd PCI slot
39789 B830                        00              db 0 ;; pci bus number
39790 B831                        30              db 0x30 ;; pci device number (bit 7-3)
39791 B832                        61              db 0x61 ;; link value INTA#
39792 B833                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39793 B835                        62              db 0x62 ;; link value INTB#
39794 B836                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39795 B838                        63              db 0x63 ;; link value INTC#
39796 B839                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39797 B83B                        60              db 0x60 ;; link value INTD#
39798 B83C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39799 B83E                        05              db 5 ;; physical slot (0 = embedded)
39800 B83F                        00              db 0 ;; reserved
39801                       0000B840            pci_routing_table_structure_end:
39802                       0000B840            rombios32_init:
39803                                             ;; save a20 and enable it
39804 B840           E4                     92    in al, 0x92
39805 B842           50                           push ax
39806 B843           0C                     02    or al, #0x02
39807 B845           E6                     92    out 0x92, al
39808                                             ;; save SS:SP to the BDA
39809 B847           31C0                         xor ax, ax
39810 B849           8ED8                         mov ds, ax
39811 B84B           8C16       0469              mov 0x0469, ss
39812 B84F           8926       0467              mov 0x0467, sp
39813 B853           2E                           SEG CS
39814 B854         0F011E       F88C                lidt [pmode_IDT_info]
39815 B859           2E                           SEG CS
39816 B85A         0F0116       B8E1                lgdt [rombios32_gdt_48]
39817                                             ;; set PE bit in CR0
39818 B85F         0F20C0                         mov eax, cr0
39819 B862           0C                     01    or al, #0x01
39820 B864         0F22C0                         mov cr0, eax
39821                                             ;; start protected mode code: ljmpl 0x10:rombios32_init1
39822 B867                        66              db 0x66, 0xea
39823 B869                      B86F              dw rombios32_05
39824 B86B                      000F              dw 0x000f ;; high 16 bit address
39825 B86D                      0010              dw 0x0010
39826                                           use32 386
39827                       0000B86F            rombios32_05:
39828                                             ;; init data segments
39829 B86F           B8               00000018    mov eax, #0x18
39830 B874           8ED8                         mov ds, ax
39831 B876           8EC0                         mov es, ax
39832 B878           8ED0                         mov ss, ax
39833 B87A           31C0                         xor eax, eax
39834 B87C           8EE0                         mov fs, ax
39835 B87E           8EE8                         mov gs, ax
39836 B880           FC                           cld
39837                                             ;; init the stack pointer to point below EBDA
39838 B881   6766    A1         040E              mov ax, [0x040e]
39839 B886           C1E0                   04    shl eax, #4
39840 B889           BC               FFFFFFF0    mov esp, #-0x10
39841 B88E           01C4                         add esp, eax
39842                                             ;; pass pointer to s3_resume_flag and s3_resume_vector to rombios32
39843 B890           68               000004B0    push #0x04b0
39844 B895           68               000004B2    push #0x04b2
39845                                             ;; call rombios32 code
39846 B89A           B8               000E0000    mov eax, #0x000e0000
39847 B89F           FFD0                         call eax
39848                                             ;; return to 16 bit protected mode first
39849 B8A1                        EA              db 0xea
39850 B8A2                  0000B8A8              dd rombios32_10
39851 B8A6                      0020              dw 0x20
39852                                           use16 386
39853                       0000B8A8            rombios32_10:
39854                                             ;; restore data segment limits to 0xffff
39855 B8A8           B8                   0028    mov ax, #0x28
39856 B8AB           8ED8                         mov ds, ax
39857 B8AD           8EC0                         mov es, ax
39858 B8AF           8ED0                         mov ss, ax
39859 B8B1           8EE0                         mov fs, ax
39860 B8B3           8EE8                         mov gs, ax
39861                                             ;; reset PE bit in CR0
39862 B8B5         0F20C0                         mov eax, cr0
39863 B8B8           24                     FE    and al, #0xFE
39864 B8BA         0F22C0                         mov cr0, eax
39865                                             ;; far jump to flush CPU queue after transition to real mode
39866                                             JMP_AP(0xf000, rombios32_real_mode)
 +a   B8BD                        EA              db 0xea
 +a   B8BE                      B8C2              dw  rombios32_real_mode
 +a   B8C0                      F000              dw 0xf000
39867                       0000B8C2            rombios32_real_mode:
39868                                             ;; restore IDT to normal real-mode defaults
39869 B8C2           2E                           SEG CS
39870 B8C3         0F011E       F891                lidt [rmode_IDT_info]
39871 B8C8           31C0                         xor ax, ax
39872 B8CA           8ED8                         mov ds, ax
39873 B8CC           8EC0                         mov es, ax
39874 B8CE           8EE0                         mov fs, ax
39875 B8D0           8EE8                         mov gs, ax
39876                                             ;; restore SS:SP from the BDA
39877 B8D2           8E16       0469              mov ss, 0x0469
39878 B8D6     66    31E4                         xor esp, esp
39879 B8D9           8B26       0467              mov sp, 0x0467
39880                                             ;; restore a20
39881 B8DD           58                           pop ax
39882 B8DE           E6                     92    out 0x92, al
39883 B8E0           C3                           ret
39884                       0000B8E1            rombios32_gdt_48:
39885 B8E1                      0030              dw 0x30
39886 B8E3                      B8E7              dw rombios32_gdt
39887 B8E5                      000F              dw 0x000f
39888                       0000B8E7            rombios32_gdt:
39889 B8E7                      0000              dw 0, 0, 0, 0
39890 B8EF                      0000              dw 0, 0, 0, 0
39891 B8F7                      FFFF              dw 0xffff, 0, 0x9b00, 0x00cf ; 32 bit flat code segment (0x10)
39892 B8FF                      FFFF              dw 0xffff, 0, 0x9300, 0x00cf ; 32 bit flat data segment (0x18)
39893 B907                      FFFF              dw 0xffff, 0, 0x9b0f, 0x0000 ; 16 bit code segment base=0xf0000 limit=0xffff
39894 B90F                      FFFF              dw 0xffff, 0, 0x9300, 0x0000 ; 16 bit data segment base=0x0 limit=0xffff
39895                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
39896                       0000B917            detect_parport:
39897 B917           52                           push dx
39898 B918           83C2                   02    add dx, #2
39899 B91B           EC                           in al, dx
39900 B91C           24                     DF    and al, #0xdf ; clear input mode
39901 B91E           EE                           out dx, al
39902 B91F           5A                           pop dx
39903 B920           B0                     AA    mov al, #0xaa
39904 B922           EE                           out dx, al
39905 B923           EC                           in al, dx
39906 B924           3C                     AA    cmp al, #0xaa
39907 B926           75           0D              jne no_parport
39908 B928           53                           push bx
39909 B929           D1E3                         shl bx, #1
39910 B92B           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
39911 B92F           5B                           pop bx
39912 B930           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
39913 B934           43                           inc bx
39914                       0000B935            no_parport:
39915 B935           C3                           ret
39916                                           ; serial port detection: base address in DX, index in BX, timeout in CL
39917                       0000B936            detect_serial:
39918 B936           52                           push dx
39919 B937           42                           inc dx
39920 B938           B0                     02    mov al, #0x02
39921 B93A           EE                           out dx, al
39922 B93B           EC                           in al, dx
39923 B93C           3C                     02    cmp al, #0x02
39924 B93E           75           19              jne no_serial
39925 B940           42                           inc dx
39926 B941           EC                           in al, dx
39927 B942           3C                     02    cmp al, #0x02
39928 B944           75           13              jne no_serial
39929 B946           4A                           dec dx
39930 B947           30C0                         xor al, al
39931 B949           EE                           out dx, al
39932 B94A           5A                           pop dx
39933 B94B           53                           push bx
39934 B94C           D1E3                         shl bx, #1
39935 B94E           8997       0400              mov [bx+0x400], dx ; Serial I/O address
39936 B952           5B                           pop bx
39937 B953           888F       047C              mov [bx+0x47c], cl ; Serial timeout
39938 B957           43                           inc bx
39939 B958           C3                           ret
39940                       0000B959            no_serial:
39941 B959           5A                           pop dx
39942 B95A           C3                           ret
39943                       0000B95B            rom_checksum:
39944 B95B           60                           pusha
39945 B95C           1E                           push ds
39946 B95D           31C0                         xor ax, ax
39947 B95F           31DB                         xor bx, bx
39948 B961           31C9                         xor cx, cx
39949 B963           31D2                         xor dx, dx
39950 B965           8A2E       0002              mov ch, [2]
39951 B969           D1E1                         shl cx, #1
39952 B96B           73           03              jnc checksum_loop
39953 B96D           87CA                         xchg dx, cx
39954 B96F           49                           dec cx
39955                       0000B970            checksum_loop:
39956 B970           0207                         add al, [bx]
39957 B972           43                           inc bx
39958 B973           E2           FB              loop checksum_loop
39959 B975           85D2                         test dx, dx
39960 B977           74           11              je checksum_out
39961 B979           0207                         add al, [bx]
39962 B97B           89D1                         mov cx, dx
39963 B97D           8CDA                         mov dx, ds
39964 B97F           80C6                   10    add dh, #0x10
39965 B982           8EDA                         mov ds, dx
39966 B984           31D2                         xor dx, dx
39967 B986           31DB                         xor bx, bx
39968 B988           EB           E6              jmp checksum_loop
39969                       0000B98A            checksum_out:
39970 B98A           24                     FF    and al, #0xff
39971 B98C           1F                           pop ds
39972 B98D           61                           popa
39973 B98E           C3                           ret
39974                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
39975                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
39976 B98F                  00000010            .align 16
39977 B990                        00              db 0
39978                       0000B991            pnp_string:
39979 B991                        24              .ascii "$PnP"
39980                       0000B995            rom_scan:
39981                                             ;; Scan for existence of valid expansion ROMS.
39982                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
39983                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
39984                                             ;; System ROM: only 0xE0000
39985                                             ;;
39986                                             ;; Header:
39987                                             ;; Offset Value
39988                                             ;; 0 0x55
39989                                             ;; 1 0xAA
39990                                             ;; 2 ROM length in 512-byte blocks
39991                                             ;; 3 ROM initialization entry point (FAR CALL)
39992                       0000B995            rom_scan_loop:
39993 B995           50                           push ax ;; Save AX
39994 B996           8ED9                         mov ds, cx
39995 B998           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
39996 B99B           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
39997 B9A1   7403    E9         009E              jne rom_scan_increment
39998 B9A6           E8         FFB2              call rom_checksum
39999 B9A9   7403    E9         0096              jnz rom_scan_increment
40000 B9AE           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
40001                                             ;; We want our increment in 512-byte quantities, rounded to
40002                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
40003 B9B1           A8                     03    test al, #0x03
40004 B9B3           74           04              jz block_count_rounded
40005 B9B5           24                     FC    and al, #0xfc ;; needs rounding up
40006 B9B7           04                     04    add al, #0x04
40007                       0000B9B9            block_count_rounded:
40008 B9B9           31DB                         xor bx, bx ;; Restore DS back to 0000:
40009 B9BB           8EDB                         mov ds, bx
40010 B9BD           50                           push ax ;; Save AX
40011 B9BE           57                           push di ;; Save DI
40012                                             ;; Push addr of ROM entry point
40013 B9BF           51                           push cx ;; Push seg
40014 B9C0           6A                     03    push #0x0003 ;; Push offset
40015                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40016                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
40017 B9C2           B8                   F000    mov ax, #0xf000
40018 B9C5           8EC0                         mov es, ax
40019 B9C7           8D3E       B991              lea di, pnp_string
40020 B9CB           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
40021 B9CD                        FF              db 0xff ;; call_far ss:[bp+0]
40022 B9CE                        5E              db 0x5e
40023 B9CF                        00              db 0
40024 B9D0           FA                           cli ;; In case expansion ROM BIOS turns IF on
40025 B9D1           83C4                   02    add sp, #2 ;; Pop offset value
40026 B9D4           59                           pop cx ;; Pop seg value (restore CX)
40027                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
40028                                             ;; to init all the ROMs and then go back and build an IPL table of
40029                                             ;; all the bootable devices, but we can get away with one pass.
40030 B9D5           8ED9                         mov ds, cx ;; ROM base
40031 B9D7           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
40032 B9DB           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
40033 B9DD           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
40034 B9E0           75           60              jne no_bev
40035 B9E2           8B47         02              mov ax, 2[bx]
40036 B9E5           3D                   506E    cmp ax, #0x506e
40037 B9E8           75           58              jne no_bev
40038 B9EA           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
40039 B9ED           3D                   0000    cmp ax, #0x0000
40040 B9F0           74           17              je no_bcv
40041                                             ;; Option ROM has BCV. Run it now.
40042 B9F2           51                           push cx ;; Push seg
40043 B9F3           50                           push ax ;; Push offset
40044                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40045 B9F4           BB                   F000    mov bx, #0xf000
40046 B9F7           8EC3                         mov es, bx
40047 B9F9           8D3E       B991              lea di, pnp_string
40048 B9FD           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
40049 B9FF                        FF              db 0xff ;; call_far ss:[bp+0]
40050 BA00                        5E              db 0x5e
40051 BA01                        00              db 0
40052 BA02           FA                           cli ;; In case expansion ROM BIOS turns IF on
40053 BA03           83C4                   02    add sp, #2 ;; Pop offset value
40054 BA06           59                           pop cx ;; Pop seg value (restore CX)
40055 BA07           EB           39              jmp no_bev
40056                       0000BA09            no_bcv:
40057 BA09           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
40058 BA0C           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
40059 BA0F           74           31              je no_bev
40060                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
40061 BA11           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
40062 BA14           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
40063 BA17           8EDB                         mov ds, bx
40064 BA19           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
40065 BA1D           83FB                   08    cmp bx, #8
40066 BA20           74           20              je no_bev ;; Get out if the table is full
40067 BA22           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
40068 BA25           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
40069 BA29           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
40070 BA2C           8947         04              mov 4[bx], ax ;; and the offset
40071 BA2F           83FF                   00    cmp di, #0x0000
40072 BA32           74           06              je no_prod_str
40073 BA34           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
40074 BA37           897F         08              mov 8[bx], di ;; and the offset
40075                       0000BA3A            no_prod_str:
40076 BA3A           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
40077 BA3D           43                           inc bx ;; We have one more entry now
40078 BA3E           891E       0080              mov 0x0080, bx ;; Remember that.
40079                       0000BA42            no_bev:
40080 BA42           5F                           pop di ;; Restore DI
40081 BA43           58                           pop ax ;; Restore AX
40082                       0000BA44            rom_scan_increment:
40083 BA44           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
40084                                                           ;; because the segment selector is shifted left 4 bits.
40085 BA47           01C1                         add cx, ax
40086 BA49           58                           pop ax ;; Restore AX
40087 BA4A           39C1                         cmp cx, ax
40088 BA4C   7703    E9         FF44              jbe rom_scan_loop
40089 BA51           31C0                         xor ax, ax ;; Restore DS back to 0000:
40090 BA53           8ED8                         mov ds, ax
40091 BA55           C3                           ret
40092                       0000BA56            post_init_pic:
40093 BA56           B0                     11    mov al, #0x11 ; send initialisation commands
40094 BA58           E6                     20    out 0x20, al
40095 BA5A           E6                     A0    out 0xa0, al
40096 BA5C           B0                     08    mov al, #0x08
40097 BA5E           E6                     21    out 0x21, al
40098 BA60           B0                     70    mov al, #0x70
40099 BA62           E6                     A1    out 0xa1, al
40100 BA64           B0                     04    mov al, #0x04
40101 BA66           E6                     21    out 0x21, al
40102 BA68           B0                     02    mov al, #0x02
40103 BA6A           E6                     A1    out 0xa1, al
40104 BA6C           B0                     01    mov al, #0x01
40105 BA6E           E6                     21    out 0x21, al
40106 BA70           E6                     A1    out 0xa1, al
40107 BA72           B0                     B8    mov al, #0xb8
40108 BA74           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
40109 BA76           B0                     8F    mov al, #0x8f
40110 BA78           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
40111 BA7A           C3                           ret
40112                                           ;; the following area can be used to write dynamically generated tables
40113 BA7B                  00000010              .align 16
40114                       0000BA80            bios_table_area_start:
40115 BA80                  AAFB4442              dd 0xaafb4442
40116 BA84                  00001178              dd bios_table_area_end - bios_table_area_start - 8;
40117                                           ;--------
40118                                           ;- POST -
40119                                           ;--------
40120 E05B                                      .org 0xe05b ; POST Entry Point
40121                       0000E05B            post:
40122 E05B           31C0                         xor ax, ax
40123                                             ;; first reset the DMA controllers
40124 E05D           E6                     0D    out 0x0d,al
40125 E05F           E6                     DA    out 0xda,al
40126                                             ;; then initialize the DMA controllers
40127 E061           B0                     C0    mov al, #0xC0
40128 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
40129 E065           B0                     00    mov al, #0x00
40130 E067           E6                     D4    out 0xD4, al ; unmask channel 4
40131                                             ;; Examine CMOS shutdown status.
40132 E069           B0                     0F    mov AL, #0x0f
40133 E06B           E6                     70    out 0x70, AL
40134 E06D           E4                     71    in AL, 0x71
40135                                             ;; backup status
40136 E06F           88C3                         mov bl, al
40137                                             ;; Reset CMOS shutdown status.
40138 E071           B0                     0F    mov AL, #0x0f
40139 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
40140 E075           B0                     00    mov AL, #0x00
40141 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
40142                                             ;; Examine CMOS shutdown status.
40143 E079           88D8                         mov al, bl
40144                                             ;; 0x00, 0x09, 0x0D+ = normal startup
40145 E07B           3C                     00    cmp AL, #0x00
40146 E07D           74           24              jz normal_post
40147 E07F           3C                     0D    cmp AL, #0x0d
40148 E081           73           20              jae normal_post
40149                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
40150 E083           3C                     05    cmp al, #0x05
40151 E085   7503    E9         D03E              je eoi_jmp_post
40152                                             ;; 0x0A = jmp via [0x40:0x67] jump
40153 E08A           3C                     0A    cmp al, #0x0a
40154 E08C   7503    E9         D03F              je jmp_post_0x467
40155                                             ;; 0x0B = iret via [0x40:0x67]
40156 E091           3C                     0B    cmp al, #0x0b
40157 E093   7503    E9         D040              je iret_post_0x467
40158                                             ;; 0x0C = retf via [0x40:0x67]
40159 E098           3C                     0C    cmp al, #0x0c
40160 E09A   7503    E9         D046              je retf_post_0x467
40161                                             ;; Examine CMOS shutdown status.
40162                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
40163 E09F           53                           push bx
40164 E0A0           E8         31AE              call _shutdown_status_panic
40165                       0000E0A3            normal_post:
40166                                             ; case 0: normal startup
40167 E0A3           FA                           cli
40168 E0A4           B8                   FFFE    mov ax, #0xfffe
40169 E0A7           89C4                         mov sp, ax
40170 E0A9           31C0                         xor ax, ax
40171 E0AB           8ED8                         mov ds, ax
40172 E0AD           8ED0                         mov ss, ax
40173                                             ;; Save shutdown status
40174 E0AF           881E       04B0              mov 0x04b0, bl
40175 E0B3           80FB                   FE    cmp bl, #0xfe
40176 E0B6   7503    E9         D037              jz s3_post
40177                                             ;; zero out BIOS data area (40:00..40:ff)
40178 E0BB           8EC0                         mov es, ax
40179 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
40180 E0C0           BF                   0400    mov di, #0x0400
40181 E0C3           FC                           cld
40182 E0C4           F3                           rep
40183 E0C5           AB                             stosw
40184 E0C6           E8         371A              call _log_bios_start
40185                                             ;; set all interrupts to default handler
40186 E0C9           31DB                         xor bx, bx ;; offset index
40187 E0CB           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
40188 E0CE           B8                   FF53    mov ax, #dummy_iret_handler
40189 E0D1           BA                   F000    mov dx, #0xF000
40190                       0000E0D4            post_default_ints:
40191 E0D4           8907                         mov [bx], ax
40192 E0D6           83C3                   02    add bx, #2
40193 E0D9           8917                         mov [bx], dx
40194 E0DB           83C3                   02    add bx, #2
40195 E0DE           E2           F4              loop post_default_ints
40196                                             ;; set vector 0x79 to zero
40197                                             ;; this is used by 'gardian angel' protection system
40198                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E0           B8                   0000    mov ax,  #0
 +a   E0E3           A3         01E4              mov 0x79*4, ax
 +a   E0E6           B8                   0000    mov ax,  #0
 +a   E0E9           A3         01E6              mov 0x79*4+2, ax
40199                                             ;; base memory in K 40:13 (word)
40200 E0EC           B8                   027F    mov ax, #(640 - 1)
40201 E0EF           A3         0413              mov 0x0413, ax
40202                                             ;; Manufacturing Test 40:12
40203                                             ;; zerod out above
40204                                             ;; Warm Boot Flag 0040:0072
40205                                             ;; value of 1234h = skip memory checks
40206                                             ;; zerod out above
40207                                             ;; Printer Services vector
40208                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F2           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F5           A3         005C              mov 0x17*4, ax
 +a   E0F8           B8                   F000    mov ax,  #0xF000
 +a   E0FB           A3         005E              mov 0x17*4+2, ax
40209                                             ;; Bootstrap failure vector
40210                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E0FE           B8                   ADD3    mov ax,  #int18_handler
 +a   E101           A3         0060              mov 0x18*4, ax
 +a   E104           B8                   F000    mov ax,  #0xF000
 +a   E107           A3         0062              mov 0x18*4+2, ax
40211                                             ;; Bootstrap Loader vector
40212                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10A           B8                   E6F2    mov ax,  #int19_handler
 +a   E10D           A3         0064              mov 0x19*4, ax
 +a   E110           B8                   F000    mov ax,  #0xF000
 +a   E113           A3         0066              mov 0x19*4+2, ax
40213                                             ;; User Timer Tick vector
40214                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E116           B8                   AE0B    mov ax,  #int1c_handler
 +a   E119           A3         0070              mov 0x1c*4, ax
 +a   E11C           B8                   F000    mov ax,  #0xF000
 +a   E11F           A3         0072              mov 0x1c*4+2, ax
40215                                             ;; Memory Size Check vector
40216                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E122           B8                   F841    mov ax,  #int12_handler
 +a   E125           A3         0048              mov 0x12*4, ax
 +a   E128           B8                   F000    mov ax,  #0xF000
 +a   E12B           A3         004A              mov 0x12*4+2, ax
40217                                             ;; Equipment Configuration Check vector
40218                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E12E           B8                   F84D    mov ax,  #int11_handler
 +a   E131           A3         0044              mov 0x11*4, ax
 +a   E134           B8                   F000    mov ax,  #0xF000
 +a   E137           A3         0046              mov 0x11*4+2, ax
40219                                             ;; System Services
40220                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13A           B8                   F859    mov ax,  #int15_handler
 +a   E13D           A3         0054              mov 0x15*4, ax
 +a   E140           B8                   F000    mov ax,  #0xF000
 +a   E143           A3         0056              mov 0x15*4+2, ax
40221                                             ;; EBDA setup
40222 E146           E8         CF6A              call ebda_post
40223                                             ;; PIT setup
40224                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E149           B8                   FEA5    mov ax,  #int08_handler
 +a   E14C           A3         0020              mov 0x08*4, ax
 +a   E14F           B8                   F000    mov ax,  #0xF000
 +a   E152           A3         0022              mov 0x08*4+2, ax
40225                                             ;; int 1C already points at dummy_iret_handler (above)
40226 E155           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
40227 E157           E6                     43    out 0x43, al
40228 E159           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
40229 E15B           E6                     40    out 0x40, al
40230 E15D           E6                     40    out 0x40, al
40231                                             ;; Keyboard
40232                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E15F           B8                   E987    mov ax,  #int09_handler
 +a   E162           A3         0024              mov 0x09*4, ax
 +a   E165           B8                   F000    mov ax,  #0xF000
 +a   E168           A3         0026              mov 0x09*4+2, ax
40233                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E16B           B8                   E82E    mov ax,  #int16_handler
 +a   E16E           A3         0058              mov 0x16*4, ax
 +a   E171           B8                   F000    mov ax,  #0xF000
 +a   E174           A3         005A              mov 0x16*4+2, ax
40234 E177           31C0                         xor ax, ax
40235 E179           8ED8                         mov ds, ax
40236 E17B           A2         0417              mov 0x0417, al
40237 E17E           A2         0418              mov 0x0418, al
40238 E181           A2         0419              mov 0x0419, al
40239 E184           A2         0471              mov 0x0471, al
40240 E187           A2         0497              mov 0x0497, al
40241 E18A           B0                     10    mov al, #0x10
40242 E18C           A2         0496              mov 0x0496, al
40243 E18F           BB                   001E    mov bx, #0x001E
40244 E192           891E       041A              mov 0x041A, bx
40245 E196           891E       041C              mov 0x041C, bx
40246 E19A           BB                   001E    mov bx, #0x001E
40247 E19D           891E       0480              mov 0x0480, bx
40248 E1A1           BB                   003E    mov bx, #0x003E
40249 E1A4           891E       0482              mov 0x0482, bx
40250 E1A8           E8         2BCD              call _keyboard_init
40251                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
40252 E1AB           A1         0410              mov ax, 0x0410
40253 E1AE           B0                     14    mov al, #0x14
40254 E1B0           E6                     70    out 0x70, al
40255 E1B2           E4                     71    in al, 0x71
40256 E1B4           A3         0410              mov 0x0410, ax
40257                                             ;; Parallel setup
40258                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1B7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BA           A3         003C              mov 0x0F*4, ax
 +a   E1BD           B8                   F000    mov ax,  #0xF000
 +a   E1C0           A3         003E              mov 0x0F*4+2, ax
40259 E1C3           31C0                         xor ax, ax
40260 E1C5           8ED8                         mov ds, ax
40261 E1C7           31DB                         xor bx, bx
40262 E1C9           B1                     14    mov cl, #0x14 ; timeout value
40263 E1CB           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
40264 E1CE           E8         D746              call detect_parport
40265 E1D1           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
40266 E1D4           E8         D740              call detect_parport
40267 E1D7           C1E3                   0E    shl bx, #0x0e
40268 E1DA           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
40269 E1DD           25                   3FFF    and ax, #0x3fff
40270 E1E0           09D8                         or ax, bx ; set number of parallel ports
40271 E1E2           A3         0410              mov 0x410, ax
40272                                             ;; Serial setup
40273                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1E5           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1E8           A3         0030              mov 0x0C*4, ax
 +a   E1EB           B8                   F000    mov ax,  #0xF000
 +a   E1EE           A3         0032              mov 0x0C*4+2, ax
40274                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F1           B8                   E739    mov ax,  #int14_handler
 +a   E1F4           A3         0050              mov 0x14*4, ax
 +a   E1F7           B8                   F000    mov ax,  #0xF000
 +a   E1FA           A3         0052              mov 0x14*4+2, ax
40275 E1FD           31DB                         xor bx, bx
40276 E1FF           B1                     0A    mov cl, #0x0a ; timeout value
40277 E201           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
40278 E204           E8         D72F              call detect_serial
40279 E207           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
40280 E20A           E8         D729              call detect_serial
40281 E20D           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
40282 E210           E8         D723              call detect_serial
40283 E213           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
40284 E216           E8         D71D              call detect_serial
40285 E219           C1E3                   09    shl bx, #0x09
40286 E21C           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
40287 E21F           25                   F1FF    and ax, #0xf1ff
40288 E222           09D8                         or ax, bx ; set number of serial port
40289 E224           A3         0410              mov 0x410, ax
40290                                             ;; CMOS RTC
40291                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E227           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22A           A3         0068              mov 0x1A*4, ax
 +a   E22D           B8                   F000    mov ax,  #0xF000
 +a   E230           A3         006A              mov 0x1A*4+2, ax
40292                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E233           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E236           A3         0128              mov 0x4A*4, ax
 +a   E239           B8                   F000    mov ax,  #0xF000
 +a   E23C           A3         012A              mov 0x4A*4+2, ax
40293                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E23F           B8                   FE93    mov ax,  #int70_handler
 +a   E242           A3         01C0              mov 0x70*4, ax
 +a   E245           B8                   F000    mov ax,  #0xF000
 +a   E248           A3         01C2              mov 0x70*4+2, ax
40294                                             ;; BIOS DATA AREA 0x4CE ???
40295 E24B           E8         CED1              call timer_tick_post
40296                                             ;; PS/2 mouse setup
40297                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E24E           B8                   AD0B    mov ax,  #int74_handler
 +a   E251           A3         01D0              mov 0x74*4, ax
 +a   E254           B8                   F000    mov ax,  #0xF000
 +a   E257           A3         01D2              mov 0x74*4+2, ax
40298                                             ;; IRQ13 (FPU exception) setup
40299                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25A           B8                   E2C7    mov ax,  #int75_handler
 +a   E25D           A3         01D4              mov 0x75*4, ax
 +a   E260           B8                   F000    mov ax,  #0xF000
 +a   E263           A3         01D6              mov 0x75*4+2, ax
40300                                             ;; Video setup
40301                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E266           B8                   F065    mov ax,  #int10_handler
 +a   E269           A3         0040              mov 0x10*4, ax
 +a   E26C           B8                   F000    mov ax,  #0xF000
 +a   E26F           A3         0042              mov 0x10*4+2, ax
40302                                             ;; PIC
40303 E272           E8         D7E1              call post_init_pic
40304 E275           B9                   C000    mov cx, #0xc000 ;; init vga bios
40305 E278           B8                   C780    mov ax, #0xc780
40306 E27B           E8         D717              call rom_scan
40307 E27E           E8         2FFA              call _print_bios_banner
40308 E281           E8         D5BC              call rombios32_init
40309                                             ;;
40310                                             ;; Floppy setup
40311                                             ;;
40312 E284           E8         CB85              call floppy_drive_post
40313                                             ;;
40314                                             ;; Hard Drive setup
40315                                             ;;
40316 E287           E8         CC09              call hard_drive_post
40317                                             ;;
40318                                             ;; ATA/ATAPI driver setup
40319                                             ;;
40320 E28A           E8         36BD              call _ata_init
40321 E28D           E8         3B0C              call _ata_detect
40322                                             ;;
40323                                             ;;
40324                                             ;; eltorito floppy/harddisk emulation from cd
40325                                             ;;
40326 E290           E8         5C12              call _cdemu_init
40327                                             ;;
40328 E293           E8         303E              call _init_boot_vectors
40329 E296           B9                   C800    mov cx, #0xc800 ;; init option roms
40330 E299           B8                   E000    mov ax, #0xe000
40331 E29C           E8         D6F6              call rom_scan
40332 E29F           E8         31C6              call _interactive_bootkey
40333 E2A2           FB                           sti ;; enable interrupts
40334 E2A3           CD                     19    int #0x19
40335 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
40336                       0000E2C3            nmi:
40337                                             ;; FIXME the NMI handler should not panic
40338                                             ;; but iret when called from int75 (fpu exception)
40339 E2C3           E8         34F9              call _nmi_handler_msg
40340 E2C6           CF                           iret
40341                       0000E2C7            int75_handler:
40342 E2C7           E6                     F0    out 0xf0, al
40343 E2C9           E8         CE3B              call eoi_both_pics
40344 E2CC           CD                     02    int 2
40345 E2CE           CF                           iret
40346                                           ;-------------------------------------------
40347                                           ;- INT 13h Fixed Disk Services Entry Point -
40348                                           ;-------------------------------------------
40349 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
40350                       0000E3FE            int13_handler:
40351 E3FE           E9         C947              jmp int13_relocated
40352 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
40353                                           ;----------
40354                                           ;- INT19h -
40355                                           ;----------
40356 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
40357                       0000E6F2            int19_handler:
40358 E6F2           E9         C6FA              jmp int19_relocated
40359                                           ;-------------------------------------------
40360                                           ;- System BIOS Configuration Data Table
40361                                           ;-------------------------------------------
40362 E6F5                                      .org 0xe6f5
40363 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
40364 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
40365 E6F7                        FC            db 0xFC
40366 E6F8                        00            db 0x00
40367 E6F9                        01            db 1
40368                                           ; Feature byte 1
40369                                           ; b7: 1=DMA channel 3 used by hard disk
40370                                           ; b6: 1=2 interrupt controllers present
40371                                           ; b5: 1=RTC present
40372                                           ; b4: 1=BIOS calls int 15h/4Fh every key
40373                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
40374                                           ; b2: 1=extended BIOS data area used
40375                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
40376                                           ; b0: 1=Dual bus (MicroChannel + ISA)
40377 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
40378                                           ; Feature byte 2
40379                                           ; b7: 1=32-bit DMA supported
40380                                           ; b6: 1=int16h, function 9 supported
40381                                           ; b5: 1=int15h/C6h (get POS data) supported
40382                                           ; b4: 1=int15h/C7h (get mem map info) supported
40383                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
40384                                           ; b2: 1=non-8042 kb controller
40385                                           ; b1: 1=data streaming supported
40386                                           ; b0: reserved
40387 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
40388                                           ; Feature byte 3
40389                                           ; b7: not used
40390                                           ; b6: reserved
40391                                           ; b5: reserved
40392                                           ; b4: POST supports ROM-to-RAM enable/disable
40393                                           ; b3: SCSI on system board
40394                                           ; b2: info panel installed
40395                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
40396                                           ; b0: SCSI supported in IML
40397 E6FC                        00            db 0x00
40398                                           ; Feature byte 4
40399                                           ; b7: IBM private
40400                                           ; b6: EEPROM present
40401                                           ; b5-3: ABIOS presence (011 = not supported)
40402                                           ; b2: private
40403                                           ; b1: memory split above 16Mb supported
40404                                           ; b0: POSTEXT directly supported by POST
40405 E6FD                        00            db 0x00
40406                                           ; Feature byte 5 (IBM)
40407                                           ; b1: enhanced mouse
40408                                           ; b0: flash EPROM
40409 E6FE                        00            db 0x00
40410 E729                                      .org 0xe729 ; Baud Rate Generator Table
40411                                           ;----------
40412                                           ;- INT14h -
40413                                           ;----------
40414 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
40415                       0000E739            int14_handler:
40416 E739           1E                           push ds
40417 E73A           60                           pusha
40418 E73B           31C0                         xor ax, ax
40419 E73D           8ED8                         mov ds, ax
40420 E73F           E8         5F79              call _int14_function
40421 E742           61                           popa
40422 E743           1F                           pop ds
40423 E744           CF                           iret
40424                                           ;----------------------------------------
40425                                           ;- INT 16h Keyboard Service Entry Point -
40426                                           ;----------------------------------------
40427 E82E                                      .org 0xe82e
40428                       0000E82E            int16_handler:
40429 E82E           FB                           sti
40430 E82F           1E                           push ds
40431 E830           9C                           pushf
40432 E831           60                           pusha
40433 E832           80FC                   00    cmp ah, #0x00
40434 E835           74           24              je int16_F00
40435 E837           80FC                   10    cmp ah, #0x10
40436 E83A           74           1F              je int16_F00
40437 E83C           BB                   F000    mov bx, #0xf000
40438 E83F           8EDB                         mov ds, bx
40439 E841           E8         737B              call _int16_function
40440 E844           61                           popa
40441 E845           9D                           popf
40442 E846           1F                           pop ds
40443 E847           74           09              jz int16_zero_set
40444                       0000E849            int16_zero_clear:
40445 E849           55                           push bp
40446 E84A           89E5                         mov bp, sp
40447 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
40448 E850           5D                           pop bp
40449 E851           CF                           iret
40450                       0000E852            int16_zero_set:
40451 E852           55                           push bp
40452 E853           89E5                         mov bp, sp
40453 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
40454 E859           5D                           pop bp
40455 E85A           CF                           iret
40456                       0000E85B            int16_F00:
40457 E85B           BB                   0040    mov bx, #0x0040
40458 E85E           8EDB                         mov ds, bx
40459                       0000E860            int16_wait_for_key:
40460 E860           FA                           cli
40461 E861           8B1E       001A              mov bx, 0x001a
40462 E865           3B1E       001C              cmp bx, 0x001c
40463 E869           75           04              jne int16_key_found
40464 E86B           FB                           sti
40465 E86C           90                           nop
40466 E86D           EB           F1              jmp int16_wait_for_key
40467                       0000E86F            int16_key_found:
40468 E86F           BB                   F000    mov bx, #0xf000
40469 E872           8EDB                         mov ds, bx
40470 E874           E8         7348              call _int16_function
40471 E877           61                           popa
40472 E878           9D                           popf
40473 E879           1F                           pop ds
40474 E87A           CF                           iret
40475                                           ;-------------------------------------------------
40476                                           ;- INT09h : Keyboard Hardware Service Entry Point -
40477                                           ;-------------------------------------------------
40478 E987                                      .org 0xe987
40479                       0000E987            int09_handler:
40480 E987           FA                           cli
40481 E988           50                           push ax
40482 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
40483 E98B           E6                     64    out #0x64, al
40484 E98D           B0                     0B    mov al, #0x0B
40485 E98F           E6                     20    out #0x20, al
40486 E991           E4                     20    in al, #0x20
40487 E993           24                     02    and al, #0x02
40488 E995           74           3E              jz int09_finish
40489 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
40490 E999           FB                           sti
40491 E99A           1E                           push ds
40492 E99B           60                           pusha
40493 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
40494 E99E           F9                           stc
40495 E99F           CD                     15    int #0x15
40496 E9A1           73           2C              jnc int09_done
40497                                             ;; check for extended key
40498 E9A3           3C                     E0    cmp al, #0xe0
40499 E9A5           75           0E              jne int09_check_pause
40500 E9A7           31C0                         xor ax, ax
40501 E9A9           8ED8                         mov ds, ax
40502 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
40503 E9AE           0C                     02    or al, #0x02
40504 E9B0           A2         0496              mov BYTE [0x496], al
40505 E9B3           EB           1A              jmp int09_done
40506                       0000E9B5            int09_check_pause: ;; check for pause key
40507 E9B5           3C                     E1    cmp al, #0xe1
40508 E9B7           75           0E              jne int09_process_key
40509 E9B9           31C0                         xor ax, ax
40510 E9BB           8ED8                         mov ds, ax
40511 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
40512 E9C0           0C                     01    or al, #0x01
40513 E9C2           A2         0496              mov BYTE [0x496], al
40514 E9C5           EB           08              jmp int09_done
40515                       0000E9C7            int09_process_key:
40516 E9C7           BB                   F000    mov bx, #0xf000
40517 E9CA           8EDB                         mov ds, bx
40518 E9CC           E8         795D              call _int09_function
40519                       0000E9CF            int09_done:
40520 E9CF           61                           popa
40521 E9D0           1F                           pop ds
40522 E9D1           FA                           cli
40523 E9D2           E8         C736              call eoi_master_pic
40524                       0000E9D5            int09_finish:
40525 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
40526 E9D7           E6                     64    out #0x64, al
40527 E9D9           58                           pop ax
40528 E9DA           CF                           iret
40529                                           ;----------------------------------------
40530                                           ;- INT 13h Diskette Service Entry Point -
40531                                           ;----------------------------------------
40532 EC59                                      .org 0xec59
40533                       0000EC59            int13_diskette:
40534 EC59           E9         C13B              jmp int13_noeltorito
40535                                           ;---------------------------------------------
40536                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
40537                                           ;---------------------------------------------
40538 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
40539                       0000EF57            int0e_handler:
40540 EF57           50                           push ax
40541 EF58           52                           push dx
40542 EF59           BA                   03F4    mov dx, #0x03f4
40543 EF5C           EC                           in al, dx
40544 EF5D           24                     C0    and al, #0xc0
40545 EF5F           3C                     C0    cmp al, #0xc0
40546 EF61           74           1E              je int0e_normal
40547 EF63           BA                   03F5    mov dx, #0x03f5
40548 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
40549 EF68           EE                           out dx, al
40550                       0000EF69            int0e_loop1:
40551 EF69           BA                   03F4    mov dx, #0x03f4
40552 EF6C           EC                           in al, dx
40553 EF6D           24                     C0    and al, #0xc0
40554 EF6F           3C                     C0    cmp al, #0xc0
40555 EF71           75           F6              jne int0e_loop1
40556                       0000EF73            int0e_loop2:
40557 EF73           BA                   03F5    mov dx, #0x03f5
40558 EF76           EC                           in al, dx
40559 EF77           BA                   03F4    mov dx, #0x03f4
40560 EF7A           EC                           in al, dx
40561 EF7B           24                     C0    and al, #0xc0
40562 EF7D           3C                     C0    cmp al, #0xc0
40563 EF7F           74           F2              je int0e_loop2
40564                       0000EF81            int0e_normal:
40565 EF81           1E                           push ds
40566 EF82           31C0                         xor ax, ax ;; segment 0000
40567 EF84           8ED8                         mov ds, ax
40568 EF86           E8         C182              call eoi_master_pic
40569 EF89           A0         043E              mov al, 0x043e
40570 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
40571 EF8E           A2         043E              mov 0x043e, al
40572 EF91           1F                           pop ds
40573 EF92           5A                           pop dx
40574 EF93           58                           pop ax
40575 EF94           CF                           iret
40576 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
40577                       0000EFC7            diskette_param_table:
40578                                           ;; Since no provisions are made for multiple drive types, most
40579                                           ;; values in this table are ignored. I set parameters for 1.44M
40580                                           ;; floppy here
40581 EFC7                        AF            db 0xAF
40582 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
40583 EFC9                        25            db 0x25
40584 EFCA                        02            db 0x02
40585 EFCB                        12            db 18
40586 EFCC                        1B            db 0x1B
40587 EFCD                        FF            db 0xFF
40588 EFCE                        6C            db 0x6C
40589 EFCF                        F6            db 0xF6
40590 EFD0                        0F            db 0x0F
40591 EFD1                        08            db 0x08
40592                                           ;----------------------------------------
40593                                           ;- INT17h : Printer Service Entry Point -
40594                                           ;----------------------------------------
40595 EFD2                                      .org 0xefd2
40596                       0000EFD2            int17_handler:
40597 EFD2           1E                           push ds
40598 EFD3           60                           pusha
40599 EFD4           31C0                         xor ax, ax
40600 EFD6           8ED8                         mov ds, ax
40601 EFD8           E8         B4C8              call _int17_function
40602 EFDB           61                           popa
40603 EFDC           1F                           pop ds
40604 EFDD           CF                           iret
40605                       0000EFDE            diskette_param_table2:
40606                                           ;; New diskette parameter table adding 3 parameters from IBM
40607                                           ;; Since no provisions are made for multiple drive types, most
40608                                           ;; values in this table are ignored. I set parameters for 1.44M
40609                                           ;; floppy here
40610 EFDE                        AF            db 0xAF
40611 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
40612 EFE0                        25            db 0x25
40613 EFE1                        02            db 0x02
40614 EFE2                        12            db 18
40615 EFE3                        1B            db 0x1B
40616 EFE4                        FF            db 0xFF
40617 EFE5                        6C            db 0x6C
40618 EFE6                        F6            db 0xF6
40619 EFE7                        0F            db 0x0F
40620 EFE8                        08            db 0x08
40621 EFE9                        4F            db 79 ;; maximum track
40622 EFEA                        00            db 0 ;; data transfer rate
40623 EFEB                        04            db 4 ;; drive type in cmos
40624 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
40625                                             HALT(11136)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2B80    mov ax,#11136
 +a   F04B           EF                           out dx,ax
40626 F04C           CF                           iret
40627                                           ;----------
40628                                           ;- INT10h -
40629                                           ;----------
40630 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
40631                       0000F065            int10_handler:
40632                                             ;; dont do anything, since the VGA BIOS handles int10h requests
40633 F065           CF                           iret
40634 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
40635                                           ;----------
40636                                           ;- INT12h -
40637                                           ;----------
40638 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
40639                                           ; ??? different for Pentium (machine check)?
40640                       0000F841            int12_handler:
40641 F841           1E                           push ds
40642 F842           B8                   0040    mov ax, #0x0040
40643 F845           8ED8                         mov ds, ax
40644 F847           A1         0013              mov ax, 0x0013
40645 F84A           1F                           pop ds
40646 F84B           CF                           iret
40647                                           ;----------
40648                                           ;- INT11h -
40649                                           ;----------
40650 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
40651                       0000F84D            int11_handler:
40652 F84D           1E                           push ds
40653 F84E           B8                   0040    mov ax, #0x0040
40654 F851           8ED8                         mov ds, ax
40655 F853           A1         0010              mov ax, 0x0010
40656 F856           1F                           pop ds
40657 F857           CF                           iret
40658                                           ;----------
40659                                           ;- INT15h -
40660                                           ;----------
40661 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
40662                       0000F859            int15_handler:
40663 F859           9C                           pushf
40664 F85A           80FC                   53    cmp ah, #0x53
40665 F85D           74           1C              je apm_call
40666 F85F           1E                           push ds
40667 F860           06                           push es
40668 F861           80FC                   86    cmp ah, #0x86
40669 F864           74           1D              je int15_handler32
40670 F866           80FC                   E8    cmp ah, #0xE8
40671 F869           74           18              je int15_handler32
40672 F86B           60                           pusha
40673 F86C           80FC                   C2    cmp ah, #0xC2
40674 F86F           74           0D              je int15_handler_mouse
40675 F871           E8         50AF              call _int15_function
40676                       0000F874            int15_handler_mouse_ret:
40677 F874           61                           popa
40678                       0000F875            int15_handler32_ret:
40679 F875           07                           pop es
40680 F876           1F                           pop ds
40681 F877           9D                           popf
40682 F878           E9         B4B9              jmp iret_modify_cf
40683                       0000F87B            apm_call:
40684 F87B           E9         BB07              jmp _apmreal_entry
40685                       0000F87E            int15_handler_mouse:
40686 F87E           E8         56C4              call _int15_function_mouse
40687 F881           EB           F1              jmp int15_handler_mouse_ret
40688                       0000F883            int15_handler32:
40689 F883     66    60                           pushad
40690 F885           E8         5E2A              call _int15_function32
40691 F888     66    61                           popad
40692 F88A           EB           E9              jmp int15_handler32_ret
40693                                           ;; Protected mode IDT descriptor
40694                                           ;;
40695                                           ;; I just make the limit 0, so the machine will shutdown
40696                                           ;; if an exception occurs during protected mode memory
40697                                           ;; transfers.
40698                                           ;;
40699                                           ;; Set base to f0000 to correspond to beginning of BIOS,
40700                                           ;; in case I actually define an IDT later
40701                                           ;; Set limit to 0
40702                       0000F88C            pmode_IDT_info:
40703 F88C                      0000            dw 0x0000 ;; limit 15:00
40704 F88E                      0000            dw 0x0000 ;; base 15:00
40705 F890                        0F            db 0x0f ;; base 23:16
40706                                           ;; Real mode IDT descriptor
40707                                           ;;
40708                                           ;; Set to typical real-mode values.
40709                                           ;; base = 000000
40710                                           ;; limit = 03ff
40711                       0000F891            rmode_IDT_info:
40712 F891                      03FF            dw 0x03ff ;; limit 15:00
40713 F893                      0000            dw 0x0000 ;; base 15:00
40714 F895                        00            db 0x00 ;; base 23:16
40715                                           ;----------
40716                                           ;- INT1Ah -
40717                                           ;----------
40718 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40719                       0000FE6E            int1a_handler:
40720 FE6E           80FC                   B1    cmp ah, #0xb1
40721 FE71           75           14              jne int1a_normal
40722 FE73           E8         B7A5              call pcibios_real
40723 FE76           72           03              jc pcibios_error
40724 FE78           CA                   0002    retf 2
40725                       0000FE7B            pcibios_error:
40726 FE7B           88E3                         mov bl, ah
40727 FE7D           B4                     B1    mov ah, #0xb1
40728 FE7F           1E                           push ds
40729 FE80           60                           pusha
40730 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40731 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40732 FE85           EB           06              jmp int1a_callfunction
40733                       0000FE87            int1a_normal:
40734 FE87           1E                           push ds
40735 FE88           60                           pusha
40736 FE89           31C0                         xor ax, ax
40737 FE8B           8ED8                         mov ds, ax
40738                       0000FE8D            int1a_callfunction:
40739 FE8D           E8         A9A7              call _int1a_function
40740 FE90           61                           popa
40741 FE91           1F                           pop ds
40742 FE92           CF                           iret
40743                                           ;;
40744                                           ;; int70h: IRQ8 - CMOS RTC
40745                                           ;;
40746                       0000FE93            int70_handler:
40747 FE93           1E                           push ds
40748 FE94     66    60                           pushad
40749 FE96           31C0                         xor ax, ax
40750 FE98           8ED8                         mov ds, ax
40751 FE9A           E8         AD46              call _int70_function
40752 FE9D     66    61                           popad
40753 FE9F           1F                           pop ds
40754 FEA0           CF                           iret
40755                                           ;---------
40756                                           ;- INT08 -
40757                                           ;---------
40758 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40759                       0000FEA5            int08_handler:
40760 FEA5           FB                           sti
40761 FEA6     66    50                           push eax
40762 FEA8           1E                           push ds
40763 FEA9           31C0                         xor ax, ax
40764 FEAB           8ED8                         mov ds, ax
40765                                             ;; time to turn off drive(s)?
40766 FEAD           A0         0440              mov al,0x0440
40767 FEB0           08C0                         or al,al
40768 FEB2           74           10              jz int08_floppy_off
40769 FEB4           FEC8                         dec al
40770 FEB6           A2         0440              mov 0x0440,al
40771 FEB9           75           09              jnz int08_floppy_off
40772                                             ;; turn motor(s) off
40773 FEBB           52                           push dx
40774 FEBC           BA                   03F2    mov dx,#0x03f2
40775 FEBF           EC                           in al,dx
40776 FEC0           24                     CF    and al,#0xcf
40777 FEC2           EE                           out dx,al
40778 FEC3           5A                           pop dx
40779                       0000FEC4            int08_floppy_off:
40780 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
40781 FEC8     66    40                           inc eax
40782                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
40783 FECA     66    3D               001800B0    cmp eax, #0x001800B0
40784 FED0           72           07              jb int08_store_ticks
40785                                             ;; there has been a midnight rollover at this point
40786 FED2     66    31C0                         xor eax, eax ;; zero out counter
40787 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
40788                       0000FED9            int08_store_ticks:
40789 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
40790                                             ;; chain to user timer tick INT #0x1c
40791 FEDD           CD                     1C    int #0x1c
40792 FEDF           FA                           cli
40793 FEE0           E8         B228              call eoi_master_pic
40794 FEE3           1F                           pop ds
40795 FEE4     66    58                           pop eax
40796 FEE6           CF                           iret
40797 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
40798 FF00                                      .org 0xff00
40799 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
40800                                           ;------------------------------------------------
40801                                           ;- IRET Instruction for Dummy Interrupt Handler -
40802                                           ;------------------------------------------------
40803 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
40804                       0000FF53            dummy_iret_handler:
40805 FF53           CF                           iret
40806 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
40807                                             HALT(11355)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2C5B    mov ax,#11355
 +a   FF5A           EF                           out dx,ax
40808 FF5B           CF                           iret
40809 FFF0                                      .org 0xfff0 ; Power-up Entry Point
40810 FFF0           EA         E05B      F000    jmp 0xf000:post
40811 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
40812 FFF5                        31            .ascii "10/11/09"
40813 FFFE                                      .org 0xfffe ; System Model ID
40814 FFFE                        FC            db 0xFC
40815 FFFF                        00            db 0x00 ; filler
40816 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
40817                                           ! 8082 endasm
40818                                           !BCC_ENDASM
40819                                           ! 8083 static Bit8u vgafont8[128*8]=
40820                                           ! Register BX used in function int70_function
40821                                           ! 8084 {
40822                                           
40823                       0000FA6E            _vgafont8:
40824                                           ! 8085  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40825 FA6E                        00            .byte	0
40826 FA6F                        00            .byte	0
40827 FA70                        00            .byte	0
40828 FA71                        00            .byte	0
40829 FA72                        00            .byte	0
40830 FA73                        00            .byte	0
40831 FA74                        00            .byte	0
40832 FA75                        00            .byte	0
40833                                           ! 8086  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
40834 FA76                        7E            .byte	$7E
40835 FA77                        81            .byte	$81
40836 FA78                        A5            .byte	$A5
40837 FA79                        81            .byte	$81
40838 FA7A                        BD            .byte	$BD
40839 FA7B                        99            .byte	$99
40840 FA7C                        81            .byte	$81
40841 FA7D                        7E            .byte	$7E
40842                                           ! 8087  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
40843 FA7E                        7E            .byte	$7E
40844 FA7F                        FF            .byte	$FF
40845 FA80                        DB            .byte	$DB
40846 FA81                        FF            .byte	$FF
40847 FA82                        C3            .byte	$C3
40848 FA83                        E7            .byte	$E7
40849 FA84                        FF            .byte	$FF
40850 FA85                        7E            .byte	$7E
40851                                           ! 8088  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40852 FA86                        6C            .byte	$6C
40853 FA87                        FE            .byte	$FE
40854 FA88                        FE            .byte	$FE
40855 FA89                        FE            .byte	$FE
40856 FA8A                        7C            .byte	$7C
40857 FA8B                        38            .byte	$38
40858 FA8C                        10            .byte	$10
40859 FA8D                        00            .byte	0
40860                                           ! 8089  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40861 FA8E                        10            .byte	$10
40862 FA8F                        38            .byte	$38
40863 FA90                        7C            .byte	$7C
40864 FA91                        FE            .byte	$FE
40865 FA92                        7C            .byte	$7C
40866 FA93                        38            .byte	$38
40867 FA94                        10            .byte	$10
40868 FA95                        00            .byte	0
40869                                           ! 8090  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
40870 FA96                        38            .byte	$38
40871 FA97                        7C            .byte	$7C
40872 FA98                        38            .byte	$38
40873 FA99                        FE            .byte	$FE
40874 FA9A                        FE            .byte	$FE
40875 FA9B                        7C            .byte	$7C
40876 FA9C                        38            .byte	$38
40877 FA9D                        7C            .byte	$7C
40878                                           ! 8091  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
40879 FA9E                        10            .byte	$10
40880 FA9F                        10            .byte	$10
40881 FAA0                        38            .byte	$38
40882 FAA1                        7C            .byte	$7C
40883 FAA2                        FE            .byte	$FE
40884 FAA3                        7C            .byte	$7C
40885 FAA4                        38            .byte	$38
40886 FAA5                        7C            .byte	$7C
40887                                           ! 8092  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
40888 FAA6                        00            .byte	0
40889 FAA7                        00            .byte	0
40890 FAA8                        18            .byte	$18
40891 FAA9                        3C            .byte	$3C
40892 FAAA                        3C            .byte	$3C
40893 FAAB                        18            .byte	$18
40894 FAAC                        00            .byte	0
40895 FAAD                        00            .byte	0
40896                                           ! 8093  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
40897 FAAE                        FF            .byte	$FF
40898 FAAF                        FF            .byte	$FF
40899 FAB0                        E7            .byte	$E7
40900 FAB1                        C3            .byte	$C3
40901 FAB2                        C3            .byte	$C3
40902 FAB3                        E7            .byte	$E7
40903 FAB4                        FF            .byte	$FF
40904 FAB5                        FF            .byte	$FF
40905                                           ! 8094  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
40906 FAB6                        00            .byte	0
40907 FAB7                        3C            .byte	$3C
40908 FAB8                        66            .byte	$66
40909 FAB9                        42            .byte	$42
40910 FABA                        42            .byte	$42
40911 FABB                        66            .byte	$66
40912 FABC                        3C            .byte	$3C
40913 FABD                        00            .byte	0
40914                                           ! 8095  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
40915 FABE                        FF            .byte	$FF
40916 FABF                        C3            .byte	$C3
40917 FAC0                        99            .byte	$99
40918 FAC1                        BD            .byte	$BD
40919 FAC2                        BD            .byte	$BD
40920 FAC3                        99            .byte	$99
40921 FAC4                        C3            .byte	$C3
40922 FAC5                        FF            .byte	$FF
40923                                           ! 8096  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
40924 FAC6                        0F            .byte	$F
40925 FAC7                        07            .byte	7
40926 FAC8                        0F            .byte	$F
40927 FAC9                        7D            .byte	$7D
40928 FACA                        CC            .byte	$CC
40929 FACB                        CC            .byte	$CC
40930 FACC                        CC            .byte	$CC
40931 FACD                        78            .byte	$78
40932                                           ! 8097  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
40933 FACE                        3C            .byte	$3C
40934 FACF                        66            .byte	$66
40935 FAD0                        66            .byte	$66
40936 FAD1                        66            .byte	$66
40937 FAD2                        3C            .byte	$3C
40938 FAD3                        18            .byte	$18
40939 FAD4                        7E            .byte	$7E
40940 FAD5                        18            .byte	$18
40941                                           ! 8098 
40942                                           ! 8098  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
40943 FAD6                        3F            .byte	$3F
40944 FAD7                        33            .byte	$33
40945 FAD8                        3F            .byte	$3F
40946 FAD9                        30            .byte	$30
40947 FADA                        30            .byte	$30
40948 FADB                        70            .byte	$70
40949 FADC                        F0            .byte	$F0
40950 FADD                        E0            .byte	$E0
40951                                           ! 8099  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
40952 FADE                        7F            .byte	$7F
40953 FADF                        63            .byte	$63
40954 FAE0                        7F            .byte	$7F
40955 FAE1                        63            .byte	$63
40956 FAE2                        63            .byte	$63
40957 FAE3                        67            .byte	$67
40958 FAE4                        E6            .byte	$E6
40959 FAE5                        C0            .byte	$C0
40960                                           ! 8100  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
40961 FAE6                        99            .byte	$99
40962 FAE7                        5A            .byte	$5A
40963 FAE8                        3C            .byte	$3C
40964 FAE9                        E7            .byte	$E7
40965 FAEA                        E7            .byte	$E7
40966 FAEB                        3C            .byte	$3C
40967 FAEC                        5A            .byte	$5A
40968 FAED                        99            .byte	$99
40969                                           ! 8101  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
40970 FAEE                        80            .byte	$80
40971 FAEF                        E0            .byte	$E0
40972 FAF0                        F8            .byte	$F8
40973 FAF1                        FE            .byte	$FE
40974 FAF2                        F8            .byte	$F8
40975 FAF3                        E0            .byte	$E0
40976 FAF4                        80            .byte	$80
40977 FAF5                        00            .byte	0
40978                                           ! 8102  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
40979 FAF6                        02            .byte	2
40980 FAF7                        0E            .byte	$E
40981 FAF8                        3E            .byte	$3E
40982 FAF9                        FE            .byte	$FE
40983 FAFA                        3E            .byte	$3E
40984 FAFB                        0E            .byte	$E
40985 FAFC                        02            .byte	2
40986 FAFD                        00            .byte	0
40987                                           ! 8103  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
40988 FAFE                        18            .byte	$18
40989 FAFF                        3C            .byte	$3C
40990 FB00                        7E            .byte	$7E
40991 FB01                        18            .byte	$18
40992 FB02                        18            .byte	$18
40993 FB03                        7E            .byte	$7E
40994 FB04                        3C            .byte	$3C
40995 FB05                        18            .byte	$18
40996                                           ! 8104  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
40997 FB06                        66            .byte	$66
40998 FB07                        66            .byte	$66
40999 FB08                        66            .byte	$66
41000 FB09                        66            .byte	$66
41001 FB0A                        66            .byte	$66
41002 FB0B                        00            .byte	0
41003 FB0C                        66            .byte	$66
41004 FB0D                        00            .byte	0
41005                                           ! 8105  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
41006 FB0E                        7F            .byte	$7F
41007 FB0F                        DB            .byte	$DB
41008 FB10                        DB            .byte	$DB
41009 FB11                        7B            .byte	$7B
41010 FB12                        1B            .byte	$1B
41011 FB13                        1B            .byte	$1B
41012 FB14                        1B            .byte	$1B
41013 FB15                        00            .byte	0
41014                                           ! 8106  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
41015 FB16                        3E            .byte	$3E
41016 FB17                        63            .byte	$63
41017 FB18                        38            .byte	$38
41018 FB19                        6C            .byte	$6C
41019 FB1A                        6C            .byte	$6C
41020 FB1B                        38            .byte	$38
41021 FB1C                        CC            .byte	$CC
41022 FB1D                        78            .byte	$78
41023                                           ! 8107  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
41024 FB1E                        00            .byte	0
41025 FB1F                        00            .byte	0
41026 FB20                        00            .byte	0
41027 FB21                        00            .byte	0
41028 FB22                        7E            .byte	$7E
41029 FB23                        7E            .byte	$7E
41030 FB24                        7E            .byte	$7E
41031 FB25                        00            .byte	0
41032                                           ! 8108  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
41033 FB26                        18            .byte	$18
41034 FB27                        3C            .byte	$3C
41035 FB28                        7E            .byte	$7E
41036 FB29                        18            .byte	$18
41037 FB2A                        7E            .byte	$7E
41038 FB2B                        3C            .byte	$3C
41039 FB2C                        18            .byte	$18
41040 FB2D                        FF            .byte	$FF
41041                                           ! 8109  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
41042 FB2E                        18            .byte	$18
41043 FB2F                        3C            .byte	$3C
41044 FB30                        7E            .byte	$7E
41045 FB31                        18            .byte	$18
41046 FB32                        18            .byte	$18
41047 FB33                        18            .byte	$18
41048 FB34                        18            .byte	$18
41049 FB35                        00            .byte	0
41050                                           ! 8110  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
41051 FB36                        18            .byte	$18
41052 FB37                        18            .byte	$18
41053 FB38                        18            .byte	$18
41054 FB39                        18            .byte	$18
41055 FB3A                        7E            .byte	$7E
41056 FB3B                        3C            .byte	$3C
41057 FB3C                        18            .byte	$18
41058 FB3D                        00            .byte	0
41059                                           ! 8111  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
41060 FB3E                        00            .byte	0
41061 FB3F                        18            .byte	$18
41062 FB40                        0C            .byte	$C
41063 FB41                        FE            .byte	$FE
41064 FB42                        0C            .byte	$C
41065 FB43                        18            .byte	$18
41066 FB44                        00            .byte	0
41067 FB45                        00            .byte	0
41068                                           ! 8112  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
41069 FB46                        00            .byte	0
41070 FB47                        30            .byte	$30
41071 FB48                        60            .byte	$60
41072 FB49                        FE            .byte	$FE
41073 FB4A                        60            .byte	$60
41074 FB4B                        30            .byte	$30
41075 FB4C                        00            .byte	0
41076 FB4D                        00            .byte	0
41077                                           ! 8113  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
41078 FB4E                        00            .byte	0
41079 FB4F                        00            .byte	0
41080 FB50                        C0            .byte	$C0
41081 FB51                        C0            .byte	$C0
41082 FB52                        C0            .byte	$C0
41083 FB53                        FE            .byte	$FE
41084 FB54                        00            .byte	0
41085 FB55                        00            .byte	0
41086                                           ! 8114  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
41087 FB56                        00            .byte	0
41088 FB57                        24            .byte	$24
41089 FB58                        66            .byte	$66
41090 FB59                        FF            .byte	$FF
41091 FB5A                        66            .byte	$66
41092 FB5B                        24            .byte	$24
41093 FB5C                        00            .byte	0
41094 FB5D                        00            .byte	0
41095                                           ! 8115  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
41096 FB5E                        00            .byte	0
41097 FB5F                        18            .byte	$18
41098 FB60                        3C            .byte	$3C
41099 FB61                        7E            .byte	$7E
41100 FB62                        FF            .byte	$FF
41101 FB63                        FF            .byte	$FF
41102 FB64                        00            .byte	0
41103 FB65                        00            .byte	0
41104                                           ! 8116  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
41105 FB66                        00            .byte	0
41106 FB67                        FF            .byte	$FF
41107 FB68                        FF            .byte	$FF
41108 FB69                        7E            .byte	$7E
41109 FB6A                        3C            .byte	$3C
41110 FB6B                        18            .byte	$18
41111 FB6C                        00            .byte	0
41112 FB6D                        00            .byte	0
41113                                           ! 8117  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41114 FB6E                        00            .byte	0
41115 FB6F                        00            .byte	0
41116 FB70                        00            .byte	0
41117 FB71                        00            .byte	0
41118 FB72                        00            .byte	0
41119 FB73                        00            .byte	0
41120 FB74                        00            .byte	0
41121 FB75                        00            .byte	0
41122                                           ! 8118  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
41123 FB76                        30            .byte	$30
41124 FB77                        78            .byte	$78
41125 FB78                        78            .byte	$78
41126 FB79                        30            .byte	$30
41127 FB7A                        30            .byte	$30
41128 FB7B                        00            .byte	0
41129 FB7C                        30            .byte	$30
41130 FB7D                        00            .byte	0
41131                                           ! 8119  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
41132 FB7E                        6C            .byte	$6C
41133 FB7F                        6C            .byte	$6C
41134 FB80                        6C            .byte	$6C
41135 FB81                        00            .byte	0
41136 FB82                        00            .byte	0
41137 FB83                        00            .byte	0
41138 FB84                        00            .byte	0
41139 FB85                        00            .byte	0
41140                                           ! 8120  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
41141 FB86                        6C            .byte	$6C
41142 FB87                        6C            .byte	$6C
41143 FB88                        FE            .byte	$FE
41144 FB89                        6C            .byte	$6C
41145 FB8A                        FE            .byte	$FE
41146 FB8B                        6C            .byte	$6C
41147 FB8C                        6C            .byte	$6C
41148 FB8D                        00            .byte	0
41149                                           ! 8121  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
41150 FB8E                        30            .byte	$30
41151 FB8F                        7C            .byte	$7C
41152 FB90                        C0            .byte	$C0
41153 FB91                        78            .byte	$78
41154 FB92                        0C            .byte	$C
41155 FB93                        F8            .byte	$F8
41156 FB94                        30            .byte	$30
41157 FB95                        00            .byte	0
41158                                           ! 8122  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
41159 FB96                        00            .byte	0
41160 FB97                        C6            .byte	$C6
41161 FB98                        CC            .byte	$CC
41162 FB99                        18            .byte	$18
41163 FB9A                        30            .byte	$30
41164 FB9B                        66            .byte	$66
41165 FB9C                        C6            .byte	$C6
41166 FB9D                        00            .byte	0
41167                                           ! 8123  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
41168 FB9E                        38            .byte	$38
41169 FB9F                        6C            .byte	$6C
41170 FBA0                        38            .byte	$38
41171 FBA1                        76            .byte	$76
41172 FBA2                        DC            .byte	$DC
41173 FBA3                        CC            .byte	$CC
41174 FBA4                        76            .byte	$76
41175 FBA5                        00            .byte	0
41176                                           ! 8124  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
41177 FBA6                        60            .byte	$60
41178 FBA7                        60            .byte	$60
41179 FBA8                        C0            .byte	$C0
41180 FBA9                        00            .byte	0
41181 FBAA                        00            .byte	0
41182 FBAB                        00            .byte	0
41183 FBAC                        00            .byte	0
41184 FBAD                        00            .byte	0
41185                                           ! 8125  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
41186 FBAE                        18            .byte	$18
41187 FBAF                        30            .byte	$30
41188 FBB0                        60            .byte	$60
41189 FBB1                        60            .byte	$60
41190 FBB2                        60            .byte	$60
41191 FBB3                        30            .byte	$30
41192 FBB4                        18            .byte	$18
41193 FBB5                        00            .byte	0
41194                                           ! 8126  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
41195 FBB6                        60            .byte	$60
41196 FBB7                        30            .byte	$30
41197 FBB8                        18            .byte	$18
41198 FBB9                        18            .byte	$18
41199 FBBA                        18            .byte	$18
41200 FBBB                        30            .byte	$30
41201 FBBC                        60            .byte	$60
41202 FBBD                        00            .byte	0
41203                                           ! 8127  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
41204 FBBE                        00            .byte	0
41205 FBBF                        66            .byte	$66
41206 FBC0                        3C            .byte	$3C
41207 FBC1                        FF            .byte	$FF
41208 FBC2                        3C            .byte	$3C
41209 FBC3                        66            .byte	$66
41210 FBC4                        00            .byte	0
41211 FBC5                        00            .byte	0
41212                                           ! 8128  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
41213 FBC6                        00            .byte	0
41214 FBC7                        30            .byte	$30
41215 FBC8                        30            .byte	$30
41216 FBC9                        FC            .byte	$FC
41217 FBCA                        30            .byte	$30
41218 FBCB                        30            .byte	$30
41219 FBCC                        00            .byte	0
41220 FBCD                        00            .byte	0
41221                                           ! 8129  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
41222 FBCE                        00            .byte	0
41223 FBCF                        00            .byte	0
41224 FBD0                        00            .byte	0
41225 FBD1                        00            .byte	0
41226 FBD2                        00            .byte	0
41227 FBD3                        30            .byte	$30
41228 FBD4                        30            .byte	$30
41229 FBD5                        60            .byte	$60
41230                                           ! 8130  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
41231 FBD6                        00            .byte	0
41232 FBD7                        00            .byte	0
41233 FBD8                        00            .byte	0
41234 FBD9                        FC            .byte	$FC
41235 FBDA                        00            .byte	0
41236 FBDB                        00            .byte	0
41237 FBDC                        00            .byte	0
41238 FBDD                        00            .byte	0
41239                                           ! 8131  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
41240 FBDE                        00            .byte	0
41241 FBDF                        00            .byte	0
41242 FBE0                        00            .byte	0
41243 FBE1                        00            .byte	0
41244 FBE2                        00            .byte	0
41245 FBE3                        30            .byte	$30
41246 FBE4                        30            .byte	$30
41247 FBE5                        00            .byte	0
41248                                           ! 8132  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
41249 FBE6                        06            .byte	6
41250 FBE7                        0C            .byte	$C
41251 FBE8                        18            .byte	$18
41252 FBE9                        30            .byte	$30
41253 FBEA                        60            .byte	$60
41254 FBEB                        C0            .byte	$C0
41255 FBEC                        80            .byte	$80
41256 FBED                        00            .byte	0
41257                                           ! 8133  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
41258 FBEE                        7C            .byte	$7C
41259 FBEF                        C6            .byte	$C6
41260 FBF0                        CE            .byte	$CE
41261 FBF1                        DE            .byte	$DE
41262 FBF2                        F6            .byte	$F6
41263 FBF3                        E6            .byte	$E6
41264 FBF4                        7C            .byte	$7C
41265 FBF5                        00            .byte	0
41266                                           ! 8134  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
41267 FBF6                        30            .byte	$30
41268 FBF7                        70            .byte	$70
41269 FBF8                        30            .byte	$30
41270 FBF9                        30            .byte	$30
41271 FBFA                        30            .byte	$30
41272 FBFB                        30            .byte	$30
41273 FBFC                        FC            .byte	$FC
41274 FBFD                        00            .byte	0
41275                                           ! 8135  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
41276 FBFE                        78            .byte	$78
41277 FBFF                        CC            .byte	$CC
41278 FC00                        0C            .byte	$C
41279 FC01                        38            .byte	$38
41280 FC02                        60            .byte	$60
41281 FC03                        CC            .byte	$CC
41282 FC04                        FC            .byte	$FC
41283 FC05                        00            .byte	0
41284                                           ! 8136  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
41285 FC06                        78            .byte	$78
41286 FC07                        CC            .byte	$CC
41287 FC08                        0C            .byte	$C
41288 FC09                        38            .byte	$38
41289 FC0A                        0C            .byte	$C
41290 FC0B                        CC            .byte	$CC
41291 FC0C                        78            .byte	$78
41292 FC0D                        00            .byte	0
41293                                           ! 8137  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
41294 FC0E                        1C            .byte	$1C
41295 FC0F                        3C            .byte	$3C
41296 FC10                        6C            .byte	$6C
41297 FC11                        CC            .byte	$CC
41298 FC12                        FE            .byte	$FE
41299 FC13                        0C            .byte	$C
41300 FC14                        1E            .byte	$1E
41301 FC15                        00            .byte	0
41302                                           ! 8138  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
41303 FC16                        FC            .byte	$FC
41304 FC17                        C0            .byte	$C0
41305 FC18                        F8            .byte	$F8
41306 FC19                        0C            .byte	$C
41307 FC1A                        0C            .byte	$C
41308 FC1B                        CC            .byte	$CC
41309 FC1C                        78            .byte	$78
41310 FC1D                        00            .byte	0
41311                                           ! 8139  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x
41312 FC1E                        38            .byte	$38
41313 FC1F                        60            .byte	$60
41314 FC20                        C0            .byte	$C0
41315 FC21                        F8            .byte	$F8
41316 FC22                        CC            .byte	$CC
41317 FC23                        CC            .byte	$CC
41318                                           ! 8139 78, 0x00,
41319 FC24                        78            .byte	$78
41320 FC25                        00            .byte	0
41321                                           ! 8140  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
41322 FC26                        FC            .byte	$FC
41323 FC27                        CC            .byte	$CC
41324 FC28                        0C            .byte	$C
41325 FC29                        18            .byte	$18
41326 FC2A                        30            .byte	$30
41327 FC2B                        30            .byte	$30
41328 FC2C                        30            .byte	$30
41329 FC2D                        00            .byte	0
41330                                           ! 8141  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
41331 FC2E                        78            .byte	$78
41332 FC2F                        CC            .byte	$CC
41333 FC30                        CC            .byte	$CC
41334 FC31                        78            .byte	$78
41335 FC32                        CC            .byte	$CC
41336 FC33                        CC            .byte	$CC
41337 FC34                        78            .byte	$78
41338 FC35                        00            .byte	0
41339                                           ! 8142  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
41340 FC36                        78            .byte	$78
41341 FC37                        CC            .byte	$CC
41342 FC38                        CC            .byte	$CC
41343 FC39                        7C            .byte	$7C
41344 FC3A                        0C            .byte	$C
41345 FC3B                        18            .byte	$18
41346 FC3C                        70            .byte	$70
41347 FC3D                        00            .byte	0
41348                                           ! 8143  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
41349 FC3E                        00            .byte	0
41350 FC3F                        30            .byte	$30
41351 FC40                        30            .byte	$30
41352 FC41                        00            .byte	0
41353 FC42                        00            .byte	0
41354 FC43                        30            .byte	$30
41355 FC44                        30            .byte	$30
41356 FC45                        00            .byte	0
41357                                           ! 8144  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
41358 FC46                        00            .byte	0
41359 FC47                        30            .byte	$30
41360 FC48                        30            .byte	$30
41361 FC49                        00            .byte	0
41362 FC4A                        00            .byte	0
41363 FC4B                        30            .byte	$30
41364 FC4C                        30            .byte	$30
41365 FC4D                        60            .byte	$60
41366                                           ! 8145  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
41367 FC4E                        18            .byte	$18
41368 FC4F                        30            .byte	$30
41369 FC50                        60            .byte	$60
41370 FC51                        C0            .byte	$C0
41371 FC52                        60            .byte	$60
41372 FC53                        30            .byte	$30
41373 FC54                        18            .byte	$18
41374 FC55                        00            .byte	0
41375                                           ! 8146  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
41376 FC56                        00            .byte	0
41377 FC57                        00            .byte	0
41378 FC58                        FC            .byte	$FC
41379 FC59                        00            .byte	0
41380 FC5A                        00            .byte	0
41381 FC5B                        FC            .byte	$FC
41382 FC5C                        00            .byte	0
41383 FC5D                        00            .byte	0
41384                                           ! 8147  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
41385 FC5E                        60            .byte	$60
41386 FC5F                        30            .byte	$30
41387 FC60                        18            .byte	$18
41388 FC61                        0C            .byte	$C
41389 FC62                        18            .byte	$18
41390 FC63                        30            .byte	$30
41391 FC64                        60            .byte	$60
41392 FC65                        00            .byte	0
41393                                           ! 8148  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
41394 FC66                        78            .byte	$78
41395 FC67                        CC            .byte	$CC
41396 FC68                        0C            .byte	$C
41397 FC69                        18            .byte	$18
41398 FC6A                        30            .byte	$30
41399 FC6B                        00            .byte	0
41400 FC6C                        30            .byte	$30
41401 FC6D                        00            .byte	0
41402                                           ! 8149  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
41403 FC6E                        7C            .byte	$7C
41404 FC6F                        C6            .byte	$C6
41405 FC70                        DE            .byte	$DE
41406 FC71                        DE            .byte	$DE
41407 FC72                        DE            .byte	$DE
41408 FC73                        C0            .byte	$C0
41409 FC74                        78            .byte	$78
41410 FC75                        00            .byte	0
41411                                           ! 8150  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
41412 FC76                        30            .byte	$30
41413 FC77                        78            .byte	$78
41414 FC78                        CC            .byte	$CC
41415 FC79                        CC            .byte	$CC
41416 FC7A                        FC            .byte	$FC
41417 FC7B                        CC            .byte	$CC
41418 FC7C                        CC            .byte	$CC
41419 FC7D                        00            .byte	0
41420                                           ! 8151  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
41421 FC7E                        FC            .byte	$FC
41422 FC7F                        66            .byte	$66
41423 FC80                        66            .byte	$66
41424 FC81                        7C            .byte	$7C
41425 FC82                        66            .byte	$66
41426 FC83                        66            .byte	$66
41427 FC84                        FC            .byte	$FC
41428 FC85                        00            .byte	0
41429                                           ! 8152  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
41430 FC86                        3C            .byte	$3C
41431 FC87                        66            .byte	$66
41432 FC88                        C0            .byte	$C0
41433 FC89                        C0            .byte	$C0
41434 FC8A                        C0            .byte	$C0
41435 FC8B                        66            .byte	$66
41436 FC8C                        3C            .byte	$3C
41437 FC8D                        00            .byte	0
41438                                           ! 8153  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
41439 FC8E                        F8            .byte	$F8
41440 FC8F                        6C            .byte	$6C
41441 FC90                        66            .byte	$66
41442 FC91                        66            .byte	$66
41443 FC92                        66            .byte	$66
41444 FC93                        6C            .byte	$6C
41445 FC94                        F8            .byte	$F8
41446 FC95                        00            .byte	0
41447                                           ! 8154  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
41448 FC96                        FE            .byte	$FE
41449 FC97                        62            .byte	$62
41450 FC98                        68            .byte	$68
41451 FC99                        78            .byte	$78
41452 FC9A                        68            .byte	$68
41453 FC9B                        62            .byte	$62
41454 FC9C                        FE            .byte	$FE
41455 FC9D                        00            .byte	0
41456                                           ! 8155  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
41457 FC9E                        FE            .byte	$FE
41458 FC9F                        62            .byte	$62
41459 FCA0                        68            .byte	$68
41460 FCA1                        78            .byte	$78
41461 FCA2                        68            .byte	$68
41462 FCA3                        60            .byte	$60
41463 FCA4                        F0            .byte	$F0
41464 FCA5                        00            .byte	0
41465                                           ! 8156  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
41466 FCA6                        3C            .byte	$3C
41467 FCA7                        66            .byte	$66
41468 FCA8                        C0            .byte	$C0
41469 FCA9                        C0            .byte	$C0
41470 FCAA                        CE            .byte	$CE
41471 FCAB                        66            .byte	$66
41472 FCAC                        3E            .byte	$3E
41473 FCAD                        00            .byte	0
41474                                           ! 8157  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
41475 FCAE                        CC            .byte	$CC
41476 FCAF                        CC            .byte	$CC
41477 FCB0                        CC            .byte	$CC
41478 FCB1                        FC            .byte	$FC
41479 FCB2                        CC            .byte	$CC
41480 FCB3                        CC            .byte	$CC
41481 FCB4                        CC            .byte	$CC
41482 FCB5                        00            .byte	0
41483                                           ! 8158  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41484 FCB6                        78            .byte	$78
41485 FCB7                        30            .byte	$30
41486 FCB8                        30            .byte	$30
41487 FCB9                        30            .byte	$30
41488 FCBA                        30            .byte	$30
41489 FCBB                        30            .byte	$30
41490 FCBC                        78            .byte	$78
41491 FCBD                        00            .byte	0
41492                                           ! 8159  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
41493 FCBE                        1E            .byte	$1E
41494 FCBF                        0C            .byte	$C
41495 FCC0                        0C            .byte	$C
41496 FCC1                        0C            .byte	$C
41497 FCC2                        CC            .byte	$CC
41498 FCC3                        CC            .byte	$CC
41499 FCC4                        78            .byte	$78
41500 FCC5                        00            .byte	0
41501                                           ! 8160  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
41502 FCC6                        E6            .byte	$E6
41503 FCC7                        66            .byte	$66
41504 FCC8                        6C            .byte	$6C
41505 FCC9                        78            .byte	$78
41506 FCCA                        6C            .byte	$6C
41507 FCCB                        66            .byte	$66
41508 FCCC                        E6            .byte	$E6
41509 FCCD                        00            .byte	0
41510                                           ! 8161  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
41511 FCCE                        F0            .byte	$F0
41512 FCCF                        60            .byte	$60
41513 FCD0                        60            .byte	$60
41514 FCD1                        60            .byte	$60
41515 FCD2                        62            .byte	$62
41516 FCD3                        66            .byte	$66
41517 FCD4                        FE            .byte	$FE
41518 FCD5                        00            .byte	0
41519                                           ! 8162  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
41520 FCD6                        C6            .byte	$C6
41521 FCD7                        EE            .byte	$EE
41522 FCD8                        FE            .byte	$FE
41523 FCD9                        FE            .byte	$FE
41524 FCDA                        D6            .byte	$D6
41525 FCDB                        C6            .byte	$C6
41526 FCDC                        C6            .byte	$C6
41527 FCDD                        00            .byte	0
41528                                           ! 8163  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
41529 FCDE                        C6            .byte	$C6
41530 FCDF                        E6            .byte	$E6
41531 FCE0                        F6            .byte	$F6
41532 FCE1                        DE            .byte	$DE
41533 FCE2                        CE            .byte	$CE
41534 FCE3                        C6            .byte	$C6
41535 FCE4                        C6            .byte	$C6
41536 FCE5                        00            .byte	0
41537                                           ! 8164  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
41538 FCE6                        38            .byte	$38
41539 FCE7                        6C            .byte	$6C
41540 FCE8                        C6            .byte	$C6
41541 FCE9                        C6            .byte	$C6
41542 FCEA                        C6            .byte	$C6
41543 FCEB                        6C            .byte	$6C
41544 FCEC                        38            .byte	$38
41545 FCED                        00            .byte	0
41546                                           ! 8165  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
41547 FCEE                        FC            .byte	$FC
41548 FCEF                        66            .byte	$66
41549 FCF0                        66            .byte	$66
41550 FCF1                        7C            .byte	$7C
41551 FCF2                        60            .byte	$60
41552 FCF3                        60            .byte	$60
41553 FCF4                        F0            .byte	$F0
41554 FCF5                        00            .byte	0
41555                                           ! 8166  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
41556 FCF6                        78            .byte	$78
41557 FCF7                        CC            .byte	$CC
41558 FCF8                        CC            .byte	$CC
41559 FCF9                        CC            .byte	$CC
41560 FCFA                        DC            .byte	$DC
41561 FCFB                        78            .byte	$78
41562 FCFC                        1C            .byte	$1C
41563 FCFD                        00            .byte	0
41564                                           ! 8167  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
41565 FCFE                        FC            .byte	$FC
41566 FCFF                        66            .byte	$66
41567 FD00                        66            .byte	$66
41568 FD01                        7C            .byte	$7C
41569 FD02                        6C            .byte	$6C
41570 FD03                        66            .byte	$66
41571 FD04                        E6            .byte	$E6
41572 FD05                        00            .byte	0
41573                                           ! 8168  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
41574 FD06                        78            .byte	$78
41575 FD07                        CC            .byte	$CC
41576 FD08                        E0            .byte	$E0
41577 FD09                        70            .byte	$70
41578 FD0A                        1C            .byte	$1C
41579 FD0B                        CC            .byte	$CC
41580 FD0C                        78            .byte	$78
41581 FD0D                        00            .byte	0
41582                                           ! 8169  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41583 FD0E                        FC            .byte	$FC
41584 FD0F                        B4            .byte	$B4
41585 FD10                        30            .byte	$30
41586 FD11                        30            .byte	$30
41587 FD12                        30            .byte	$30
41588 FD13                        30            .byte	$30
41589 FD14                        78            .byte	$78
41590 FD15                        00            .byte	0
41591                                           ! 8170  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
41592 FD16                        CC            .byte	$CC
41593 FD17                        CC            .byte	$CC
41594 FD18                        CC            .byte	$CC
41595 FD19                        CC            .byte	$CC
41596 FD1A                        CC            .byte	$CC
41597 FD1B                        CC            .byte	$CC
41598 FD1C                        FC            .byte	$FC
41599 FD1D                        00            .byte	0
41600                                           ! 8171  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41601 FD1E                        CC            .byte	$CC
41602 FD1F                        CC            .byte	$CC
41603 FD20                        CC            .byte	$CC
41604 FD21                        CC            .byte	$CC
41605 FD22                        CC            .byte	$CC
41606 FD23                        78            .byte	$78
41607 FD24                        30            .byte	$30
41608 FD25                        00            .byte	0
41609                                           ! 8172  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
41610 FD26                        C6            .byte	$C6
41611 FD27                        C6            .byte	$C6
41612 FD28                        C6            .byte	$C6
41613 FD29                        D6            .byte	$D6
41614 FD2A                        FE            .byte	$FE
41615 FD2B                        EE            .byte	$EE
41616 FD2C                        C6            .byte	$C6
41617 FD2D                        00            .byte	0
41618                                           ! 8173  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
41619 FD2E                        C6            .byte	$C6
41620 FD2F                        C6            .byte	$C6
41621 FD30                        6C            .byte	$6C
41622 FD31                        38            .byte	$38
41623 FD32                        38            .byte	$38
41624 FD33                        6C            .byte	$6C
41625 FD34                        C6            .byte	$C6
41626 FD35                        00            .byte	0
41627                                           ! 8174  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
41628 FD36                        CC            .byte	$CC
41629 FD37                        CC            .byte	$CC
41630 FD38                        CC            .byte	$CC
41631 FD39                        78            .byte	$78
41632 FD3A                        30            .byte	$30
41633 FD3B                        30            .byte	$30
41634 FD3C                        78            .byte	$78
41635 FD3D                        00            .byte	0
41636                                           ! 8175  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
41637 FD3E                        FE            .byte	$FE
41638 FD3F                        C6            .byte	$C6
41639 FD40                        8C            .byte	$8C
41640 FD41                        18            .byte	$18
41641 FD42                        32            .byte	$32
41642 FD43                        66            .byte	$66
41643 FD44                        FE            .byte	$FE
41644 FD45                        00            .byte	0
41645                                           ! 8176  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
41646 FD46                        78            .byte	$78
41647 FD47                        60            .byte	$60
41648 FD48                        60            .byte	$60
41649 FD49                        60            .byte	$60
41650 FD4A                        60            .byte	$60
41651 FD4B                        60            .byte	$60
41652 FD4C                        78            .byte	$78
41653 FD4D                        00            .byte	0
41654                                           ! 8177  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
41655 FD4E                        C0            .byte	$C0
41656 FD4F                        60            .byte	$60
41657 FD50                        30            .byte	$30
41658 FD51                        18            .byte	$18
41659 FD52                        0C            .byte	$C
41660 FD53                        06            .byte	6
41661 FD54                        02            .byte	2
41662 FD55                        00            .byte	0
41663                                           ! 8178  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
41664 FD56                        78            .byte	$78
41665 FD57                        18            .byte	$18
41666 FD58                        18            .byte	$18
41667 FD59                        18            .byte	$18
41668 FD5A                        18            .byte	$18
41669 FD5B                        18            .byte	$18
41670 FD5C                        78            .byte	$78
41671 FD5D                        00            .byte	0
41672                                           ! 8179  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
41673 FD5E                        10            .byte	$10
41674 FD5F                        38            .byte	$38
41675 FD60                        6C            .byte	$6C
41676 FD61                        C6            .byte	$C6
41677 FD62                        00            .byte	0
41678 FD63                        00            .byte	0
41679 FD64                        00            .byte	0
41680 FD65                        00            .byte	0
41681                                           ! 8180  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
41682 FD66                        00            .byte	0
41683 FD67                        00            .byte	0
41684 FD68                        00            .byte	0
41685 FD69                        00            .byte	0
41686 FD6A                        00            .byte	0
41687 FD6B                        00            .byte	0
41688 FD6C                        00            .byte	0
41689 FD6D                        FF            .byte	$FF
41690                                           ! 8181  0x30, 0x30, 0x18, 0x00, 0x00
41691 FD6E                        30            .byte	$30
41692 FD6F                        30            .byte	$30
41693 FD70                        18            .byte	$18
41694 FD71                        00            .byte	0
41695                                           ! 8181 , 0x00, 0x00, 0x00,
41696 FD72                        00            .byte	0
41697 FD73                        00            .byte	0
41698 FD74                        00            .byte	0
41699 FD75                        00            .byte	0
41700                                           ! 8182  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
41701 FD76                        00            .byte	0
41702 FD77                        00            .byte	0
41703 FD78                        78            .byte	$78
41704 FD79                        0C            .byte	$C
41705 FD7A                        7C            .byte	$7C
41706 FD7B                        CC            .byte	$CC
41707 FD7C                        76            .byte	$76
41708 FD7D                        00            .byte	0
41709                                           ! 8183  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
41710 FD7E                        E0            .byte	$E0
41711 FD7F                        60            .byte	$60
41712 FD80                        60            .byte	$60
41713 FD81                        7C            .byte	$7C
41714 FD82                        66            .byte	$66
41715 FD83                        66            .byte	$66
41716 FD84                        DC            .byte	$DC
41717 FD85                        00            .byte	0
41718                                           ! 8184  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41719 FD86                        00            .byte	0
41720 FD87                        00            .byte	0
41721 FD88                        78            .byte	$78
41722 FD89                        CC            .byte	$CC
41723 FD8A                        C0            .byte	$C0
41724 FD8B                        CC            .byte	$CC
41725 FD8C                        78            .byte	$78
41726 FD8D                        00            .byte	0
41727                                           ! 8185  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
41728 FD8E                        1C            .byte	$1C
41729 FD8F                        0C            .byte	$C
41730 FD90                        0C            .byte	$C
41731 FD91                        7C            .byte	$7C
41732 FD92                        CC            .byte	$CC
41733 FD93                        CC            .byte	$CC
41734 FD94                        76            .byte	$76
41735 FD95                        00            .byte	0
41736                                           ! 8186  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41737 FD96                        00            .byte	0
41738 FD97                        00            .byte	0
41739 FD98                        78            .byte	$78
41740 FD99                        CC            .byte	$CC
41741 FD9A                        FC            .byte	$FC
41742 FD9B                        C0            .byte	$C0
41743 FD9C                        78            .byte	$78
41744 FD9D                        00            .byte	0
41745                                           ! 8187  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41746 FD9E                        38            .byte	$38
41747 FD9F                        6C            .byte	$6C
41748 FDA0                        60            .byte	$60
41749 FDA1                        F0            .byte	$F0
41750 FDA2                        60            .byte	$60
41751 FDA3                        60            .byte	$60
41752 FDA4                        F0            .byte	$F0
41753 FDA5                        00            .byte	0
41754                                           ! 8188  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41755 FDA6                        00            .byte	0
41756 FDA7                        00            .byte	0
41757 FDA8                        76            .byte	$76
41758 FDA9                        CC            .byte	$CC
41759 FDAA                        CC            .byte	$CC
41760 FDAB                        7C            .byte	$7C
41761 FDAC                        0C            .byte	$C
41762 FDAD                        F8            .byte	$F8
41763                                           ! 8189  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
41764 FDAE                        E0            .byte	$E0
41765 FDAF                        60            .byte	$60
41766 FDB0                        6C            .byte	$6C
41767 FDB1                        76            .byte	$76
41768 FDB2                        66            .byte	$66
41769 FDB3                        66            .byte	$66
41770 FDB4                        E6            .byte	$E6
41771 FDB5                        00            .byte	0
41772                                           ! 8190  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
41773 FDB6                        30            .byte	$30
41774 FDB7                        00            .byte	0
41775 FDB8                        70            .byte	$70
41776 FDB9                        30            .byte	$30
41777 FDBA                        30            .byte	$30
41778 FDBB                        30            .byte	$30
41779 FDBC                        78            .byte	$78
41780 FDBD                        00            .byte	0
41781                                           ! 8191  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
41782 FDBE                        0C            .byte	$C
41783 FDBF                        00            .byte	0
41784 FDC0                        0C            .byte	$C
41785 FDC1                        0C            .byte	$C
41786 FDC2                        0C            .byte	$C
41787 FDC3                        CC            .byte	$CC
41788 FDC4                        CC            .byte	$CC
41789 FDC5                        78            .byte	$78
41790                                           ! 8192  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
41791 FDC6                        E0            .byte	$E0
41792 FDC7                        60            .byte	$60
41793 FDC8                        66            .byte	$66
41794 FDC9                        6C            .byte	$6C
41795 FDCA                        78            .byte	$78
41796 FDCB                        6C            .byte	$6C
41797 FDCC                        E6            .byte	$E6
41798 FDCD                        00            .byte	0
41799                                           ! 8193  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41800 FDCE                        70            .byte	$70
41801 FDCF                        30            .byte	$30
41802 FDD0                        30            .byte	$30
41803 FDD1                        30            .byte	$30
41804 FDD2                        30            .byte	$30
41805 FDD3                        30            .byte	$30
41806 FDD4                        78            .byte	$78
41807 FDD5                        00            .byte	0
41808                                           ! 8194  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
41809 FDD6                        00            .byte	0
41810 FDD7                        00            .byte	0
41811 FDD8                        CC            .byte	$CC
41812 FDD9                        FE            .byte	$FE
41813 FDDA                        FE            .byte	$FE
41814 FDDB                        D6            .byte	$D6
41815 FDDC                        C6            .byte	$C6
41816 FDDD                        00            .byte	0
41817                                           ! 8195  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
41818 FDDE                        00            .byte	0
41819 FDDF                        00            .byte	0
41820 FDE0                        F8            .byte	$F8
41821 FDE1                        CC            .byte	$CC
41822 FDE2                        CC            .byte	$CC
41823 FDE3                        CC            .byte	$CC
41824 FDE4                        CC            .byte	$CC
41825 FDE5                        00            .byte	0
41826                                           ! 8196  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
41827 FDE6                        00            .byte	0
41828 FDE7                        00            .byte	0
41829 FDE8                        78            .byte	$78
41830 FDE9                        CC            .byte	$CC
41831 FDEA                        CC            .byte	$CC
41832 FDEB                        CC            .byte	$CC
41833 FDEC                        78            .byte	$78
41834 FDED                        00            .byte	0
41835                                           ! 8197  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
41836 FDEE                        00            .byte	0
41837 FDEF                        00            .byte	0
41838 FDF0                        DC            .byte	$DC
41839 FDF1                        66            .byte	$66
41840 FDF2                        66            .byte	$66
41841 FDF3                        7C            .byte	$7C
41842 FDF4                        60            .byte	$60
41843 FDF5                        F0            .byte	$F0
41844                                           ! 8198  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
41845 FDF6                        00            .byte	0
41846 FDF7                        00            .byte	0
41847 FDF8                        76            .byte	$76
41848 FDF9                        CC            .byte	$CC
41849 FDFA                        CC            .byte	$CC
41850 FDFB                        7C            .byte	$7C
41851 FDFC                        0C            .byte	$C
41852 FDFD                        1E            .byte	$1E
41853                                           ! 8199  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
41854 FDFE                        00            .byte	0
41855 FDFF                        00            .byte	0
41856 FE00                        DC            .byte	$DC
41857 FE01                        76            .byte	$76
41858 FE02                        66            .byte	$66
41859 FE03                        60            .byte	$60
41860 FE04                        F0            .byte	$F0
41861 FE05                        00            .byte	0
41862                                           ! 8200  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
41863 FE06                        00            .byte	0
41864 FE07                        00            .byte	0
41865 FE08                        7C            .byte	$7C
41866 FE09                        C0            .byte	$C0
41867 FE0A                        78            .byte	$78
41868 FE0B                        0C            .byte	$C
41869 FE0C                        F8            .byte	$F8
41870 FE0D                        00            .byte	0
41871                                           ! 8201  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
41872 FE0E                        10            .byte	$10
41873 FE0F                        30            .byte	$30
41874 FE10                        7C            .byte	$7C
41875 FE11                        30            .byte	$30
41876 FE12                        30            .byte	$30
41877 FE13                        34            .byte	$34
41878 FE14                        18            .byte	$18
41879 FE15                        00            .byte	0
41880                                           ! 8202  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
41881 FE16                        00            .byte	0
41882 FE17                        00            .byte	0
41883 FE18                        CC            .byte	$CC
41884 FE19                        CC            .byte	$CC
41885 FE1A                        CC            .byte	$CC
41886 FE1B                        CC            .byte	$CC
41887 FE1C                        76            .byte	$76
41888 FE1D                        00            .byte	0
41889                                           ! 8203  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41890 FE1E                        00            .byte	0
41891 FE1F                        00            .byte	0
41892 FE20                        CC            .byte	$CC
41893 FE21                        CC            .byte	$CC
41894 FE22                        CC            .byte	$CC
41895 FE23                        78            .byte	$78
41896 FE24                        30            .byte	$30
41897 FE25                        00            .byte	0
41898                                           ! 8204  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
41899 FE26                        00            .byte	0
41900 FE27                        00            .byte	0
41901 FE28                        C6            .byte	$C6
41902 FE29                        D6            .byte	$D6
41903 FE2A                        FE            .byte	$FE
41904 FE2B                        FE            .byte	$FE
41905 FE2C                        6C            .byte	$6C
41906 FE2D                        00            .byte	0
41907                                           ! 8205  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
41908 FE2E                        00            .byte	0
41909 FE2F                        00            .byte	0
41910 FE30                        C6            .byte	$C6
41911 FE31                        6C            .byte	$6C
41912 FE32                        38            .byte	$38
41913 FE33                        6C            .byte	$6C
41914 FE34                        C6            .byte	$C6
41915 FE35                        00            .byte	0
41916                                           ! 8206  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41917 FE36                        00            .byte	0
41918 FE37                        00            .byte	0
41919 FE38                        CC            .byte	$CC
41920 FE39                        CC            .byte	$CC
41921 FE3A                        CC            .byte	$CC
41922 FE3B                        7C            .byte	$7C
41923 FE3C                        0C            .byte	$C
41924 FE3D                        F8            .byte	$F8
41925                                           ! 8207  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
41926 FE3E                        00            .byte	0
41927 FE3F                        00            .byte	0
41928 FE40                        FC            .byte	$FC
41929 FE41                        98            .byte	$98
41930 FE42                        30            .byte	$30
41931 FE43                        64            .byte	$64
41932 FE44                        FC            .byte	$FC
41933 FE45                        00            .byte	0
41934                                           ! 8208  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
41935 FE46                        1C            .byte	$1C
41936 FE47                        30            .byte	$30
41937 FE48                        30            .byte	$30
41938 FE49                        E0            .byte	$E0
41939 FE4A                        30            .byte	$30
41940 FE4B                        30            .byte	$30
41941 FE4C                        1C            .byte	$1C
41942 FE4D                        00            .byte	0
41943                                           ! 8209  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
41944 FE4E                        18            .byte	$18
41945 FE4F                        18            .byte	$18
41946 FE50                        18            .byte	$18
41947 FE51                        00            .byte	0
41948 FE52                        18            .byte	$18
41949 FE53                        18            .byte	$18
41950 FE54                        18            .byte	$18
41951 FE55                        00            .byte	0
41952                                           ! 8210  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
41953 FE56                        E0            .byte	$E0
41954 FE57                        30            .byte	$30
41955 FE58                        30            .byte	$30
41956 FE59                        1C            .byte	$1C
41957 FE5A                        30            .byte	$30
41958 FE5B                        30            .byte	$30
41959 FE5C                        E0            .byte	$E0
41960 FE5D                        00            .byte	0
41961                                           ! 8211  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41962 FE5E                        76            .byte	$76
41963 FE5F                        DC            .byte	$DC
41964 FE60                        00            .byte	0
41965 FE61                        00            .byte	0
41966 FE62                        00            .byte	0
41967 FE63                        00            .byte	0
41968 FE64                        00            .byte	0
41969 FE65                        00            .byte	0
41970                                           ! 8212  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
41971 FE66                        00            .byte	0
41972 FE67                        10            .byte	$10
41973 FE68                        38            .byte	$38
41974 FE69                        6C            .byte	$6C
41975 FE6A                        C6            .byte	$C6
41976 FE6B                        C6            .byte	$C6
41977 FE6C                        FE            .byte	$FE
41978 FE6D                        00            .byte	0
41979                                           ! 8213 };
41980                                           !BCC_EOS
41981                                           ! 8214 #asm
41982                                           !BCC_ASM
41983 CC00                                      .org 0xcc00
41984                       0000CC00            bios_table_area_end:
41985                                           ! 8217 endasm
41986                                           !BCC_ENDASM
41987                                           ! 8218 
41988                       0000CC00            .784:
41989                       0000CC00            .793:
41990 CC00                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
41991 CC28                        20            .ascii	" found at index %d"
41992 CC3A                        0A            .byte	$A
41993 CC3B                        00            .byte	0
41994                       0000CC3C            .782:
41995                       0000CC3C            .794:
41996 CC3C                        50            .ascii	"PCI device %04x:%04x not found at index "
41997 CC64                        25            .ascii	"%d"
41998 CC66                        0A            .byte	$A
41999 CC67                        00            .byte	0
42000                       0000CC68            .77C:
42001                       0000CC68            .795:
42002 CC68                        62            .ascii	"bad PCI vendor ID %04x"
42003 CC7E                        0A            .byte	$A
42004 CC7F                        00            .byte	0
42005                       0000CC80            .778:
42006                       0000CC80            .796:
42007 CC80                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
42008 CCA4                        0A            .byte	$A
42009 CCA5                        00            .byte	0
42010                       0000CCA6            .774:
42011                       0000CCA6            .797:
42012 CCA6                        50            .ascii	"PCI BIOS: PCI not present"
42013 CCBF                        0A            .byte	$A
42014 CCC0                        00            .byte	0
42015                       0000CCC1            .759:
42016                       0000CCC1            .798:
42017 CCC1                        42            .ascii	"Booting from %x:%x"
42018 CCD3                        0A            .byte	$A
42019 CCD4                        00            .byte	0
42020                       0000CCD5            .744:
42021                       0000CCD5            .799:
42022 CCD5                        49            .ascii	"Invalid boot device (0x%x)"
42023 CCEF                        0A            .byte	$A
42024 CCF0                        00            .byte	0
42025                       0000CCF1            .741:
42026                       0000CCF1            .79A:
42027 CCF1                        4E            .ascii	"No bootable device."
42028 CD04                        0A            .byte	$A
42029 CD05                        00            .byte	0
42030                       0000CD06            .72B:
42031                       0000CD06            .79B:
42032 CD06                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
42033 CD2B                        0A            .byte	$A
42034 CD2C                        00            .byte	0
42035                       0000CD2D            .726:
42036                       0000CD2D            .79C:
42037 CD2D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
42038 CD50                        0A            .byte	$A
42039 CD51                        00            .byte	0
42040                       0000CD52            .714:
42041                       0000CD52            .79D:
42042 CD52                        66            .ascii	"floppy: int13: bad floppy type"
42043 CD70                        0A            .byte	$A
42044 CD71                        00            .byte	0
42045                       0000CD72            .6FC:
42046                       0000CD72            .79E:
42047 CD72                        69            .ascii	"int13_diskette_function: write error"
42048 CD96                        0A            .byte	$A
42049 CD97                        00            .byte	0
42050                       0000CD98            .6F6:
42051                       0000CD98            .79F:
42052 CD98                        69            .ascii	"int13_diskette: ctrl not ready"
42053 CDB6                        0A            .byte	$A
42054 CDB7                        00            .byte	0
42055                       0000CDB8            .6DB:
42056                       0000CDB8            .7A0:
42057 CDB8                        69            .ascii	"int13_diskette_function: read error"
42058 CDDB                        0A            .byte	$A
42059 CDDC                        00            .byte	0
42060                       0000CDDD            .6D5:
42061                       0000CDDD            .7A1:
42062 CDDD                        69            .ascii	"int13_diskette: ctrl not ready"
42063 CDFB                        0A            .byte	$A
42064 CDFC                        00            .byte	0
42065                       0000CDFD            .6C3:
42066                       0000CDFD            .7A2:
42067 CDFD                        69            .ascii	"int13_diskette: ctrl not ready"
42068 CE1B                        0A            .byte	$A
42069 CE1C                        00            .byte	0
42070                       0000CE1D            .6AE:
42071                       0000CE1D            .7A3:
42072 CE1D                        69            .ascii	"int13_diskette: read/write/verify: param"
42073 CE45                        65            .ascii	"eter out of range"
42074 CE56                        0A            .byte	$A
42075 CE57                        00            .byte	0
42076                       0000CE58            .64C:
42077                       0000CE58            .7A4:
42078 CE58                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
42079 CE80                        2C            .ascii	", returns fail"
42080 CE8E                        0A            .byte	$A
42081 CE8F                        00            .byte	0
42082                       0000CE90            .634:
42083                       0000CE90            .7A5:
42084 CE90                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
42085 CEB8                        0A            .byte	$A
42086 CEB9                        00            .byte	0
42087                       0000CEBA            .616:
42088                       0000CEBA            .7A6:
42089 CEBA                        69            .ascii	"int13_cdemu: function %02x, emulation no"
42090 CEE2                        74            .ascii	"t active for DL= %02x"
42091 CEF7                        0A            .byte	$A
42092 CEF8                        00            .byte	0
42093                       0000CEF9            .612:
42094                       0000CEF9            .7A7:
42095 CEF9                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
42096 CF1C                        0A            .byte	$A
42097 CF1D                        00            .byte	0
42098                       0000CF1E            .60D:
42099                       0000CF1E            .7A8:
42100 CF1E                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
42101 CF46                        20            .ascii	" report"
42102 CF4D                        0A            .byte	$A
42103 CF4E                        00            .byte	0
42104                       0000CF4F            .602:
42105                       0000CF4F            .7A9:
42106 CF4F                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
42107 CF6F                        0A            .byte	$A
42108 CF70                        00            .byte	0
42109                       0000CF71            .5BB:
42110                       0000CF71            .7AA:
42111 CF71                        69            .ascii	"int13_cdrom: function %02x, status %02x "
42112 CF99                        21            .ascii	"!"
42113 CF9A                        0A            .byte	$A
42114 CF9B                        00            .byte	0
42115                       0000CF9C            .5B5:
42116                       0000CF9C            .7AB:
42117 CF9C                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
42118 CFC4                        62            .ascii	"bits lba"
42119 CFCC                        0A            .byte	$A
42120 CFCD                        00            .byte	0
42121                       0000CFCE            .59B:
42122                       0000CFCE            .7AC:
42123 CFCE                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
42124 CFF6                        69            .ascii	"ice for ELDL=%02x"
42125 D007                        0A            .byte	$A
42126 D008                        00            .byte	0
42127                       0000D009            .598:
42128                       0000D009            .7AD:
42129 D009                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
42130 D031                        72            .ascii	"range %02x"
42131 D03B                        0A            .byte	$A
42132 D03C                        00            .byte	0
42133                       0000D03D            .590:
42134                       0000D03D            .7AE:
42135 D03D                        69            .ascii	"int13_harddisk: function %02xh unsupport"
42136 D065                        65            .ascii	"ed, returns fail"
42137 D075                        0A            .byte	$A
42138 D076                        00            .byte	0
42139                       0000D077            .58A:
42140                       0000D077            .7AF:
42141 D077                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
42142 D09F                        6E            .ascii	"nted, returns success"
42143 D0B4                        0A            .byte	$A
42144 D0B5                        00            .byte	0
42145                       0000D0B6            .549:
42146                       0000D0B6            .7B0:
42147 D0B6                        69            .ascii	"int13_harddisk: function %02x, error %02"
42148 D0DE                        78            .ascii	"x !"
42149 D0E1                        0A            .byte	$A
42150 D0E2                        00            .byte	0
42151                       0000D0E3            .540:
42152                       0000D0E3            .7B1:
42153 D0E3                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42154 D10B                        66            .ascii	"f range"
42155 D112                        0A            .byte	$A
42156 D113                        00            .byte	0
42157                       0000D114            .53C:
42158                       0000D114            .7B2:
42159 D114                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42160 D13C                        66            .ascii	"f range"
42161 D143                        0A            .byte	$A
42162 D144                        00            .byte	0
42163                       0000D145            .52E:
42164                       0000D145            .7B3:
42165 D145                        66            .ascii	"format disk track called"
42166 D15D                        0A            .byte	$A
42167 D15E                        00            .byte	0
42168                       0000D15F            .52C:
42169                       0000D15F            .7B4:
42170 D15F                        69            .ascii	"int13_harddisk: function %02x, error %02"
42171 D187                        78            .ascii	"x !"
42172 D18A                        0A            .byte	$A
42173 D18B                        00            .byte	0
42174                       0000D18C            .521:
42175                       0000D18C            .7B5:
42176 D18C                        69            .ascii	"int13_harddisk: function %02x, parameter"
42177 D1B4                        73            .ascii	"s out of range %04x/%04x/%04x!"
42178 D1D2                        0A            .byte	$A
42179 D1D3                        00            .byte	0
42180                       0000D1D4            .51C:
42181                       0000D1D4            .7B6:
42182 D1D4                        69            .ascii	"int13_harddisk: function %02x, parameter"
42183 D1FC                        20            .ascii	" out of range!"
42184 D20A                        0A            .byte	$A
42185 D20B                        00            .byte	0
42186                       0000D20C            .50C:
42187                       0000D20C            .7B7:
42188 D20C                        69            .ascii	"int13_harddisk: function %02x, unmapped "
42189 D234                        64            .ascii	"device for ELDL=%02x"
42190 D248                        0A            .byte	$A
42191 D249                        00            .byte	0
42192                       0000D24A            .509:
42193                       0000D24A            .7B8:
42194 D24A                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
42195 D272                        6F            .ascii	"of range %02x"
42196 D27F                        0A            .byte	$A
42197 D280                        00            .byte	0
42198                       0000D281            .4F6:
42199                       0000D281            .7B9:
42200 D281                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
42201 D2A9                        6F            .ascii	"ode are zero?"
42202 D2B6                        0A            .byte	$A
42203 D2B7                        00            .byte	0
42204                       0000D2B8            .4DE:
42205                       0000D2B8            .7BA:
42206 D2B8                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
42207 D2E0                        72            .ascii	"read: 0x%02x!"
42208 D2ED                        0A            .byte	$A
42209 D2EE                        00            .byte	0
42210                       0000D2EF            .4B3:
42211                       0000D2EF            .7BB:
42212 D2EF                        4B            .ascii	"KBD: int09 handler: AL=0"
42213 D307                        0A            .byte	$A
42214 D308                        00            .byte	0
42215                       0000D309            .4B0:
42216                       0000D309            .7BC:
42217 D309                        73            .ascii	"setkbdcomm"
42218 D313                        00            .byte	0
42219                       0000D314            .4A9:
42220                       0000D314            .7BD:
42221 D314                        73            .ascii	"sendmouse"
42222 D31D                        00            .byte	0
42223                       0000D31E            .4A6:
42224                       0000D31E            .7BE:
42225 D31E                        65            .ascii	"enabmouse"
42226 D327                        00            .byte	0
42227                       0000D328            .49F:
42228                       0000D328            .7BF:
42229 D328                        65            .ascii	"enabmouse"
42230 D331                        00            .byte	0
42231                       0000D332            .49C:
42232                       0000D332            .7C0:
42233 D332                        69            .ascii	"inhibmouse"
42234 D33C                        00            .byte	0
42235                       0000D33D            .495:
42236                       0000D33D            .7C1:
42237 D33D                        69            .ascii	"inhibmouse"
42238 D347                        00            .byte	0
42239                       0000D348            .488:
42240                       0000D348            .7C2:
42241 D348                        4B            .ascii	"KBD: unsupported int 16h function %02x"
42242 D36E                        0A            .byte	$A
42243 D36F                        00            .byte	0
42244                       0000D370            .477:
42245                       0000D370            .7C3:
42246 D370                        4B            .ascii	"KBD: int16h: out of keyboard input"
42247 D392                        0A            .byte	$A
42248 D393                        00            .byte	0
42249                       0000D394            .449:
42250                       0000D394            .7C4:
42251 D394                        4B            .ascii	"KBD: int16h: out of keyboard input"
42252 D3B6                        0A            .byte	$A
42253 D3B7                        00            .byte	0
42254                       0000D3B8            .436:
42255                       0000D3B8            .7C5:
42256 D3B8                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42257 D3E0                        74            .ascii	"t yet supported!"
42258 D3F0                        0A            .byte	$A
42259 D3F1                        00            .byte	0
42260                       0000D3F2            .40F:
42261                       0000D3F2            .7C6:
42262 D3F2                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42263 D41A                        74            .ascii	"t yet supported!"
42264 D42A                        0A            .byte	$A
42265 D42B                        00            .byte	0
42266                       0000D42C            .403:
42267                       0000D42C            .7C7:
42268 D42C                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
42269 D444                        0A            .byte	$A
42270 D445                        00            .byte	0
42271                       0000D446            .3ED:
42272                       0000D446            .7C8:
42273 D446                        4D            .ascii	"Mouse status returned %02x (should be ac"
42274 D46E                        6B            .ascii	"k)"
42275 D470                        0A            .byte	$A
42276 D471                        00            .byte	0
42277                       0000D472            .3DD:
42278                       0000D472            .7C9:
42279 D472                        4D            .ascii	"Mouse status returned %02x (should be ac"
42280 D49A                        6B            .ascii	"k)"
42281 D49C                        0A            .byte	$A
42282 D49D                        00            .byte	0
42283                       0000D49E            .3DA:
42284                       0000D49E            .7CA:
42285 D49E                        4D            .ascii	"Mouse status returned %02x (should be ac"
42286 D4C6                        6B            .ascii	"k)"
42287 D4C8                        0A            .byte	$A
42288 D4C9                        00            .byte	0
42289                       0000D4CA            .3B8:
42290                       0000D4CA            .7CB:
42291 D4CA                        4D            .ascii	"Mouse reset returned %02x (should be ack"
42292 D4F2                        29            .ascii	")"
42293 D4F3                        0A            .byte	$A
42294 D4F4                        00            .byte	0
42295                       0000D4F5            .38F:
42296                       0000D4F5            .7CC:
42297 D4F5                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42298 D51D                        74            .ascii	"t yet supported!"
42299 D52D                        0A            .byte	$A
42300 D52E                        00            .byte	0
42301                       0000D52F            .38D:
42302                       0000D52F            .7CD:
42303 D52F                        45            .ascii	"EISA BIOS not present"
42304 D544                        0A            .byte	$A
42305 D545                        00            .byte	0
42306                       0000D546            .389:
42307                       0000D546            .7CE:
42308 D546                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
42309 D56E                        72            .ascii	"rted!"
42310 D573                        0A            .byte	$A
42311 D574                        00            .byte	0
42312                       0000D575            .371:
42313                       0000D575            .7CF:
42314 D575                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
42315 D59D                        20            .ascii	" control not supported"
42316 D5B3                        0A            .byte	$A
42317 D5B4                        00            .byte	0
42318                       0000D5B5            .30B:
42319                       0000D5B5            .7D0:
42320 D5B5                        61            .ascii	"ata_is_ready returned %d"
42321 D5CD                        0A            .byte	$A
42322 D5CE                        00            .byte	0
42323                       0000D5CF            .2F5:
42324                       0000D5CF            .7D1:
42325 D5CF                        25            .ascii	"%dMB medium detected"
42326 D5E3                        0A            .byte	$A
42327 D5E4                        00            .byte	0
42328                       0000D5E5            .2F0:
42329                       0000D5E5            .7D2:
42330 D5E5                        55            .ascii	"Unsupported sector size %u"
42331 D5FF                        0A            .byte	$A
42332 D600                        00            .byte	0
42333                       0000D601            .2EB:
42334                       0000D601            .7D3:
42335 D601                        57            .ascii	"Waiting for device to detect medium... "
42336 D628                        00            .byte	0
42337                       0000D629            .2DD:
42338                       0000D629            .7D4:
42339 D629                        6E            .ascii	"not implemented for non-ATAPI device"
42340 D64D                        0A            .byte	$A
42341 D64E                        00            .byte	0
42342                       0000D64F            .2A3:
42343                       0000D64F            .7D5:
42344 D64F                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
42345 D677                        65            .ascii	"et"
42346 D679                        0A            .byte	$A
42347 D67A                        00            .byte	0
42348                       0000D67B            .253:
42349                       0000D67B            .7D6:
42350 D67B                        0A            .byte	$A
42351 D67C                        00            .byte	0
42352                       0000D67D            .24E:
42353                       0000D67D            .7D7:
42354 D67D                        6D            .ascii	"master"
42355 D683                        00            .byte	0
42356                       0000D684            .24D:
42357                       0000D684            .7D8:
42358 D684                        20            .ascii	" slave"
42359 D68A                        00            .byte	0
42360                       0000D68B            .24C:
42361                       0000D68B            .7D9:
42362 D68B                        61            .ascii	"ata%d %s: Unknown device"
42363 D6A3                        0A            .byte	$A
42364 D6A4                        00            .byte	0
42365                       0000D6A5            .24A:
42366                       0000D6A5            .7DA:
42367 D6A5                        20            .ascii	" ATAPI-%d Device"
42368 D6B5                        0A            .byte	$A
42369 D6B6                        00            .byte	0
42370                       0000D6B7            .248:
42371                       0000D6B7            .7DB:
42372 D6B7                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
42373 D6CF                        0A            .byte	$A
42374 D6D0                        00            .byte	0
42375                       0000D6D1            .244:
42376                       0000D6D1            .7DC:
42377 D6D1                        25            .ascii	"%c"
42378 D6D3                        00            .byte	0
42379                       0000D6D4            .23D:
42380                       0000D6D4            .7DD:
42381 D6D4                        6D            .ascii	"master"
42382 D6DA                        00            .byte	0
42383                       0000D6DB            .23C:
42384                       0000D6DB            .7DE:
42385 D6DB                        20            .ascii	" slave"
42386 D6E1                        00            .byte	0
42387                       0000D6E2            .23B:
42388                       0000D6E2            .7DF:
42389 D6E2                        61            .ascii	"ata%d %s: "
42390 D6EC                        00            .byte	0
42391                       0000D6ED            .239:
42392                       0000D6ED            .7E0:
42393 D6ED                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
42394 D70B                        0A            .byte	$A
42395 D70C                        00            .byte	0
42396                       0000D70D            .237:
42397                       0000D70D            .7E1:
42398 D70D                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
42399 D72B                        0A            .byte	$A
42400 D72C                        00            .byte	0
42401                       0000D72D            .233:
42402                       0000D72D            .7E2:
42403 D72D                        25            .ascii	"%c"
42404 D72F                        00            .byte	0
42405                       0000D730            .22C:
42406                       0000D730            .7E3:
42407 D730                        6D            .ascii	"master"
42408 D736                        00            .byte	0
42409                       0000D737            .22B:
42410                       0000D737            .7E4:
42411 D737                        20            .ascii	" slave"
42412 D73D                        00            .byte	0
42413                       0000D73E            .22A:
42414                       0000D73E            .7E5:
42415 D73E                        61            .ascii	"ata%d %s: "
42416 D748                        00            .byte	0
42417                       0000D749            .1FF:
42418                       0000D749            .7E6:
42419 D749                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
42420 D771                        65            .ascii	"e"
42421 D772                        0A            .byte	$A
42422 D773                        00            .byte	0
42423                       0000D774            .1FA:
42424                       0000D774            .7E7:
42425 D774                        20            .ascii	" LCHS=%d/%d/%d"
42426 D782                        0A            .byte	$A
42427 D783                        00            .byte	0
42428                       0000D784            .1DA:
42429                       0000D784            .7E8:
42430 D784                        72            .ascii	"r-echs"
42431 D78A                        00            .byte	0
42432                       0000D78B            .1D8:
42433                       0000D78B            .7E9:
42434 D78B                        6C            .ascii	"large"
42435 D790                        00            .byte	0
42436                       0000D791            .1D6:
42437                       0000D791            .7EA:
42438 D791                        6C            .ascii	"lba"
42439 D794                        00            .byte	0
42440                       0000D795            .1D4:
42441                       0000D795            .7EB:
42442 D795                        6E            .ascii	"none"
42443 D799                        00            .byte	0
42444                       0000D79A            .1CA:
42445                       0000D79A            .7EC:
42446 D79A                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
42447 D7BE                        00            .byte	0
42448                       0000D7BF            .1C0:
42449                       0000D7BF            .7ED:
42450 D7BF                        61            .ascii	"ata-detect: Failed to detect ATA device"
42451 D7E6                        0A            .byte	$A
42452 D7E7                        00            .byte	0
42453                       0000D7E8            .19F:
42454                       0000D7E8            .7EE:
42455 D7E8                        49            .ascii	"IDE time out"
42456 D7F4                        0A            .byte	$A
42457 D7F5                        00            .byte	0
42458                       0000D7F6            .163:
42459                       0000D7F6            .7EF:
42460 D7F6                        53            .ascii	"S3 resume jump to %x:%x"
42461 D80D                        0A            .byte	$A
42462 D80E                        00            .byte	0
42463                       0000D80F            .15F:
42464                       0000D80F            .7F0:
42465 D80F                        53            .ascii	"S3 resume called %x 0x%lx"
42466 D828                        0A            .byte	$A
42467 D829                        00            .byte	0
42468                       0000D82A            .159:
42469                       0000D82A            .7F1:
42470 D82A                        25            .ascii	"%s"
42471 D82C                        0A            .byte	$A
42472 D82D                        00            .byte	0
42473                       0000D82E            .158:
42474                       0000D82E            .7F2:
42475 D82E                        49            .ascii	"INT18: BOOT FAILURE"
42476 D841                        0A            .byte	$A
42477 D842                        00            .byte	0
42478                       0000D843            .157:
42479                       0000D843            .7F3:
42480 D843                        4E            .ascii	"NMI Handler called"
42481 D855                        0A            .byte	$A
42482 D856                        00            .byte	0
42483                       0000D857            .156:
42484                       0000D857            .7F4:
42485 D857                        43            .ascii	"CDROM boot failure code : %04x"
42486 D875                        0A            .byte	$A
42487 D876                        00            .byte	0
42488                       0000D877            .155:
42489                       0000D877            .7F5:
42490 D877                        0A            .byte	$A,$A
42491 D879                        00            .byte	0
42492                       0000D87A            .154:
42493                       0000D87A            .7F6:
42494 D87A                        3A            .ascii	": could not read the boot disk"
42495 D898                        00            .byte	0
42496                       0000D899            .152:
42497                       0000D899            .7F7:
42498 D899                        3A            .ascii	": not a bootable disk"
42499 D8AE                        00            .byte	0
42500                       0000D8AF            .14D:
42501                       0000D8AF            .7F8:
42502 D8AF                        42            .ascii	"Boot failed"
42503 D8BA                        00            .byte	0
42504                       0000D8BB            .14C:
42505                       0000D8BB            .7F9:
42506 D8BB                        42            .ascii	"Bad drive type"
42507 D8C9                        0A            .byte	$A
42508 D8CA                        00            .byte	0
42509                       0000D8CB            .148:
42510                       0000D8CB            .7FA:
42511 D8CB                        2E            .ascii	"..."
42512 D8CE                        0A            .byte	$A
42513 D8CF                        00            .byte	0
42514                       0000D8D0            .147:
42515                       0000D8D0            .7FB:
42516 D8D0                        20            .ascii	" [%S]"
42517 D8D5                        00            .byte	0
42518                       0000D8D6            .143:
42519                       0000D8D6            .7FC:
42520 D8D6                        42            .ascii	"Booting from %s"
42521 D8E5                        00            .byte	0
42522                       0000D8E6            .142:
42523                       0000D8E6            .7FD:
42524 D8E6                        42            .ascii	"Bad drive type"
42525 D8F4                        0A            .byte	$A
42526 D8F5                        00            .byte	0
42527                       0000D8F6            .13C:
42528                       0000D8F6            .7FE:
42529 D8F6                        0A            .byte	$A
42530 D8F7                        00            .byte	0
42531                       0000D8F8            .130:
42532                       0000D8F8            .7FF:
42533 D8F8                        0A            .byte	$A
42534 D8F9                        00            .byte	0
42535                       0000D8FA            .12F:
42536                       0000D8FA            .800:
42537 D8FA                        20            .ascii	" [%S]"
42538 D8FF                        00            .byte	0
42539                       0000D900            .12C:
42540                       0000D900            .801:
42541 D900                        25            .ascii	"%s"
42542 D902                        00            .byte	0
42543                       0000D903            .12A:
42544                       0000D903            .802:
42545 D903                        25            .ascii	"%s"
42546 D905                        0A            .byte	$A
42547 D906                        00            .byte	0
42548                       0000D907            .123:
42549                       0000D907            .803:
42550 D907                        25            .ascii	"%d. "
42551 D90B                        00            .byte	0
42552                       0000D90C            .11E:
42553                       0000D90C            .804:
42554 D90C                        53            .ascii	"Select boot device:"
42555 D91F                        0A            .byte	$A,$A
42556 D921                        00            .byte	0
42557                       0000D922            .115:
42558                       0000D922            .805:
42559 D922                        50            .ascii	"Press F12 for boot menu."
42560 D93A                        0A            .byte	$A,$A
42561 D93C                        00            .byte	0
42562                       0000D93D            .109:
42563                       0000D93D            .806:
42564 D93D                        61            .ascii	"apmbios pcibios eltorito rombios32 "
42565 D960                        0A            .byte	$A,$A
42566 D962                        00            .byte	0
42567                       0000D963            .108:
42568                       0000D963            .807:
42569 D963                        31            .ascii	"10/11/09"
42570 D96B                        00            .byte	0
42571                       0000D96C            .107:
42572                       0000D96C            .808:
42573 D96C                        42            .ascii	"Bochs BIOS - build: %s"
42574 D982                        0A            .byte	$A
42575 D983                        25            .ascii	"%s"
42576 D985                        0A            .byte	$A
42577 D986                        4F            .ascii	"Options: "
42578 D98F                        00            .byte	0
42579                       0000D990            .106:
42580                       0000D990            .809:
42581 D990                        52            .ascii	"Returned from s3_resume."
42582 D9A8                        0A            .byte	$A
42583 D9A9                        00            .byte	0
42584                       0000D9AA            .105:
42585                       0000D9AA            .80A:
42586 D9AA                        55            .ascii	"Unimplemented shutdown status: %02x"
42587 D9CD                        0A            .byte	$A
42588 D9CE                        00            .byte	0
42589                       0000D9CF            .104:
42590                       0000D9CF            .80B:
42591 D9CF                        4B            .ascii	"Keyboard error:%u"
42592 D9E0                        0A            .byte	$A
42593 D9E1                        00            .byte	0
42594                       0000D9E2            .8D:
42595                       0000D9E2            .80C:
42596 D9E2                        62            .ascii	"bios_printf: unknown format"
42597 D9FD                        0A            .byte	$A
42598 D9FE                        00            .byte	0
42599                       0000D9FF            .41:
42600                       0000D9FF            .80D:
42601 D9FF                        46            .ascii	"FATAL: "
42602 DA06                        00            .byte	0
42603 DA07                                      .bss
42604                                           
42605                                           ! 0 errors detected

Symbols:
..FFDA                      0 FFFC A   ..FFDB                      0 FFE0 A   
..FFDC                      0 FFE0 A   ..FFDD                      0 FFCA A   
..FFDE                      0 FFCA A   ..FFDF                      0 FFCA A   
..FFE0                      0 FFCA A   ..FFE1                      0 FFCA A   
..FFE2                      0 FFCA A   ..FFE3                      0 FFFC A   
..FFE4                      0 FFFC A   ..FFE5                      0 FFFC A   
..FFE6                      0 FFDE A   ..FFE7                      0 FFDE A   
..FFE8                      0 FFDE A   ..FFE9                      0 FFDE A   
..FFEA                      0 FFD2 A   ..FFEB                      0 FFDE A   
..FFEC                      0 FFD8 A   ..FFED                      0 FFD8 A   
..FFEE                      0 FFD8 A   ..FFEF                      0 FFD8 A   
..FFF0                      0 FFCA A   ..FFF1                      0 FFD8 A   
..FFF2                      0 FFF8 A   ..FFF3                      0 FFF4 A   
..FFF4                      0 FFF0 A   ..FFF5                      0 FFF0 A   
..FFF6                      0 FFF0 A   ..FFF7                      0 FFEA A   
..FFF8                      0 FFF6 A   ..FFF9                      0 F7E2 A   
..FFFA                      0 FFD4 A   ..FFFB                      0 FDBA A   
..FFFC                      0 FDBA A   ..FFFD                      0 FDD8 A   
..FFFE                      0 FDD8 A   ..FFFF                      0 FFC4 A   
.1                          0 0194 A   .10                         0 06EB A   
.100                        0 1214 A   .101                        0 120B A   
.102                        0 122A A   .103                        0 1221 A   
.104                        0 D9CF A   .105                        0 D9AA A   
.106                        0 D990 A   .107                        0 D96C A   
.108                        0 D963 A   .109                        0 D93D A   
.10A                        0 12A2 A   .10B                        0 12AC A   
.10C                        0 12B6 A   .10D                        0 12C0 A   
.10E                        0 12CA A   .10F                        0 1446 A   
.11                         0 06D5 A   .110                        0 1440 A   
.111                        0 1487 A   .112                        0 1480 A   
.113                        0 147D A   .114                        0 1487 A   
.115                        0 D922 A   .116                        0 165D A   
.117                        0 14AC A   .118                        0 165D A   
.119                        0 14BB A   .11A                        0 14C7 A   
.11B                        0 14C0 A   .11C                        0 14BD A   
.11D                        0 14C7 A   .11E                        0 D90C A   
.11F                        0 15F6 A   .12                         0 0719 A   
.120                        0 15E3 A   .121                        0 15EA A   
.122                        0 14EE A   .123                        0 D907 A   
.124                        0 15E3 A   .126                        0 15C7 A   
.127                        0 1528 A   .128                        0 1528 A   
.129                        0 1528 A   .12A                        0 D903 A   
.12B                        0 154B A   .12C                        0 D900 A   
.12D                        0 15B5 A   .12E                        0 1574 A   
.12F                        0 D8FA A   .13                         0 0705 A   
.130                        0 D8F8 A   .131                        0 15F6 A   
.132                        0 164F A   .133                        0 1648 A   
.134                        0 15FF A   .135                        0 161B A   
.136                        0 1613 A   .137                        0 160C A   
.138                        0 1648 A   .139                        0 1648 A   
.13A                        0 1625 A   .13B                        0 164F A   
.13C                        0 D8F6 A   .13D                        0 1683 A   
.13E                        0 167D A   .13F                        0 16A0 A   
.14                         0 06FA A   .140                        0 1692 A   
.141                        0 168A A   .142                        0 D8E6 A   
.143                        0 D8D6 A   .144                        0 1732 A   
.145                        0 16E2 A   .146                        0 16C8 A   
.147                        0 D8D0 A   .148                        0 D8CB A   
.149                        0 1763 A   .14A                        0 1756 A   
.14B                        0 174E A   .14C                        0 D8BB A   
.14D                        0 D8AF A   .14E                        0 179B A   
.14F                        0 1778 A   .15                         0 06ED A   
.150                        0 178E A   .151                        0 177F A   
.152                        0 D899 A   .153                        0 179B A   
.154                        0 D87A A   .155                        0 D877 A   
.156                        0 D857 A   .157                        0 D843 A   
.158                        0 D82E A   .159                        0 D82A A   
.15A                        0 1825 A   .15B                        0 1811 A   
.15C                        0 1837 A   .15D                        0 1844 A   
.15E                        0 1846 A   .15F                        0 D80F A   
.16                         0 0705 A   .160                        0 18CE A   
.161                        0 18C8 A   .162                        0 18BD A   
.163                        0 D7F6 A   .164                        0 19E8 A   
.165                        0 19DA A   .166                        0 19E1 A   
.167                        0 196A A   .168                        0 19E8 A   
.169                        0 1BB9 A   .16A                        0 1BA9 A   
.16B                        0 1BB0 A   .16C                        0 19F0 A   
.16D                        0 1BB9 A   .16E                        0 1C00 A   
.16F                        0 1BF2 A   .17                         0 0719 A   
.170                        0 1BF9 A   .171                        0 1BC0 A   
.172                        0 1C00 A   .173                        0 1D87 A   
.174                        0 1D84 A   .175                        0 1C55 A   
.176                        0 1C84 A   .177                        0 1C79 A   
.178                        0 1D18 A   .179                        0 1CA0 A   
.17A                        0 1C8B A   .17B                        0 1C98 A   
.17C                        0 1C94 A   .17D                        0 1C9A A   
.17E                        0 1D18 A   .17F                        0 1CC4 A   
.18                         0 070C A   .180                        0 1CA7 A   
.181                        0 1CBD A   .182                        0 1CB9 A   
.183                        0 1CB0 A   .184                        0 1CBF A   
.185                        0 1D18 A   .186                        0 1CE8 A   
.187                        0 1CCB A   .188                        0 1CE1 A   
.189                        0 1CDD A   .18A                        0 1CD4 A   
.18B                        0 1CE3 A   .18C                        0 1D18 A   
.18D                        0 1D0C A   .18E                        0 1CEF A   
.18F                        0 1D05 A   .19                         0 076E A   
.190                        0 1D01 A   .191                        0 1CF8 A   
.192                        0 1D07 A   .193                        0 1D18 A   
.194                        0 1D18 A   .195                        0 1D13 A   
.196                        0 1D25 A   .197                        0 1D1F A   
.198                        0 1D45 A   .199                        0 1D36 A   
.19A                        0 1D55 A   .19B                        0 1D4E A   
.19C                        0 1D84 A   .19D                        0 1D82 A   
.19E                        0 1D5C A   .19F                        0 D7E8 A   
.1A                         0 0758 A   .1A0                        0 2C80 A   
.1A1                        0 2C70 A   .1A2                        0 2C77 A   
.1A3                        0 1ED2 A   .1A4                        0 1F45 A   
.1A5                        0 1F41 A   .1A6                        0 1F47 A   
.1A7                        0 213B A   .1A8                        0 1FF6 A   
.1A9                        0 1FEC A   .1AA                        0 202B A   
.1AB                        0 2027 A   .1AC                        0 202D A   
.1AD                        0 213B A   .1AE                        0 2073 A   
.1AF                        0 2069 A   .1B                         0 079C A   
.1B0                        0 20D6 A   .1B1                        0 20B6 A   
.1B2                        0 20AE A   .1B3                        0 213B A   
.1B4                        0 210E A   .1B5                        0 20EE A   
.1B6                        0 20E6 A   .1B7                        0 20DE A   
.1B8                        0 213B A   .1B9                        0 213B A   
.1BA                        0 211E A   .1BB                        0 2116 A   
.1BC                        0 2709 A   .1BD                        0 2161 A   
.1BE                        0 21E3 A   .1BF                        0 21D5 A   
.1C                         0 0788 A   .1C0                        0 D7BF A   
.1C1                        0 21FC A   .1C2                        0 21F8 A   
.1C3                        0 21FE A   .1C4                        0 2219 A   
.1C5                        0 2215 A   .1C6                        0 221B A   
.1C7                        0 22B5 A   .1C8                        0 2281 A   
.1C9                        0 22DA A   .1CA                        0 D79A A   
.1CB                        0 245F A   .1CC                        0 244E A   
.1CD                        0 2457 A   .1CE                        0 2440 A   
.1CF                        0 245F A   .1D                         0 077D A   
.1D0                        0 24E2 A   .1D2                        0 24D2 A   
.1D3                        0 2490 A   .1D4                        0 D795 A   
.1D5                        0 24A0 A   .1D6                        0 D791 A   
.1D7                        0 24B0 A   .1D8                        0 D78B A   
.1D9                        0 24C0 A   .1DA                        0 D784 A   
.1DB                        0 2660 A   .1DD                        0 264A A   
.1DE                        0 24E9 A   .1DF                        0 24EC A   
.1E                         0 0770 A   .1E0                        0 2543 A   
.1E1                        0 253A A   .1E2                        0 2580 A   
.1E3                        0 2555 A   .1E4                        0 254C A   
.1E5                        0 2580 A   .1E6                        0 2567 A   
.1E7                        0 255E A   .1E8                        0 2580 A   
.1E9                        0 2579 A   .1EA                        0 2570 A   
.1EB                        0 2580 A   .1EC                        0 25A1 A   
.1ED                        0 261C A   .1EE                        0 25AA A   
.1EF                        0 25D5 A   .1F                         0 0788 A   
.1F0                        0 25CE A   .1F1                        0 261C A   
.1F2                        0 2646 A   .1F3                        0 263D A   
.1F4                        0 261E A   .1F5                        0 263D A   
.1F6                        0 263B A   .1F7                        0 2646 A   
.1F8                        0 2670 A   .1F9                        0 2669 A   
.1FA                        0 D774 A   .1FB                        0 2892 A   
.1FC                        0 2712 A   .1FD                        0 2794 A   
.1FE                        0 2786 A   .1FF                        0 D749 A   
.2                          0 05F1 A   .20                         0 079C A   
.200                        0 27C2 A   .201                        0 27BE A   
.202                        0 27C4 A   .203                        0 27DF A   
.204                        0 27DB A   .205                        0 27E1 A   
.206                        0 2AB2 A   .208                        0 2AA6 A   
.209                        0 289B A   .20A                        0 28FC A   
.20B                        0 295D A   .20C                        0 294C A   
.20D                        0 2955 A   .20E                        0 2933 A   
.20F                        0 294C A   .21                         0 078F A   
.210                        0 294A A   .211                        0 295D A   
.212                        0 29EA A   .213                        0 29D7 A   
.214                        0 29E0 A   .215                        0 2965 A   
.216                        0 29EA A   .217                        0 2A52 A   
.218                        0 2A41 A   .219                        0 2A4A A   
.21A                        0 2A04 A   .21B                        0 2A3F A   
.21C                        0 2A21 A   .21D                        0 2A41 A   
.21E                        0 2A52 A   .21F                        0 2AA2 A   
.22                         0 0809 A   .220                        0 2A5A A   
.221                        0 2AA2 A   .222                        0 2A91 A   
.223                        0 2A9A A   .224                        0 2A74 A   
.225                        0 2AA2 A   .226                        0 2C6A A   
.228                        0 2C5A A   .229                        0 2AB8 A   
.22A                        0 D73E A   .22B                        0 D737 A   
.22C                        0 D730 A   .22D                        0 2AC5 A   
.22E                        0 2AC0 A   .22F                        0 2AC8 A   
.23                         0 07F0 A   .230                        0 2B22 A   
.231                        0 2AFB A   .232                        0 2AE6 A   
.233                        0 D72D A   .234                        0 2B22 A   
.235                        0 2B4B A   .236                        0 2B30 A   
.237                        0 D70D A   .238                        0 2B77 A   
.239                        0 D6ED A   .23A                        0 2B7A A   
.23B                        0 D6E2 A   .23C                        0 D6DB A   
.23D                        0 D6D4 A   .23E                        0 2B87 A   
.23F                        0 2B82 A   .24                         0 0837 A   
.240                        0 2B8A A   .241                        0 2BE4 A   
.242                        0 2BBD A   .243                        0 2BA8 A   
.244                        0 D6D1 A   .245                        0 2BE4 A   
.246                        0 2C19 A   .247                        0 2C02 A   
.248                        0 D6B7 A   .249                        0 2C2E A   
.24A                        0 D6A5 A   .24B                        0 2C30 A   
.24C                        0 D68B A   .24D                        0 D684 A   
.24E                        0 D67D A   .24F                        0 2C3D A   
.25                         0 0823 A   .250                        0 2C38 A   
.251                        0 2C40 A   .252                        0 2C80 A   
.253                        0 D67B A   .254                        0 2E08 A   
.255                        0 2D84 A   .256                        0 2D8F A   
.257                        0 2D8B A   .258                        0 2D91 A   
.259                        0 2DF7 A   .25A                        0 2DCC A   
.25B                        0 2DC5 A   .25C                        0 2DE6 A   
.25D                        0 2DD3 A   .25E                        0 2DF7 A   
.25F                        0 2EB9 A   .26                         0 0818 A   
.260                        0 2EAD A   .261                        0 2EC1 A   
.262                        0 2F08 A   .263                        0 2F01 A   
.264                        0 3089 A   .265                        0 2F22 A   
.266                        0 3028 A   .267                        0 2F6C A   
.268                        0 2F45 A   .269                        0 2F3A A   
.26A                        0 2F2E A   .26B                        0 2F30 A   
.26D                        0 30E9 A   .26E                        0 30E5 A   
.26F                        0 30EB A   .27                         0 080B A   
.270                        0 3140 A   .271                        0 3137 A   
.272                        0 3150 A   .273                        0 3150 A   
.274                        0 3149 A   .275                        0 31F6 A   
.276                        0 31F3 A   .277                        0 3151 A   
.278                        0 31E1 A   .279                        0 31CD A   
.27A                        0 31DD A   .27B                        0 31D6 A   
.27C                        0 31F3 A   .27D                        0 31F1 A   
.27E                        0 31EA A   .27F                        0 31F6 A   
.28                         0 0823 A   .280                        0 32A2 A   
.281                        0 3296 A   .282                        0 32AA A   
.283                        0 32F1 A   .284                        0 32EA A   
.285                        0 3472 A   .286                        0 330B A   
.287                        0 3411 A   .288                        0 3355 A   
.289                        0 332E A   .28A                        0 3323 A   
.28B                        0 3317 A   .28C                        0 3319 A   
.28E                        0 34D2 A   .28F                        0 34CE A   
.29                         0 0837 A   .290                        0 34D4 A   
.291                        0 3529 A   .292                        0 3520 A   
.293                        0 3539 A   .294                        0 3539 A   
.295                        0 3532 A   .296                        0 35D0 A   
.297                        0 35CD A   .298                        0 353A A   
.299                        0 35BB A   .29A                        0 35A7 A   
.29B                        0 35B7 A   .29C                        0 35B0 A   
.29D                        0 35CD A   .29E                        0 35CB A   
.29F                        0 35C4 A   .2A                         0 082A A   
.2A0                        0 35D0 A   .2A1                        0 362C A   
.2A2                        0 3617 A   .2A3                        0 D64F A   
.2A4                        0 363C A   .2A5                        0 3635 A   
.2A6                        0 36A5 A   .2A7                        0 36A0 A   
.2A8                        0 36B1 A   .2A9                        0 36AC A   
.2AA                        0 36FD A   .2AB                        0 36F6 A   
.2AC                        0 3768 A   .2AD                        0 3764 A   
.2AE                        0 376A A   .2AF                        0 37BD A   
.2B                         0 08AA A   .2B0                        0 37B4 A   
.2B1                        0 37CD A   .2B2                        0 37CD A   
.2B3                        0 37C6 A   .2B4                        0 3824 A   
.2B5                        0 3801 A   .2B6                        0 3A9F A   
.2B7                        0 3A9C A   .2B8                        0 3A99 A   
.2B9                        0 382D A   .2BA                        0 3856 A   
.2BB                        0 3834 A   .2BC                        0 3867 A   
.2BD                        0 38A8 A   .2BE                        0 38A5 A   
.2BF                        0 389C A   .2C                         0 0897 A   
.2C0                        0 38B8 A   .2C1                        0 38B1 A   
.2C2                        0 3917 A   .2C3                        0 3901 A   
.2C4                        0 392B A   .2C5                        0 3958 A   
.2C6                        0 3938 A   .2C7                        0 3979 A   
.2C8                        0 3993 A   .2C9                        0 398E A   
.2CA                        0 39A1 A   .2CB                        0 399C A   
.2CC                        0 39AF A   .2CD                        0 39AA A   
.2CE                        0 39D6 A   .2CF                        0 39B8 A   
.2D                         0 0881 A   .2D0                        0 39D6 A   
.2D1                        0 39CF A   .2D2                        0 39C6 A   
.2D3                        0 39FD A   .2D4                        0 39DD A   
.2D5                        0 3A15 A   .2D6                        0 3A9C A   
.2D7                        0 3AAF A   .2D8                        0 3AA8 A   
.2D9                        0 3B21 A   .2DA                        0 3B1A A   
.2DB                        0 3B93 A   .2DC                        0 3B7E A   
.2DD                        0 D629 A   .2DE                        0 3C85 A   
.2DF                        0 3C75 A   .2E                         0 08AA A   
.2E0                        0 3BCA A   .2E1                        0 3BFF A   
.2E2                        0 3BF9 A   .2E3                        0 3C59 A   
.2E4                        0 3C18 A   .2E5                        0 3C26 A   
.2E6                        0 3C1F A   .2E7                        0 3C59 A   
.2E8                        0 3C3B A   .2E9                        0 3C34 A   
.2EA                        0 3C2D A   .2EB                        0 D601 A   
.2EC                        0 3C85 A   .2ED                        0 3D2C A   
.2EE                        0 3D11 A   .2EF                        0 3CF9 A   
.2F                         0 095A A   .2F0                        0 D5E5 A   
.2F1                        0 3DC9 A   .2F2                        0 3DB7 A   
.2F3                        0 3E0F A   .2F4                        0 3DEB A   
.2F5                        0 D5CF A   .2F6                        0 3E56 A   
.2F7                        0 3E50 A   .2F8                        0 3E7A A   
.2F9                        0 3E74 A   .2FA                        0 3E9E A   
.2FB                        0 3E98 A   .2FC                        0 3F1D A   
.2FD                        0 3F23 A   .2FE                        0 3F80 A   
.2FF                        0 3F6F A   .3                          0 05E6 A   
.30                         0 094C A   .300                        0 3F78 A   
.301                        0 3F5D A   .302                        0 3F6F A   
.303                        0 3F6D A   .304                        0 3F80 A   
.305                        0 3F8F A   .306                        0 3F88 A   
.307                        0 3FC1 A   .308                        0 3FAF A   
.309                        0 3FA3 A   .30A                        0 3FA5 A   
.30B                        0 D5B5 A   .30C                        0 4038 A   
.30D                        0 4031 A   .30E                        0 4047 A   
.30F                        0 4040 A   .31                         0 08D6 A   
.310                        0 4093 A   .311                        0 4081 A   
.312                        0 408A A   .313                        0 404F A   
.314                        0 4081 A   .315                        0 407A A   
.316                        0 4093 A   .317                        0 40E1 A   
.318                        0 40CF A   .319                        0 40D8 A   
.31A                        0 409B A   .31B                        0 40CF A   
.31C                        0 40C8 A   .31D                        0 40E1 A   
.31E                        0 4219 A   .31F                        0 4212 A   
.32                         0 0920 A   .320                        0 4228 A   
.321                        0 4221 A   .322                        0 4237 A   
.323                        0 4230 A   .324                        0 4246 A   
.325                        0 423F A   .326                        0 4255 A   
.327                        0 424E A   .328                        0 4264 A   
.329                        0 425D A   .32A                        0 4293 A   
.32B                        0 4280 A   .32C                        0 42BE A   
.32D                        0 42AD A   .32E                        0 429B A   
.32F                        0 42BE A   .33                         0 08FA A   
.330                        0 4311 A   .331                        0 430A A   
.332                        0 44D6 A   .333                        0 44CF A   
.334                        0 461E A   .336                        0 4606 A   
.337                        0 44E6 A   .338                        0 451C A   
.339                        0 4552 A   .33A                        0 4588 A   
.33B                        0 4681 A   .33C                        0 462F A   
.33D                        0 4663 A   .33E                        0 4640 A   
.33F                        0 4681 A   .34                         0 0940 A   
.340                        0 46A3 A   .341                        0 4692 A   
.342                        0 4917 A   .343                        0 46FC A   
.344                        0 46F3 A   .345                        0 4915 A   
.347                        0 48FD A   .348                        0 4702 A   
.349                        0 4747 A   .34A                        0 4729 A   
.34B                        0 4780 A   .34C                        0 47BE A   
.34D                        0 4810 A   .34E                        0 47F7 A   
.34F                        0 47D1 A   .35                         0 0940 A   
.350                        0 47F7 A   .351                        0 47EA A   
.352                        0 4810 A   .353                        0 4809 A   
.354                        0 4837 A   .355                        0 4817 A   
.356                        0 483C A   .357                        0 4847 A   
.358                        0 4899 A   .359                        0 4880 A   
.35A                        0 485A A   .35B                        0 4880 A   
.35C                        0 4873 A   .35D                        0 4899 A   
.35E                        0 4892 A   .35F                        0 48BC A   
.36                         0 092E A   .360                        0 48A0 A   
.361                        0 48C1 A   .362                        0 48CB A   
.363                        0 48F3 A   .364                        0 491F A   
.365                        0 4F41 A   .367                        0 4EDD A   
.368                        0 4942 A   .369                        0 49E7 A   
.36B                        0 49D1 A   .36C                        0 4948 A   
.36D                        0 4960 A   .36E                        0 4978 A   
.36F                        0 4999 A   .37                         0 095A A   
.370                        0 49AE A   .371                        0 D575 A   
.372                        0 49EA A   .373                        0 49FA A   
.374                        0 4A05 A   .375                        0 4A15 A   
.376                        0 4ADF A   .377                        0 4A1E A   
.378                        0 4AD0 A   .379                        0 4A34 A   
.37A                        0 4ADD A   .37B                        0 4B33 A   
.37C                        0 4B1F A   .37D                        0 4AE6 A   
.37E                        0 4B33 A   .37F                        0 4B36 A   
.38                         0 09A3 A   .380                        0 4B71 A   
.381                        0 4B6A A   .382                        0 4D43 A   
.383                        0 4D69 A   .384                        0 4D63 A   
.385                        0 4D74 A   .386                        0 4E49 A   
.387                        0 4E4C A   .388                        0 4E4F A   
.389                        0 D546 A   .38A                        0 4E6D A   
.38B                        0 4E89 A   .38C                        0 4E9A A   
.38D                        0 D52F A   .38E                        0 4EB8 A   
.38F                        0 D4F5 A   .39                         0 0994 A   
.390                        0 4F26 A   .391                        0 4F08 A   
.392                        0 55BE A   .394                        0 55B6 A   
.395                        0 4F64 A   .396                        0 558F A   
.398                        0 556A A   .399                        0 4F6A A   
.39A                        0 5067 A   .39C                        0 5059 A   
.39D                        0 4F70 A   .39E                        0 4FB1 A   
.39F                        0 4F86 A   .3A                         0 099B A   
.3A0                        0 4FB1 A   .3A1                        0 4FA0 A   
.3A2                        0 4F99 A   .3A3                        0 4FC6 A   
.3A4                        0 4FF0 A   .3A5                        0 4FDF A   
.3A6                        0 5034 A   .3A7                        0 5006 A   
.3A8                        0 5034 A   .3A9                        0 5020 A   
.3AA                        0 5019 A   .3AB                        0 5046 A   
.3AC                        0 506A A   .3AD                        0 506A A   
.3AE                        0 50D1 A   .3AF                        0 5073 A   
.3B                         0 0983 A   .3B0                        0 508B A   
.3B1                        0 507A A   .3B2                        0 5170 A   
.3B3                        0 50E9 A   .3B4                        0 5108 A   
.3B5                        0 50FC A   .3B6                        0 5123 A   
.3B7                        0 510F A   .3B8                        0 D4CA A   
.3B9                        0 5170 A   .3BA                        0 512A A   
.3BB                        0 5170 A   .3BC                        0 513D A   
.3BD                        0 5170 A   .3BE                        0 5150 A   
.3BF                        0 5182 A   .3C                         0 0994 A   
.3C0                        0 51E2 A   .3C2                        0 51BF A   
.3C3                        0 5187 A   .3C4                        0 518E A   
.3C5                        0 5195 A   .3C6                        0 519C A   
.3C7                        0 51A3 A   .3C8                        0 51AA A   
.3C9                        0 51B1 A   .3CA                        0 51B8 A   
.3CB                        0 51E0 A   .3CC                        0 51D2 A   
.3CD                        0 5240 A   .3CE                        0 51E9 A   
.3CF                        0 5231 A   .3D                         0 0992 A   
.3D0                        0 51FC A   .3D1                        0 523E A   
.3D2                        0 524D A   .3D3                        0 5250 A   
.3D4                        0 52EC A   .3D5                        0 525F A   
.3D6                        0 52DD A   .3D7                        0 5272 A   
.3D8                        0 5299 A   .3D9                        0 5285 A   
.3DA                        0 D49E A   .3DB                        0 52CE A   
.3DC                        0 52BA A   .3DD                        0 D472 A   
.3DE                        0 52EA A   .3DF                        0 52F9 A   
.3E                         0 09A3 A   .3E0                        0 5307 A   
.3E1                        0 534A A   .3E2                        0 531D A   
.3E3                        0 5357 A   .3E4                        0 535A A   
.3E5                        0 54CE A   .3E7                        0 54BA A   
.3E8                        0 5360 A   .3E9                        0 5410 A   
.3EA                        0 537B A   .3EB                        0 53A2 A   
.3EC                        0 538E A   .3ED                        0 D446 A   
.3EE                        0 5410 A   .3EF                        0 53A9 A   
.3F                         0 09E7 A   .3F0                        0 5410 A   
.3F1                        0 53BC A   .3F2                        0 5410 A   
.3F3                        0 53CF A   .3F4                        0 5410 A   
.3F5                        0 53E2 A   .3F6                        0 542D A   
.3F7                        0 542D A   .3F8                        0 5448 A   
.3F9                        0 543A A   .3FA                        0 5454 A   
.3FB                        0 5474 A   .3FC                        0 545B A   
.3FD                        0 546F A   .3FE                        0 5471 A   
.3FF                        0 548A A   .4                          0 05D1 A   
.40                         0 09CC A   .400                        0 547B A   
.401                        0 5497 A   .402                        0 54A4 A   
.403                        0 D42C A   .404                        0 54D1 A   
.405                        0 5531 A   .406                        0 551B A   
.407                        0 5514 A   .408                        0 552F A   
.409                        0 5524 A   .40A                        0 5539 A   
.40B                        0 555B A   .40C                        0 558D A   
.40D                        0 557D A   .40E                        0 5591 A   
.40F                        0 D3F2 A   .41                         0 D9FF A   
.410                        0 5BBB A   .412                        0 5BAD A   
.413                        0 56DE A   .414                        0 5724 A   
.415                        0 5B86 A   .417                        0 5B7A A   
.418                        0 572A A   .419                        0 5B16 A   
.41A                        0 5745 A   .41B                        0 57C6 A   
.41C                        0 57BA A   .41D                        0 5890 A   
.41E                        0 580D A   .41F                        0 5AF5 A   
.42                         0 0D67 A   .421                        0 5AD2 A   
.422                        0 5925 A   .423                        0 5957 A   
.424                        0 598A A   .425                        0 59BD A   
.426                        0 5A00 A   .427                        0 5A42 A   
.428                        0 5A89 A   .429                        0 5A7C A   
.42A                        0 5A71 A   .42B                        0 5A93 A   
.42C                        0 5A95 A   .42D                        0 5AC8 A   
.42E                        0 5AF3 A   .42F                        0 5AE5 A   
.43                         0 0D51 A   .430                        0 5B1B A   
.431                        0 5B1D A   .432                        0 5B4D A   
.433                        0 5B47 A   .434                        0 5B73 A   
.435                        0 5B88 A   .436                        0 D3B8 A   
.437                        0 5CA6 A   .438                        0 5C03 A   
.439                        0 5C31 A   .43A                        0 5C22 A   
.43B                        0 5C14 A   .43C                        0 5C31 A   
.43D                        0 5CA5 A   .43E                        0 5C3E A   
.43F                        0 5C88 A   .44                         0 09EA A   
.440                        0 5C79 A   .441                        0 5C6B A   
.442                        0 5C88 A   .443                        0 5FFD A   
.445                        0 5FB3 A   .446                        0 5CB0 A   
.447                        0 5CD4 A   .448                        0 5CC6 A   
.449                        0 D394 A   .44A                        0 5CE9 A   
.44B                        0 5CE2 A   .44C                        0 5CDB A   
.44D                        0 5CF5 A   .44E                        0 5CF5 A   
.44F                        0 5CF0 A   .45                         0 09FF A   
.450                        0 5D07 A   .451                        0 5D28 A   
.452                        0 5D1C A   .453                        0 5D3D A   
.454                        0 5D36 A   .455                        0 5D2F A   
.456                        0 5D49 A   .457                        0 5D49 A   
.458                        0 5D44 A   .459                        0 5D63 A   
.45A                        0 5D82 A   .45B                        0 5DA6 A   
.45C                        0 5D9A A   .45D                        0 5DB0 A   
.45E                        0 5DB3 A   .45F                        0 5DC0 A   
.46                         0 09F1 A   .460                        0 5E07 A   
.461                        0 5DED A   .462                        0 5DE0 A   
.463                        0 5E07 A   .464                        0 5DFC A   
.465                        0 5E7B A   .466                        0 5E0E A   
.467                        0 5E7B A   .468                        0 5E1B A   
.469                        0 5E7B A   .46A                        0 5E70 A   
.46B                        0 5E1B A   .46C                        0 5E4A A   
.46D                        0 5E30 A   .46E                        0 5E23 A   
.46F                        0 5E4A A   .47                         0 0D4A A   
.470                        0 5E3F A   .471                        0 5E70 A   
.472                        0 5E51 A   .473                        0 5E7B A   
.474                        0 5E84 A   .475                        0 5EA8 A   
.476                        0 5E9A A   .477                        0 D370 A   
.478                        0 5EBB A   .479                        0 5EB6 A   
.47A                        0 5EAF A   .47B                        0 5ECD A   
.47C                        0 5EEE A   .47D                        0 5EE2 A   
.47E                        0 5F01 A   .47F                        0 5EFC A   
.48                         0 0D3B A   .480                        0 5EF5 A   
.481                        0 5F1B A   .482                        0 5F7A A   
.483                        0 5F87 A   .484                        0 5F89 A   
.485                        0 5F9B A   .486                        0 5F90 A   
.487                        0 5F9B A   .488                        0 D348 A   
.489                        0 5FEC A   .48A                        0 5FC6 A   
.48B                        0 60D8 A   .48C                        0 6055 A   
.48D                        0 60CF A   .48E                        0 60A8 A   
.48F                        0 60BE A   .49                         0 0A08 A   
.490                        0 60B8 A   .491                        0 60DE A   
.492                        0 60E2 A   .493                        0 6128 A   
.494                        0 6116 A   .495                        0 D33D A   
.496                        0 6147 A   .497                        0 6138 A   
.498                        0 6138 A   .499                        0 6147 A   
.49A                        0 617A A   .49B                        0 6168 A   
.49C                        0 D332 A   .49D                        0 61D5 A   
.49E                        0 61C3 A   .49F                        0 D328 A   
.4A                         0 0A37 A   .4A0                        0 61F4 A   
.4A1                        0 61E5 A   .4A2                        0 61E5 A   
.4A3                        0 61F4 A   .4A4                        0 6221 A   
.4A5                        0 620F A   .4A6                        0 D31E A   
.4A7                        0 6279 A   .4A8                        0 6267 A   
.4A9                        0 D314 A   .4AA                        0 62B4 A   
.4AB                        0 62A5 A   .4AC                        0 62A5 A   
.4AD                        0 62B4 A   .4AE                        0 6301 A   
.4AF                        0 62F0 A   .4B                         0 0A16 A   
.4B0                        0 D309 A   .4B1                        0 6351 A   
.4B2                        0 633F A   .4B3                        0 D2EF A   
.4B4                        0 696C A   .4B6                        0 6915 A   
.4B7                        0 638F A   .4B8                        0 63CA A   
.4B9                        0 63E9 A   .4BA                        0 6408 A   
.4BB                        0 6427 A   .4BC                        0 6446 A   
.4BD                        0 6465 A   .4BE                        0 64CD A   
.4BF                        0 646E A   .4C                         0 0A0F A   
.4C0                        0 64B1 A   .4C1                        0 6493 A   
.4C2                        0 64CD A   .4C3                        0 64D0 A   
.4C4                        0 6538 A   .4C5                        0 64D9 A   
.4C6                        0 651C A   .4C7                        0 64FE A   
.4C8                        0 6538 A   .4C9                        0 653B A   
.4CA                        0 657E A   .4CB                        0 6560 A   
.4CC                        0 659A A   .4CD                        0 659D A   
.4CE                        0 65E0 A   .4CF                        0 65C2 A   
.4D                         0 0D39 A   .4D0                        0 65FC A   
.4D1                        0 65FF A   .4D2                        0 6640 A   
.4D3                        0 6608 A   .4D4                        0 6643 A   
.4D5                        0 6668 A   .4D6                        0 664C A   
.4D7                        0 666B A   .4D8                        0 66A6 A   
.4D9                        0 66C5 A   .4DA                        0 66D1 A   
.4DB                        0 66CE A   .4DC                        0 66F0 A   
.4DD                        0 66D8 A   .4DE                        0 D2B8 A   
.4DF                        0 6736 A   .4E                         0 0AD2 A   
.4E0                        0 66F9 A   .4E1                        0 68E3 A   
.4E2                        0 677C A   .4E3                        0 673F A   
.4E4                        0 68E3 A   .4E5                        0 67B7 A   
.4E6                        0 6793 A   .4E7                        0 6785 A   
.4E8                        0 678C A   .4E9                        0 68E3 A   
.4EA                        0 6854 A   .4EB                        0 67C2 A   
.4EC                        0 6817 A   .4ED                        0 67E1 A   
.4EE                        0 6851 A   .4EF                        0 68E3 A   
.4F                         0 0A5C A   .4F0                        0 68AF A   
.4F1                        0 6873 A   .4F2                        0 68E3 A   
.4F3                        0 68FF A   .4F4                        0 68F1 A   
.4F5                        0 68EA A   .4F6                        0 D281 A   
.4F7                        0 697D A   .4F8                        0 6975 A   
.4F9                        0 6A03 A   .4FA                        0 69FD A   
.4FB                        0 6A11 A   .4FC                        0 6A0B A   
.4FD                        0 6A88 A   .4FE                        0 6A84 A   
.4FF                        0 6AC1 A   .5                          0 05E6 A   
.50                         0 0A55 A   .500                        0 6ABD A   
.501                        0 6B4E A   .502                        0 6AFD A   
.503                        0 6B4C A   .504                        0 6B46 A   
.505                        0 6B55 A   .506                        0 6BC7 A   
.507                        0 6BA5 A   .508                        0 6B9E A   
.509                        0 D24A A   .50A                        0 6C0B A   
.50B                        0 6BE9 A   .50C                        0 D20C A   
.50D                        0 7B04 A   .50F                        0 7A86 A   
.51                         0 0A69 A   .510                        0 6C15 A   
.511                        0 6C29 A   .512                        0 6C71 A   
.513                        0 6C69 A   .514                        0 6C77 A   
.515                        0 6C7A A   .516                        0 6C7A A   
.517                        0 6C7A A   .518                        0 6CF0 A   
.519                        0 6CD4 A   .51A                        0 6CCD A   
.51B                        0 6CC6 A   .51C                        0 D1D4 A   
.51D                        0 6D84 A   .51E                        0 6D5F A   
.51F                        0 6D57 A   .52                         0 0A63 A   
.520                        0 6D4F A   .521                        0 D18C A   
.522                        0 6D96 A   .523                        0 6D90 A   
.524                        0 6E52 A   .525                        0 6DE0 A   
.526                        0 6DD8 A   .527                        0 6E91 A   
.528                        0 6E5E A   .529                        0 6EC2 A   
.52A                        0 6F11 A   .52B                        0 6EE4 A   
.52C                        0 D15F A   .52D                        0 6F1A A   
.52E                        0 D145 A   .52F                        0 6F35 A   
.53                         0 0A78 A   .530                        0 7013 A   
.531                        0 704B A   .532                        0 7043 A   
.533                        0 705C A   .534                        0 705F A   
.535                        0 7110 A   .536                        0 7130 A   
.537                        0 7130 A   .538                        0 7130 A   
.539                        0 7130 A   .53A                        0 71C0 A   
.53B                        0 71A4 A   .53C                        0 D114 A   
.53D                        0 723C A   .53E                        0 7220 A   
.53F                        0 71FC A   .54                         0 0A70 A   
.540                        0 D0E3 A   .541                        0 725A A   
.542                        0 7254 A   .543                        0 7248 A   
.544                        0 7299 A   .545                        0 7266 A   
.546                        0 72CA A   .547                        0 7320 A   
.548                        0 72F3 A   .549                        0 D0B6 A   
.54A                        0 7329 A   .54B                        0 7329 A   
.54C                        0 7332 A   .54D                        0 7346 A   
.54E                        0 7364 A   .54F                        0 735E A   
.55                         0 0A7E A   .550                        0 7551 A   
.551                        0 736E A   .552                        0 74BA A   
.553                        0 7492 A   .554                        0 7442 A   
.555                        0 7483 A   .556                        0 7485 A   
.558                        0 74E4 A   .559                        0 77CE A   
.55A                        0 755B A   .55B                        0 7636 A   
.55C                        0 7632 A   .55D                        0 7638 A   
.55E                        0 7654 A   .55F                        0 7650 A   
.56                         0 0ACF A   .560                        0 7656 A   
.561                        0 766D A   .562                        0 7669 A   
.563                        0 766F A   .564                        0 7688 A   
.565                        0 7684 A   .566                        0 768A A   
.567                        0 7769 A   .568                        0 7756 A   
.569                        0 777A A   .56A                        0 77B1 A   
.56B                        0 77A3 A   .56C                        0 77AA A   
.56D                        0 7786 A   .56E                        0 77B1 A   
.56F                        0 7A13 A   .57                         0 0AC1 A   
.570                        0 77D8 A   .571                        0 78D1 A   
.572                        0 7880 A   .573                        0 78D1 A   
.574                        0 7965 A   .575                        0 7927 A   
.576                        0 7965 A   .577                        0 79F3 A   
.578                        0 79E5 A   .579                        0 79EC A   
.57A                        0 79C7 A   .57B                        0 79F3 A   
.57C                        0 7A1C A   .57D                        0 7A43 A   
.57F                        0 7A31 A   .58                         0 0AC8 A   
.580                        0 7A21 A   .581                        0 7A21 A   
.582                        0 7A21 A   .583                        0 7A21 A   
.584                        0 7A29 A   .585                        0 7A46 A   
.586                        0 7A46 A   .587                        0 7A46 A   
.588                        0 7A46 A   .589                        0 7A46 A   
.58A                        0 D077 A   .58B                        0 7A65 A   
.58C                        0 7A65 A   .58D                        0 7A65 A   
.58E                        0 7A65 A   .58F                        0 7A65 A   
.59                         0 0A87 A   .590                        0 D03D A   
.591                        0 7ACE A   .592                        0 7A9C A   
.593                        0 7B01 A   .594                        0 7AE1 A   
.595                        0 7BB5 A   .596                        0 7B93 A   
.597                        0 7B8C A   .598                        0 D009 A   
.599                        0 7BF9 A   .59A                        0 7BD7 A   
.59B                        0 CFCE A   .59C                        0 8633 A   
.59E                        0 85B5 A   .59F                        0 7C03 A   
.5A                         0 0AAE A   .5A0                        0 7C03 A   
.5A1                        0 7C03 A   .5A2                        0 7C03 A   
.5A3                        0 7C03 A   .5A4                        0 7C03 A   
.5A5                        0 7C03 A   .5A6                        0 7C03 A   
.5A7                        0 7C0C A   .5A8                        0 7C0C A   
.5A9                        0 7C0C A   .5AA                        0 7C20 A   
.5AB                        0 7C68 A   .5AC                        0 7C60 A   
.5AD                        0 7C6E A   .5AE                        0 7C71 A   
.5AF                        0 7C85 A   .5B                         0 0AA6 A   
.5B0                        0 7CA5 A   .5B1                        0 7CA5 A   
.5B2                        0 7CA5 A   .5B3                        0 7D28 A   
.5B4                        0 7D0C A   .5B5                        0 CF9C A   
.5B6                        0 7D5E A   .5B7                        0 7D58 A   
.5B8                        0 7D4C A   .5B9                        0 7E81 A   
.5BA                        0 7E54 A   .5BB                        0 CF71 A   
.5BC                        0 7E8A A   .5BD                        0 7E97 A   
.5BE                        0 7E91 A   .5BF                        0 7F9F A   
.5C                         0 0AB7 A   .5C1                        0 7F8F A   
.5C2                        0 7EBA A   .5C3                        0 7EDC A   
.5C4                        0 7EC1 A   .5C5                        0 7F0D A   
.5C6                        0 7F2F A   .5C7                        0 7F14 A   
.5C8                        0 7F5E A   .5C9                        0 7F5A A   
.5CA                        0 7F60 A   .5CB                        0 7F70 A   
.5CC                        0 7F7B A   .5CD                        0 7F77 A   
.5CE                        0 7F7D A   .5CF                        0 7FA8 A   
.5D                         0 0ACF A   .5D0                        0 7FDD A   
.5D1                        0 7FCC A   .5D2                        0 8008 A   
.5D3                        0 7FF7 A   .5D4                        0 8011 A   
.5D5                        0 802F A   .5D6                        0 8029 A   
.5D7                        0 8105 A   .5D8                        0 8039 A   
.5D9                        0 8308 A   .5DA                        0 810F A   
.5DB                        0 81E3 A   .5DC                        0 81DF A   
.5DD                        0 81E5 A   .5DE                        0 82EB A   
.5DF                        0 82DD A   .5E                         0 0D34 A   
.5E0                        0 82E4 A   .5E1                        0 82C0 A   
.5E2                        0 82EB A   .5E3                        0 854D A   
.5E4                        0 8312 A   .5E5                        0 840B A   
.5E6                        0 83BA A   .5E7                        0 840B A   
.5E8                        0 849F A   .5E9                        0 8461 A   
.5EA                        0 849F A   .5EB                        0 852D A   
.5EC                        0 851F A   .5ED                        0 8526 A   
.5EE                        0 8501 A   .5EF                        0 852D A   
.5F                         0 0AEE A   .5F0                        0 8556 A   
.5F1                        0 856A A   .5F2                        0 8591 A   
.5F4                        0 857F A   .5F5                        0 856F A   
.5F6                        0 856F A   .5F7                        0 856F A   
.5F8                        0 856F A   .5F9                        0 8577 A   
.5FA                        0 8594 A   .5FB                        0 8594 A   
.5FC                        0 8594 A   .5FD                        0 8594 A   
.5FE                        0 8594 A   .5FF                        0 8594 A   
.6                          0 05E0 A   .60                         0 0AD9 A   
.600                        0 8594 A   .601                        0 8594 A   
.602                        0 CF4F A   .603                        0 85FD A   
.604                        0 85CB A   .605                        0 8630 A   
.606                        0 8610 A   .607                        0 8886 A   
.609                        0 8868 A   .60A                        0 86AA A   
.60B                        0 86AA A   .60C                        0 86AA A   
.60D                        0 CF1E A   .60E                        0 86C4 A   
.60F                        0 8842 A   .61                         0 0D34 A   
.610                        0 8832 A   .611                        0 8849 A   
.612                        0 CEF9 A   .613                        0 897C A   
.614                        0 895A A   .615                        0 8941 A   
.616                        0 CEBA A   .617                        0 8EDF A   
.619                        0 8E64 A   .61A                        0 8986 A   
.61B                        0 8986 A   .61C                        0 8986 A   
.61D                        0 8986 A   .61E                        0 8986 A   
.61F                        0 8986 A   .62                         0 0C84 A   
.620                        0 8986 A   .621                        0 8986 A   
.622                        0 898F A   .623                        0 898F A   
.624                        0 89A3 A   .625                        0 89EB A   
.626                        0 89E3 A   .627                        0 89F1 A   
.628                        0 89F4 A   .629                        0 89F4 A   
.62A                        0 8A89 A   .62B                        0 8A83 A   
.62C                        0 8AA7 A   .62D                        0 8AA1 A   
.62E                        0 8A99 A   .62F                        0 8A91 A   
.63                         0 0AF7 A   .630                        0 8AB9 A   
.631                        0 8AB3 A   .632                        0 8D32 A   
.633                        0 8CFB A   .634                        0 CE90 A   
.635                        0 8D3B A   .636                        0 8E1A A   
.638                        0 8E0E A   .639                        0 8DE8 A   
.63A                        0 8DF4 A   .63B                        0 8E00 A   
.63C                        0 8E30 A   .63D                        0 8E44 A   
.63E                        0 8E44 A   .63F                        0 8E44 A   
.64                         0 0B9F A   .640                        0 8E44 A   
.641                        0 8E44 A   .642                        0 8E44 A   
.643                        0 8E44 A   .644                        0 8E44 A   
.645                        0 8E44 A   .646                        0 8E44 A   
.647                        0 8E44 A   .648                        0 8E44 A   
.649                        0 8E44 A   .64A                        0 8E44 A   
.64B                        0 8E44 A   .64C                        0 CE58 A   
.64D                        0 8EA9 A   .64E                        0 8E77 A   
.64F                        0 8EDC A   .65                         0 0B2C A   
.650                        0 8EBC A   .651                        0 8F7D A   
.652                        0 8F74 A   .653                        0 8F68 A   
.654                        0 8F7D A   .655                        0 8FD0 A   
.656                        0 8FC9 A   .657                        0 8FD5 A   
.658                        0 901D A   .659                        0 9014 A   
.65A                        0 9008 A   .65B                        0 901D A   
.65C                        0 905C A   .65D                        0 9024 A   
.65E                        0 903F A   .65F                        0 9036 A   
.66                         0 0B73 A   .660                        0 9025 A   
.661                        0 903F A   .662                        0 9088 A   
.663                        0 907E A   .664                        0 909D A   
.665                        0 9097 A   .666                        0 90B1 A   
.667                        0 90AA A   .668                        0 90DC A   
.669                        0 90D6 A   .66A                        0 90FB A   
.66B                        0 90F5 A   .66C                        0 911C A   
.66D                        0 910E A   .66E                        0 9124 A   
.66F                        0 913E A   .67                         0 0B36 A   
.670                        0 912B A   .671                        0 91FF A   
.672                        0 9158 A   .673                        0 9145 A   
.674                        0 91FF A   .675                        0 9172 A   
.676                        0 915F A   .677                        0 91FF A   
.678                        0 918C A   .679                        0 9179 A   
.67A                        0 91FF A   .67B                        0 91A5 A   
.67C                        0 9193 A   .67D                        0 91FF A   
.67E                        0 91BE A   .67F                        0 91AC A   
.68                         0 0B9C A   .680                        0 91FF A   
.681                        0 91D7 A   .682                        0 91C5 A   
.683                        0 91FF A   .684                        0 91F0 A   
.685                        0 91DE A   .686                        0 91FF A   
.687                        0 920E A   .688                        0 9206 A   
.689                        0 9214 A   .68A                        0 9286 A   
.68B                        0 927F A   .68C                        0 926C A   
.68D                        0 9286 A   .68E                        0 92BC A   
.68F                        0 92AC A   .69                         0 0C81 A   
.690                        0 92CA A   .691                        0 931B A   
.692                        0 930D A   .693                        0 9323 A   
.694                        0 9332 A   .695                        0 932A A   
.696                        0 9339 A   .697                        0 A455 A   
.699                        0 A416 A   .69A                        0 9353 A   
.69B                        0 9380 A   .69C                        0 9360 A   
.69D                        0 93A1 A   .69E                        0 9393 A   
.69F                        0 93A9 A   .6A                         0 0BD2 A   
.6A0                        0 93D0 A   .6A1                        0 93B0 A   
.6A2                        0 93FD A   .6A3                        0 943B A   
.6A4                        0 9433 A   .6A5                        0 943F A   
.6A6                        0 943F A   .6A7                        0 943F A   
.6A8                        0 94C0 A   .6A9                        0 9488 A   
.6AA                        0 9481 A   .6AB                        0 947A A   
.6AC                        0 9473 A   .6AD                        0 946C A   
.6AE                        0 CE1D A   .6AF                        0 94F9 A   
.6B                         0 0BA6 A   .6B0                        0 94CF A   
.6B1                        0 9541 A   .6B2                        0 9508 A   
.6B3                        0 9541 A   .6B4                        0 9517 A   
.6B5                        0 98FE A   .6B6                        0 954A A   
.6B7                        0 957A A   .6B8                        0 9573 A   
.6B9                        0 95C3 A   .6BA                        0 9599 A   
.6BB                        0 976A A   .6BC                        0 9763 A   
.6BD                        0 970B A   .6BE                        0 9750 A   
.6BF                        0 9723 A   .6C                         0 0C81 A   
.6C0                        0 976A A   .6C1                        0 97C0 A   
.6C2                        0 97B2 A   .6C3                        0 CDFD A   
.6C4                        0 98D3 A   .6C5                        0 98A9 A   
.6C6                        0 9CD5 A   .6C7                        0 9CAD A   
.6C8                        0 9907 A   .6C9                        0 9937 A   
.6CA                        0 9930 A   .6CB                        0 9980 A   
.6CC                        0 9956 A   .6CD                        0 9B19 A   
.6CE                        0 9B12 A   .6CF                        0 9ABA A   
.6D                         0 0C81 A   .6D0                        0 9AFF A   
.6D1                        0 9AD2 A   .6D2                        0 9B19 A   
.6D3                        0 9B6F A   .6D4                        0 9B61 A   
.6D5                        0 CDDD A   .6D6                        0 9C83 A   
.6D7                        0 9C58 A   .6D8                        0 9C75 A   
.6D9                        0 9C61 A   .6DA                        0 9C83 A   
.6DB                        0 CDB8 A   .6DC                        0 9CD5 A   
.6DD                        0 9CD8 A   .6DE                        0 9D37 A   
.6DF                        0 9D1B A   .6E                         0 0BE2 A   
.6E0                        0 9D14 A   .6E1                        0 9D0D A   
.6E2                        0 9D06 A   .6E3                        0 9CFF A   
.6E4                        0 9D66 A   .6E5                        0 9D46 A   
.6E6                        0 9DAE A   .6E7                        0 9D75 A   
.6E8                        0 9DAE A   .6E9                        0 9D84 A   
.6EA                        0 9DDE A   .6EB                        0 9DD7 A   
.6EC                        0 9E26 A   .6ED                        0 9DFC A   
.6EE                        0 9F7E A   .6EF                        0 9F77 A   
.6F                         0 0BD9 A   .6F0                        0 9F29 A   
.6F1                        0 9F64 A   .6F2                        0 9F41 A   
.6F3                        0 9F7E A   .6F4                        0 9FD4 A   
.6F5                        0 9FC6 A   .6F6                        0 CD98 A   
.6F7                        0 A0E8 A   .6F8                        0 A0BD A   
.6F9                        0 A0DA A   .6FA                        0 A0C6 A   
.6FB                        0 A0E8 A   .6FC                        0 CD72 A   
.6FD                        0 A115 A   .6FE                        0 A157 A   
.6FF                        0 A122 A   .7                          0 05F1 A   
.70                         0 0BEF A   .700                        0 A178 A   
.701                        0 A171 A   .702                        0 A188 A   
.703                        0 A181 A   .704                        0 A19D A   
.705                        0 A18F A   .706                        0 A1A5 A   
.707                        0 A2C2 A   .709                        0 A29B A   
.70A                        0 A1DF A   .70B                        0 A1F1 A   
.70C                        0 A205 A   .70D                        0 A219 A   
.70E                        0 A22D A   .70F                        0 A241 A   
.71                         0 0BE9 A   .710                        0 A254 A   
.711                        0 A266 A   .712                        0 A278 A   
.713                        0 A28B A   .714                        0 CD52 A   
.715                        0 A2C0 A   .716                        0 A2AE A   
.717                        0 A2DB A   .718                        0 A2FE A   
.719                        0 A2E8 A   .71A                        0 A31F A   
.71B                        0 A311 A   .71C                        0 A327 A   
.71D                        0 A342 A   .71E                        0 A336 A   
.71F                        0 A34D A   .72                         0 0BFE A   
.720                        0 A351 A   .721                        0 A37E A   
.722                        0 A35E A   .723                        0 A39E A   
.724                        0 A3BE A   .725                        0 A3DE A   
.726                        0 CD2D A   .727                        0 A43B A   
.728                        0 A429 A   .729                        0 A488 A   
.72A                        0 A47B A   .72B                        0 CD06 A   
.72C                        0 A5CF A   .72D                        0 A4DC A   
.72E                        0 A4D3 A   .72F                        0 A4C9 A   
.73                         0 0BF6 A   .730                        0 A563 A   
.731                        0 A4FD A   .732                        0 A563 A   
.733                        0 A54C A   .734                        0 A545 A   
.735                        0 A563 A   .736                        0 A55C A   
.737                        0 A5A1 A   .738                        0 A56A A   
.739                        0 A5C5 A   .73A                        0 A5BD A   
.73B                        0 A5D7 A   .73C                        0 A67B A   
.73D                        0 A64F A   .73E                        0 A690 A   
.73F                        0 A690 A   .74                         0 0C04 A   
.740                        0 A682 A   .741                        0 CCF1 A   
.742                        0 A6BD A   .743                        0 A6A8 A   
.744                        0 CCD5 A   .745                        0 A801 A   
.747                        0 A7E5 A   .748                        0 A6CC A   
.749                        0 A6CC A   .74A                        0 A6D8 A   
.74B                        0 A6D4 A   .74C                        0 A6DA A   
.74D                        0 A72A A   .74E                        0 A719 A   
.74F                        0 A763 A   .75                         0 0C81 A   
.750                        0 A741 A   .751                        0 A732 A   
.752                        0 A763 A   .753                        0 A753 A   
.754                        0 A77C A   .755                        0 A7A2 A   
.756                        0 A789 A   .757                        0 A7C3 A   
.758                        0 A7DF A   .759                        0 CCC1 A   
.75A                        0 ABDF A   .75C                        0 ABB4 A   
.75D                        0 A843 A   .75E                        0 A867 A   
.75F                        0 A88A A   .76                         0 0C73 A   
.760                        0 A89C A   .761                        0 A891 A   
.762                        0 A8E3 A   .763                        0 A8ED A   
.764                        0 A8EA A   .765                        0 A95D A   
.766                        0 A974 A   .767                        0 A969 A   
.768                        0 A9B5 A   .769                        0 A9CA A   
.76A                        0 A9BC A   .76B                        0 AA3E A   
.76C                        0 AA63 A   .76D                        0 AA58 A   
.76E                        0 AA6D A   .76F                        0 AA6A A   
.77                         0 0C7A A   .770                        0 AAD4 A   
.771                        0 AB08 A   .772                        0 AB20 A   
.773                        0 AB0F A   .774                        0 CCA6 A   
.775                        0 AB9A A   .776                        0 AB3F A   
.777                        0 AB29 A   .778                        0 CC80 A   
.779                        0 AB9A A   .77A                        0 AB59 A   
.77B                        0 AB46 A   .77C                        0 CC68 A   
.77D                        0 AB9A A   .77E                        0 AB9A A   
.77F                        0 AB60 A   .78                         0 0C0D A   
.780                        0 AB80 A   .781                        0 AB67 A   
.782                        0 CC3C A   .783                        0 AB9A A   
.784                        0 CC00 A   .785                        0 ABAA A   
.786                        0 ABD7 A   .787                        0 ABC7 A   
.788                        0 AD04 A   .789                        0 AC15 A   
.78A                        0 AC22 A   .78B                        0 AC1E A   
.78C                        0 AD04 A   .78D                        0 AC2D A   
.78E                        0 AD04 A   .78F                        0 AC41 A   
.79                         0 0C60 A   .790                        0 ACD1 A   
.791                        0 AC67 A   .792                        0 AD01 A   
.793                        0 CC00 A   .794                        0 CC3C A   
.795                        0 CC68 A   .796                        0 CC80 A   
.797                        0 CCA6 A   .798                        0 CCC1 A   
.799                        0 CCD5 A   .79A                        0 CCF1 A   
.79B                        0 CD06 A   .79C                        0 CD2D A   
.79D                        0 CD52 A   .79E                        0 CD72 A   
.79F                        0 CD98 A   .7A                         0 0C58 A   
.7A0                        0 CDB8 A   .7A1                        0 CDDD A   
.7A2                        0 CDFD A   .7A3                        0 CE1D A   
.7A4                        0 CE58 A   .7A5                        0 CE90 A   
.7A6                        0 CEBA A   .7A7                        0 CEF9 A   
.7A8                        0 CF1E A   .7A9                        0 CF4F A   
.7AA                        0 CF71 A   .7AB                        0 CF9C A   
.7AC                        0 CFCE A   .7AD                        0 D009 A   
.7AE                        0 D03D A   .7AF                        0 D077 A   
.7B                         0 0C69 A   .7B0                        0 D0B6 A   
.7B1                        0 D0E3 A   .7B2                        0 D114 A   
.7B3                        0 D145 A   .7B4                        0 D15F A   
.7B5                        0 D18C A   .7B6                        0 D1D4 A   
.7B7                        0 D20C A   .7B8                        0 D24A A   
.7B9                        0 D281 A   .7BA                        0 D2B8 A   
.7BB                        0 D2EF A   .7BC                        0 D309 A   
.7BD                        0 D314 A   .7BE                        0 D31E A   
.7BF                        0 D328 A   .7C                         0 0C81 A   
.7C0                        0 D332 A   .7C1                        0 D33D A   
.7C2                        0 D348 A   .7C3                        0 D370 A   
.7C4                        0 D394 A   .7C5                        0 D3B8 A   
.7C6                        0 D3F2 A   .7C7                        0 D42C A   
.7C8                        0 D446 A   .7C9                        0 D472 A   
.7CA                        0 D49E A   .7CB                        0 D4CA A   
.7CC                        0 D4F5 A   .7CD                        0 D52F A   
.7CE                        0 D546 A   .7CF                        0 D575 A   
.7D                         0 0D34 A   .7D0                        0 D5B5 A   
.7D1                        0 D5CF A   .7D2                        0 D5E5 A   
.7D3                        0 D601 A   .7D4                        0 D629 A   
.7D5                        0 D64F A   .7D6                        0 D67B A   
.7D7                        0 D67D A   .7D8                        0 D684 A   
.7D9                        0 D68B A   .7DA                        0 D6A5 A   
.7DB                        0 D6B7 A   .7DC                        0 D6D1 A   
.7DD                        0 D6D4 A   .7DE                        0 D6DB A   
.7DF                        0 D6E2 A   .7E                         0 0CC3 A   
.7E0                        0 D6ED A   .7E1                        0 D70D A   
.7E2                        0 D72D A   .7E3                        0 D730 A   
.7E4                        0 D737 A   .7E5                        0 D73E A   
.7E6                        0 D749 A   .7E7                        0 D774 A   
.7E8                        0 D784 A   .7E9                        0 D78B A   
.7EA                        0 D791 A   .7EB                        0 D795 A   
.7EC                        0 D79A A   .7ED                        0 D7BF A   
.7EE                        0 D7E8 A   .7EF                        0 D7F6 A   
.7F                         0 0C8B A   .7F0                        0 D80F A   
.7F1                        0 D82A A   .7F2                        0 D82E A   
.7F3                        0 D843 A   .7F4                        0 D857 A   
.7F5                        0 D877 A   .7F6                        0 D87A A   
.7F7                        0 D899 A   .7F8                        0 D8AF A   
.7F9                        0 D8BB A   .7FA                        0 D8CB A   
.7FB                        0 D8D0 A   .7FC                        0 D8D6 A   
.7FD                        0 D8E6 A   .7FE                        0 D8F6 A   
.7FF                        0 D8F8 A   .8                          0 067F A   
.80                         0 0CAF A   .800                        0 D8FA A   
.801                        0 D900 A   .802                        0 D903 A   
.803                        0 D907 A   .804                        0 D90C A   
.805                        0 D922 A   .806                        0 D93D A   
.807                        0 D963 A   .808                        0 D96C A   
.809                        0 D990 A   .80A                        0 D9AA A   
.80B                        0 D9CF A   .80C                        0 D9E2 A   
.80D                        0 D9FF A   .81                         0 0C95 A   
.82                         0 0CC1 A   .83                         0 0D34 A   
.84                         0 0CDC A   .85                         0 0CCA A   
.86                         0 0D34 A   .87                         0 0D11 A   
.88                         0 0CE3 A   .89                         0 0D34 A   
.8A                         0 0D26 A   .8B                         0 0D18 A   
.8C                         0 0D34 A   .8D                         0 D9E2 A   
.8E                         0 0D4A A   .8F                         0 0D67 A   
.9                          0 0670 A   .90                         0 0D74 A   
.91                         0 0D70 A   .92                         0 0DAC A   
.93                         0 0D92 A   .94                         0 0D85 A   
.95                         0 0DAC A   .96                         0 0DA1 A   
.97                         0 0DEA A   .98                         0 0DDF A   
.99                         0 0DB4 A   .9A                         0 0DDF A   
.9B                         0 0DD0 A   .9C                         0 0DEA A   
.9D                         0 0E27 A   .9E                         0 0E0D A   
.9F                         0 0E00 A   .A                          0 0697 A   
.A0                         0 0E27 A   .A1                         0 0E1C A   
.A2                         0 0E36 A   .A3                         0 0E2E A   
.A4                         0 0E66 A   .A5                         0 0E4C A   
.A6                         0 0E3E A   .A7                         0 0E66 A   
.A8                         0 0E5B A   .A9                         0 0E76 A   
.AA                         0 0E6D A   .AB                         0 0E8C A   
.AC                         0 0E83 A   .AD                         0 0ECA A   
.AE                         0 0EB0 A   .AF                         0 0EA2 A   
.B                          0 0688 A   .B0                         0 0ECA A   
.B1                         0 0EBF A   .B2                         0 0EDA A   
.B3                         0 0ED1 A   .B4                         0 0F0A A   
.B5                         0 0EF0 A   .B6                         0 0EE2 A   
.B7                         0 0F0A A   .B8                         0 0EFF A   
.B9                         0 0F1A A   .BA                         0 0F11 A   
.BB                         0 0F30 A   .BC                         0 0F27 A   
.BD                         0 0F8A A   .BE                         0 0F70 A   
.BF                         0 0F62 A   .C                          0 06BB A   
.C0                         0 0F8A A   .C1                         0 0F7F A   
.C2                         0 0F9A A   .C3                         0 0F91 A   
.C4                         0 0FCA A   .C5                         0 0FB0 A   
.C6                         0 0FA2 A   .C7                         0 0FCA A   
.C8                         0 0FBF A   .C9                         0 0FDA A   
.CA                         0 0FD1 A   .CB                         0 0FF0 A   
.CC                         0 0FE7 A   .CD                         0 1020 A   
.CE                         0 1006 A   .CF                         0 0FF8 A   
.D                          0 06A0 A   .D0                         0 1020 A   
.D1                         0 1015 A   .D2                         0 1030 A   
.D3                         0 1027 A   .D4                         0 1046 A   
.D5                         0 103D A   .D6                         0 1084 A   
.D7                         0 106A A   .D8                         0 105C A   
.D9                         0 1084 A   .DA                         0 1079 A   
.DB                         0 1094 A   .DC                         0 108B A   
.DD                         0 10C4 A   .DE                         0 10AA A   
.DF                         0 109C A   .E                          0 06B0 A   
.E0                         0 10C4 A   .E1                         0 10B9 A   
.E2                         0 10D4 A   .E3                         0 10CB A   
.E4                         0 10EA A   .E5                         0 10E1 A   
.E6                         0 1128 A   .E7                         0 110E A   
.E8                         0 1100 A   .E9                         0 1128 A   
.EA                         0 111D A   .EB                         0 1138 A   
.EC                         0 112F A   .ED                         0 1176 A   
.EE                         0 115C A   .EF                         0 114E A   
.F                          0 06A7 A   .F0                         0 1176 A   
.F1                         0 116B A   .F2                         0 1186 A   
.F3                         0 117D A   .F4                         0 11C4 A   
.F5                         0 11AA A   .F6                         0 119C A   
.F7                         0 11C4 A   .F8                         0 11B9 A   
.F9                         0 11D4 A   .FA                         0 11CB A   
.FB                         0 1204 A   .FC                         0 11EA A   
.FD                         0 11DC A   .FE                         0 1204 A   
.FF                         0 11F9 A   .FFDD                       0 8F16 A   
.FFDE                       0 8F00 A   .FFDF                       0 8EEA A   
.FFE0                       0 8F0C A   .FFE2                       0 8EDF A   
.FFE3                       0 88B3 A   .FFE4                       0 8886 A   
.FFE6                       0 866D A   .FFE7                       0 8657 A   
.FFE8                       0 8641 A   .FFE9                       0 8663 A   
.FFEB                       0 8636 A   .FFEC                       0 7B12 A   
.FFED                       0 7B3E A   .FFEE                       0 7B28 A   
.FFEF                       0 7B34 A   .FFF1                       0 7B07 A   
.FFF4                       0 5B88 A   .FFFA                       0 3C8C A   
BcdToBin                    0 B110 A   _apm16_entry                0 B2BA A   
_apm32_entry                0 B1D5 A   _apmreal_entry              0 B385 A   
_ata_cmd_data_in            0 2E24 A E _ata_cmd_data_out           0 320D A E 
_ata_cmd_non_data           0 2E1D A E _ata_cmd_packet             0 35E7 A E 
_ata_detect                 0 1D9C A E _ata_init                   0 194A A E 
_ata_reset                  0 2CCC A E _atapi_get_sense            0 3AC6 A E 
_atapi_is_cdrom             0 3E33 A E _atapi_is_ready             0 3B4B A E 
_await_ide                  0 1C24 A   _bios_cvs_version_string    0 0194 A   
_bios_printf                0 09A7 A E _cdemu_emulated_drive       0 3EF6 A E 
_cdemu_init                 0 3EA5 A E _cdemu_isactive             0 3ECF A E 
_cdrom_boot                 0 3F3B A E _check_for_keystroke        0 0960 A E 
_debugger_off               0 185E A E _debugger_on                0 184C A E 
_delay_ticks                0 08AE A E _delay_ticks_and_check_for+ 0 0976 A E 
_dequeue_key                0 6001 A E _determine_floppy_media     0 A4A2 A E 
_drivetypes                 0 12A2 A   _eltorito                   0 3F23 A   
_enable_mouse_int_and_even+ 0 61AF A E _enqueue_key                0 699D A E 
_floppy_drive_exists        0 92F5 A E _floppy_drive_recal         0 9242 A E 
_floppy_media_known         0 9060 A E _floppy_media_sense         0 90E3 A E 
_floppy_prepare_controller  0 8F81 A E _floppy_reset_controller    0 8F33 A E 
_get_CS                     0 064E A E _get_SS                     0 0651 A E 
_get_boot_vector            0 141B A   _get_keystroke              0 096E A E 
_get_mouse_data             0 629D A E _inb                        0 0542 A E 
_inb_cmos                   0 0587 A E _inhibit_mouse_int_and_eve+ 0 6102 A E 
_init_boot_vectors          0 12D4 A   _init_rtc                   0 0593 A E 
_int09_function             0 632C A E _int13_cdemu                0 88DA A E 
_int13_cdrom                0 7B5B A E _int13_diskette_function    0 933D A E 
_int13_eltorito             0 868A A E _int13_harddisk             0 6B6C A E 
_int14_function             0 46BB A E _int15_function             0 4923 A E 
_int15_function32           0 56B2 A E _int15_function_mouse       0 4F45 A E 
_int16_function             0 5BBF A E _int17_function             0 A4A3 A E 
_int18_panic_msg            0 17D1 A E _int19_function             0 A5DB A E 
_int1a_function             0 A837 A E _int70_function             0 ABE3 A E 
_int74_function             0 6A51 A E _interactive_bootkey        0 1468 A E 
_inw                        0 054D A E _isotag                     0 3F1D A   
_keyboard_init              0 0D78 A E _keyboard_panic             0 123C A E 
_log_bios_start             0 17E3 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 17BF A E _outb                       0 0558 A E 
_outb_cmos                  0 0578 A E _outw                       0 0568 A E 
_panic_msg_keyb_buffer_ful+ 0 60E2 A   _print_bios_banner          0 127B A E 
_print_boot_device          0 1661 A E _print_boot_failure         0 1744 A E 
_print_cdromboot_failure    0 17AA A E _put_int                    0 06BD A E 
_put_luint                  0 07C3 A E _put_str                    0 087A A E 
_put_uint                   0 0740 A E _read_byte                  0 05F8 A E 
_read_dword                 0 0083 A E _read_word                  0 060B A E 
_rtc_updating               0 05C4 A E _s3_resume                  0 186F A E 
_s3_resume_panic            0 1269 A E _scan_to_scanascii          0 01C8 A   
_send                       0 0664 A E _send_to_mouse_ctrl         0 6253 A E 
_set_diskette_current_cyl   0 A471 A E _set_diskette_ret_status    0 A459 A E 
_set_e820_range             0 55C2 A E _set_enable_a20             0 17F9 A E 
_set_kbd_command_byte       0 62DE A E _shutdown_status_panic      0 1251 A E 
_vgafont8                   0 FA6E A   _wrch                       0 0654 A E 
_write_byte                 0 061E A E _write_dword                0 009B A E 
_write_word                 0 0636 A E apm16_04                    0 B2BB A   
apm16_05                    0 B2C2 A   apm16_07                    0 B2CB A   
apm16_07_1                  0 B2EF A   apm16_07_poweroff           0 B2E5 A   
apm16_07_poweroff_str       0 B2A1 A   apm16_07_standby            0 B301 A   
apm16_07_standby_str        0 B2B2 A   apm16_07_suspend            0 B2F2 A   
apm16_07_suspend_str        0 B2AA A   apm16_08                    0 B310 A   
apm16_0a                    0 B316 A   apm16_0b                    0 B32A A   
apm16_0e                    0 B332 A   apm16_0f                    0 B33C A   
apm16_10                    0 B342 A   apm16_error                 0 B350 A   
apm16_ok                    0 B34D A   apm16_out_str               0 B289 A   
apm16_out_str1              0 B290 A   apm16_out_str2              0 B29C A   
apm16_unimplemented         0 B350 A   apm32_04                    0 B1D7 A   
apm32_05                    0 B1E0 A   apm32_07                    0 B1EB A   
apm32_07_1                  0 B21C A   apm32_07_poweroff           0 B20E A   
apm32_07_poweroff_str       0 B1BC A   apm32_07_standby            0 B230 A   
apm32_07_standby_str        0 B1CD A   apm32_07_suspend            0 B21F A   
apm32_07_suspend_str        0 B1C5 A   apm32_08                    0 B241 A   
apm32_0a                    0 B247 A   apm32_0b                    0 B25D A   
apm32_0e                    0 B265 A   apm32_0f                    0 B26F A   
apm32_10                    0 B275 A   apm32_error                 0 B285 A   
apm32_ok                    0 B281 A   apm32_out_str               0 B1A9 A   
apm32_out_str1              0 B1AD A   apm32_out_str2              0 B1B9 A   
apm32_unimplemented         0 B285 A   apm_call                    0 F87B A   
apmreal_00                  0 B385 A   apmreal_01                  0 B397 A   
apmreal_02                  0 B39E A   apmreal_03                  0 B3B4 A   
apmreal_04                  0 B3D3 A   apmreal_05                  0 B3DA A   
apmreal_07                  0 B3E3 A   apmreal_07_1                0 B407 A   
apmreal_07_poweroff         0 B3FD A   apmreal_07_poweroff_str     0 B36B A   
apmreal_07_standby          0 B419 A   apmreal_07_standby_str      0 B37C A   
apmreal_07_suspend          0 B40A A   apmreal_07_suspend_str      0 B374 A   
apmreal_08                  0 B428 A   apmreal_0a                  0 B42E A   
apmreal_0b                  0 B442 A   apmreal_0e                  0 B44A A   
apmreal_0f                  0 B454 A   apmreal_10                  0 B45A A   
apmreal_error               0 B46A A   apmreal_ok                  0 B465 A   
apmreal_out_str             0 B353 A   apmreal_out_str1            0 B35A A   
apmreal_out_str2            0 B366 A   apmreal_unimplemented       0 B46A A   
ata_in_16                   0 3177 A   ata_in_32                   0 317B A   
ata_in_adjust               0 3163 A   ata_in_done                 0 317E A   
ata_in_no_adjust            0 316A A   ata_out_16                  0 3560 A   
ata_out_32                  0 3565 A   ata_out_adjust              0 354C A   
ata_out_done                0 3569 A   ata_out_no_adjust           0 3553 A   
ata_packet_after            0 3A51 A   ata_packet_done             0 3A6B A   
ata_packet_in_16            0 3A4A A   ata_packet_in_32            0 3A4E A   
ata_packet_in_after_16      0 3A5E A   ata_packet_in_after_32      0 3A63 A   
ata_packet_in_after_32_loo+ 0 3A65 A   ata_packet_in_before_16     0 3A28 A   
ata_packet_in_before_32     0 3A2D A   ata_packet_in_before_32_lo+ 0 3A2F A   
ata_packet_no_before        0 3A35 A   bios32_end                  0 B4B3 A   
bios32_entry_point          0 B480 A   bios32_structure            0 B470 A   
bios_table_area_end         0 CC00 A   bios_table_area_start       0 BA80 A   
block_count_rounded         0 B9B9 A   carry_set                   0 AD3F A   
check_for_hd1               0 AFC9 A   checksum_loop               0 B970 A   
checksum_out                0 B98A A   detect_parport              0 B917 A   
detect_serial               0 B936 A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 096D A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 B0B3 A   
eoi_both_pics               0 B107 A   eoi_jmp_post                0 B0C8 A   
eoi_master_pic              0 B10B A   f0_missing                  0 AE47 A   
f1_missing                  0 AE52 A   floppy_drive_post           0 AE0C A   
halt2_loop                  0 0D71 A   hard_drive_post             0 AE93 A   
hd0_post_above_2048         0 AF8B A   hd0_post_above_4096         0 AF99 A   
hd0_post_above_8192         0 AFA7 A   hd0_post_checksum_loop      0 AFBC A   
hd0_post_logical_chs        0 AF6A A   hd0_post_physical_chs       0 AF5C A   
hd0_post_store_logical      0 AFAD A   hd1_post_above_2048         0 B074 A   
hd1_post_above_4096         0 B082 A   hd1_post_above_8192         0 B090 A   
hd1_post_checksum_loop      0 B0A5 A   hd1_post_logical_chs        0 B053 A   
hd1_post_physical_chs       0 B046 A   hd1_post_store_logical      0 B096 A   
idiv_                       0 0165 A   idiv_u                      0 0169 A   
int08_floppy_off            0 FEC4 A   int08_handler               0 FEA5 A   
int08_store_ticks           0 FED9 A   int09_check_pause           0 E9B5 A   
int09_done                  0 E9CF A   int09_finish                0 E9D5 A   
int09_handler               0 E987 A   int09_process_key           0 E9C7 A   
int0e_handler               0 EF57 A   int0e_loop1                 0 EF69 A   
int0e_loop2                 0 EF73 A   int0e_normal                0 EF81 A   
int10_handler               0 F065 A   int11_handler               0 F84D A   
int12_handler               0 F841 A   int13_cdemu_inactive        0 AD93 A   
int13_cdrom_rme_end         0 7FEF A   int13_disk                  0 ADC2 A   
int13_diskette              0 EC59 A   int13_handler               0 E3FE A   
int13_legacy                0 AD9B A   int13_nocdemu               0 AD80 A   
int13_noeltorito            0 AD97 A   int13_not_eltorito          0 AD5D A   
int13_notcdrom              0 ADC2 A   int13_notfloppy             0 ADAE A   
int13_out                   0 ADCF A   int13_relocated             0 AD48 A   
int14_handler               0 E739 A   int1586_tick                0 5713 A   
int1586_tick_end            0 5721 A   int15_handler               0 F859 A   
int15_handler32             0 F883 A   int15_handler32_ret         0 F875 A   
int15_handler_mouse         0 F87E A   int15_handler_mouse_ret     0 F874 A   
int16_F00                   0 E85B A   int16_handler               0 E82E A   
int16_key_found             0 E86F A   int16_wait_for_key          0 E860 A   
int16_zero_clear            0 E849 A   int16_zero_set              0 E852 A   
int17_handler               0 EFD2 A   int18_handler               0 ADD3 A   
int19_handler               0 E6F2 A   int19_load_done             0 A70D A   
int19_next_boot             0 AE06 A   int19_relocated             0 ADEF A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 AE0B A   
int70_handler               0 FE93 A   int74_done                  0 AD2A A   
int74_handler               0 AD0B A   int75_handler               0 E2C7 A   
int76_handler               0 B196 A   iret_modify_cf              0 AD34 A   
iret_post_0x467             0 B0D8 A   jmp_post_0x467              0 B0D0 A   
laddl                       0 00C3 A   laddul                      0 00C3 A   
landl                       0 00BB A   landul                      0 00BB A   
lcmpl                       0 00CB A   lcmpul                      0 00CB A   
ldecl                       0 0102 A   ldecul                      0 0102 A   
ldivul                      0 016E A   lincl                       0 010F A   
lincul                      0 010F A   lmull                       0 00E9 A   
lmulul                      0 00E9 A   look_drive0                 0 AE3E A   
look_drive1                 0 AE49 A   lorl                        0 0107 A   
lorul                       0 0107 A   lsl_exit                    0 0164 A   
lsl_loop                    0 0158 A   lsll                        0 0147 A   
lslul                       0 0147 A   lsr_exit                    0 0146 A   
lsr_loop                    0 013A A   lsrul                       0 0129 A   
lsubl                       0 00E1 A   lsubul                      0 00E1 A   
ltstl                       0 0114 A   ltstul                      0 0114 A   
memcpyb_end                 0 004B A   memcpyd_end                 0 007B A   
memsetb_end                 0 001E A   nmi                         0 E2C3 A   
no_bcv                      0 BA09 A   no_bev                      0 BA42 A   
no_key                      0 096B A   no_parport                  0 B935 A   
no_prod_str                 0 BA3A A   no_serial                   0 B959 A   
normal_post                 0 E0A3 A   pci_present                 0 B63D A   
pci_pro_devloop             0 B4ED A   pci_pro_devloop2            0 B523 A   
pci_pro_f02                 0 B4DC A   pci_pro_f03                 0 B518 A   
pci_pro_f08                 0 B551 A   pci_pro_f09                 0 B570 A   
pci_pro_f0a                 0 B58E A   pci_pro_f0b                 0 B5A2 A   
pci_pro_f0c                 0 B5BE A   pci_pro_f0d                 0 B5DC A   
pci_pro_fail                0 B5F2 A   pci_pro_nextdev             0 B508 A   
pci_pro_nextdev2            0 B541 A   pci_pro_ok                  0 B5F7 A   
pci_pro_select_reg          0 B5FE A   pci_pro_unknown             0 B5F0 A   
pci_real_devloop            0 B671 A   pci_real_devloop2           0 B6A3 A   
pci_real_f02                0 B65E A   pci_real_f03                0 B69A A   
pci_real_f08                0 B6D0 A   pci_real_f09                0 B6E8 A   
pci_real_f0a                0 B700 A   pci_real_f0b                0 B714 A   
pci_real_f0c                0 B72B A   pci_real_f0d                0 B742 A   
pci_real_f0e                0 B755 A   pci_real_fail               0 B795 A   
pci_real_nextdev            0 B687 A   pci_real_nextdev2           0 B6BD A   
pci_real_ok                 0 B79B A   pci_real_select_reg         0 B7A3 A   
pci_real_too_small          0 B78A A   pci_real_unknown            0 B793 A   
pci_routing_table_structur+ 0 B7C0 A   pci_routing_table_structur+ 0 B840 A   
pci_routing_table_structur+ 0 B7E0 A   pcibios_error               0 FE7B A   
pcibios_protected           0 B4C0 A   pcibios_real                0 B61B A   
pmode_IDT_info              0 F88C A   pnp_string                  0 B991 A   
post                        0 E05B A   post_d0_extended            0 AEF5 A   
post_d0_type47              0 AF06 A   post_d1_exists              0 AFD4 A   
post_d1_extended            0 AFDF A   post_d1_type47              0 AFF0 A   
post_default_ints           0 E0D4 A   post_init_pic               0 BA56 A   
protected_mode              0 4CEC A   protmode_switch             0 4E25 A   
real_mode                   0 4D16 A   retf_post_0x467             0 B0E5 A   
rmode_IDT_info              0 F891 A   rom_checksum                0 B95B A   
rom_scan                    0 B995 A   rom_scan_increment          0 BA44 A   
rom_scan_loop               0 B995 A   rombios32_05                0 B86F A   
rombios32_10                0 B8A8 A   rombios32_gdt               0 B8E7 A   
rombios32_gdt_48            0 B8E1 A   rombios32_init              0 B840 A   
rombios32_real_mode         0 B8C2 A   s3_post                     0 B0F2 A   
timer_tick_post             0 B11F A   unknown_service             0 B4B1 A   

00000 errors
00000 warnings
