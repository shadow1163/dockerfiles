00001                                           ! 1 
00002                                           ! 1 # 1 "_rombiosl_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void memsetb(seg,offset,value,count);
00040                                           !BCC_EOS
00041                                           ! 32   void memcpyb(dseg,doffset,sseg,soffset,count);
00042                                           !BCC_EOS
00043                                           ! 33   void memcpyd(dseg,doffset,sseg,soffset,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   memsetb(seg,offset,value,count)
00047                                           ! 36     Bit16u seg;
00048                                           export	_memsetb
00049                       00000000            _memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u value;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            _memsetb.count	set	8
00061                       00000002            _memsetb.seg	set	2
00062                       00000006            _memsetb.value	set	6
00063                       00000004            _memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           85C9                             test cx, cx
00072 000C           74           10                  je memsetb_end
00073 000E           8B46         04                  mov ax, 4[bp] ; segment
00074 0011           8EC0                             mov es, ax
00075 0013           8B46         06                  mov ax, 6[bp] ; offset
00076 0016           89C7                             mov di, ax
00077 0018           8A46         08                  mov al, 8[bp] ; value
00078 001B           FC                               cld
00079 001C           F3                               rep
00080 001D           AA                                stosb
00081                       0000001E              memsetb_end:
00082 001E           5F                               pop di
00083 001F           07                               pop es
00084 0020           59                               pop cx
00085 0021           58                               pop ax
00086 0022           5D                             pop bp
00087                                           ! 65 endasm
00088                                           !BCC_ENDASM
00089                                           ! 66   }
00090 0023           C3                         ret
00091                                           ! 67     void
00092                                           ! 68   memcpyb(dseg,doffset,sseg,soffset,count)
00093                                           ! 69     Bit16u dseg;
00094                                           export	_memcpyb
00095                       00000024            _memcpyb:
00096                                           !BCC_EOS
00097                                           ! 70     Bit16u doffset;
00098                                           !BCC_EOS
00099                                           ! 71     Bit16u sseg;
00100                                           !BCC_EOS
00101                                           ! 72     Bit16u soffset;
00102                                           !BCC_EOS
00103                                           ! 73     Bit16u count;
00104                                           !BCC_EOS
00105                                           ! 74   {
00106                                           ! 75 #asm
00107                                           !BCC_ASM
00108                       0000000A            _memcpyb.count	set	$A
00109                       00000006            _memcpyb.sseg	set	6
00110                       00000008            _memcpyb.soffset	set	8
00111                       00000002            _memcpyb.dseg	set	2
00112                       00000004            _memcpyb.doffset	set	4
00113 0024           55                             push bp
00114 0025           89E5                           mov bp, sp
00115 0027           50                               push ax
00116 0028           51                               push cx
00117 0029           06                               push es
00118 002A           57                               push di
00119 002B           1E                               push ds
00120 002C           56                               push si
00121 002D           8B4E         0C                  mov cx, 12[bp] ; count
00122 0030           85C9                             test cx, cx
00123 0032           74           17                  je memcpyb_end
00124 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00125 0037           8EC0                             mov es, ax
00126 0039           8B46         06                  mov ax, 6[bp] ; doffset
00127 003C           89C7                             mov di, ax
00128 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00129 0041           8ED8                             mov ds, ax
00130 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00131 0046           89C6                             mov si, ax
00132 0048           FC                               cld
00133 0049           F3                               rep
00134 004A           A4                                movsb
00135                       0000004B              memcpyb_end:
00136 004B           5E                               pop si
00137 004C           1F                               pop ds
00138 004D           5F                               pop di
00139 004E           07                               pop es
00140 004F           59                               pop cx
00141 0050           58                               pop ax
00142 0051           5D                             pop bp
00143                                           ! 106 endasm
00144                                           !BCC_ENDASM
00145                                           ! 107   }
00146 0052           C3                         ret
00147                                           ! 108     void
00148                                           ! 109 
00149                                           ! 109   memcpyd(dseg,doffset,sseg,soffset,count)
00150                                           ! 110     Bit16u dseg;
00151                                           export	_memcpyd
00152                       00000053            _memcpyd:
00153                                           !BCC_EOS
00154                                           ! 111     Bit16u doffset;
00155                                           !BCC_EOS
00156                                           ! 112     Bit16u sseg;
00157                                           !BCC_EOS
00158                                           ! 113     Bit16u soffset;
00159                                           !BCC_EOS
00160                                           ! 114     Bit16u count;
00161                                           !BCC_EOS
00162                                           ! 115   {
00163                                           ! 116 #asm
00164                                           !BCC_ASM
00165                       0000000A            _memcpyd.count	set	$A
00166                       00000006            _memcpyd.sseg	set	6
00167                       00000008            _memcpyd.soffset	set	8
00168                       00000002            _memcpyd.dseg	set	2
00169                       00000004            _memcpyd.doffset	set	4
00170 0053           55                             push bp
00171 0054           89E5                           mov bp, sp
00172 0056           50                               push ax
00173 0057           51                               push cx
00174 0058           06                               push es
00175 0059           57                               push di
00176 005A           1E                               push ds
00177 005B           56                               push si
00178 005C           8B4E         0C                  mov cx, 12[bp] ; count
00179 005F           85C9                             test cx, cx
00180 0061           74           18                  je memcpyd_end
00181 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00182 0066           8EC0                             mov es, ax
00183 0068           8B46         06                  mov ax, 6[bp] ; doffset
00184 006B           89C7                             mov di, ax
00185 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00186 0070           8ED8                             mov ds, ax
00187 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00188 0075           89C6                             mov si, ax
00189 0077           FC                               cld
00190 0078           F3                               rep
00191 0079     66    A5                                movsd
00192                       0000007B              memcpyd_end:
00193 007B           5E                               pop si
00194 007C           1F                               pop ds
00195 007D           5F                               pop di
00196 007E           07                               pop es
00197 007F           59                               pop cx
00198 0080           58                               pop ax
00199 0081           5D                             pop bp
00200                                           ! 147 endasm
00201                                           !BCC_ENDASM
00202                                           ! 148   }
00203 0082           C3                         ret
00204                                           ! 149   static Bit32u read_dword();
00205                                           !BCC_EOS
00206                                           ! 150   static void write_dword();
00207                                           !BCC_EOS
00208                                           ! 151     Bit32u
00209                                           ! 152   read_dword(seg, offset)
00210                                           ! 153     Bit16u seg;
00211                                           export	_read_dword
00212                       00000083            _read_dword:
00213                                           !BCC_EOS
00214                                           ! 154     Bit16u offset;
00215                                           !BCC_EOS
00216                                           ! 155   {
00217                                           ! 156 #asm
00218                                           !BCC_ASM
00219                       00000002            _read_dword.seg	set	2
00220                       00000004            _read_dword.offset	set	4
00221 0083           55                             push bp
00222 0084           89E5                           mov bp, sp
00223 0086           53                               push bx
00224 0087           1E                               push ds
00225 0088           8B46         04                  mov ax, 4[bp] ; segment
00226 008B           8ED8                             mov ds, ax
00227 008D           8B5E         06                  mov bx, 6[bp] ; offset
00228 0090           8B07                             mov ax, [bx]
00229 0092           83C3                   02        add bx, #2
00230 0095           8B17                             mov dx, [bx]
00231                                                 ;; ax = return value (word)
00232                                                 ;; dx = return value (word)
00233 0097           1F                               pop ds
00234 0098           5B                               pop bx
00235 0099           5D                             pop bp
00236                                           ! 172 endasm
00237                                           !BCC_ENDASM
00238                                           ! 173   }
00239 009A           C3                         ret
00240                                           ! 174     void
00241                                           ! 175   write_dword(seg, offset, data)
00242                                           ! 176     Bit16u seg;
00243                                           export	_write_dword
00244                       0000009B            _write_dword:
00245                                           !BCC_EOS
00246                                           ! 177     Bit16u offset;
00247                                           !BCC_EOS
00248                                           ! 178     Bit32u data;
00249                                           !BCC_EOS
00250                                           ! 179   {
00251                                           ! 180 #asm
00252                                           !BCC_ASM
00253                       00000002            _write_dword.seg	set	2
00254                       00000006            _write_dword.data	set	6
00255                       00000004            _write_dword.offset	set	4
00256 009B           55                             push bp
00257 009C           89E5                           mov bp, sp
00258 009E           50                               push ax
00259 009F           53                               push bx
00260 00A0           1E                               push ds
00261 00A1           8B46         04                  mov ax, 4[bp] ; segment
00262 00A4           8ED8                             mov ds, ax
00263 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00264 00A9           8B46         08                  mov ax, 8[bp] ; data word
00265 00AC           8907                             mov [bx], ax ; write data word
00266 00AE           83C3                   02        add bx, #2
00267 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00268 00B4           8907                             mov [bx], ax ; write data word
00269 00B6           1F                               pop ds
00270 00B7           5B                               pop bx
00271 00B8           58                               pop ax
00272 00B9           5D                             pop bp
00273                                           ! 198 endasm
00274                                           !BCC_ENDASM
00275                                           ! 199   }
00276 00BA           C3                         ret
00277                                           ! 200 #asm
00278                                           !BCC_ASM
00279                       00000002            _write_dword.seg	set	2
00280                       00000006            _write_dword.data	set	6
00281                       00000004            _write_dword.offset	set	4
00282                                             ;; and function
00283                       000000BB              landl:
00284                       000000BB              landul:
00285 00BB           36                             SEG SS
00286 00BC           2305                             and ax,[di]
00287 00BE           36                             SEG SS
00288 00BF           235D         02                  and bx,2[di]
00289 00C2           C3                             ret
00290                                             ;; add function
00291                       000000C3              laddl:
00292                       000000C3              laddul:
00293 00C3           36                             SEG SS
00294 00C4           0305                             add ax,[di]
00295 00C6           36                             SEG SS
00296 00C7           135D         02                  adc bx,2[di]
00297 00CA           C3                             ret
00298                                             ;; cmp function
00299                       000000CB              lcmpl:
00300                       000000CB              lcmpul:
00301 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00302 00D1     66    C1E3                   10      shl ebx, #16
00303 00D5     66    09D8                           or eax, ebx
00304 00D8     66    C1EB                   10      shr ebx, #16
00305 00DC           36                             SEG SS
00306 00DD     66    3B05                             cmp eax, dword ptr [di]
00307 00E0           C3                             ret
00308                                             ;; sub function
00309                       000000E1              lsubl:
00310                       000000E1              lsubul:
00311 00E1           36                             SEG SS
00312 00E2           2B05                           sub ax,[di]
00313 00E4           36                             SEG SS
00314 00E5           1B5D         02                sbb bx,2[di]
00315 00E8           C3                             ret
00316                                             ;; mul function
00317                       000000E9              lmull:
00318                       000000E9              lmulul:
00319 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00320 00EF     66    C1E3                   10      shl ebx, #16
00321 00F3     66    09D8                           or eax, ebx
00322 00F6           36                             SEG SS
00323 00F7     66    F725                           mul eax, dword ptr [di]
00324 00FA     66    89C3                           mov ebx, eax
00325 00FD     66    C1EB                   10      shr ebx, #16
00326 0101           C3                             ret
00327                                             ;; dec function
00328                       00000102              ldecl:
00329                       00000102              ldecul:
00330 0102           36                             SEG SS
00331 0103     66    FF0F                           dec dword ptr [bx]
00332 0106           C3                             ret
00333                                             ;; or function
00334                       00000107              lorl:
00335                       00000107              lorul:
00336 0107           36                             SEG SS
00337 0108           0B05                           or ax,[di]
00338 010A           36                             SEG SS
00339 010B           0B5D         02                or bx,2[di]
00340 010E           C3                             ret
00341                                             ;; inc function
00342                       0000010F              lincl:
00343                       0000010F              lincul:
00344 010F           36                             SEG SS
00345 0110     66    FF07                           inc dword ptr [bx]
00346 0113           C3                             ret
00347                                             ;; tst function
00348                       00000114              ltstl:
00349                       00000114              ltstul:
00350 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00351 011A     66    C1E3                   10      shl ebx, #16
00352 011E     66    09D8                           or eax, ebx
00353 0121     66    C1EB                   10      shr ebx, #16
00354 0125     66    85C0                           test eax, eax
00355 0128           C3                             ret
00356                                             ;; sr function
00357                       00000129              lsrul:
00358 0129           89F9                           mov cx,di
00359 012B           E3           19                jcxz lsr_exit
00360 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00361 0133     66    C1E3                   10      shl ebx, #16
00362 0137     66    09D8                           or eax, ebx
00363                       0000013A              lsr_loop:
00364 013A     66    D1E8                           shr eax, #1
00365 013D           E2           FB                loop lsr_loop
00366 013F     66    89C3                           mov ebx, eax
00367 0142     66    C1EB                   10      shr ebx, #16
00368                       00000146              lsr_exit:
00369 0146           C3                             ret
00370                                             ;; sl function
00371                       00000147              lsll:
00372                       00000147              lslul:
00373 0147           89F9                           mov cx,di
00374 0149           E3           19                jcxz lsl_exit
00375 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00376 0151     66    C1E3                   10      shl ebx, #16
00377 0155     66    09D8                           or eax, ebx
00378                       00000158              lsl_loop:
00379 0158     66    D1E0                           shl eax, #1
00380 015B           E2           FB                loop lsl_loop
00381 015D     66    89C3                           mov ebx, eax
00382 0160     66    C1EB                   10      shr ebx, #16
00383                       00000164              lsl_exit:
00384 0164           C3                             ret
00385                       00000165              idiv_:
00386 0165           99                             cwd
00387 0166           F7FB                           idiv bx
00388 0168           C3                             ret
00389                       00000169              idiv_u:
00390 0169           31D2                           xor dx,dx
00391 016B           F7F3                           div bx
00392 016D           C3                             ret
00393                       0000016E              ldivul:
00394 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00395 0174     66    C1E3                   10      shl ebx, #16
00396 0178     66    09D8                           or eax, ebx
00397 017B     66    31D2                           xor edx, edx
00398 017E           36                             SEG SS
00399 017F           8B5D         02                mov bx, 2[di]
00400 0182     66    C1E3                   10      shl ebx, #16
00401 0186           36                             SEG SS
00402 0187           8B1D                           mov bx, [di]
00403 0189     66    F7F3                           div ebx
00404 018C     66    89C3                           mov ebx, eax
00405 018F     66    C1EB                   10      shr ebx, #16
00406 0193           C3                             ret
00407                                           ! 326 endasm
00408                                           !BCC_ENDASM
00409                                           ! 327 typedef struct {
00410                                           ! 328   unsigned char filler1[0x400];
00411                                           !BCC_EOS
00412                                           ! 329   unsigned char filler2[0x6c];
00413                                           !BCC_EOS
00414                                           ! 330   Bit16u ticks_low;
00415                                           !BCC_EOS
00416                                           ! 331   Bit16u ticks_high;
00417                                           !BCC_EOS
00418                                           ! 332   Bit8u midnight_flag;
00419                                           !BCC_EOS
00420                                           ! 333 } bios_data_t;
00421                                           !BCC_EOS
00422                                           ! 334   typedef struct {
00423                                           ! 335     Bit16u heads;
00424                                           !BCC_EOS
00425                                           ! 336     Bit16u cylinders;
00426                                           !BCC_EOS
00427                                           ! 337     Bit16u spt;
00428                                           !BCC_EOS
00429                                           ! 338   } chs_t;
00430                                           !BCC_EOS
00431                                           ! 339   typedef struct {
00432                                           ! 340     Bit16u iobase1;
00433                                           !BCC_EOS
00434                                           ! 341     Bit16u iobase2;
00435                                           !BCC_EOS
00436                                           ! 342     Bit8u prefix;
00437                                           !BCC_EOS
00438                                           ! 343     Bit8u unused;
00439                                           !BCC_EOS
00440                                           ! 344     Bit8u irq;
00441                                           !BCC_EOS
00442                                           ! 345     Bit8u blkcount;
00443                                           !BCC_EOS
00444                                           ! 346     Bit8u dma;
00445                                           !BCC_EOS
00446                                           ! 347     Bit8u pio;
00447                                           !BCC_EOS
00448                                           ! 348     Bit16u options;
00449                                           !BCC_EOS
00450                                           ! 349     Bit16u reserved;
00451                                           !BCC_EOS
00452                                           ! 350     Bit8u revision;
00453                                           !BCC_EOS
00454                                           ! 351     Bit8u checksum;
00455                                           !BCC_EOS
00456                                           ! 352   } dpte_t;
00457                                           !BCC_EOS
00458                                           ! 353   typedef struct {
00459                                           ! 354     Bit8u iface;
00460                                           !BCC_EOS
00461                                           ! 355     Bit16u iobase1;
00462                                           !BCC_EOS
00463                                           ! 356     Bit16u iobase2;
00464                                           !BCC_EOS
00465                                           ! 357     Bit8u irq;
00466                                           !BCC_EOS
00467                                           ! 358   } ata_channel_t;
00468                                           !BCC_EOS
00469                                           ! 359   typedef struct {
00470                                           ! 360     Bit8u type;
00471                                           !BCC_EOS
00472                                           ! 361     Bit8u device;
00473                                           !BCC_EOS
00474                                           ! 362     Bit8u removable;
00475                                           !BCC_EOS
00476                                           ! 363     Bit8u lock;
00477                                           !BCC_EOS
00478                                           ! 364     Bit8u mode;
00479                                           !BCC_EOS
00480                                           ! 365     Bit16u blksize;
00481                                           !BCC_EOS
00482                                           ! 366     Bit8
00483                                           ! 366 u translation;
00484                                           !BCC_EOS
00485                                           ! 367     chs_t lchs;
00486                                           !BCC_EOS
00487                                           ! 368     chs_t pchs;
00488                                           !BCC_EOS
00489                                           ! 369     Bit32u sectors_low;
00490                                           !BCC_EOS
00491                                           ! 370     Bit32u sectors_high;
00492                                           !BCC_EOS
00493                                           ! 371   } ata_device_t;
00494                                           !BCC_EOS
00495                                           ! 372   typedef struct {
00496                                           ! 373     ata_channel_t channels[4];
00497                                           !BCC_EOS
00498                                           ! 374     ata_device_t devices[(4*2)];
00499                                           !BCC_EOS
00500                                           ! 375     Bit8u hdcount, hdidmap[(4*2)];
00501                                           !BCC_EOS
00502                                           ! 376     Bit8u cdcount, cdidmap[(4*2)];
00503                                           !BCC_EOS
00504                                           ! 377     dpte_t dpte;
00505                                           !BCC_EOS
00506                                           ! 378     Bit16u trsfsectors;
00507                                           !BCC_EOS
00508                                           ! 379     Bit32u trsfbytes;
00509                                           !BCC_EOS
00510                                           ! 380   } ata_t;
00511                                           !BCC_EOS
00512                                           ! 381   typedef struct {
00513                                           ! 382     Bit8u active;
00514                                           !BCC_EOS
00515                                           ! 383     Bit8u media;
00516                                           !BCC_EOS
00517                                           ! 384     Bit8u emulated_drive;
00518                                           !BCC_EOS
00519                                           ! 385     Bit8u controller_index;
00520                                           !BCC_EOS
00521                                           ! 386     Bit16u device_spec;
00522                                           !BCC_EOS
00523                                           ! 387     Bit32u ilba;
00524                                           !BCC_EOS
00525                                           ! 388     Bit16u buffer_segment;
00526                                           !BCC_EOS
00527                                           ! 389     Bit16u load_segment;
00528                                           !BCC_EOS
00529                                           ! 390     Bit16u sector_count;
00530                                           !BCC_EOS
00531                                           ! 391     chs_t vdevice;
00532                                           !BCC_EOS
00533                                           ! 392   } cdemu_t;
00534                                           !BCC_EOS
00535                                           ! 393   typedef struct {
00536                                           ! 394     unsigned char filler1[0x3D];
00537                                           !BCC_EOS
00538                                           ! 395     unsigned char fdpt0[0x10];
00539                                           !BCC_EOS
00540                                           ! 396     unsigned char fdpt1[0x10];
00541                                           !BCC_EOS
00542                                           ! 397     unsigned char filler2[0xC4];
00543                                           !BCC_EOS
00544                                           ! 398     ata_t ata;
00545                                           !BCC_EOS
00546                                           ! 399     cdemu_t cdemu;
00547                                           !BCC_EOS
00548                                           ! 400   } ebda_data_t;
00549                                           !BCC_EOS
00550                                           ! 401   typedef struct {
00551                                           ! 402     Bit8u size;
00552                                           !BCC_EOS
00553                                           ! 403     Bit8u reserved;
00554                                           !BCC_EOS
00555                                           ! 404     Bit16u count;
00556                                           !BCC_EOS
00557                                           ! 405     Bit16u offset;
00558                                           !BCC_EOS
00559                                           ! 406     Bit16u segment;
00560                                           !BCC_EOS
00561                                           ! 407     Bit32u lba1;
00562                                           !BCC_EOS
00563                                           ! 408     Bit32u lba2;
00564                                           !BCC_EOS
00565                                           ! 409   } int13ext_t;
00566                                           !BCC_EOS
00567                                           ! 410   typedef struct {
00568                                           ! 411     Bit16u size;
00569                                           !BCC_EOS
00570                                           ! 412     Bit16u infos;
00571                                           !BCC_EOS
00572                                           ! 413     Bit32u cylinders;
00573                                           !BCC_EOS
00574                                           ! 414     Bit32u heads;
00575                                           !BCC_EOS
00576                                           ! 415     Bit32u spt;
00577                                           !BCC_EOS
00578                                           ! 416     Bit32u sector_count1;
00579                                           !BCC_EOS
00580                                           ! 417     Bit32u sector_count2;
00581                                           !BCC_EOS
00582                                           ! 418     Bit16u blksize;
00583                                           !BCC_EOS
00584                                           ! 419     Bit16u dpte_offset;
00585                                           !BCC_EOS
00586                                           ! 420     Bit16u dpte_segment;
00587                                           !BCC_EOS
00588                                           ! 421     Bit16u key;
00589                                           !BCC_EOS
00590                                           ! 422     Bit8u dpi_length;
00591                                           !BCC_EOS
00592                                           ! 423     Bit8u reserved1;
00593                                           !BCC_EOS
00594                                           ! 424     Bit16u reserved2;
00595                                           !BCC_EOS
00596                                           ! 425     Bit8u host_bus[4];
00597                                           !BCC_EOS
00598                                           ! 426     Bit8u iface_type[8];
00599                                           !BCC_EOS
00600                                           ! 427     Bit8u iface_path[8];
00601                                           !BCC_EOS
00602                                           ! 428     Bit8u device_path[8];
00603                                           !BCC_EOS
00604                                           ! 429     Bit8u reserved3;
00605                                           !BCC_EOS
00606                                           ! 430     Bit8u checksum;
00607                                           !BCC_EOS
00608                                           ! 431   } dpt_t;
00609                                           !BCC_EOS
00610                                           ! 432 typedef struct {
00611                                           ! 433   union {
00612                                           ! 434     struct {
00613                                           ! 435       Bit16u di, si, bp, sp;
00614                                           !BCC_EOS
00615                                           ! 436       Bit16u bx, dx, cx, ax;
00616                                           !BCC_EOS
00617                                           ! 437     } r16;
00618                                           !BCC_EOS
00619                                           ! 438     struct {
00620                                           ! 439       Bit16u filler[4];
00621                                           !BCC_EOS
00622                                           ! 440       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00623                                           !BCC_EOS
00624                                           ! 441     } r8;
00625                                           !BCC_EOS
00626                                           ! 442   } u;
00627                                           !BCC_EOS
00628                                           ! 443 } pusha_regs_t;
00629                                           !BCC_EOS
00630                                           ! 444 typedef struct {
00631                                           ! 445  union {
00632                                           ! 446   struct {
00633                                           ! 447     Bit32u edi, esi, ebp, esp;
00634                                           !BCC_EOS
00635                                           ! 448     Bit32u ebx, edx, ecx, eax;
00636                                           !BCC_EOS
00637                                           ! 449   } r32;
00638                                           !BCC_EOS
00639                                           ! 450   struct {
00640                                           ! 451     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00641                                           !BCC_EOS
00642                                           ! 452     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00643                                           !BCC_EOS
00644                                           ! 453   } r16;
00645                                           !BCC_EOS
00646                                           ! 454   struct {
00647                                           ! 455     Bit32u filler[4];
00648                                           !BCC_EOS
00649                                           ! 456     Bit8u bl, bh;
00650                                           !BCC_EOS
00651                                           ! 457     Bit16u filler1;
00652                                           !BCC_EOS
00653                                           ! 458     Bit8u dl, dh;
00654                                           !BCC_EOS
00655                                           ! 459     Bit16u filler2;
00656                                           !BCC_EOS
00657                                           ! 460     Bit8u cl, ch;
00658                                           !BCC_EOS
00659                                           ! 461     Bit16u filler3;
00660                                           !BCC_EOS
00661                                           ! 462   
00662                                           ! 462   Bit8u al, ah;
00663                                           !BCC_EOS
00664                                           ! 463     Bit16u filler4;
00665                                           !BCC_EOS
00666                                           ! 464   } r8;
00667                                           !BCC_EOS
00668                                           ! 465  } u;
00669                                           !BCC_EOS
00670                                           ! 466 } pushad_regs_t;
00671                                           !BCC_EOS
00672                                           ! 467 typedef struct {
00673                                           ! 468   union {
00674                                           ! 469     struct {
00675                                           ! 470       Bit16u flags;
00676                                           !BCC_EOS
00677                                           ! 471     } r16;
00678                                           !BCC_EOS
00679                                           ! 472     struct {
00680                                           ! 473       Bit8u flagsl;
00681                                           !BCC_EOS
00682                                           ! 474       Bit8u flagsh;
00683                                           !BCC_EOS
00684                                           ! 475     } r8;
00685                                           !BCC_EOS
00686                                           ! 476   } u;
00687                                           !BCC_EOS
00688                                           ! 477 } flags_t;
00689                                           !BCC_EOS
00690                                           ! 478 typedef struct {
00691                                           ! 479   Bit16u ip;
00692                                           !BCC_EOS
00693                                           ! 480   Bit16u cs;
00694                                           !BCC_EOS
00695                                           ! 481   flags_t flags;
00696                                           !BCC_EOS
00697                                           ! 482 } iret_addr_t;
00698                                           !BCC_EOS
00699                                           ! 483 typedef struct {
00700                                           ! 484   Bit16u type;
00701                                           !BCC_EOS
00702                                           ! 485   Bit16u flags;
00703                                           !BCC_EOS
00704                                           ! 486   Bit32u vector;
00705                                           !BCC_EOS
00706                                           ! 487   Bit32u description;
00707                                           !BCC_EOS
00708                                           ! 488   Bit32u reserved;
00709                                           !BCC_EOS
00710                                           ! 489 } ipl_entry_t;
00711                                           !BCC_EOS
00712                                           ! 490 static Bit8u inb();
00713                                           !BCC_EOS
00714                                           ! 491 static Bit8u inb_cmos();
00715                                           !BCC_EOS
00716                                           ! 492 static void outb();
00717                                           !BCC_EOS
00718                                           ! 493 static void outb_cmos();
00719                                           !BCC_EOS
00720                                           ! 494 static Bit16u inw();
00721                                           !BCC_EOS
00722                                           ! 495 static void outw();
00723                                           !BCC_EOS
00724                                           ! 496 static void init_rtc();
00725                                           !BCC_EOS
00726                                           ! 497 static bx_bool rtc_updating();
00727                                           !BCC_EOS
00728                                           ! 498 static Bit8u read_byte();
00729                                           !BCC_EOS
00730                                           ! 499 static Bit16u read_word();
00731                                           !BCC_EOS
00732                                           ! 500 static void write_byte();
00733                                           !BCC_EOS
00734                                           ! 501 static void write_word();
00735                                           !BCC_EOS
00736                                           ! 502 static void bios_printf();
00737                                           !BCC_EOS
00738                                           ! 503 static Bit8u inhibit_mouse_int_and_events();
00739                                           !BCC_EOS
00740                                           ! 504 static void enable_mouse_int_and_events();
00741                                           !BCC_EOS
00742                                           ! 505 static Bit8u send_to_mouse_ctrl();
00743                                           !BCC_EOS
00744                                           ! 506 static Bit8u get_mouse_data();
00745                                           !BCC_EOS
00746                                           ! 507 static void set_kbd_command_byte();
00747                                           !BCC_EOS
00748                                           ! 508 static void int09_function();
00749                                           !BCC_EOS
00750                                           ! 509 static void int13_harddisk();
00751                                           !BCC_EOS
00752                                           ! 510 static void int13_cdrom();
00753                                           !BCC_EOS
00754                                           ! 511 static void int13_cdemu();
00755                                           !BCC_EOS
00756                                           ! 512 static void int13_eltorito();
00757                                           !BCC_EOS
00758                                           ! 513 static void int13_diskette_function();
00759                                           !BCC_EOS
00760                                           ! 514 static void int14_function();
00761                                           !BCC_EOS
00762                                           ! 515 static void int15_function();
00763                                           !BCC_EOS
00764                                           ! 516 static void int16_function();
00765                                           !BCC_EOS
00766                                           ! 517 static void int17_function();
00767                                           !BCC_EOS
00768                                           ! 518 static void int19_function();
00769                                           !BCC_EOS
00770                                           ! 519 static void int1a_function();
00771                                           !BCC_EOS
00772                                           ! 520 static void int70_function();
00773                                           !BCC_EOS
00774                                           ! 521 static void int74_function();
00775                                           !BCC_EOS
00776                                           ! 522 static Bit16u get_CS();
00777                                           !BCC_EOS
00778                                           ! 523 static Bit16u get_SS();
00779                                           !BCC_EOS
00780                                           ! 524 static unsigned int enqueue_key();
00781                                           !BCC_EOS
00782                                           ! 525 static unsigned int dequeue_key();
00783                                           !BCC_EOS
00784                                           ! 526 static void get_hd_geometry();
00785                                           !BCC_EOS
00786                                           ! 527 static void set_diskette_ret_status();
00787                                           !BCC_EOS
00788                                           ! 528 static void set_diskette_current_cyl();
00789                                           !BCC_EOS
00790                                           ! 529 static void determine_floppy_media();
00791                                           !BCC_EOS
00792                                           ! 530 static bx_bool floppy_drive_exists();
00793                                           !BCC_EOS
00794                                           ! 531 static bx_bool floppy_drive_recal();
00795                                           !BCC_EOS
00796                                           ! 532 static bx_bool floppy_media_known();
00797                                           !BCC_EOS
00798                                           ! 533 static bx_bool floppy_media_sense();
00799                                           !BCC_EOS
00800                                           ! 534 static bx_bool set_enable_a20();
00801                                           !BCC_EOS
00802                                           ! 535 static void debugger_on();
00803                                           !BCC_EOS
00804                                           ! 536 static void debugger_off();
00805                                           !BCC_EOS
00806                                           ! 537 static void keyboard_init();
00807                                           !BCC_EOS
00808                                           ! 538 static void keyboard_panic();
00809                                           !BCC_EOS
00810                                           ! 539 static void shutdown_status_panic();
00811                                           !BCC_EOS
00812                                           ! 540 static void nmi_handler_msg();
00813                                           !BCC_EOS
00814                                           ! 541 static void delay_ticks();
00815                                           !BCC_EOS
00816                                           ! 542 static void delay_ticks_and_check_for_keystro
00817                                           ! 542 ke();
00818                                           !BCC_EOS
00819                                           ! 543 static void interactive_bootkey();
00820                                           !BCC_EOS
00821                                           ! 544 static void print_bios_banner();
00822                                           !BCC_EOS
00823                                           ! 545 static void print_boot_device();
00824                                           !BCC_EOS
00825                                           ! 546 static void print_boot_failure();
00826                                           !BCC_EOS
00827                                           ! 547 static void print_cdromboot_failure();
00828                                           !BCC_EOS
00829                                           ! 548 void ata_init();
00830                                           !BCC_EOS
00831                                           ! 549 void ata_detect();
00832                                           !BCC_EOS
00833                                           ! 550 void ata_reset();
00834                                           !BCC_EOS
00835                                           ! 551 Bit16u ata_cmd_non_data();
00836                                           !BCC_EOS
00837                                           ! 552 Bit16u ata_cmd_data_in();
00838                                           !BCC_EOS
00839                                           ! 553 Bit16u ata_cmd_data_out();
00840                                           !BCC_EOS
00841                                           ! 554 Bit16u ata_cmd_packet();
00842                                           !BCC_EOS
00843                                           ! 555 Bit16u atapi_get_sense();
00844                                           !BCC_EOS
00845                                           ! 556 Bit16u atapi_is_ready();
00846                                           !BCC_EOS
00847                                           ! 557 Bit16u atapi_is_cdrom();
00848                                           !BCC_EOS
00849                                           ! 558 void cdemu_init();
00850                                           !BCC_EOS
00851                                           ! 559 Bit8u cdemu_isactive();
00852                                           !BCC_EOS
00853                                           ! 560 Bit8u cdemu_emulated_drive();
00854                                           !BCC_EOS
00855                                           ! 561 Bit16u cdrom_boot();
00856                                           !BCC_EOS
00857                                           ! 562 static char bios_cvs_version_string[] = "$Revision: 1.231.2.1 $ $Date: 2009/06/07 07:49:09 $";
00858                                           
00859                       00000194            _bios_cvs_version_string:
00860                       00000194            .1:
00861 0194                        24            .ascii	"$Revision: 1.231.2.1 $ $Date: 2009/06/07"
00862 01BC                        20            .ascii	" 07:49:09 $"
00863 01C7                        00            .byte	0
00864                                           !BCC_EOS
00865                                           ! 563 static struct {
00866                                           ! 564   Bit16u normal;
00867                                           !BCC_EOS
00868                                           ! 565   Bit16u shift;
00869                                           !BCC_EOS
00870                                           ! 566   Bit16u control;
00871                                           !BCC_EOS
00872                                           ! 567   Bit16u alt;
00873                                           !BCC_EOS
00874                                           ! 568   Bit8u lock_flags;
00875                                           !BCC_EOS
00876                                           ! 569   } scan_to_scanascii[0x58 + 1] = {
00877                       000001C8            _scan_to_scanascii:
00878                                           ! 570       { 0, 0, 0, 0, 0 },
00879 01C8                      0000            .word	0
00880 01CA                      0000            .word	0
00881 01CC                      0000            .word	0
00882 01CE                      0000            .word	0
00883 01D0                        00            .byte	0
00884 01D1                  00000001            .blkb	1
00885                                           ! 571       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00886 01D2                      011B            .word	$11B
00887 01D4                      011B            .word	$11B
00888 01D6                      011B            .word	$11B
00889 01D8                      0100            .word	$100
00890 01DA                        00            .byte	0
00891 01DB                  00000001            .blkb	1
00892                                           ! 572       { 0x0231, 0x0221, 0, 0x7800, 0 },
00893 01DC                      0231            .word	$231
00894 01DE                      0221            .word	$221
00895 01E0                      0000            .word	0
00896 01E2                      7800            .word	$7800
00897 01E4                        00            .byte	0
00898 01E5                  00000001            .blkb	1
00899                                           ! 573       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00900 01E6                      0332            .word	$332
00901 01E8                      0340            .word	$340
00902 01EA                      0300            .word	$300
00903 01EC                      7900            .word	$7900
00904 01EE                        00            .byte	0
00905 01EF                  00000001            .blkb	1
00906                                           ! 574       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00907 01F0                      0433            .word	$433
00908 01F2                      0423            .word	$423
00909 01F4                      0000            .word	0
00910 01F6                      7A00            .word	$7A00
00911 01F8                        00            .byte	0
00912 01F9                  00000001            .blkb	1
00913                                           ! 575       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00914 01FA                      0534            .word	$534
00915 01FC                      0524            .word	$524
00916 01FE                      0000            .word	0
00917 0200                      7B00            .word	$7B00
00918 0202                        00            .byte	0
00919 0203                  00000001            .blkb	1
00920                                           ! 576       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00921 0204                      0635            .word	$635
00922 0206                      0625            .word	$625
00923 0208                      0000            .word	0
00924 020A                      7C00            .word	$7C00
00925 020C                        00            .byte	0
00926 020D                  00000001            .blkb	1
00927                                           ! 577       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00928 020E                      0736            .word	$736
00929 0210                      075E            .word	$75E
00930 0212                      071E            .word	$71E
00931 0214                      7D00            .word	$7D00
00932 0216                        00            .byte	0
00933 0217                  00000001            .blkb	1
00934                                           ! 578       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00935 0218                      0837            .word	$837
00936 021A                      0826            .word	$826
00937 021C                      0000            .word	0
00938 021E                      7E00            .word	$7E00
00939 0220                        00            .byte	0
00940 0221                  00000001            .blkb	1
00941                                           ! 579       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00942 0222                      0938            .word	$938
00943 0224                      092A            .word	$92A
00944 0226                      0000            .word	0
00945 0228                      7F00            .word	$7F00
00946 022A                        00            .byte	0
00947 022B                  00000001            .blkb	1
00948                                           ! 580       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00949 022C                      0A39            .word	$A39
00950 022E                      0A28            .word	$A28
00951 0230                      0000            .word	0
00952 0232                      8000            .word	$8000
00953 0234                        00            .byte	0
00954 0235                  00000001            .blkb	1
00955                                           ! 581       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00956 0236                      0B30            .word	$B30
00957 0238                      0B29            .word	$B29
00958 023A                      0000            .word	0
00959 023C                      8100            .word	$8100
00960 023E                        00            .byte	0
00961 023F                  00000001            .blkb	1
00962                                           ! 582       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
00963 0240                      0C2D            .word	$C2D
00964 0242                      0C5F            .word	$C5F
00965 0244                      0C1F            .word	$C1F
00966 0246                      8200            .word	$8200
00967 0248                        00            .byte	0
00968 0249                  00000001            .blkb	1
00969                                           ! 583       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
00970 024A                      0D3D            .word	$D3D
00971 024C                      0D2B            .word	$D2B
00972 024E                      0000            .word	0
00973 0250                      8300            .word	$8300
00974 0252                        00            .byte	0
00975 0253                  00000001            .blkb	1
00976                                           ! 584       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
00977 0254                      0E08            .word	$E08
00978 0256                      0E08            .word	$E08
00979 0258                      0E7F            .word	$E7F
00980 025A                      0000            .word	0
00981 025C                        00            .byte	0
00982 025D                  00000001            .blkb	1
00983                                           ! 585       { 0x0f09, 0x0f00, 0, 0, 0 },
00984 025E                      0F09            .word	$F09
00985 0260                      0F00            .word	$F00
00986 0262                      0000            .word	0
00987 0264                      0000            .word	0
00988 0266                        00            .byte	0
00989 0267                  00000001            .blkb	1
00990                                           ! 586       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
00991 0268                      1071            .word	$1071
00992 026A                      1051            .word	$1051
00993 026C                      1011            .word	$1011
00994 026E                      1000            .word	$1000
00995 0270                        40            .byte	$40
00996 0271                  00000001            .blkb	1
00997                                           ! 587       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
00998 0272                      1177            .word	$1177
00999 0274                      1157            .word	$1157
01000 0276                      1117            .word	$1117
01001 0278                      1100            .word	$1100
01002 027A                        40            .byte	$40
01003 027B                  00000001            .blkb	1
01004                                           ! 588       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01005 027C                      1265            .word	$1265
01006 027E                      1245            .word	$1245
01007 0280                      1205            .word	$1205
01008 0282                      1200            .word	$1200
01009 0284                        40            .byte	$40
01010 0285                  00000001            .blkb	1
01011                                           ! 589       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01012 0286                      1372            .word	$1372
01013 0288                      1352            .word	$1352
01014 028A                      1312            .word	$1312
01015 028C                      1300            .word	$1300
01016 028E                        40            .byte	$40
01017 028F                  00000001            .blkb	1
01018                                           ! 590       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01019 0290                      1474            .word	$1474
01020 0292                      1454            .word	$1454
01021 0294                      1414            .word	$1414
01022 0296                      1400            .word	$1400
01023 0298                        40            .byte	$40
01024 0299                  00000001            .blkb	1
01025                                           ! 591       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01026 029A                      1579            .word	$1579
01027 029C                      1559            .word	$1559
01028 029E                      1519            .word	$1519
01029 02A0                      1500            .word	$1500
01030 02A2                        40            .byte	$40
01031 02A3                  00000001            .blkb	1
01032                                           ! 592       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01033 02A4                      1675            .word	$1675
01034 02A6                      1655            .word	$1655
01035 02A8                      1615            .word	$1615
01036 02AA                      1600            .word	$1600
01037 02AC                        40            .byte	$40
01038 02AD                  00000001            .blkb	1
01039                                           ! 593       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01040 02AE                      1769            .word	$1769
01041 02B0                      1749            .word	$1749
01042 02B2                      1709            .word	$1709
01043 02B4                      1700            .word	$1700
01044 02B6                        40            .byte	$40
01045 02B7                  00000001            .blkb	1
01046                                           ! 594       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01047 02B8                      186F            .word	$186F
01048 02BA                      184F            .word	$184F
01049 02BC                      180F            .word	$180F
01050 02BE                      1800            .word	$1800
01051 02C0                        40            .byte	$40
01052 02C1                  00000001            .blkb	1
01053                                           ! 595       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01054 02C2                      1970            .word	$1970
01055 02C4                      1950            .word	$1950
01056 02C6                      1910            .word	$1910
01057 02C8                      1900            .word	$1900
01058 02CA                        40            .byte	$40
01059 02CB                  00000001            .blkb	1
01060                                           ! 596       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01061 02CC                      1A5B            .word	$1A5B
01062 02CE                      1A7B            .word	$1A7B
01063 02D0                      1A1B            .word	$1A1B
01064 02D2                      0000            .word	0
01065 02D4                        00            .byte	0
01066 02D5                  00000001            .blkb	1
01067                                           ! 597       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01068 02D6                      1B5D            .word	$1B5D
01069 02D8                      1B7D            .word	$1B7D
01070 02DA                      1B1D            .word	$1B1D
01071 02DC                      0000            .word	0
01072 02DE                        00            .byte	0
01073 02DF                  00000001            .blkb	1
01074                                           ! 598       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01075 02E0                      1C0D            .word	$1C0D
01076 02E2                      1C0D            .word	$1C0D
01077 02E4                      1C0A            .word	$1C0A
01078 02E6                      0000            .word	0
01079 02E8                        00            .byte	0
01080 02E9                  00000001            .blkb	1
01081                                           ! 599       { 0, 0, 0, 0, 0 },
01082 02EA                      0000            .word	0
01083 02EC                      0000            .word	0
01084 02EE                      0000            .word	0
01085 02F0                      0000            .word	0
01086 02F2                        00            .byte	0
01087 02F3                  00000001            .blkb	1
01088                                           ! 600       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x
01089 02F4                      1E61            .word	$1E61
01090 02F6                      1E41            .word	$1E41
01091 02F8                      1E01            .word	$1E01
01092 02FA                      1E00            .word	$1E00
01093                                           ! 600 40 },
01094 02FC                        40            .byte	$40
01095 02FD                  00000001            .blkb	1
01096                                           ! 601       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01097 02FE                      1F73            .word	$1F73
01098 0300                      1F53            .word	$1F53
01099 0302                      1F13            .word	$1F13
01100 0304                      1F00            .word	$1F00
01101 0306                        40            .byte	$40
01102 0307                  00000001            .blkb	1
01103                                           ! 602       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01104 0308                      2064            .word	$2064
01105 030A                      2044            .word	$2044
01106 030C                      2004            .word	$2004
01107 030E                      2000            .word	$2000
01108 0310                        40            .byte	$40
01109 0311                  00000001            .blkb	1
01110                                           ! 603       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01111 0312                      2166            .word	$2166
01112 0314                      2146            .word	$2146
01113 0316                      2106            .word	$2106
01114 0318                      2100            .word	$2100
01115 031A                        40            .byte	$40
01116 031B                  00000001            .blkb	1
01117                                           ! 604       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01118 031C                      2267            .word	$2267
01119 031E                      2247            .word	$2247
01120 0320                      2207            .word	$2207
01121 0322                      2200            .word	$2200
01122 0324                        40            .byte	$40
01123 0325                  00000001            .blkb	1
01124                                           ! 605       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01125 0326                      2368            .word	$2368
01126 0328                      2348            .word	$2348
01127 032A                      2308            .word	$2308
01128 032C                      2300            .word	$2300
01129 032E                        40            .byte	$40
01130 032F                  00000001            .blkb	1
01131                                           ! 606       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01132 0330                      246A            .word	$246A
01133 0332                      244A            .word	$244A
01134 0334                      240A            .word	$240A
01135 0336                      2400            .word	$2400
01136 0338                        40            .byte	$40
01137 0339                  00000001            .blkb	1
01138                                           ! 607       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01139 033A                      256B            .word	$256B
01140 033C                      254B            .word	$254B
01141 033E                      250B            .word	$250B
01142 0340                      2500            .word	$2500
01143 0342                        40            .byte	$40
01144 0343                  00000001            .blkb	1
01145                                           ! 608       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01146 0344                      266C            .word	$266C
01147 0346                      264C            .word	$264C
01148 0348                      260C            .word	$260C
01149 034A                      2600            .word	$2600
01150 034C                        40            .byte	$40
01151 034D                  00000001            .blkb	1
01152                                           ! 609       { 0x273b, 0x273a, 0, 0, 0 },
01153 034E                      273B            .word	$273B
01154 0350                      273A            .word	$273A
01155 0352                      0000            .word	0
01156 0354                      0000            .word	0
01157 0356                        00            .byte	0
01158 0357                  00000001            .blkb	1
01159                                           ! 610       { 0x2827, 0x2822, 0, 0, 0 },
01160 0358                      2827            .word	$2827
01161 035A                      2822            .word	$2822
01162 035C                      0000            .word	0
01163 035E                      0000            .word	0
01164 0360                        00            .byte	0
01165 0361                  00000001            .blkb	1
01166                                           ! 611       { 0x2960, 0x297e, 0, 0, 0 },
01167 0362                      2960            .word	$2960
01168 0364                      297E            .word	$297E
01169 0366                      0000            .word	0
01170 0368                      0000            .word	0
01171 036A                        00            .byte	0
01172 036B                  00000001            .blkb	1
01173                                           ! 612       { 0, 0, 0, 0, 0 },
01174 036C                      0000            .word	0
01175 036E                      0000            .word	0
01176 0370                      0000            .word	0
01177 0372                      0000            .word	0
01178 0374                        00            .byte	0
01179 0375                  00000001            .blkb	1
01180                                           ! 613       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01181 0376                      2B5C            .word	$2B5C
01182 0378                      2B7C            .word	$2B7C
01183 037A                      2B1C            .word	$2B1C
01184 037C                      0000            .word	0
01185 037E                        00            .byte	0
01186 037F                  00000001            .blkb	1
01187                                           ! 614       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01188 0380                      2C7A            .word	$2C7A
01189 0382                      2C5A            .word	$2C5A
01190 0384                      2C1A            .word	$2C1A
01191 0386                      2C00            .word	$2C00
01192 0388                        40            .byte	$40
01193 0389                  00000001            .blkb	1
01194                                           ! 615       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01195 038A                      2D78            .word	$2D78
01196 038C                      2D58            .word	$2D58
01197 038E                      2D18            .word	$2D18
01198 0390                      2D00            .word	$2D00
01199 0392                        40            .byte	$40
01200 0393                  00000001            .blkb	1
01201                                           ! 616       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01202 0394                      2E63            .word	$2E63
01203 0396                      2E43            .word	$2E43
01204 0398                      2E03            .word	$2E03
01205 039A                      2E00            .word	$2E00
01206 039C                        40            .byte	$40
01207 039D                  00000001            .blkb	1
01208                                           ! 617       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01209 039E                      2F76            .word	$2F76
01210 03A0                      2F56            .word	$2F56
01211 03A2                      2F16            .word	$2F16
01212 03A4                      2F00            .word	$2F00
01213 03A6                        40            .byte	$40
01214 03A7                  00000001            .blkb	1
01215                                           ! 618       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01216 03A8                      3062            .word	$3062
01217 03AA                      3042            .word	$3042
01218 03AC                      3002            .word	$3002
01219 03AE                      3000            .word	$3000
01220 03B0                        40            .byte	$40
01221 03B1                  00000001            .blkb	1
01222                                           ! 619       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01223 03B2                      316E            .word	$316E
01224 03B4                      314E            .word	$314E
01225 03B6                      310E            .word	$310E
01226 03B8                      3100            .word	$3100
01227 03BA                        40            .byte	$40
01228 03BB                  00000001            .blkb	1
01229                                           ! 620       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01230 03BC                      326D            .word	$326D
01231 03BE                      324D            .word	$324D
01232 03C0                      320D            .word	$320D
01233 03C2                      3200            .word	$3200
01234 03C4                        40            .byte	$40
01235 03C5                  00000001            .blkb	1
01236                                           ! 621       { 0x332c, 0x333c, 0, 0, 0 },
01237 03C6                      332C            .word	$332C
01238 03C8                      333C            .word	$333C
01239 03CA                      0000            .word	0
01240 03CC                      0000            .word	0
01241 03CE                        00            .byte	0
01242 03CF                  00000001            .blkb	1
01243                                           ! 622       { 0x342e, 0x343e, 0, 0, 0 },
01244 03D0                      342E            .word	$342E
01245 03D2                      343E            .word	$343E
01246 03D4                      0000            .word	0
01247 03D6                      0000            .word	0
01248 03D8                        00            .byte	0
01249 03D9                  00000001            .blkb	1
01250                                           ! 623       { 0x352f, 0x353f, 0, 0, 0 },
01251 03DA                      352F            .word	$352F
01252 03DC                      353F            .word	$353F
01253 03DE                      0000            .word	0
01254 03E0                      0000            .word	0
01255 03E2                        00            .byte	0
01256 03E3                  00000001            .blkb	1
01257                                           ! 624       { 0, 0, 0, 0, 0 },
01258 03E4                      0000            .word	0
01259 03E6                      0000            .word	0
01260 03E8                      0000            .word	0
01261 03EA                      0000            .word	0
01262 03EC                        00            .byte	0
01263 03ED                  00000001            .blkb	1
01264                                           ! 625       { 0x372a, 0x372a, 0, 0, 0 },
01265 03EE                      372A            .word	$372A
01266 03F0                      372A            .word	$372A
01267 03F2                      0000            .word	0
01268 03F4                      0000            .word	0
01269 03F6                        00            .byte	0
01270 03F7                  00000001            .blkb	1
01271                                           ! 626       { 0, 0, 0, 0, 0 },
01272 03F8                      0000            .word	0
01273 03FA                      0000            .word	0
01274 03FC                      0000            .word	0
01275 03FE                      0000            .word	0
01276 0400                        00            .byte	0
01277 0401                  00000001            .blkb	1
01278                                           ! 627       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01279 0402                      3920            .word	$3920
01280 0404                      3920            .word	$3920
01281 0406                      3920            .word	$3920
01282 0408                      3920            .word	$3920
01283 040A                        00            .byte	0
01284 040B                  00000001            .blkb	1
01285                                           ! 628       { 0, 0, 0, 0, 0 },
01286 040C                      0000            .word	0
01287 040E                      0000            .word	0
01288 0410                      0000            .word	0
01289 0412                      0000            .word	0
01290 0414                        00            .byte	0
01291 0415                  00000001            .blkb	1
01292                                           ! 629       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01293 0416                      3B00            .word	$3B00
01294 0418                      5400            .word	$5400
01295 041A                      5E00            .word	$5E00
01296 041C                      6800            .word	$6800
01297 041E                        00            .byte	0
01298 041F                  00000001            .blkb	1
01299                                           ! 630       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01300 0420                      3C00            .word	$3C00
01301 0422                      5500            .word	$5500
01302 0424                      5F00            .word	$5F00
01303 0426                      6900            .word	$6900
01304 0428                        00            .byte	0
01305 0429                  00000001            .blkb	1
01306                                           ! 631       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01307 042A                      3D00            .word	$3D00
01308 042C                      5600            .word	$5600
01309 042E                      6000            .word	$6000
01310 0430                      6A00            .word	$6A00
01311 0432                        00            .byte	0
01312 0433                  00000001            .blkb	1
01313                                           ! 632       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01314 0434                      3E00            .word	$3E00
01315 0436                      5700            .word	$5700
01316 0438                      6100            .word	$6100
01317 043A                      6B00            .word	$6B00
01318 043C                        00            .byte	0
01319 043D                  00000001            .blkb	1
01320                                           ! 633       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01321 043E                      3F00            .word	$3F00
01322 0440                      5800            .word	$5800
01323 0442                      6200            .word	$6200
01324 0444                      6C00            .word	$6C00
01325 0446                        00            .byte	0
01326 0447                  00000001            .blkb	1
01327                                           ! 634       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01328 0448                      4000            .word	$4000
01329 044A                      5900            .word	$5900
01330 044C                      6300            .word	$6300
01331 044E                      6D00            .word	$6D00
01332 0450                        00            .byte	0
01333 0451                  00000001            .blkb	1
01334                                           ! 635       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01335 0452                      4100            .word	$4100
01336 0454                      5A00            .word	$5A00
01337 0456                      6400            .word	$6400
01338 0458                      6E00            .word	$6E00
01339 045A                        00            .byte	0
01340 045B                  00000001            .blkb	1
01341                                           ! 636       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01342 045C                      4200            .word	$4200
01343 045E                      5B00            .word	$5B00
01344 0460                      6500            .word	$6500
01345 0462                      6F00            .word	$6F00
01346 0464                        00            .byte	0
01347 0465                  00000001            .blkb	1
01348                                           ! 637       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01349 0466                      4300            .word	$4300
01350 0468                      5C00            .word	$5C00
01351 046A                      6600            .word	$6600
01352 046C                      7000            .word	$7000
01353 046E                        00            .byte	0
01354 046F                  00000001            .blkb	1
01355                                           ! 638       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01356 0470                      4400            .word	$4400
01357 0472                      5D00            .word	$5D00
01358 0474                      6700            .word	$6700
01359 0476                      7100            .word	$7100
01360 0478                        00            .byte	0
01361 0479                  00000001            .blkb	1
01362                                           ! 639       { 0, 0, 0, 0, 0 },
01363 047A                      0000            .word	0
01364 047C                      0000            .word	0
01365 047E                      0000            .word	0
01366 0480                      0000            .word	0
01367 0482                        00            .byte	0
01368 0483                  00000001            .blkb	1
01369                                           ! 640       { 0, 0, 0, 0, 0 },
01370 0484                      0000            .word	0
01371 0486                      0000            .word	0
01372 0488                      0000            .word	0
01373 048A                      0000            .word	0
01374 048C                        00            .byte	0
01375 048D                  00000001            .blkb	1
01376                                           ! 641       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01377 048E                      4700            .word	$4700
01378 0490                      4737            .word	$4737
01379 0492                      7700            .word	$7700
01380 0494                      0000            .word	0
01381 0496                        20            .byte	$20
01382 0497                  00000001            .blkb	1
01383                                           ! 642       { 0x4800, 0x4838, 0, 0, 0x20 },
01384 0498                      4800            .word	$4800
01385 049A                      4838            .word	$4838
01386 049C                      0000            .word	0
01387 049E                      0000            .word	0
01388 04A0                        20            .byte	$20
01389 04A1                  00000001            .blkb	1
01390                                           ! 643       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01391 04A2                      4900            .word	$4900
01392 04A4                      4939            .word	$4939
01393 04A6                      8400            .word	$8400
01394 04A8                      0000            .word	0
01395 04AA                        20            .byte	$20
01396 04AB                  00000001            .blkb	1
01397                                           ! 644       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01398 04AC                      4A2D            .word	$4A2D
01399 04AE                      4A2D            .word	$4A2D
01400 04B0                      0000            .word	0
01401 04B2                      0000            .word	0
01402 04B4                        00            .byte	0
01403 04B5                  00000001            .blkb	1
01404                                           ! 645       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01405 04B6                      4B00            .word	$4B00
01406 04B8                      4B34            .word	$4B34
01407 04BA                      7300            .word	$7300
01408 04BC                      0000            .word	0
01409 04BE                        20            .byte	$20
01410 04BF                  00000001            .blkb	1
01411                                           ! 646       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01412 04C0                      4C00            .word	$4C00
01413 04C2                      4C35            .word	$4C35
01414 04C4                      0000            .word	0
01415 04C6                      0000            .word	0
01416 04C8                        20            .byte	$20
01417 04C9                  00000001            .blkb	1
01418                                           ! 647       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01419 04CA                      4D00            .word	$4D00
01420 04CC                      4D36            .word	$4D36
01421 04CE                      7400            .word	$7400
01422 04D0                      0000            .word	0
01423 04D2                        20            .byte	$20
01424 04D3                  00000001            .blkb	1
01425                                           ! 648       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01426 04D4                      4E2B            .word	$4E2B
01427 04D6                      4E2B            .word	$4E2B
01428 04D8                      0000            .word	0
01429 04DA                      0000            .word	0
01430 04DC                        00            .byte	0
01431 04DD                  00000001            .blkb	1
01432                                           ! 649       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01433 04DE                      4F00            .word	$4F00
01434 04E0                      4F31            .word	$4F31
01435 04E2                      7500            .word	$7500
01436 04E4                      0000            .word	0
01437 04E6                        20            .byte	$20
01438 04E7                  00000001            .blkb	1
01439                                           ! 650       { 0x5000, 0x5032, 0, 0, 0
01440 04E8                      5000            .word	$5000
01441 04EA                      5032            .word	$5032
01442 04EC                      0000            .word	0
01443 04EE                      0000            .word	0
01444                                           ! 650 x20 },
01445 04F0                        20            .byte	$20
01446 04F1                  00000001            .blkb	1
01447                                           ! 651       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01448 04F2                      5100            .word	$5100
01449 04F4                      5133            .word	$5133
01450 04F6                      7600            .word	$7600
01451 04F8                      0000            .word	0
01452 04FA                        20            .byte	$20
01453 04FB                  00000001            .blkb	1
01454                                           ! 652       { 0x5200, 0x5230, 0, 0, 0x20 },
01455 04FC                      5200            .word	$5200
01456 04FE                      5230            .word	$5230
01457 0500                      0000            .word	0
01458 0502                      0000            .word	0
01459 0504                        20            .byte	$20
01460 0505                  00000001            .blkb	1
01461                                           ! 653       { 0x5300, 0x532e, 0, 0, 0x20 },
01462 0506                      5300            .word	$5300
01463 0508                      532E            .word	$532E
01464 050A                      0000            .word	0
01465 050C                      0000            .word	0
01466 050E                        20            .byte	$20
01467 050F                  00000001            .blkb	1
01468                                           ! 654       { 0, 0, 0, 0, 0 },
01469 0510                      0000            .word	0
01470 0512                      0000            .word	0
01471 0514                      0000            .word	0
01472 0516                      0000            .word	0
01473 0518                        00            .byte	0
01474 0519                  00000001            .blkb	1
01475                                           ! 655       { 0, 0, 0, 0, 0 },
01476 051A                      0000            .word	0
01477 051C                      0000            .word	0
01478 051E                      0000            .word	0
01479 0520                      0000            .word	0
01480 0522                        00            .byte	0
01481 0523                  00000001            .blkb	1
01482                                           ! 656       { 0x565c, 0x567c, 0, 0, 0 },
01483 0524                      565C            .word	$565C
01484 0526                      567C            .word	$567C
01485 0528                      0000            .word	0
01486 052A                      0000            .word	0
01487 052C                        00            .byte	0
01488 052D                  00000001            .blkb	1
01489                                           ! 657       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01490 052E                      8500            .word	$8500
01491 0530                      8700            .word	$8700
01492 0532                      8900            .word	$8900
01493 0534                      8B00            .word	$8B00
01494 0536                        00            .byte	0
01495 0537                  00000001            .blkb	1
01496                                           ! 658       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01497 0538                      8600            .word	$8600
01498 053A                      8800            .word	$8800
01499 053C                      8A00            .word	$8A00
01500 053E                      8C00            .word	$8C00
01501 0540                        00            .byte	0
01502 0541                  00000001            .blkb	1
01503                                           ! 659       };
01504                                           !BCC_EOS
01505                                           ! 660   Bit8u
01506                                           ! 661 inb(port)
01507                                           ! 662   Bit16u port;
01508                                           
01509                                           export	_inb
01510                       00000542            _inb:
01511                                           !BCC_EOS
01512                                           ! 663 {
01513                                           ! 664 #asm
01514                                           !BCC_ASM
01515                       00000002            _inb.port	set	2
01516 0542           55                           push bp
01517 0543           89E5                         mov bp, sp
01518 0545           52                             push dx
01519 0546           8B56         04                mov dx, 4[bp]
01520 0549           EC                             in al, dx
01521 054A           5A                             pop dx
01522 054B           5D                           pop bp
01523                                           ! 672 endasm
01524                                           !BCC_ENDASM
01525                                           ! 673 }
01526 054C           C3                         ret
01527                                           ! 674   Bit16u
01528                                           ! 675 inw(port)
01529                                           ! 676   Bit16u port;
01530                                           export	_inw
01531                       0000054D            _inw:
01532                                           !BCC_EOS
01533                                           ! 677 {
01534                                           ! 678 #asm
01535                                           !BCC_ASM
01536                       00000002            _inw.port	set	2
01537 054D           55                           push bp
01538 054E           89E5                         mov bp, sp
01539 0550           52                             push dx
01540 0551           8B56         04                mov dx, 4[bp]
01541 0554           ED                             in ax, dx
01542 0555           5A                             pop dx
01543 0556           5D                           pop bp
01544                                           ! 686 endasm
01545                                           !BCC_ENDASM
01546                                           ! 687 }
01547 0557           C3                         ret
01548                                           ! 688   void
01549                                           ! 689 outb(port, val)
01550                                           ! 690   Bit16u port;
01551                                           export	_outb
01552                       00000558            _outb:
01553                                           !BCC_EOS
01554                                           ! 691   Bit8u val;
01555                                           !BCC_EOS
01556                                           ! 692 {
01557                                           ! 693 #asm
01558                                           !BCC_ASM
01559                       00000004            _outb.val	set	4
01560                       00000002            _outb.port	set	2
01561 0558           55                           push bp
01562 0559           89E5                         mov bp, sp
01563 055B           50                             push ax
01564 055C           52                             push dx
01565 055D           8B56         04                mov dx, 4[bp]
01566 0560           8A46         06                mov al, 6[bp]
01567 0563           EE                             out dx, al
01568 0564           5A                             pop dx
01569 0565           58                             pop ax
01570 0566           5D                           pop bp
01571                                           ! 704 endasm
01572                                           !BCC_ENDASM
01573                                           ! 705 }
01574 0567           C3                         ret
01575                                           ! 706   void
01576                                           ! 707 outw(port, val)
01577                                           ! 708   Bit16u port;
01578                                           export	_outw
01579                       00000568            _outw:
01580                                           !BCC_EOS
01581                                           ! 709   Bit16u val;
01582                                           !BCC_EOS
01583                                           ! 710 {
01584                                           ! 711 #asm
01585                                           !BCC_ASM
01586                       00000004            _outw.val	set	4
01587                       00000002            _outw.port	set	2
01588 0568           55                           push bp
01589 0569           89E5                         mov bp, sp
01590 056B           50                             push ax
01591 056C           52                             push dx
01592 056D           8B56         04                mov dx, 4[bp]
01593 0570           8B46         06                mov ax, 6[bp]
01594 0573           EF                             out dx, ax
01595 0574           5A                             pop dx
01596 0575           58                             pop ax
01597 0576           5D                           pop bp
01598                                           ! 722 endasm
01599                                           !BCC_ENDASM
01600                                           ! 723 }
01601 0577           C3                         ret
01602                                           ! 724   void
01603                                           ! 725 outb_cmos(cmos_reg, val)
01604                                           ! 726   Bit8u cmos_reg;
01605                                           export	_outb_cmos
01606                       00000578            _outb_cmos:
01607                                           !BCC_EOS
01608                                           ! 727   Bit8u val;
01609                                           !BCC_EOS
01610                                           ! 728 {
01611                                           ! 729 #asm
01612                                           !BCC_ASM
01613                       00000002            _outb_cmos.cmos_reg	set	2
01614                       00000004            _outb_cmos.val	set	4
01615 0578           55                           push bp
01616 0579           89E5                         mov bp, sp
01617 057B           8A46         04                mov al, 4[bp] ;; cmos_reg
01618 057E           E6                     70      out 0x70, al
01619 0580           8A46         06                mov al, 6[bp] ;; val
01620 0583           E6                     71      out 0x71, al
01621 0585           5D                           pop bp
01622                                           ! 737 endasm
01623                                           !BCC_ENDASM
01624                                           ! 738 }
01625 0586           C3                         ret
01626                                           ! 739   Bit8u
01627                                           ! 740 inb_cmos(cmos_reg)
01628                                           ! 741   Bit8u cmos_reg;
01629                                           export	_inb_cmos
01630                       00000587            _inb_cmos:
01631                                           !BCC_EOS
01632                                           ! 742 {
01633                                           ! 743 #asm
01634                                           !BCC_ASM
01635                       00000002            _inb_cmos.cmos_reg	set	2
01636 0587           55                           push bp
01637 0588           89E5                         mov bp, sp
01638 058A           8A46         04                mov al, 4[bp] ;; cmos_reg
01639 058D           E6                     70      out 0x70, al
01640 058F           E4                     71      in al, 0x71
01641 0591           5D                           pop bp
01642                                           ! 750 endasm
01643                                           !BCC_ENDASM
01644                                           ! 751 }
01645 0592           C3                         ret
01646                                           ! 752   void
01647                                           ! 753 init_rtc()
01648                                           ! 754 {
01649                                           export	_init_rtc
01650                       00000593            _init_rtc:
01651                                           ! 755   outb_cmos(0x0a, 0x26);
01652 0593           55                         push	bp
01653 0594           89E5                       mov	bp,sp
01654                                           ! Debug: list int = const $26 (used reg = )
01655 0596           B8                   0026  mov	ax,*$26
01656 0599           50                         push	ax
01657                                           ! Debug: list int = const $A (used reg = )
01658 059A           B8                   000A  mov	ax,*$A
01659 059D           50                         push	ax
01660                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01661 059E           E8         FFD7            call	_outb_cmos
01662 05A1           89EC                       mov	sp,bp
01663                                           !BCC_EOS
01664                                           ! 756   outb_cmos(0x0b, 0x02);
01665                                           ! Debug: list int = const 2 (used reg = )
01666 05A3           B8                   0002  mov	ax,*2
01667 05A6           50                         push	ax
01668                                           ! Debug: list int = const $B (used reg = )
01669 05A7           B8                   000B  mov	ax,*$B
01670 05AA           50                         push	ax
01671                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01672 05AB           E8         FFCA            call	_outb_cmos
01673 05AE           89EC                       mov	sp,bp
01674                                           !BCC_EOS
01675                                           ! 757   inb_cmos(0x0c);
01676                                           ! Debug: list int = const $C (used reg = )
01677 05B0           B8                   000C  mov	ax,*$C
01678 05B3           50                         push	ax
01679                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01680 05B4           E8         FFD0            call	_inb_cmos
01681 05B7           89EC                       mov	sp,bp
01682                                           !BCC_EOS
01683                                           ! 758   inb_cmos(0x0d);
01684                                           ! Debug: list int = const $D (used reg = )
01685 05B9           B8                   000D  mov	ax,*$D
01686 05BC           50                         push	ax
01687                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01688 05BD           E8         FFC7            call	_inb_cmos
01689 05C0           89EC                       mov	sp,bp
01690                                           !BCC_EOS
01691                                           ! 759 }
01692 05C2           5D                         pop	bp
01693 05C3           C3                         ret
01694                                           ! 760   bx_bool
01695                                           ! 761 rtc_updating()
01696                                           ! 762 {
01697                                           export	_rtc_updating
01698                       000005C4            _rtc_updating:
01699                                           ! 763   Bit16u count;
01700                                           !BCC_EOS
01701                                           ! 764   count = 25000;
01702 05C4           55                         push	bp
01703 05C5           89E5                       mov	bp,sp
01704 05C7           4C                         dec	sp
01705 05C8           4C                         dec	sp
01706                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01707 05C9           B8                   61A8  mov	ax,#$61A8
01708 05CC           8946         FE            mov	-2[bp],ax
01709                                           !BCC_EOS
01710                                           ! 765   while (--count != 0) {
01711 05CF           EB           15            jmp .3
01712                       000005D1            .4:
01713                                           ! 766     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01714                                           ! Debug: list int = const $A (used reg = )
01715 05D1           B8                   000A  mov	ax,*$A
01716 05D4           50                         push	ax
01717                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01718 05D5           E8         FFAF            call	_inb_cmos
01719 05D8           44                         inc	sp
01720 05D9           44                         inc	sp
01721                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01722 05DA           24                     80  and	al,#$80
01723                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01724 05DC           84C0                       test	al,al
01725 05DE           75           06            jne 	.5
01726                       000005E0            .6:
01727                                           ! 767       return(0);
01728 05E0           31C0                       xor	ax,ax
01729 05E2           89EC                       mov	sp,bp
01730 05E4           5D                         pop	bp
01731 05E5           C3                         ret
01732                                           !BCC_EOS
01733                                           ! 768     }
01734                       000005E6            .5:
01735                                           ! 769   return(1);
01736                       000005E6            .3:
01737                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01738 05E6           8B46         FE            mov	ax,-2[bp]
01739 05E9           48                         dec	ax
01740 05EA           8946         FE            mov	-2[bp],ax
01741                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01742 05ED           85C0                       test	ax,ax
01743 05EF           75           E0            jne	.4
01744                       000005F1            .7:
01745                       000005F1            .2:
01746 05F1           B8                   0001  mov	ax,*1
01747 05F4           89EC                       mov	sp,bp
01748 05F6           5D                         pop	bp
01749 05F7           C3                         ret
01750                                           !BCC_EOS
01751                                           ! 770 }
01752                                           ! 771   Bit8u
01753                                           ! 772 read_byte(seg, offset)
01754                                           ! 773   Bit16u seg;
01755                                           export	_read_byte
01756                       000005F8            _read_byte:
01757                                           !BCC_EOS
01758                                           ! 774   Bit16u offset;
01759                                           !BCC_EOS
01760                                           ! 775 {
01761                                           ! 776 #asm
01762                                           !BCC_ASM
01763                       00000002            _read_byte.seg	set	2
01764                       00000004            _read_byte.offset	set	4
01765 05F8           55                           push bp
01766 05F9           89E5                         mov bp, sp
01767 05FB           53                             push bx
01768 05FC           1E                             push ds
01769 05FD           8B46         04                mov ax, 4[bp] ; segment
01770 0600           8ED8                           mov ds, ax
01771 0602           8B5E         06                mov bx, 6[bp] ; offset
01772 0605           8A07                           mov al, [bx]
01773                                               ;; al = return value (byte)
01774 0607           1F                             pop ds
01775 0608           5B                             pop bx
01776 0609           5D                           pop bp
01777                                           ! 789 endasm
01778                                           !BCC_ENDASM
01779                                           ! 790 }
01780 060A           C3                         ret
01781                                           ! 791   Bit16u
01782                                           ! 792 read_word(seg, offset)
01783                                           ! 793   Bit16u seg;
01784                                           export	_read_word
01785                       0000060B            _read_word:
01786                                           !BCC_EOS
01787                                           ! 794   Bit16u offset;
01788                                           !BCC_EOS
01789                                           ! 795 {
01790                                           ! 796 #asm
01791                                           !BCC_ASM
01792                       00000002            _read_word.seg	set	2
01793                       00000004            _read_word.offset	set	4
01794 060B           55                           push bp
01795 060C           89E5                         mov bp, sp
01796 060E           53                             push bx
01797 060F           1E                             push ds
01798 0610           8B46         04                mov ax, 4[bp] ; segment
01799 0613           8ED8                           mov ds, ax
01800 0615           8B5E         06                mov bx, 6[bp] ; offset
01801 0618           8B07                           mov ax, [bx]
01802                                               ;; ax = return value (word)
01803 061A           1F                             pop ds
01804 061B           5B                             pop bx
01805 061C           5D                           pop bp
01806                                           ! 809 endasm
01807                                           !BCC_ENDASM
01808                                           ! 810 }
01809 061D           C3                         ret
01810                                           ! 811   void
01811                                           ! 812 write_byte(seg, offset, data)
01812                                           ! 813   Bit16u seg;
01813                                           export	_write_byte
01814                       0000061E            _write_byte:
01815                                           !BCC_EOS
01816                                           ! 814   Bit16u offset;
01817                                           !BCC_EOS
01818                                           ! 815   Bit8u data;
01819                                           !BCC_EOS
01820                                           ! 816 {
01821                                           ! 817 #asm
01822                                           !BCC_ASM
01823                       00000002            _write_byte.seg	set	2
01824                       00000006            _write_byte.data	set	6
01825                       00000004            _write_byte.offset	set	4
01826 061E           55                           push bp
01827 061F           89E5                         mov bp, sp
01828 0621           50                             push ax
01829 0622           53                             push bx
01830 0623           1E                             push ds
01831 0624           8B46         04                mov ax, 4[bp] ; segment
01832 0627           8ED8                           mov ds, ax
01833 0629           8B5E         06                mov bx, 6[bp] ; offset
01834 062C           8A46         08                mov al, 8[bp] ; data byte
01835 062F           8807                           mov [bx], al ; write data byte
01836 0631           1F                             pop ds
01837 0632           5B                             pop bx
01838 0633           58                             pop ax
01839 0634           5D                           pop bp
01840                                           ! 832 endasm
01841                                           !BCC_ENDASM
01842                                           ! 833 }
01843 0635           C3                         ret
01844                                           ! 834   void
01845                                           ! 835 write_word(seg, offset, data)
01846                                           ! 836   Bit16u seg;
01847                                           export	_write_word
01848                       00000636            _write_word:
01849                                           !BCC_EOS
01850                                           ! 837   Bit16u offset;
01851                                           !BCC_EOS
01852                                           ! 838   Bit16u data;
01853                                           !BCC_EOS
01854                                           ! 839 {
01855                                           ! 840 #asm
01856                                           !BCC_ASM
01857                       00000002            _write_word.seg	set	2
01858                       00000006            _write_word.data	set	6
01859                       00000004            _write_word.offset	set	4
01860 0636           55                           push bp
01861 0637           89E5                         mov bp, sp
01862 0639           50                             push ax
01863 063A           53                             push bx
01864 063B           1E                             push ds
01865 063C           8B46         04                mov ax, 4[bp] ; segment
01866 063F           8ED8                           mov ds, ax
01867 0641           8B5E         06                mov bx, 6[bp] ; offset
01868 0644           8B46         08                mov ax, 8[bp] ; data word
01869 0647           8907                           mov [bx], ax ; write data word
01870 0649           1F                             pop ds
01871 064A           5B                             pop bx
01872 064B           58                             pop ax
01873 064C           5D                           pop bp
01874                                           ! 855 endasm
01875                                           !BCC_ENDASM
01876                                           ! 856 }
01877 064D           C3                         ret
01878                                           ! 857   Bit16u
01879                                           ! 858 get_CS()
01880                                           ! 859 {
01881                                           export	_get_CS
01882                       0000064E            _get_CS:
01883                                           ! 860 #asm
01884                                           !BCC_ASM
01885 064E           8CC8                         mov ax, cs
01886                                           ! 862 endasm
01887                                           !BCC_ENDASM
01888                                           ! 863 }
01889 0650           C3                         ret
01890                                           ! 864   Bit16u
01891                                           ! 865 get_SS()
01892                                           ! 866 {
01893                                           export	_get_SS
01894                       00000651            _get_SS:
01895                                           ! 867 #asm
01896                                           !BCC_ASM
01897 0651           8CD0                         mov ax, ss
01898                                           ! 869 endasm
01899                                           !BCC_ENDASM
01900                                           ! 870 }
01901 0653           C3                         ret
01902                                           ! 871   void
01903                                           ! 872 wrch(c)
01904                                           ! 873   Bit8u c;
01905                                           export	_wrch
01906                       00000654            _wrch:
01907                                           !BCC_EOS
01908                                           ! 874 {
01909                                           ! 875 #asm
01910                                           !BCC_ASM
01911                       00000002            _wrch.c	set	2
01912 0654           55                           push bp
01913 0655           89E5                         mov bp, sp
01914 0657           53                           push bx
01915 0658           B4                     0E    mov ah, #0x0e
01916 065A           8A46         04              mov al, 4[bp]
01917 065D           31DB                         xor bx,bx
01918 065F           CD                     10    int #0x10
01919 0661           5B                           pop bx
01920 0662           5D                           pop bp
01921                                           ! 885 endasm
01922                                           !BCC_ENDASM
01923                                           ! 886 }
01924 0663           C3                         ret
01925                                           ! 887   void
01926                                           ! 888 send(action, c)
01927                                           ! 889   Bit16u action;
01928                                           export	_send
01929                       00000664            _send:
01930                                           !BCC_EOS
01931                                           ! 890   Bit8u c;
01932                                           !BCC_EOS
01933                                           ! 891 {
01934                                           ! 892   if (action & 8) outb(0x403, c);
01935 0664           55                         push	bp
01936 0665           89E5                       mov	bp,sp
01937                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
01938 0667           8A46         04            mov	al,4[bp]
01939 066A           24                     08  and	al,*8
01940 066C           84C0                       test	al,al
01941 066E           74           0F            je  	.8
01942                       00000670            .9:
01943                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01944 0670           8A46         06            mov	al,6[bp]
01945 0673           30E4                       xor	ah,ah
01946 0675           50                         push	ax
01947                                           ! Debug: list int = const $403 (used reg = )
01948 0676           B8                   0403  mov	ax,#$403
01949 0679           50                         push	ax
01950                                           ! Debug: func () void = outb+0 (used reg = )
01951 067A           E8         FEDB            call	_outb
01952 067D           89EC                       mov	sp,bp
01953                                           !BCC_EOS
01954                                           ! 893   if (action & 4) outb(0x402, c);
01955                       0000067F            .8:
01956                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
01957 067F           8A46         04            mov	al,4[bp]
01958 0682           24                     04  and	al,*4
01959 0684           84C0                       test	al,al
01960 0686           74           0F            je  	.A
01961                       00000688            .B:
01962                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01963 0688           8A46         06            mov	al,6[bp]
01964 068B           30E4                       xor	ah,ah
01965 068D           50                         push	ax
01966                                           ! Debug: list int = const $402 (used reg = )
01967 068E           B8                   0402  mov	ax,#$402
01968 0691           50                         push	ax
01969                                           ! Debug: func () void = outb+0 (used reg = )
01970 0692           E8         FEC3            call	_outb
01971 0695           89EC                       mov	sp,bp
01972                                           !BCC_EOS
01973                                           ! 894   if (action & 2) {
01974                       00000697            .A:
01975                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
01976 0697           8A46         04            mov	al,4[bp]
01977 069A           24                     02  and	al,*2
01978 069C           84C0                       test	al,al
01979 069E           74           1B            je  	.C
01980                       000006A0            .D:
01981                                           ! 895     if (c == '\n') wrch('\r');
01982                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
01983 06A0           8A46         06            mov	al,6[bp]
01984 06A3           3C                     0A  cmp	al,*$A
01985 06A5           75           09            jne 	.E
01986                       000006A7            .F:
01987                                           ! Debug: list int = const $D (used reg = )
01988 06A7           B8                   000D  mov	ax,*$D
01989 06AA           50                         push	ax
01990                                           ! Debug: func () void = wrch+0 (used reg = )
01991 06AB           E8         FFA6            call	_wrch
01992 06AE           89EC                       mov	sp,bp
01993                                           !BCC_EOS
01994                                           ! 896     wrch(c);
01995                       000006B0            .E:
01996                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
01997 06B0           8A46         06            mov	al,6[bp]
01998 06B3           30E4                       xor	ah,ah
01999 06B5           50                         push	ax
02000                                           ! Debug: func () void = wrch+0 (used reg = )
02001 06B6           E8         FF9B            call	_wrch
02002 06B9           89EC                       mov	sp,bp
02003                                           !BCC_EOS
02004                                           ! 897   }
02005                                           ! 898 }
02006                       000006BB            .C:
02007 06BB           5D                         pop	bp
02008 06BC           C3                         ret
02009                                           ! 899   void
02010                                           ! 900 put_int(action, val, width, neg)
02011                                           ! 901   Bit16u action;
02012                                           export	_put_int
02013                       000006BD            _put_int:
02014                                           !BCC_EOS
02015                                           ! 902   short val, width;
02016                                           !BCC_EOS
02017                                           ! 903   bx_bool neg;
02018                                           !BCC_EOS
02019                                           ! 904 {
02020                                           ! 905   short nval = val / 10;
02021 06BD           55                         push	bp
02022 06BE           89E5                       mov	bp,sp
02023 06C0           4C                         dec	sp
02024 06C1           4C                         dec	sp
02025                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02026 06C2           8B46         06            mov	ax,6[bp]
02027 06C5           BB                   000A  mov	bx,*$A
02028 06C8           99                         cwd
02029 06C9           F7FB                       idiv	bx
02030                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02031 06CB           8946         FE            mov	-2[bp],ax
02032                                           !BCC_EOS
02033                                           ! 906   if (nval)
02034 06CE           8B46         FE            mov	ax,-2[bp]
02035 06D1           85C0                       test	ax,ax
02036 06D3           74           16            je  	.10
02037                       000006D5            .11:
02038                                           ! 907     put_int(action, nval, width - 1, neg);
02039                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02040 06D5           FF76         0A            push	$A[bp]
02041                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02042 06D8           8B46         08            mov	ax,8[bp]
02043                                           ! Debug: list int = ax-1 (used reg = )
02044 06DB           48                         dec	ax
02045 06DC           50                         push	ax
02046                                           ! Debug: list short nval = [S+8-4] (used reg = )
02047 06DD           FF76         FE            push	-2[bp]
02048                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02049 06E0           FF76         04            push	4[bp]
02050                                           ! Debug: func () void = put_int+0 (used reg = )
02051 06E3           E8         FFD7            call	_put_int
02052 06E6           83C4                   08  add	sp,*8
02053                                           !BCC_EOS
02054                                           ! 908   else {
02055 06E9           EB           2E            jmp .12
02056                       000006EB            .10:
02057                                           ! 909     while (--width > 0) send(action, ' ');
02058 06EB           EB           0D            jmp .14
02059                       000006ED            .15:
02060                                           ! Debug: list int = const $20 (used reg = )
02061 06ED           B8                   0020  mov	ax,*$20
02062 06F0           50                         push	ax
02063                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02064 06F1           FF76         04            push	4[bp]
02065                                           ! Debug: func () void = send+0 (used reg = )
02066 06F4           E8         FF6D            call	_send
02067 06F7           83C4                   04  add	sp,*4
02068                                           !BCC_EOS
02069                                           ! 910     if (neg) send(action, '-');
02070                       000006FA            .14:
02071                                           ! Debug: predec short width = [S+4+6] (used reg = )
02072 06FA           8B46         08            mov	ax,8[bp]
02073 06FD           48                         dec	ax
02074 06FE           8946         08            mov	8[bp],ax
02075                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02076 0701           85C0                       test	ax,ax
02077 0703           7F           E8            jg 	.15
02078                       00000705            .16:
02079                       00000705            .13:
02080 0705           8B46         0A            mov	ax,$A[bp]
02081 0708           85C0                       test	ax,ax
02082 070A           74           0D            je  	.17
02083                       0000070C            .18:
02084                                           ! Debug: list int = const $2D (used reg = )
02085 070C           B8                   002D  mov	ax,*$2D
02086 070F           50                         push	ax
02087                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02088 0710           FF76         04            push	4[bp]
02089                                           ! Debug: func () void = send+0 (used reg = )
02090 0713           E8         FF4E            call	_send
02091 0716           83C4                   04  add	sp,*4
02092                                           !BCC_EOS
02093                                           ! 911   }
02094                       00000719            .17:
02095                                           ! 912   send(action, val - (nval * 10) + '0');
02096                       00000719            .12:
02097                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02098 0719           8B46         FE            mov	ax,-2[bp]
02099 071C           89C2                       mov	dx,ax
02100 071E           D1E0                       shl	ax,*1
02101 0720           D1E0                       shl	ax,*1
02102 0722           01D0                       add	ax,dx
02103 0724           D1E0                       shl	ax,*1
02104                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02105 0726           50                         push	ax
02106 0727           8B46         06            mov	ax,6[bp]
02107 072A           2B46         FC            sub	ax,-4[bp]
02108 072D           44                         inc	sp
02109 072E           44                         inc	sp
02110                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02111                                           ! Debug: list int = ax+$30 (used reg = )
02112 072F           05                   0030  add	ax,*$30
02113 0732           50                         push	ax
02114                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02115 0733           FF76         04            push	4[bp]
02116                                           ! Debug: func () void = send+0 (used reg = )
02117 0736           E8         FF2B            call	_send
02118 0739           83C4                   04  add	sp,*4
02119                                           !BCC_EOS
02120                                           ! 913 }
02121 073C           89EC                       mov	sp,bp
02122 073E           5D                         pop	bp
02123 073F           C3                         ret
02124                                           ! 914   void
02125                                           ! Register BX used in function put_int
02126                                           ! 915 put_uint(action, val, width, neg)
02127                                           ! 916   Bit16u action;
02128                                           export	_put_uint
02129                       00000740            _put_uint:
02130                                           !BCC_EOS
02131                                           ! 917   unsigned short val;
02132                                           !BCC_EOS
02133                                           ! 918   short width;
02134                                           !BCC_EOS
02135                                           ! 919   bx_bool neg;
02136                                           !BCC_EOS
02137                                           ! 920 {
02138                                           ! 921   unsigned short nval = val / 10;
02139 0740           55                         push	bp
02140 0741           89E5                       mov	bp,sp
02141 0743           4C                         dec	sp
02142 0744           4C                         dec	sp
02143                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02144 0745           8B46         06            mov	ax,6[bp]
02145 0748           BB                   000A  mov	bx,*$A
02146 074B           E8         FA1B            call	idiv_u
02147                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02148 074E           8946         FE            mov	-2[bp],ax
02149                                           !BCC_EOS
02150                                           ! 922   if (nval)
02151 0751           8B46         FE            mov	ax,-2[bp]
02152 0754           85C0                       test	ax,ax
02153 0756           74           16            je  	.19
02154                       00000758            .1A:
02155                                           ! 923     put_uint(action, nval, width - 1, neg);
02156                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02157 0758           FF76         0A            push	$A[bp]
02158                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02159 075B           8B46         08            mov	ax,8[bp]
02160                                           ! Debug: list int = ax-1 (used reg = )
02161 075E           48                         dec	ax
02162 075F           50                         push	ax
02163                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02164 0760           FF76         FE            push	-2[bp]
02165                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02166 0763           FF76         04            push	4[bp]
02167                                           ! Debug: func () void = put_uint+0 (used reg = )
02168 0766           E8         FFD7            call	_put_uint
02169 0769           83C4                   08  add	sp,*8
02170                                           !BCC_EOS
02171                                           ! 924   else {
02172 076C           EB           2E            jmp .1B
02173                       0000076E            .19:
02174                                           ! 925     while (--width > 0) send(action, ' ');
02175 076E           EB           0D            jmp .1D
02176                       00000770            .1E:
02177                                           ! Debug: list int = const $20 (used reg = )
02178 0770           B8                   0020  mov	ax,*$20
02179 0773           50                         push	ax
02180                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02181 0774           FF76         04            push	4[bp]
02182                                           ! Debug: func () void = send+0 (used reg = )
02183 0777           E8         FEEA            call	_send
02184 077A           83C4                   04  add	sp,*4
02185                                           !BCC_EOS
02186                                           ! 926     if (neg) send(action, '-');
02187                       0000077D            .1D:
02188                                           ! Debug: predec short width = [S+4+6] (used reg = )
02189 077D           8B46         08            mov	ax,8[bp]
02190 0780           48                         dec	ax
02191 0781           8946         08            mov	8[bp],ax
02192                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02193 0784           85C0                       test	ax,ax
02194 0786           7F           E8            jg 	.1E
02195                       00000788            .1F:
02196                       00000788            .1C:
02197 0788           8B46         0A            mov	ax,$A[bp]
02198 078B           85C0                       test	ax,ax
02199 078D           74           0D            je  	.20
02200                       0000078F            .21:
02201                                           ! Debug: list int = const $2D (used reg = )
02202 078F           B8                   002D  mov	ax,*$2D
02203 0792           50                         push	ax
02204                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02205 0793           FF76         04            push	4[bp]
02206                                           ! Debug: func () void = send+0 (used reg = )
02207 0796           E8         FECB            call	_send
02208 0799           83C4                   04  add	sp,*4
02209                                           !BCC_EOS
02210                                           ! 927   }
02211                       0000079C            .20:
02212                                           ! 928   send(action, val - (nval * 10) + '0');
02213                       0000079C            .1B:
02214                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02215 079C           8B46         FE            mov	ax,-2[bp]
02216 079F           89C2                       mov	dx,ax
02217 07A1           D1E0                       shl	ax,*1
02218 07A3           D1E0                       shl	ax,*1
02219 07A5           01D0                       add	ax,dx
02220 07A7           D1E0                       shl	ax,*1
02221                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02222 07A9           50                         push	ax
02223 07AA           8B46         06            mov	ax,6[bp]
02224 07AD           2B46         FC            sub	ax,-4[bp]
02225 07B0           44                         inc	sp
02226 07B1           44                         inc	sp
02227                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02228                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02229 07B2           05                   0030  add	ax,*$30
02230 07B5           50                         push	ax
02231                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02232 07B6           FF76         04            push	4[bp]
02233                                           ! Debug: func () void = send+0 (used reg = )
02234 07B9           E8         FEA8            call	_send
02235 07BC           83C4                   04  add	sp,*4
02236                                           !BCC_EOS
02237                                           ! 929 }
02238 07BF           89EC                       mov	sp,bp
02239 07C1           5D                         pop	bp
02240 07C2           C3                         ret
02241                                           ! 930   void
02242                                           ! Register BX used in function put_uint
02243                                           ! 931 put_luint(action, val, width, neg)
02244                                           ! 932   Bit16u action;
02245                                           export	_put_luint
02246                       000007C3            _put_luint:
02247                                           !BCC_EOS
02248                                           ! 933   unsigned long val;
02249                                           !BCC_EOS
02250                                           ! 934   short width;
02251                                           !BCC_EOS
02252                                           ! 935   bx_bool neg;
02253                                           !BCC_EOS
02254                                           ! 936 {
02255                                           ! 937   unsigned long nval = val / 10;
02256 07C3           55                         push	bp
02257 07C4           89E5                       mov	bp,sp
02258 07C6           83C4                   FC  add	sp,*-4
02259                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02260 07C9           B8                   000A  mov	ax,*$A
02261 07CC           31DB                       xor	bx,bx
02262 07CE           53                         push	bx
02263 07CF           50                         push	ax
02264 07D0           8B46         06            mov	ax,6[bp]
02265 07D3           8B5E         08            mov	bx,8[bp]
02266 07D6           8D7E         F8            lea	di,-8[bp]
02267 07D9           E8         F992            call	ldivul
02268 07DC           83C4                   04  add	sp,*4
02269                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02270 07DF           8946         FC            mov	-4[bp],ax
02271 07E2           895E         FE            mov	-2[bp],bx
02272                                           !BCC_EOS
02273                                           ! 938   if (nval)
02274 07E5           8B46         FC            mov	ax,-4[bp]
02275 07E8           8B5E         FE            mov	bx,-2[bp]
02276 07EB           E8         F926            call	ltstl
02277 07EE           74           19            je  	.22
02278                       000007F0            .23:
02279                                           ! 939     put_luint(action, nval, wid
02280                                           ! 939 th - 1, neg);
02281                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02282 07F0           FF76         0C            push	$C[bp]
02283                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02284 07F3           8B46         0A            mov	ax,$A[bp]
02285                                           ! Debug: list int = ax-1 (used reg = )
02286 07F6           48                         dec	ax
02287 07F7           50                         push	ax
02288                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02289 07F8           FF76         FE            push	-2[bp]
02290 07FB           FF76         FC            push	-4[bp]
02291                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02292 07FE           FF76         04            push	4[bp]
02293                                           ! Debug: func () void = put_luint+0 (used reg = )
02294 0801           E8         FFBF            call	_put_luint
02295 0804           83C4                   0A  add	sp,*$A
02296                                           !BCC_EOS
02297                                           ! 940   else {
02298 0807           EB           2E            jmp .24
02299                       00000809            .22:
02300                                           ! 941     while (--width > 0) send(action, ' ');
02301 0809           EB           0D            jmp .26
02302                       0000080B            .27:
02303                                           ! Debug: list int = const $20 (used reg = )
02304 080B           B8                   0020  mov	ax,*$20
02305 080E           50                         push	ax
02306                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02307 080F           FF76         04            push	4[bp]
02308                                           ! Debug: func () void = send+0 (used reg = )
02309 0812           E8         FE4F            call	_send
02310 0815           83C4                   04  add	sp,*4
02311                                           !BCC_EOS
02312                                           ! 942     if (neg) send(action, '-');
02313                       00000818            .26:
02314                                           ! Debug: predec short width = [S+6+8] (used reg = )
02315 0818           8B46         0A            mov	ax,$A[bp]
02316 081B           48                         dec	ax
02317 081C           8946         0A            mov	$A[bp],ax
02318                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02319 081F           85C0                       test	ax,ax
02320 0821           7F           E8            jg 	.27
02321                       00000823            .28:
02322                       00000823            .25:
02323 0823           8B46         0C            mov	ax,$C[bp]
02324 0826           85C0                       test	ax,ax
02325 0828           74           0D            je  	.29
02326                       0000082A            .2A:
02327                                           ! Debug: list int = const $2D (used reg = )
02328 082A           B8                   002D  mov	ax,*$2D
02329 082D           50                         push	ax
02330                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02331 082E           FF76         04            push	4[bp]
02332                                           ! Debug: func () void = send+0 (used reg = )
02333 0831           E8         FE30            call	_send
02334 0834           83C4                   04  add	sp,*4
02335                                           !BCC_EOS
02336                                           ! 943   }
02337                       00000837            .29:
02338                                           ! 944   send(action, val - (nval * 10) + '0');
02339                       00000837            .24:
02340                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02341                                           ! Debug: expression subtree swapping
02342 0837           B8                   000A  mov	ax,*$A
02343 083A           31DB                       xor	bx,bx
02344 083C           8D7E         FC            lea	di,-4[bp]
02345 083F           E8         F8A7            call	lmulul
02346                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02347 0842           53                         push	bx
02348 0843           50                         push	ax
02349 0844           8B46         06            mov	ax,6[bp]
02350 0847           8B5E         08            mov	bx,8[bp]
02351 084A           8D7E         F8            lea	di,-8[bp]
02352 084D           E8         F891            call	lsubul
02353 0850           83C4                   04  add	sp,*4
02354                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02355 0853           53                         push	bx
02356 0854           50                         push	ax
02357 0855           B8                   0030  mov	ax,*$30
02358 0858           31DB                       xor	bx,bx
02359 085A           53                         push	bx
02360 085B           50                         push	ax
02361 085C           8B46         F8            mov	ax,-8[bp]
02362 085F           8B5E         FA            mov	bx,-6[bp]
02363 0862           8D7E         F4            lea	di,-$C[bp]
02364 0865           E8         F85B            call	laddul
02365 0868           83C4                   08  add	sp,*8
02366                                           ! Debug: list unsigned long = bx+0 (used reg = )
02367 086B           53                         push	bx
02368 086C           50                         push	ax
02369                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02370 086D           FF76         04            push	4[bp]
02371                                           ! Debug: func () void = send+0 (used reg = )
02372 0870           E8         FDF1            call	_send
02373 0873           83C4                   06  add	sp,*6
02374                                           !BCC_EOS
02375                                           ! 945 }
02376 0876           89EC                       mov	sp,bp
02377 0878           5D                         pop	bp
02378 0879           C3                         ret
02379                                           ! 946 void put_str(action, segment, offset)
02380                                           ! Register BX used in function put_luint
02381                                           ! 947   Bit16u action;
02382                                           export	_put_str
02383                       0000087A            _put_str:
02384                                           !BCC_EOS
02385                                           ! 948   Bit16u segment;
02386                                           !BCC_EOS
02387                                           ! 949   Bit16u offset;
02388                                           !BCC_EOS
02389                                           ! 950 {
02390                                           ! 951   Bit8u c;
02391                                           !BCC_EOS
02392                                           ! 952   while (c = read_byte(segment, offset)) {
02393 087A           55                         push	bp
02394 087B           89E5                       mov	bp,sp
02395 087D           4C                         dec	sp
02396 087E           4C                         dec	sp
02397 087F           EB           16            jmp .2C
02398                       00000881            .2D:
02399                                           ! 953     send(action, c);
02400                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02401 0881           8A46         FF            mov	al,-1[bp]
02402 0884           30E4                       xor	ah,ah
02403 0886           50                         push	ax
02404                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02405 0887           FF76         04            push	4[bp]
02406                                           ! Debug: func () void = send+0 (used reg = )
02407 088A           E8         FDD7            call	_send
02408 088D           83C4                   04  add	sp,*4
02409                                           !BCC_EOS
02410                                           ! 954     offset++;
02411                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02412 0890           8B46         08            mov	ax,8[bp]
02413 0893           40                         inc	ax
02414 0894           8946         08            mov	8[bp],ax
02415                                           !BCC_EOS
02416                                           ! 955   }
02417                                           ! 956 }
02418                       00000897            .2C:
02419                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02420 0897           FF76         08            push	8[bp]
02421                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02422 089A           FF76         06            push	6[bp]
02423                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02424 089D           E8         FD58            call	_read_byte
02425 08A0           83C4                   04  add	sp,*4
02426                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02427 08A3           8846         FF            mov	-1[bp],al
02428 08A6           84C0                       test	al,al
02429 08A8           75           D7            jne	.2D
02430                       000008AA            .2E:
02431                       000008AA            .2B:
02432 08AA           89EC                       mov	sp,bp
02433 08AC           5D                         pop	bp
02434 08AD           C3                         ret
02435                                           ! 957   void
02436                                           ! 958 delay_ticks(ticks)
02437                                           ! 959   Bit16u ticks;
02438                                           export	_delay_ticks
02439                       000008AE            _delay_ticks:
02440                                           !BCC_EOS
02441                                           ! 960 {
02442                                           ! 961   long ticks_to_wait, delta;
02443                                           !BCC_EOS
02444                                           ! 962   Bit32u prev_ticks, t;
02445                                           !BCC_EOS
02446                                           ! 963 #asm
02447 08AE           55                         push	bp
02448 08AF           89E5                       mov	bp,sp
02449 08B1           83C4                   F0  add	sp,*-$10
02450                                           !BCC_EOS
02451                                           !BCC_ASM
02452                       00000014            _delay_ticks.ticks	set	$14
02453                       00000004            .delay_ticks.ticks	set	4
02454                       00000000            _delay_ticks.t	set	0
02455                       FFFFFFF0            .delay_ticks.t	set	-$10
02456                       00000004            _delay_ticks.prev_ticks	set	4
02457                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02458                       00000008            _delay_ticks.delta	set	8
02459                       FFFFFFF8            .delay_ticks.delta	set	-8
02460                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02461                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02462 08B4           9C                           pushf
02463 08B5           FB                           sti
02464                                           ! 966 endasm
02465                                           !BCC_ENDASM
02466                                           !BCC_EOS
02467                                           ! 967   ticks_to_wait = ticks;
02468                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02469 08B6           8B46         04            mov	ax,4[bp]
02470 08B9           31DB                       xor	bx,bx
02471 08BB           8946         FC            mov	-4[bp],ax
02472 08BE           895E         FE            mov	-2[bp],bx
02473                                           !BCC_EOS
02474                                           ! 968   prev_ticks = read_dword(0x0, 0x46c);
02475                                           ! Debug: list int = const $46C (used reg = )
02476 08C1           B8                   046C  mov	ax,#$46C
02477 08C4           50                         push	ax
02478                                           ! Debug: list int = const 0 (used reg = )
02479 08C5           31C0                       xor	ax,ax
02480 08C7           50                         push	ax
02481                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02482 08C8           E8         F7B8            call	_read_dword
02483 08CB           89D3                       mov	bx,dx
02484 08CD           83C4                   04  add	sp,*4
02485                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02486 08D0           8946         F4            mov	-$C[bp],ax
02487 08D3           895E         F6            mov	-$A[bp],bx
02488                                           !BCC_EOS
02489                                           ! 969   do
02490                                           ! 970   {
02491                       000008D6            .31:
02492                                           ! 971 #asm
02493                                           !BCC_EOS
02494                                           !BCC_ASM
02495                       00000014            _delay_ticks.ticks	set	$14
02496                       00000004            .delay_ticks.ticks	set	4
02497                       00000000            _delay_ticks.t	set	0
02498                       FFFFFFF0            .delay_ticks.t	set	-$10
02499                       00000004            _delay_ticks.prev_ticks	set	4
02500                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02501                       00000008            _delay_ticks.delta	set	8
02502                       FFFFFFF8            .delay_ticks.delta	set	-8
02503                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02504                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02505 08D6           F4                             hlt
02506                                           ! 973 endasm
02507                                           !BCC_ENDASM
02508                                           !BCC_EOS
02509                                           ! 974     t = read_dword(0x0, 0x46c);
02510                                           ! Debug: list int = const $46C (used reg = )
02511 08D7           B8                   046C  mov	ax,#$46C
02512 08DA           50                         push	ax
02513                                           ! Debug: list int = const 0 (used reg = )
02514 08DB           31C0                       xor	ax,ax
02515 08DD           50                         push	ax
02516                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02517 08DE           E8         F7A2            call	_read_dword
02518 08E1           89D3                       mov	bx,dx
02519 08E3           83C4                   04  add	sp,*4
02520                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02521 08E6           8946         F0            mov	-$10[bp],ax
02522 08E9           895E         F2            mov	-$E[bp],bx
02523                                           !BCC_EOS
02524                                           ! 975     if (t > prev_ticks)
02525                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02526 08EC           8B46         F4            mov	ax,-$C[bp]
02527 08EF           8B5E         F6            mov	bx,-$A[bp]
02528 08F2           8D7E         F0            lea	di,-$10[bp]
02529 08F5           E8         F7D3            call	lcmpul
02530 08F8           73           26            jae 	.32
02531                       000008FA            .33:
02532                                           ! 976     {
02533                                           ! 977       delta = t - prev_ticks;
02534                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02535 08FA           8B46         F0            mov	ax,-$10[bp]
02536 08FD           8B5E         F2            mov	bx,-$E[bp]
02537 0900           8D7E         F4            lea	di,-$C[bp]
02538 0903           E8         F7DB            call	lsubul
02539                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02540 0906           8946         F8            mov	-8[bp],ax
02541 0909           895E         FA            mov	-6[bp],bx
02542                                           !BCC_EOS
02543                                           ! 978       ticks_to_wait -= delta;
02544                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02545 090C           8B46         FC            mov	ax,-4[bp]
02546 090F           8B5E         FE            mov	bx,-2[bp]
02547 0912           8D7E         F8            lea	di,-8[bp]
02548 0915           E8         F7C9            call	lsubl
02549 0918           8946         FC            mov	-4[bp],ax
02550 091B           895E         FE            mov	-2[bp],bx
02551                                           !BCC_EOS
02552                                           ! 979     }
02553                                           ! 980     else if (t < prev_ticks)
02554 091E           EB           20            jmp .34
02555                       00000920            .32:
02556                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02557 0920           8B46         F4            mov	ax,-$C[bp]
02558 0923           8B5E         F6            mov	bx,-$A[bp]
02559 0926           8D7E         F0            lea	di,-$10[bp]
02560 0929           E8         F79F            call	lcmpul
02561 092C           76           12            jbe 	.35
02562                       0000092E            .36:
02563                                           ! 981     {
02564                                           ! 982       ticks_to_wait -= t;
02565                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02566 092E           8B46         FC            mov	ax,-4[bp]
02567 0931           8B5E         FE            mov	bx,-2[bp]
02568 0934           8D7E         F0            lea	di,-$10[bp]
02569 0937           E8         F7A7            call	lsubul
02570 093A           8946         FC            mov	-4[bp],ax
02571 093D           895E         FE            mov	-2[bp],bx
02572                                           !BCC_EOS
02573                                           ! 983     }
02574                                           ! 984     prev_ticks = t;
02575                       00000940            .35:
02576                       00000940            .34:
02577                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02578 0940           8B46         F0            mov	ax,-$10[bp]
02579 0943           8B5E         F2            mov	bx,-$E[bp]
02580 0946           8946         F4            mov	-$C[bp],ax
02581 0949           895E         F6            mov	-$A[bp],bx
02582                                           !BCC_EOS
02583                                           ! 985   } while (ticks_to_wait > 0);
02584                       0000094C            .30:
02585                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02586 094C           31C0                       xor	ax,ax
02587 094E           31DB                       xor	bx,bx
02588 0950           8D7E         FC            lea	di,-4[bp]
02589 0953           E8         F775            call	lcmpl
02590 0956         0F8C         FF7C            blt 	.31
02591                       0000095A            .37:
02592                                           !BCC_EOS
02593                                           ! 986 #asm
02594                       0000095A            .2F:
02595                                           !BCC_EOS
02596                                           !BCC_ASM
02597                       00000014            _delay_ticks.ticks	set	$14
02598                       00000004            .delay_ticks.ticks	set	4
02599                       00000000            _delay_ticks.t	set	0
02600                       FFFFFFF0            .delay_ticks.t	set	-$10
02601                       00000004            _delay_ticks.prev_ticks	set	4
02602                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02603                       00000008            _delay_ticks.delta	set	8
02604                       FFFFFFF8            .delay_ticks.delta	set	-8
02605                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02606                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02607 095A           FA                           cli
02608 095B           9D                           popf
02609                                           ! 989 endasm
02610                                           !BCC_ENDASM
02611                                           !BCC_EOS
02612                                           ! 990 }
02613 095C           89EC                       mov	sp,bp
02614 095E           5D                         pop	bp
02615 095F           C3                         ret
02616                                           ! 991   Bit8u
02617                                           ! Register BX used in function delay_ticks
02618                                           ! 992 check_for_keystroke()
02619                                           ! 993 {
02620                                           export	_check_for_keystroke
02621                       00000960            _check_for_keystroke:
02622                                           ! 994 #asm
02623                                           !BCC_ASM
02624 0960           B8                   0100    mov ax, #0x100
02625 0963           CD                     16    int #0x16
02626 0965           74           04              jz no_key
02627 0967           B0                     01    mov al, #1
02628 0969           EB           02              jmp done
02629                       0000096B            no_key:
02630 096B           30C0                         xor al, al
02631                       0000096D            done:
02632                                           ! 1003 endasm
02633                                           !BCC_ENDASM
02634                                           ! 1004 }
02635 096D           C3                         ret
02636                                           ! 1005   Bit8u
02637                                           ! 1006 get_keystroke()
02638                                           ! 1007 {
02639                                           export	_get_keystroke
02640                       0000096E            _get_keystroke:
02641                                           ! 1008 #asm
02642                                           !BCC_ASM
02643 096E           B8                   0000    mov ax, #0x0
02644 0971           CD                     16    int #0x16
02645 0973           86C4                         xchg ah, al
02646                                           ! 1012 endasm
02647                                           !BCC_ENDASM
02648                                           ! 1013 }
02649 0975           C3                         ret
02650                                           ! 1014   void
02651                                           ! 1015 delay_ticks_and_check_for_keystroke(ticks, count)
02652                                           ! 1016   Bit16u ticks, count;
02653                                           export	_delay_ticks_and_check_for_keystroke
02654                       00000976            _delay_ticks_and_check_for_keystroke:
02655                                           !BCC_EOS
02656                                           ! 1017 {
02657                                           ! 1018   Bit16u i;
02658                                           !BCC_EOS
02659                                           ! 1019   for (i = 1; i <= count; i++) {
02660 0976           55                         push	bp
02661 0977           89E5                       mov	bp,sp
02662 0979           4C                         dec	sp
02663 097A           4C                         dec	sp
02664                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02665 097B           B8                   0001  mov	ax,*1
02666 097E           8946         FE            mov	-2[bp],ax
02667                                           !BCC_EOS
02668                                           !BCC_EOS
02669 0981           EB           18            jmp .3A
02670                       00000983            .3B:
02671                                           ! 1020     delay_ticks(ticks);
02672                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02673 0983           FF76         04            push	4[bp]
02674                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02675 0986           E8         FF25            call	_delay_ticks
02676 0989           44                         inc	sp
02677 098A           44                         inc	sp
02678                                           !BCC_EOS
02679                                           ! 1021     if (check_for_keystroke())
02680                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02681 098B           E8         FFD2            call	_check_for_keystroke
02682 098E           84C0                       test	al,al
02683 0990           74           02            je  	.3C
02684                       00000992            .3D:
02685                                           ! 1022       break;
02686 0992           EB           0F            jmp .38
02687                                           !BCC_EOS
02688                                           ! 1023   }
02689                       00000994            .3C:
02690                                           ! 1024 }
02691                       00000994            .39:
02692                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02693 0994           8B46         FE            mov	ax,-2[bp]
02694 0997           40                         inc	ax
02695 0998           8946         FE            mov	-2[bp],ax
02696                       0000099B            .3A:
02697                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02698 099B           8B46         FE            mov	ax,-2[bp]
02699 099E           3B46         06            cmp	ax,6[bp]
02700 09A1           76           E0            jbe	.3B
02701                       000009A3            .3E:
02702                       000009A3            .38:
02703 09A3           89EC                       mov	sp,bp
02704 09A5           5D                         pop	bp
02705 09A6           C3                         ret
02706                                           ! 1025   void
02707                                           ! 1026 bios_printf(action, s)
02708                                           ! 1027   Bit16u action;
02709                                           export	_bios_printf
02710                       000009A7            _bios_printf:
02711                                           !BCC_EOS
02712                                           ! 1028   Bit8u *s;
02713                                           !BCC_EOS
02714                                           ! 1029 {
02715                                           ! 1030   Bit8u c, format_char;
02716                                           !BCC_EOS
02717                                           ! 1031   bx_bool in_format;
02718                                           !BCC_EOS
02719                                           ! 1032   short i;
02720                                           !BCC_EOS
02721                                           ! 1033   Bit16u *arg_ptr;
02722                                           !BCC_EOS
02723                                           ! 1034   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02724                                           !BCC_EOS
02725                                           ! 1035   arg_ptr = &s;
02726 09A7           55                         push	bp
02727 09A8           89E5                       mov	bp,sp
02728 09AA           83C4                   EA  add	sp,*-$16
02729                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02730 09AD           8D5E         06            lea	bx,6[bp]
02731 09B0           895E         F8            mov	-8[bp],bx
02732                                           !BCC_EOS
02733                                           ! 1036   arg_seg = get_SS();
02734                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02735 09B3           E8         FC9B            call	_get_SS
02736                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02737 09B6           8946         F6            mov	-$A[bp],ax
02738                                           !BCC_EOS
02739                                           ! 1037   in_format = 0;
02740                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02741 09B9           31C0                       xor	ax,ax
02742 09BB           8946         FC            mov	-4[bp],ax
02743                                           !BCC_EOS
02744                                           ! 1038   format_width = 0;
02745                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02746 09BE           31C0                       xor	ax,ax
02747 09C0           8946         EC            mov	-$14[bp],ax
02748                                           !BCC_EOS
02749                                           ! 1039   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02750                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02751 09C3           8A46         04            mov	al,4[bp]
02752 09C6           24                     07  and	al,*7
02753                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02754 09C8           3C                     07  cmp	al,*7
02755 09CA           75           1B            jne 	.3F
02756                       000009CC            .40:
02757                                           ! 1040     outb(0x401, 0x00);
02758                                           ! Debug: list int = const 0 (used reg = )
02759 09CC           31C0                       xor	ax,ax
02760 09CE           50                         push	ax
02761                                           ! Debug: list int = const $401 (used reg = )
02762 09CF           B8                   0401  mov	ax,#$401
02763 09D2           50                         push	ax
02764                                           ! Debug: func () void = outb+0 (used reg = )
02765 09D3           E8         FB82            call	_outb
02766 09D6           83C4                   04  add	sp,*4
02767                                           !BCC_EOS
02768                                           ! 1041     bios_printf (2, "FATAL: ");
02769                                           ! Debug: list * char = .41+0 (used reg = )
02770 09D9           BB                   D9F5  mov	bx,#.41
02771 09DC           53                         push	bx
02772                                           ! Debug: list int = const 2 (used reg = )
02773 09DD           B8                   0002  mov	ax,*2
02774 09E0           50                         push	ax
02775                                           ! Debug: func () void = bios_printf+0 (used reg = )
02776 09E1           E8         FFC3            call	_bios_printf
02777 09E4           83C4                   04  add	sp,*4
02778                                           !BCC_EOS
02779                                           ! 1042   }
02780                                           ! 1043   while (c = read_byte(get_CS(), s)) {
02781                       000009E7            .3F:
02782 09E7           E9         0367            br 	.43
02783                       000009EA            .44:
02784                                           ! 1044     if ( c == '%' ) {
02785                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02786 09EA           8A46         FF            mov	al,-1[bp]
02787 09ED           3C                     25  cmp	al,*$25
02788 09EF           75           0E            jne 	.45
02789                       000009F1            .46:
02790                                           ! 1045       in_format = 1;
02791                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02792 09F1           B8                   0001  mov	ax,*1
02793 09F4           8946         FC            mov	-4[bp],ax
02794                                           !BCC_EOS
02795                                           ! 1046       format_width = 0;
02796                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02797 09F7           31C0                       xor	ax,ax
02798 09F9           8946         EC            mov	-$14[bp],ax
02799                                           !BCC_EOS
02800                                           ! 1047     }
02801                                           ! 1048     else if (in_format) {
02802 09FC           E9         034B            br 	.47
02803                       000009FF            .45:
02804 09FF           8B46         FC            mov	ax,-4[bp]
02805 0A02           85C0                       test	ax,ax
02806 0A04         0F84         0333            beq 	.48
02807                       00000A08            .49:
02808                                           ! 1049       if ( (c>='0') && (c<='9') ) {
02809                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02810 0A08           8A46         FF            mov	al,-1[bp]
02811 0A0B           3C                     30  cmp	al,*$30
02812 0A0D           72           28            jb  	.4A
02813                       00000A0F            .4C:
02814                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02815 0A0F           8A46         FF            mov	al,-1[bp]
02816 0A12           3C                     39  cmp	al,*$39
02817 0A14           77           21            ja  	.4A
02818                       00000A16            .4B:
02819                                           ! 1050         format_width = (format_width * 10) + (c - '0');
02820                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02821 0A16           8A46         FF            mov	al,-1[bp]
02822 0A19           30E4                       xor	ah,ah
02823 0A1B           05                   FFD0  add	ax,*-$30
02824 0A1E           50                         push	ax
02825                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02826 0A1F           8B46         EC            mov	ax,-$14[bp]
02827 0A22           89C2                       mov	dx,ax
02828 0A24           D1E0                       shl	ax,*1
02829 0A26           D1E0                       shl	ax,*1
02830 0A28           01D0                       add	ax,dx
02831 0A2A           D1E0                       shl	ax,*1
02832                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02833 0A2C           0346         E8            add	ax,-$18[bp]
02834 0A2F           44                         inc	sp
02835 0A30           44                         inc	sp
02836                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02837 0A31           8946         EC            mov	-$14[bp],ax
02838                                           !BCC_EOS
02839                                           ! 1051       }
02840                                           ! 1052       else {
02841 0A34           E9         0302            br 	.4D
02842                       00000A37            .4A:
02843                                           ! 1053         arg_ptr++;
02844                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02845 0A37           8B5E         F8            mov	bx,-8[bp]
02846 0A3A           43                         inc	bx
02847 0A3B           43                         inc	bx
02848 0A3C           895E         F8            mov	-8[bp],bx
02849                                           !BCC_EOS
02850                                           ! 1054         arg = read_word(arg_seg, arg_ptr);
02851                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02852 0A3F           FF76         F8            push	-8[bp]
02853                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
02854 0A42           FF76         F6            push	-$A[bp]
02855                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02856 0A45           E8         FBC3            call	_read_word
02857 0A48           83C4                   04  add	sp,*4
02858                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
02859 0A4B           8946         F4            mov	-$C[bp],ax
02860                                           !BCC_EOS
02861                                           ! 1055         if (c == 'x' || c == 'X') {
02862                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
02863 0A4E           8A46         FF            mov	al,-1[bp]
02864 0A51           3C                     78  cmp	al,*$78
02865 0A53           74           07            je  	.4F
02866                       00000A55            .50:
02867                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
02868 0A55           8A46         FF            mov	al,-1[bp]
02869 0A58           3C                     58  cmp	al,*$58
02870 0A5A           75           76            jne 	.4E
02871                       00000A5C            .4F:
02872                                           ! 1056           if (format_width == 0)
02873                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02874 0A5C           8B46         EC            mov	ax,-$14[bp]
02875 0A5F           85C0                       test	ax,ax
02876 0A61           75           06            jne 	.51
02877                       00000A63            .52:
02878                                           ! 1057             format_width = 4;
02879                                           ! 1057 
02880                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
02881 0A63           B8                   0004  mov	ax,*4
02882 0A66           8946         EC            mov	-$14[bp],ax
02883                                           !BCC_EOS
02884                                           ! 1058           if (c == 'x')
02885                       00000A69            .51:
02886                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
02887 0A69           8A46         FF            mov	al,-1[bp]
02888 0A6C           3C                     78  cmp	al,*$78
02889 0A6E           75           08            jne 	.53
02890                       00000A70            .54:
02891                                           ! 1059             hexadd = 'a';
02892                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
02893 0A70           B8                   0061  mov	ax,*$61
02894 0A73           8946         EA            mov	-$16[bp],ax
02895                                           !BCC_EOS
02896                                           ! 1060           else
02897                                           ! 1061             hexadd = 'A';
02898 0A76           EB           06            jmp .55
02899                       00000A78            .53:
02900                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
02901 0A78           B8                   0041  mov	ax,*$41
02902 0A7B           8946         EA            mov	-$16[bp],ax
02903                                           !BCC_EOS
02904                                           ! 1062           for (i=format_width-1; i>=0; i--) {
02905                       00000A7E            .55:
02906                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
02907 0A7E           8B46         EC            mov	ax,-$14[bp]
02908                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02909 0A81           48                         dec	ax
02910 0A82           8946         FA            mov	-6[bp],ax
02911                                           !BCC_EOS
02912                                           !BCC_EOS
02913 0A85           EB           41            jmp .58
02914                       00000A87            .59:
02915                                           ! 1063             nibble = (arg >> (4 * i)) & 0x000f;
02916                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02917                                           ! Debug: expression subtree swapping
02918 0A87           8B46         FA            mov	ax,-6[bp]
02919 0A8A           D1E0                       shl	ax,*1
02920 0A8C           D1E0                       shl	ax,*1
02921                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
02922 0A8E           89C3                       mov	bx,ax
02923 0A90           8B46         F4            mov	ax,-$C[bp]
02924 0A93           89D9                       mov	cx,bx
02925 0A95           D3E8                       shr	ax,cl
02926                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
02927 0A97           24                     0F  and	al,*$F
02928                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
02929 0A99           30E4                       xor	ah,ah
02930 0A9B           8946         F2            mov	-$E[bp],ax
02931                                           !BCC_EOS
02932                                           ! 1064             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
02933                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
02934 0A9E           8B46         F2            mov	ax,-$E[bp]
02935 0AA1           3D                   0009  cmp	ax,*9
02936 0AA4           77           08            ja  	.5A
02937                       00000AA6            .5B:
02938                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
02939 0AA6           8B46         F2            mov	ax,-$E[bp]
02940 0AA9           05                   0030  add	ax,*$30
02941 0AAC           EB           09            jmp .5C
02942                       00000AAE            .5A:
02943                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
02944 0AAE           8B46         F2            mov	ax,-$E[bp]
02945                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
02946 0AB1           05                   FFF6  add	ax,*-$A
02947 0AB4           0346         EA            add	ax,-$16[bp]
02948                       00000AB7            .5C:
02949                                           ! Debug: list unsigned int = ax+0 (used reg = )
02950 0AB7           50                         push	ax
02951                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02952 0AB8           FF76         04            push	4[bp]
02953                                           ! Debug: func () void = send+0 (used reg = )
02954 0ABB           E8         FBA6            call	_send
02955 0ABE           83C4                   04  add	sp,*4
02956                                           !BCC_EOS
02957                                           ! 1065           }
02958                                           ! 1066         }
02959                       00000AC1            .57:
02960                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
02961 0AC1           8B46         FA            mov	ax,-6[bp]
02962 0AC4           48                         dec	ax
02963 0AC5           8946         FA            mov	-6[bp],ax
02964                       00000AC8            .58:
02965                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
02966 0AC8           8B46         FA            mov	ax,-6[bp]
02967 0ACB           85C0                       test	ax,ax
02968 0ACD           7D           B8            jge	.59
02969                       00000ACF            .5D:
02970                       00000ACF            .56:
02971                                           ! 1067         else if (c == 'u') {
02972 0ACF           E9         0262            br 	.5E
02973                       00000AD2            .4E:
02974                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
02975 0AD2           8A46         FF            mov	al,-1[bp]
02976 0AD5           3C                     75  cmp	al,*$75
02977 0AD7           75           15            jne 	.5F
02978                       00000AD9            .60:
02979                                           ! 1068           put_uint(action, arg, format_width, 0);
02980                                           ! Debug: list int = const 0 (used reg = )
02981 0AD9           31C0                       xor	ax,ax
02982 0ADB           50                         push	ax
02983                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
02984 0ADC           FF76         EC            push	-$14[bp]
02985                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
02986 0ADF           FF76         F4            push	-$C[bp]
02987                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
02988 0AE2           FF76         04            push	4[bp]
02989                                           ! Debug: func () void = put_uint+0 (used reg = )
02990 0AE5           E8         FC58            call	_put_uint
02991 0AE8           83C4                   08  add	sp,*8
02992                                           !BCC_EOS
02993                                           ! 1069         }
02994                                           ! 1070         else if (c == 'l') {
02995 0AEB           E9         0246            br 	.61
02996                       00000AEE            .5F:
02997                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
02998 0AEE           8A46         FF            mov	al,-1[bp]
02999 0AF1           3C                     6C  cmp	al,*$6C
03000 0AF3         0F85         018D            bne 	.62
03001                       00000AF7            .63:
03002                                           ! 1071           s++;
03003                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03004 0AF7           8B5E         06            mov	bx,6[bp]
03005 0AFA           43                         inc	bx
03006 0AFB           895E         06            mov	6[bp],bx
03007                                           !BCC_EOS
03008                                           ! 1072           c = read_byte(get_CS(), s);
03009                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03010 0AFE           FF76         06            push	6[bp]
03011                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03012 0B01           E8         FB4A            call	_get_CS
03013                                           ! Debug: list unsigned short = ax+0 (used reg = )
03014 0B04           50                         push	ax
03015                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03016 0B05           E8         FAF0            call	_read_byte
03017 0B08           83C4                   04  add	sp,*4
03018                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03019 0B0B           8846         FF            mov	-1[bp],al
03020                                           !BCC_EOS
03021                                           ! 1073           arg_ptr++;
03022                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03023 0B0E           8B5E         F8            mov	bx,-8[bp]
03024 0B11           43                         inc	bx
03025 0B12           43                         inc	bx
03026 0B13           895E         F8            mov	-8[bp],bx
03027                                           !BCC_EOS
03028                                           ! 1074           hibyte = read_word(arg_seg, arg_ptr);
03029                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03030 0B16           FF76         F8            push	-8[bp]
03031                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03032 0B19           FF76         F6            push	-$A[bp]
03033                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03034 0B1C           E8         FAEC            call	_read_word
03035 0B1F           83C4                   04  add	sp,*4
03036                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03037 0B22           8946         F0            mov	-$10[bp],ax
03038                                           !BCC_EOS
03039                                           ! 1075           if (c == 'd') {
03040                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03041 0B25           8A46         FF            mov	al,-1[bp]
03042 0B28           3C                     64  cmp	al,*$64
03043 0B2A           75           73            jne 	.64
03044                       00000B2C            .65:
03045                                           ! 1076             if (hibyte & 0x8000)
03046                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03047 0B2C           8B46         F0            mov	ax,-$10[bp]
03048 0B2F           25                   8000  and	ax,#$8000
03049 0B32           85C0                       test	ax,ax
03050 0B34           74           3D            je  	.66
03051                       00000B36            .67:
03052                                           ! 1077               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03053                                           ! Debug: list int = const 1 (used reg = )
03054 0B36           B8                   0001  mov	ax,*1
03055 0B39           50                         push	ax
03056                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03057 0B3A           8B46         EC            mov	ax,-$14[bp]
03058                                           ! Debug: list unsigned int = ax-1 (used reg = )
03059 0B3D           48                         dec	ax
03060 0B3E           50                         push	ax
03061                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03062 0B3F           8B46         F4            mov	ax,-$C[bp]
03063 0B42           31DB                       xor	bx,bx
03064 0B44           53                         push	bx
03065 0B45           50                         push	ax
03066                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03067 0B46           8B46         F0            mov	ax,-$10[bp]
03068 0B49           31DB                       xor	bx,bx
03069                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03070 0B4B           93                         xchg	bx,ax
03071 0B4C           31C0                       xor	ax,ax
03072                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03073 0B4E           8D7E         E2            lea	di,-$1E[bp]
03074 0B51           E8         F5B3            call	lorul
03075 0B54           83C4                   04  add	sp,*4
03076                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03077 0B57           53                         push	bx
03078 0B58           50                         push	ax
03079 0B59           31C0                       xor	ax,ax
03080 0B5B           31DB                       xor	bx,bx
03081 0B5D           8D7E         E2            lea	di,-$1E[bp]
03082 0B60           E8         F57E            call	lsubul
03083 0B63           83C4                   04  add	sp,*4
03084                                           ! Debug: list unsigned long = bx+0 (used reg = )
03085 0B66           53                         push	bx
03086 0B67           50                         push	ax
03087                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03088 0B68           FF76         04            push	4[bp]
03089                                           ! Debug: func () void = put_luint+0 (used reg = )
03090 0B6B           E8         FC55            call	_put_luint
03091 0B6E           83C4                   0A  add	sp,*$A
03092                                           !BCC_EOS
03093                                           ! 1078             else
03094                                           ! 1079               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03095 0B71           EB           29            jmp .68
03096                       00000B73            .66:
03097                                           ! Debug: list int = const 0 (used reg = )
03098 0B73           31C0                       xor	ax,ax
03099 0B75           50                         push	ax
03100                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03101 0B76           FF76         EC            push	-$14[bp]
03102                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03103 0B79           8B46         F4            mov	ax,-$C[bp]
03104 0B7C           31DB                       xor	bx,bx
03105 0B7E           53                         push	bx
03106 0B7F           50                         push	ax
03107                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03108 0B80           8B46         F0            mov	ax,-$10[bp]
03109 0B83           31DB                       xor	bx,bx
03110                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03111 0B85           93                         xchg	bx,ax
03112 0B86           31C0                       xor	ax,ax
03113                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03114 0B88           8D7E         E2            lea	di,-$1E[bp]
03115 0B8B           E8         F579            call	lorul
03116 0B8E           83C4                   04  add	sp,*4
03117                                           ! Debug: list unsigned long = bx+0 (used reg = )
03118 0B91           53                         push	bx
03119 0B92           50                         push	ax
03120                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03121 0B93           FF76         04            push	4[bp]
03122                                           ! Debug: func () void = put_luint+0 (used reg = )
03123 0B96           E8         FC2A            call	_put_luint
03124 0B99           83C4                   0A  add	sp,*$A
03125                                           !BCC_EOS
03126                                           ! 1080           }
03127                       00000B9C            .68:
03128                                           ! 1081           else if (c == 'u') {
03129 0B9C           E9         00E2            br 	.69
03130                       00000B9F            .64:
03131                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03132 0B9F           8A46         FF            mov	al,-1[bp]
03133 0BA2           3C                     75  cmp	al,*$75
03134 0BA4           75           2C            jne 	.6A
03135                       00000BA6            .6B:
03136                                           ! 1082             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03137                                           ! Debug: list int = const 0 (used reg = )
03138 0BA6           31C0                       xor	ax,ax
03139 0BA8           50                         push	ax
03140                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03141 0BA9           FF76         EC            push	-$14[bp]
03142                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03143 0BAC           8B46         F4            mov	ax,-$C[bp]
03144 0BAF           31DB                       xor	bx,bx
03145 0BB1           53                         push	bx
03146 0BB2           50                         push	ax
03147                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03148 0BB3           8B46         F0            mov	ax,-$10[bp]
03149 0BB6           31DB                       xor	bx,bx
03150                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03151 0BB8           93                         xchg	bx,ax
03152 0BB9           31C0                       xor	ax,ax
03153                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03154 0BBB           8D7E         E2            lea	di,-$1E[bp]
03155 0BBE           E8         F546            call	lorul
03156 0BC1           83C4                   04  add	sp,*4
03157                                           ! Debug: list unsigned long = bx+0 (used reg = )
03158 0BC4           53                         push	bx
03159 0BC5           50                         push	ax
03160                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03161 0BC6           FF76         04            push	4[bp]
03162                                           ! Debug: func () void = put_luint+0 (used reg = )
03163 0BC9           E8         FBF7            call	_put_luint
03164 0BCC           83C4                   0A  add	sp,*$A
03165                                           !BCC_EOS
03166                                           ! 1083           }
03167                                           ! 1084           else if (c == 'x' || c == 'X')
03168 0BCF           E9         00AF            br 	.6C
03169                       00000BD2            .6A:
03170                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03171 0BD2           8A46         FF            mov	al,-1[bp]
03172 0BD5           3C                     78  cmp	al,*$78
03173 0BD7           74           09            je  	.6E
03174                       00000BD9            .6F:
03175                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03176 0BD9           8A46         FF            mov	al,-1[bp]
03177 0BDC           3C                     58  cmp	al,*$58
03178 0BDE         0F85         009F            bne 	.6D
03179                       00000BE2            .6E:
03180                                           ! 1085           {
03181                                           ! 1086             if (format_width == 0)
03182                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03183 0BE2           8B46         EC            mov	ax,-$14[bp]
03184 0BE5           85C0                       test	ax,ax
03185 0BE7           75           06            jne 	.70
03186                       00000BE9            .71:
03187                                           ! 1087               format_width = 8;
03188                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03189 0BE9           B8                   0008  mov	ax,*8
03190 0BEC           8946         EC            mov	-$14[bp],ax
03191                                           !BCC_EOS
03192                                           ! 1088             if (c == 'x')
03193                       00000BEF            .70:
03194                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03195 0BEF           8A46         FF            mov	al,-1[bp]
03196 0BF2           3C                     78  cmp	al,*$78
03197 0BF4           75           08            jne 	.72
03198                       00000BF6            .73:
03199                                           ! 1089               hexadd = 'a';
03200                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03201 0BF6           B8                   0061  mov	ax,*$61
03202 0BF9           8946         EA            mov	-$16[bp],ax
03203                                           !BCC_EOS
03204                                           ! 1090             else
03205                                           ! 1091               hexadd = 'A';
03206 0BFC           EB           06            jmp .74
03207                       00000BFE            .72:
03208                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03209 0BFE           B8                   0041  mov	ax,*$41
03210 0C01           8946         EA            mov	-$16[bp],ax
03211                                           !BCC_EOS
03212                                           ! 1092             for (i=format_width-1; i>=0; i--) {
03213                       00000C04            .74:
03214                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03215 0C04           8B46         EC            mov	ax,-$14[bp]
03216                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03217 0C07           48                         dec	ax
03218 0C08           8946         FA            mov	-6[bp],ax
03219                                           !BCC_EOS
03220                                           !BCC_EOS
03221 0C0B           EB           6D            jmp .77
03222                       00000C0D            .78:
03223                                           ! 1093               nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03224                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03225                                           ! Debug: expression subtree swapping
03226 0C0D           8B46         FA            mov	ax,-6[bp]
03227 0C10           D1E0                       shl	ax,*1
03228 0C12           D1E0                       shl	ax,*1
03229 0C14           50                         push	ax
03230                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03231 0C15           8B46         F4            mov	ax,-$C[bp]
03232 0C18           31DB                       xor	bx,bx
03233 0C1A           53                         push	bx
03234 0C1B           50                         push	ax
03235                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03236 0C1C           8B46         F0            mov	ax,-$10[bp]
03237 0C1F           31DB                       xor	bx,bx
03238                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03239 0C21           93                         xchg	bx,ax
03240 0C22           31C0                       xor	ax,ax
03241                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03242 0C24           8D7E         E4            lea	di,-$1C[bp]
03243 0C27           E8         F4DD            call	lorul
03244 0C2A           83C4                   04  add	sp,*4
03245                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03246 0C2D           8B7E         E8            mov	di,-$18[bp]
03247 0C30           E8         F4F6            call	lsrul
03248 0C33           44                         inc	sp
03249 0C34           44                         inc	sp
03250                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03251 0C35           53                         push	bx
03252 0C36           50                         push	ax
03253 0C37           B8                   000F  mov	ax,*$F
03254 0C3A           31DB                       xor	bx,bx
03255 0C3C           53                         push	bx
03256 0C3D           50                         push	ax
03257 0C3E           8B46         E6            mov	ax,-$1A[bp]
03258 0C41           8B5E         E8            mov	bx,-$18[bp]
03259 0C44           8D7E         E2            lea	di,-$1E[bp]
03260 0C47           E8         F471            call	landul
03261 0C4A           83C4                   08  add	sp,*8
03262                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03263 0C4D           8946         F2            mov	-$E[bp],ax
03264                                           !BCC_EOS
03265                                           ! 1094               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03266                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03267 0C50           8B46         F2            mov	ax,-$E[bp]
03268 0C53           3D                   0009  cmp	ax,*9
03269 0C56           77           08            ja  	.79
03270                       00000C58            .7A:
03271                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03272 0C58           8B46         F2            mov	ax,-$E[bp]
03273 0C5B           05                   0030  add	ax,*$30
03274 0C5E           EB           09            jmp .7B
03275                       00000C60            .79:
03276                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03277 0C60           8B46         F2            mov	ax,-$E[bp]
03278                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03279 0C63           05                   FFF6  add	ax,*-$A
03280 0C66           0346         EA            add	ax,-$16[bp]
03281                       00000C69            .7B:
03282                                           ! Debug: list unsigned int = ax+0 (used reg = )
03283 0C69           50                         push	ax
03284                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03285 0C6A           FF76         04            push	4[bp]
03286                                           ! Debug: func () void = send+0 (used reg = )
03287 0C6D           E8         F9F4            call	_send
03288 0C70           83C4                   04  add	sp,*4
03289                                           !BCC_EOS
03290                                           ! 1095             }
03291                                           ! 1096           }
03292                       00000C73            .76:
03293                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03294 0C73           8B46         FA            mov	ax,-6[bp]
03295 0C76           48                         dec	ax
03296 0C77           8946         FA            mov	-6[bp],ax
03297                       00000C7A            .77:
03298                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03299 0C7A           8B46         FA            mov	ax,-6[bp]
03300 0C7D           85C0                       test	ax,ax
03301 0C7F           7D           8C            jge	.78
03302                       00000C81            .7C:
03303                       00000C81            .75:
03304                                           ! 1097         }
03305                       00000C81            .6D:
03306                       00000C81            .6C:
03307                       00000C81            .69:
03308                                           ! 1098         else if (c == 'd') {
03309 0C81           E9         00B0            br 	.7D
03310                       00000C84            .62:
03311                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03312 0C84           8A46         FF            mov	al,-1[bp]
03313 0C87           3C                     64  cmp	al,*$64
03314 0C89           75           38            jne 	.7E
03315                       00000C8B            .7F:
03316                                           ! 1099           if (arg & 0x8000)
03317                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03318 0C8B           8B46         F4            mov	ax,-$C[bp]
03319 0C8E           25                   8000  and	ax,#$8000
03320 0C91           85C0                       test	ax,ax
03321 0C93           74           1A            je  	.80
03322                       00000C95            .81:
03323                                           ! 1100             put_int(action, -arg, format_width - 1, 1);
03324                                           ! Debug: list int = const 1 (used reg = )
03325 0C95           B8                   0001  mov	ax,*1
03326 0C98           50                         push	ax
03327                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03328 0C99           8B46         EC            mov	ax,-$14[bp]
03329                                           ! Debug: list unsigned int = ax-1 (used reg = )
03330 0C9C           48                         dec	ax
03331 0C9D           50                         push	ax
03332                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03333 0C9E           31C0                       xor	ax,ax
03334 0CA0           2B46         F4            sub	ax,-$C[bp]
03335                                           ! Debug: list unsigned int = ax+0 (used reg = )
03336 0CA3           50                         push	ax
03337                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03338 0CA4           FF76         04            push	4[bp]
03339                                           ! Debug: func () void = put_int+0 (used reg = )
03340 0CA7           E8         FA13            call	_put_int
03341 0CAA           83C4                   08  add	sp,*8
03342                                           !BCC_EOS
03343                                           ! 1101           else
03344                                           ! 1102             put_int(action, arg, format_width, 0);
03345 0CAD           EB           12            jmp .82
03346                       00000CAF            .80:
03347                                           ! Debug: list int = const 0 (used reg = )
03348 0CAF           31C0                       xor	ax,ax
03349 0CB1           50                         push	ax
03350                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03351 0CB2           FF76         EC            push	-$14[bp]
03352                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03353 0CB5           FF76         F4            push	-$C[bp]
03354                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03355 0CB8           FF76         04            push	4[bp]
03356                                           ! Debug: func () void = put_int+0 (used reg = )
03357 0CBB           E8         F9FF            call	_put_int
03358 0CBE           83C4                   08  add	sp,*8
03359                                           !BCC_EOS
03360                                           ! 1103         }
03361                       00000CC1            .82:
03362                                           ! 1104         else if (c == 's') {
03363 0CC1           EB           71            jmp .83
03364                       00000CC3            .7E:
03365                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03366 0CC3           8A46         FF            mov	al,-1[bp]
03367 0CC6           3C                     73  cmp	al,*$73
03368 0CC8           75           12            jne 	.84
03369                       00000CCA            .85:
03370                                           ! 1105           put_str(action, get_CS(), arg);
03371                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03372 0CCA           FF76         F4            push	-$C[bp]
03373                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03374 0CCD           E8         F97E            call	_get_CS
03375                                           ! Debug: list unsigned short = ax+0 (used reg = )
03376 0CD0           50                         push	ax
03377                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03378 0CD1           FF76         04            push	4[bp]
03379                                           ! Debug: func () void = put_str+0 (used reg = )
03380 0CD4           E8         FBA3            call	_put_str
03381 0CD7           83C4                   06  add	sp,*6
03382                                           !BCC_EOS
03383                                           ! 1106         }
03384                                           ! 1107         else if (c == 'S') {
03385 0CDA           EB           58            jmp .86
03386                       00000CDC            .84:
03387                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03388 0CDC           8A46         FF            mov	al,-1[bp]
03389 0CDF           3C                     53  cmp	al,*$53
03390 0CE1           75           2E            jne 	.87
03391                       00000CE3            .88:
03392                                           ! 1108           hibyte = arg;
03393                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03394 0CE3           8B46         F4            mov	ax,-$C[bp]
03395 0CE6           8946         F0            mov	-$10[bp],ax
03396                                           !BCC_EOS
03397                                           ! 1109           arg_ptr++;
03398                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03399 0CE9           8B5E         F8            mov	bx,-8[bp]
03400 0CEC           43                         inc	bx
03401 0CED           43                         inc	bx
03402 0CEE           895E         F8            mov	-8[bp],bx
03403                                           !BCC_EOS
03404                                           ! 1110           arg = read_word(arg_seg, arg_ptr);
03405                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03406 0CF1           FF76         F8            push	-8[bp]
03407                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03408 0CF4           FF76         F6            push	-$A[bp]
03409                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03410 0CF7           E8         F911            call	_read_word
03411 0CFA           83C4                   04  add	sp,*4
03412                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03413 0CFD           8946         F4            mov	-$C[bp],ax
03414                                           !BCC_EOS
03415                                           ! 1111           put_str(action, hibyte, arg);
03416                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03417 0D00           FF76         F4            push	-$C[bp]
03418                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03419 0D03           FF76         F0            push	-$10[bp]
03420                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03421 0D06           FF76         04            push	4[bp]
03422                                           ! Debug: func () void = put_str+0 (used reg = )
03423 0D09           E8         FB6E            call	_put_str
03424 0D0C           83C4                   06  add	sp,*6
03425                                           !BCC_EOS
03426                                           ! 1112         }
03427                                           ! 1113         else if (c == 'c') {
03428 0D0F           EB           23            jmp .89
03429                       00000D11            .87:
03430                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03431 0D11           8A46         FF            mov	al,-1[bp]
03432 0D14           3C                     63  cmp	al,*$63
03433 0D16           75           0E            jne 	.8A
03434                       00000D18            .8B:
03435                                           ! 1114           send(action, arg);
03436                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03437 0D18           FF76         F4            push	-$C[bp]
03438                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03439 0D1B           FF76         04            push	4[bp]
03440                                           ! Debug: func () void = send+0 (used reg = )
03441 0D1E           E8         F943            call	_send
03442 0D21           83C4                   04  add	sp,*4
03443                                           !BCC_EOS
03444                                           ! 1115         }
03445                                           ! 1116         else
03446                                           ! 1117           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03447 0D24           EB           0E            jmp .8C
03448                       00000D26            .8A:
03449                                           ! Debug: list * char = .8D+0 (used reg = )
03450 0D26           BB                   D9D8  mov	bx,#.8D
03451 0D29           53                         push	bx
03452                                           ! Debug: list int = const 7 (used reg = )
03453 0D2A           B8                   0007  mov	ax,*7
03454 0D2D           50                         push	ax
03455                                           ! Debug: func () void = bios_printf+0 (used reg = )
03456 0D2E           E8         FC76            call	_bios_printf
03457 0D31           83C4                   04  add	sp,*4
03458                                           !BCC_EOS
03459                                           ! 1118           in_format = 0;
03460                       00000D34            .8C:
03461                       00000D34            .89:
03462                       00000D34            .86:
03463                       00000D34            .83:
03464                       00000D34            .7D:
03465                       00000D34            .61:
03466                       00000D34            .5E:
03467                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03468 0D34           31C0                       xor	ax,ax
03469 0D36           8946         FC            mov	-4[bp],ax
03470                                           !BCC_EOS
03471                                           ! 1119       }
03472                                           ! 1120     }
03473                       00000D39            .4D:
03474                                           ! 1121     else {
03475 0D39           EB           0F            jmp .8E
03476                       00000D3B            .48:
03477                                           ! 1122       send(action, c);
03478                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03479 0D3B           8A46         FF            mov	al,-1[bp]
03480 0D3E           30E4                       xor	ah,ah
03481 0D40           50                         push	ax
03482                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03483 0D41           FF76         04            push	4[bp]
03484                                           ! Debug: func () void = send+0 (used reg = )
03485 0D44           E8         F91D            call	_send
03486 0D47           83C4                   04  add	sp,*4
03487                                           !BCC_EOS
03488                                           ! 1123     }
03489                                           ! 1124     s ++;
03490                       00000D4A            .8E:
03491                       00000D4A            .47:
03492                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03493 0D4A           8B5E         06            mov	bx,6[bp]
03494 0D4D           43                         inc	bx
03495 0D4E           895E         06            mov	6[bp],bx
03496                                           !BCC_EOS
03497                                           ! 1125   }
03498                                           ! 1126   if (a
03499                       00000D51            .43:
03500                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03501 0D51           FF76         06            push	6[bp]
03502                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03503 0D54           E8         F8F7            call	_get_CS
03504                                           ! Debug: list unsigned short = ax+0 (used reg = )
03505 0D57           50                         push	ax
03506                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03507 0D58           E8         F89D            call	_read_byte
03508 0D5B           83C4                   04  add	sp,*4
03509                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03510 0D5E           8846         FF            mov	-1[bp],al
03511 0D61           84C0                       test	al,al
03512 0D63         0F85         FC83            bne 	.44
03513                       00000D67            .8F:
03514                       00000D67            .42:
03515                                           ! 1126 ction & 1) {
03516                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03517 0D67           8A46         04            mov	al,4[bp]
03518 0D6A           24                     01  and	al,*1
03519 0D6C           84C0                       test	al,al
03520 0D6E           74           04            je  	.90
03521                       00000D70            .91:
03522                                           ! 1127 #asm
03523                                           !BCC_EOS
03524                                           !BCC_ASM
03525                       00000002            _bios_printf.format_width	set	2
03526                       FFFFFFEC            .bios_printf.format_width	set	-$14
03527                       00000014            _bios_printf.format_char	set	$14
03528                       FFFFFFFE            .bios_printf.format_char	set	-2
03529                       00000006            _bios_printf.hibyte	set	6
03530                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03531                       0000000E            _bios_printf.arg_ptr	set	$E
03532                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03533                       0000001A            _bios_printf.action	set	$1A
03534                       00000004            .bios_printf.action	set	4
03535                       00000010            _bios_printf.i	set	$10
03536                       FFFFFFFA            .bios_printf.i	set	-6
03537                       0000000C            _bios_printf.arg_seg	set	$C
03538                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03539                       00000004            _bios_printf.shift_count	set	4
03540                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03541                       00000012            _bios_printf.in_format	set	$12
03542                       FFFFFFFC            .bios_printf.in_format	set	-4
03543                       0000001C            _bios_printf.s	set	$1C
03544                       00000006            .bios_printf.s	set	6
03545                       00000008            _bios_printf.nibble	set	8
03546                       FFFFFFF2            .bios_printf.nibble	set	-$E
03547                       00000015            _bios_printf.c	set	$15
03548                       FFFFFFFF            .bios_printf.c	set	-1
03549                       00000000            _bios_printf.hexadd	set	0
03550                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03551                       0000000A            _bios_printf.arg	set	$A
03552                       FFFFFFF4            .bios_printf.arg	set	-$C
03553 0D70           FA                             cli
03554                       00000D71             halt2_loop:
03555 0D71           F4                             hlt
03556 0D72           EB           FD                jmp halt2_loop
03557                                           ! 1132 endasm
03558                                           !BCC_ENDASM
03559                                           !BCC_EOS
03560                                           ! 1133   }
03561                                           ! 1134 }
03562                       00000D74            .90:
03563 0D74           89EC                       mov	sp,bp
03564 0D76           5D                         pop	bp
03565 0D77           C3                         ret
03566                                           ! 1135   void
03567                                           ! Register BX used in function bios_printf
03568                                           ! 1136 keyboard_init()
03569                                           ! 1137 {
03570                                           export	_keyboard_init
03571                       00000D78            _keyboard_init:
03572                                           ! 1138     Bit16u max;
03573                                           !BCC_EOS
03574                                           ! 1139     max=0xffff;
03575 0D78           55                         push	bp
03576 0D79           89E5                       mov	bp,sp
03577 0D7B           4C                         dec	sp
03578 0D7C           4C                         dec	sp
03579                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03580 0D7D           B8                   FFFF  mov	ax,#$FFFF
03581 0D80           8946         FE            mov	-2[bp],ax
03582                                           !BCC_EOS
03583                                           ! 1140     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03584 0D83           EB           0D            jmp .93
03585                       00000D85            .94:
03586                                           ! Debug: list int = const 0 (used reg = )
03587 0D85           31C0                       xor	ax,ax
03588 0D87           50                         push	ax
03589                                           ! Debug: list int = const $80 (used reg = )
03590 0D88           B8                   0080  mov	ax,#$80
03591 0D8B           50                         push	ax
03592                                           ! Debug: func () void = outb+0 (used reg = )
03593 0D8C           E8         F7C9            call	_outb
03594 0D8F           83C4                   04  add	sp,*4
03595                                           !BCC_EOS
03596                                           ! 1141     max=0x2000;
03597                       00000D92            .93:
03598                                           ! Debug: list int = const $64 (used reg = )
03599 0D92           B8                   0064  mov	ax,*$64
03600 0D95           50                         push	ax
03601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03602 0D96           E8         F7A9            call	_inb
03603 0D99           44                         inc	sp
03604 0D9A           44                         inc	sp
03605                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03606 0D9B           24                     02  and	al,*2
03607 0D9D           84C0                       test	al,al
03608 0D9F           74           0B            je  	.95
03609                       00000DA1            .96:
03610                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03611 0DA1           8B46         FE            mov	ax,-2[bp]
03612 0DA4           48                         dec	ax
03613 0DA5           8946         FE            mov	-2[bp],ax
03614                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03615 0DA8           85C0                       test	ax,ax
03616 0DAA           75           D9            jne	.94
03617                       00000DAC            .95:
03618                       00000DAC            .92:
03619                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03620 0DAC           B8                   2000  mov	ax,#$2000
03621 0DAF           8946         FE            mov	-2[bp],ax
03622                                           !BCC_EOS
03623                                           ! 1142     while (--max > 0) {
03624 0DB2           EB           2B            jmp .98
03625                       00000DB4            .99:
03626                                           ! 1143         outb(0x80, 0x00);
03627                                           ! Debug: list int = const 0 (used reg = )
03628 0DB4           31C0                       xor	ax,ax
03629 0DB6           50                         push	ax
03630                                           ! Debug: list int = const $80 (used reg = )
03631 0DB7           B8                   0080  mov	ax,#$80
03632 0DBA           50                         push	ax
03633                                           ! Debug: func () void = outb+0 (used reg = )
03634 0DBB           E8         F79A            call	_outb
03635 0DBE           83C4                   04  add	sp,*4
03636                                           !BCC_EOS
03637                                           ! 1144         if (inb(0x64) & 0x01) {
03638                                           ! Debug: list int = const $64 (used reg = )
03639 0DC1           B8                   0064  mov	ax,*$64
03640 0DC4           50                         push	ax
03641                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03642 0DC5           E8         F77A            call	_inb
03643 0DC8           44                         inc	sp
03644 0DC9           44                         inc	sp
03645                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03646 0DCA           24                     01  and	al,*1
03647 0DCC           84C0                       test	al,al
03648 0DCE           74           0F            je  	.9A
03649                       00000DD0            .9B:
03650                                           ! 1145             inb(0x60);
03651                                           ! Debug: list int = const $60 (used reg = )
03652 0DD0           B8                   0060  mov	ax,*$60
03653 0DD3           50                         push	ax
03654                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03655 0DD4           E8         F76B            call	_inb
03656 0DD7           44                         inc	sp
03657 0DD8           44                         inc	sp
03658                                           !BCC_EOS
03659                                           ! 1146             max = 0x2000;
03660                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03661 0DD9           B8                   2000  mov	ax,#$2000
03662 0DDC           8946         FE            mov	-2[bp],ax
03663                                           !BCC_EOS
03664                                           ! 1147         }
03665                                           ! 1148     }
03666                       00000DDF            .9A:
03667                                           ! 1149     outb(0x64, 0xaa);
03668                       00000DDF            .98:
03669                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03670 0DDF           8B46         FE            mov	ax,-2[bp]
03671 0DE2           48                         dec	ax
03672 0DE3           8946         FE            mov	-2[bp],ax
03673                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03674 0DE6           85C0                       test	ax,ax
03675 0DE8           75           CA            jne	.99
03676                       00000DEA            .9C:
03677                       00000DEA            .97:
03678                                           ! Debug: list int = const $AA (used reg = )
03679 0DEA           B8                   00AA  mov	ax,#$AA
03680 0DED           50                         push	ax
03681                                           ! Debug: list int = const $64 (used reg = )
03682 0DEE           B8                   0064  mov	ax,*$64
03683 0DF1           50                         push	ax
03684                                           ! Debug: func () void = outb+0 (used reg = )
03685 0DF2           E8         F763            call	_outb
03686 0DF5           83C4                   04  add	sp,*4
03687                                           !BCC_EOS
03688                                           ! 1150     max=0xffff;
03689                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03690 0DF8           B8                   FFFF  mov	ax,#$FFFF
03691 0DFB           8946         FE            mov	-2[bp],ax
03692                                           !BCC_EOS
03693                                           ! 1151     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03694 0DFE           EB           0D            jmp .9E
03695                       00000E00            .9F:
03696                                           ! Debug: list int = const 0 (used reg = )
03697 0E00           31C0                       xor	ax,ax
03698 0E02           50                         push	ax
03699                                           ! Debug: list int = const $80 (used reg = )
03700 0E03           B8                   0080  mov	ax,#$80
03701 0E06           50                         push	ax
03702                                           ! Debug: func () void = outb+0 (used reg = )
03703 0E07           E8         F74E            call	_outb
03704 0E0A           83C4                   04  add	sp,*4
03705                                           !BCC_EOS
03706                                           ! 1152     if (max==0x0) keyboard_panic(00);
03707                       00000E0D            .9E:
03708                                           ! Debug: list int = const $64 (used reg = )
03709 0E0D           B8                   0064  mov	ax,*$64
03710 0E10           50                         push	ax
03711                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03712 0E11           E8         F72E            call	_inb
03713 0E14           44                         inc	sp
03714 0E15           44                         inc	sp
03715                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03716 0E16           24                     02  and	al,*2
03717 0E18           84C0                       test	al,al
03718 0E1A           74           0B            je  	.A0
03719                       00000E1C            .A1:
03720                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03721 0E1C           8B46         FE            mov	ax,-2[bp]
03722 0E1F           48                         dec	ax
03723 0E20           8946         FE            mov	-2[bp],ax
03724                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03725 0E23           85C0                       test	ax,ax
03726 0E25           75           D9            jne	.9F
03727                       00000E27            .A0:
03728                       00000E27            .9D:
03729                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03730 0E27           8B46         FE            mov	ax,-2[bp]
03731 0E2A           85C0                       test	ax,ax
03732 0E2C           75           08            jne 	.A2
03733                       00000E2E            .A3:
03734                                           ! Debug: list int = const 0 (used reg = )
03735 0E2E           31C0                       xor	ax,ax
03736 0E30           50                         push	ax
03737                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03738 0E31           E8         0408            call	_keyboard_panic
03739 0E34           44                         inc	sp
03740 0E35           44                         inc	sp
03741                                           !BCC_EOS
03742                                           ! 1153     max=0xffff;
03743                       00000E36            .A2:
03744                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03745 0E36           B8                   FFFF  mov	ax,#$FFFF
03746 0E39           8946         FE            mov	-2[bp],ax
03747                                           !BCC_EOS
03748                                           ! 1154     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03749 0E3C           EB           0E            jmp .A5
03750                       00000E3E            .A6:
03751                                           ! Debug: list int = const 1 (used reg = )
03752 0E3E           B8                   0001  mov	ax,*1
03753 0E41           50                         push	ax
03754                                           ! Debug: list int = const $80 (used reg = )
03755 0E42           B8                   0080  mov	ax,#$80
03756 0E45           50                         push	ax
03757                                           ! Debug: func () void = outb+0 (used reg = )
03758 0E46           E8         F70F            call	_outb
03759 0E49           83C4                   04  add	sp,*4
03760                                           !BCC_EOS
03761                                           ! 1155     if (max==0x0) keyboard_panic(01);
03762                       00000E4C            .A5:
03763                                           ! Debug: list int = const $64 (used reg = )
03764 0E4C           B8                   0064  mov	ax,*$64
03765 0E4F           50                         push	ax
03766                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03767 0E50           E8         F6EF            call	_inb
03768 0E53           44                         inc	sp
03769 0E54           44                         inc	sp
03770                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03771 0E55           24                     01  and	al,*1
03772                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03773 0E57           84C0                       test	al,al
03774 0E59           75           0B            jne 	.A7
03775                       00000E5B            .A8:
03776                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03777 0E5B           8B46         FE            mov	ax,-2[bp]
03778 0E5E           48                         dec	ax
03779 0E5F           8946         FE            mov	-2[bp],ax
03780                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03781 0E62           85C0                       test	ax,ax
03782 0E64           75           D8            jne	.A6
03783                       00000E66            .A7:
03784                       00000E66            .A4:
03785                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03786 0E66           8B46         FE            mov	ax,-2[bp]
03787 0E69           85C0                       test	ax,ax
03788 0E6B           75           09            jne 	.A9
03789                       00000E6D            .AA:
03790                                           ! Debug: list int = const 1 (used reg = )
03791 0E6D           B8                   0001  mov	ax,*1
03792 0E70           50                         push	ax
03793                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03794 0E71           E8         03C8            call	_keyboard_panic
03795 0E74           44                         inc	sp
03796 0E75           44                         inc	sp
03797                                           !BCC_EOS
03798                                           ! 1156     if ((inb(0x60) != 0x55)){
03799                       00000E76            .A9:
03800                                           ! Debug: list int = const $60 (used reg = )
03801 0E76           B8                   0060  mov	ax,*$60
03802 0E79           50                         push	ax
03803                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03804 0E7A           E8         F6C5            call	_inb
03805 0E7D           44                         inc	sp
03806 0E7E           44                         inc	sp
03807                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03808 0E7F           3C                     55  cmp	al,*$55
03809 0E81           74           09            je  	.AB
03810                       00000E83            .AC:
03811                                           ! 1157         keyboard_panic(991);
03812                                           ! Debug: list int = const $3DF (used reg = )
03813 0E83           B8                   03DF  mov	ax,#$3DF
03814 0E86           50                         push	ax
03815                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03816 0E87           E8         03B2            call	_keyboard_panic
03817 0E8A           44                         inc	sp
03818 0E8B           44                         inc	sp
03819                                           !BCC_EOS
03820                                           ! 1158     }
03821                                           ! 1159     outb(0x64,0xab);
03822                       00000E8C            .AB:
03823                                           ! Debug: list int = const $AB (used reg = )
03824 0E8C           B8                   00AB  mov	ax,#$AB
03825 0E8F           50                         push	ax
03826                                           ! Debug: list int = const $64 (used reg = )
03827 0E90           B8                   0064  mov	ax,*$64
03828 0E93           50                         push	ax
03829                                           ! Debug: func () void = outb+0 (used reg = )
03830 0E94           E8         F6C1            call	_outb
03831 0E97           83C4                   04  add	sp,*4
03832                                           !BCC_EOS
03833                                           ! 1160     max=0xffff;
03834                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03835 0E9A           B8                   FFFF  mov	ax,#$FFFF
03836 0E9D           8946         FE            mov	-2[bp],ax
03837                                           !BCC_EOS
03838                                           ! 1161     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03839 0EA0           EB           0E            jmp .AE
03840                       00000EA2            .AF:
03841                                           ! Debug: list int = const $10 (used reg = )
03842 0EA2           B8                   0010  mov	ax,*$10
03843 0EA5           50                         push	ax
03844                                           ! Debug: list int = const $80 (used reg = )
03845 0EA6           B8                   0080  mov	ax,#$80
03846 0EA9           50                         push	ax
03847                                           ! Debug: func () void = outb+0 (used reg = )
03848 0EAA           E8         F6AB            call	_outb
03849 0EAD           83C4                   04  add	sp,*4
03850                                           !BCC_EOS
03851                                           ! 1162     if (max==0x0) keyboard_panic(10);
03852                       00000EB0            .AE:
03853                                           ! Debug: list int = const $64 (used reg = )
03854 0EB0           B8                   0064  mov	ax,*$64
03855 0EB3           50                         push	ax
03856                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03857 0EB4           E8         F68B            call	_inb
03858 0EB7           44                         inc	sp
03859 0EB8           44                         inc	sp
03860                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03861 0EB9           24                     02  and	al,*2
03862 0EBB           84C0                       test	al,al
03863 0EBD           74           0B            je  	.B0
03864                       00000EBF            .B1:
03865                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03866 0EBF           8B46         FE            mov	ax,-2[bp]
03867 0EC2           48                         dec	ax
03868 0EC3           8946         FE            mov	-2[bp],ax
03869                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03870 0EC6           85C0                       test	ax,ax
03871 0EC8           75           D8            jne	.AF
03872                       00000ECA            .B0:
03873                       00000ECA            .AD:
03874                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03875 0ECA           8B46         FE            mov	ax,-2[bp]
03876 0ECD           85C0                       test	ax,ax
03877 0ECF           75           09            jne 	.B2
03878                       00000ED1            .B3:
03879                                           ! Debug: list int = const $A (used reg = )
03880 0ED1           B8                   000A  mov	ax,*$A
03881 0ED4           50                         push	ax
03882                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03883 0ED5           E8         0364            call	_keyboard_panic
03884 0ED8           44                         inc	sp
03885 0ED9           44                         inc	sp
03886                                           !BCC_EOS
03887                                           ! 1163     max=0xffff;
03888                       00000EDA            .B2:
03889                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03890 0EDA           B8                   FFFF  mov	ax,#$FFFF
03891 0EDD           8946         FE            mov	-2[bp],ax
03892                                           !BCC_EOS
03893                                           ! 1164     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
03894 0EE0           EB           0E            jmp .B5
03895                       00000EE2            .B6:
03896                                           ! Debug: list int = const $11 (used reg = )
03897 0EE2           B8                   0011  mov	ax,*$11
03898 0EE5           50                         push	ax
03899                                           ! Debug: list int = const $80 (used reg = )
03900 0EE6           B8                   0080  mov	ax,#$80
03901 0EE9           50                         push	ax
03902                                           ! Debug: func () void = outb+0 (used reg = )
03903 0EEA           E8         F66B            call	_outb
03904 0EED           83C4                   04  add	sp,*4
03905                                           !BCC_EOS
03906                                           ! 1165     if (max==0x0) keyboard_panic(11);
03907                       00000EF0            .B5:
03908                                           ! Debug: list int = const $64 (used reg = )
03909 0EF0           B8                   0064  mov	ax,*$64
03910 0EF3           50                         push	ax
03911                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03912 0EF4           E8         F64B            call	_inb
03913 0EF7           44                         inc	sp
03914 0EF8           44                         inc	sp
03915                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03916 0EF9           24                     01  and	al,*1
03917                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03918 0EFB           84C0                       test	al,al
03919 0EFD           75           0B            jne 	.B7
03920                       00000EFF            .B8:
03921                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03922 0EFF           8B46         FE            mov	ax,-2[bp]
03923 0F02           48                         dec	ax
03924 0F03           8946         FE            mov	-2[bp],ax
03925                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03926 0F06           85C0                       test	ax,ax
03927 0F08           75           D8            jne	.B6
03928                       00000F0A            .B7:
03929                       00000F0A            .B4:
03930                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03931 0F0A           8B46         FE            mov	ax,-2[bp]
03932 0F0D           85C0                       test	ax,ax
03933 0F0F           75           09            jne 	.B9
03934                       00000F11            .BA:
03935                                           ! Debug: list int = const $B (used reg = )
03936 0F11           B8                   000B  mov	ax,*$B
03937 0F14           50                         push	ax
03938                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03939 0F15           E8         0324            call	_keyboard_panic
03940 0F18           44                         inc	sp
03941 0F19           44                         inc	sp
03942                                           !BCC_EOS
03943                                           ! 1166     if ((inb(0x60) != 0x00)) {
03944                       00000F1A            .B9:
03945                                           ! Debug: list int = const $60 (used reg = )
03946 0F1A           B8                   0060  mov	ax,*$60
03947 0F1D           50                         push	ax
03948                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03949 0F1E           E8         F621            call	_inb
03950 0F21           44                         inc	sp
03951 0F22           44                         inc	sp
03952                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03953 0F23           84C0                       test	al,al
03954 0F25           74           09            je  	.BB
03955                       00000F27            .BC:
03956                                           ! 1167         keyboard_panic(992);
03957                                           ! Debug: list int = const $3E0 (used reg = )
03958 0F27           B8                   03E0  mov	ax,#$3E0
03959 0F2A           50                         push	ax
03960                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03961 0F2B           E8         030E            call	_keyboard_panic
03962 0F2E           44                         inc	sp
03963 0F2F           44                         inc	sp
03964                                           !BCC_EOS
03965                                           ! 1168     }
03966                                           ! 1169     outb(0x64,0xae);
03967                       00000F30            .BB:
03968                                           ! Debug: list int = const $AE (used reg = )
03969 0F30           B8                   00AE  mov	ax,#$AE
03970 0F33           50                         push	ax
03971                                           ! Debug: list int = const $64 (used reg = )
03972 0F34           B8                   0064  mov	ax,*$64
03973 0F37           50                         push	ax
03974                                           ! Debug: func () void = outb+0 (used reg = )
03975 0F38           E8         F61D            call	_outb
03976 0F3B           83C4                   04  add	sp,*4
03977                                           !BCC_EOS
03978                                           ! 1170     outb(0x64,0xa8);
03979                                           ! Debug: list int = const $A8 (used reg = )
03980 0F3E           B8                   00A8  mov	ax,#$A8
03981 0F41           50                         push	ax
03982                                           ! Debug: list int = const $64 (used reg = )
03983 0F42           B8                   0064  mov	ax,*$64
03984 0F45           50                         push	ax
03985                                           ! Debug: func () void = outb+0 (used reg = )
03986 0F46           E8         F60F            call	_outb
03987 0F49           83C4                   04  add	sp,*4
03988                                           !BCC_EOS
03989                                           ! 1171     outb(0x60, 0xff);
03990                                           ! Debug: list int = const $FF (used reg = )
03991 0F4C           B8                   00FF  mov	ax,#$FF
03992 0F4F           50                         push	ax
03993                                           ! Debug: list int = const $60 (used reg = )
03994 0F50           B8                   0060  mov	ax,*$60
03995 0F53           50                         push	ax
03996                                           ! Debug: func () void = outb+0 (used reg = )
03997 0F54           E8         F601            call	_outb
03998 0F57           83C4                   04  add	sp,*4
03999                                           !BCC_EOS
04000                                           ! 1172     max=0xffff;
04001                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04002 0F5A           B8                   FFFF  mov	ax,#$FFFF
04003 0F5D           8946         FE            mov	-2[bp],ax
04004                                           !BCC_EOS
04005                                           ! 1173     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
04006 0F60           EB           0E            jmp .BE
04007                       00000F62            .BF:
04008                                           ! Debug: list int = const $20 (used reg = )
04009 0F62           B8                   0020  mov	ax,*$20
04010 0F65           50                         push	ax
04011                                           ! Debug: list int = const $80 (used reg = )
04012 0F66           B8                   0080  mov	ax,#$80
04013 0F69           50                         push	ax
04014                                           ! Debug: func () void = outb+0 (used reg = )
04015 0F6A           E8         F5EB            call	_outb
04016 0F6D           83C4                   04  add	sp,*4
04017                                           !BCC_EOS
04018                                           ! 1174     if (max==0x0) keyboard_panic(20);
04019                       00000F70            .BE:
04020                                           ! Debug: list int = const $64 (used reg = )
04021 0F70           B8                   0064  mov	ax,*$64
04022 0F73           50                         push	ax
04023                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04024 0F74           E8         F5CB            call	_inb
04025 0F77           44                         inc	sp
04026 0F78           44                         inc	sp
04027                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04028 0F79           24                     02  and	al,*2
04029 0F7B           84C0                       test	al,al
04030 0F7D           74           0B            je  	.C0
04031                       00000F7F            .C1:
04032                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04033 0F7F           8B46         FE            mov	ax,-2[bp]
04034 0F82           48                         dec	ax
04035 0F83           8946         FE            mov	-2[bp],ax
04036                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04037 0F86           85C0                       test	ax,ax
04038 0F88           75           D8            jne	.BF
04039                       00000F8A            .C0:
04040                       00000F8A            .BD:
04041                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04042 0F8A           8B46         FE            mov	ax,-2[bp]
04043 0F8D           85C0                       test	ax,ax
04044 0F8F           75           09            jne 	.C2
04045                       00000F91            .C3:
04046                                           ! Debug: list int = const $14 (used reg = )
04047 0F91           B8                   0014  mov	ax,*$14
04048 0F94           50                         push	ax
04049                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04050 0F95           E8         02A4            call	_keyboard_panic
04051 0F98           44                         inc	sp
04052 0F99           44                         inc	sp
04053                                           !BCC_EOS
04054                                           ! 1175     max=0xffff;
04055                       00000F9A            .C2:
04056                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04057 0F9A           B8                   FFFF  mov	ax,#$FFFF
04058 0F9D           8946         FE            mov	-2[bp],ax
04059                                           !BCC_EOS
04060                                           ! 1176     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04061 0FA0           EB           0E            jmp .C5
04062                       00000FA2            .C6:
04063                                           ! Debug: list int = const $21 (used reg = )
04064 0FA2           B8                   0021  mov	ax,*$21
04065 0FA5           50                         push	ax
04066                                           ! Debug: list int = const $80 (used reg = )
04067 0FA6           B8                   0080  mov	ax,#$80
04068 0FA9           50                         push	ax
04069                                           ! Debug: func () void = outb+0 (used reg = )
04070 0FAA           E8         F5AB            call	_outb
04071 0FAD           83C4                   04  add	sp,*4
04072                                           !BCC_EOS
04073                                           ! 1177     if (max==0x0) keyboard_panic(21);
04074                       00000FB0            .C5:
04075                                           ! Debug: list int = const $64 (used reg = )
04076 0FB0           B8                   0064  mov	ax,*$64
04077 0FB3           50                         push	ax
04078                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04079 0FB4           E8         F58B            call	_inb
04080 0FB7           44                         inc	sp
04081 0FB8           44                         inc	sp
04082                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04083 0FB9           24                     01  and	al,*1
04084                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04085 0FBB           84C0                       test	al,al
04086 0FBD           75           0B            jne 	.C7
04087                       00000FBF            .C8:
04088                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04089 0FBF           8B46         FE            mov	ax,-2[bp]
04090 0FC2           48                         dec	ax
04091 0FC3           8946         FE            mov	-2[bp],ax
04092                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04093 0FC6           85C0                       test	ax,ax
04094 0FC8           75           D8            jne	.C6
04095                       00000FCA            .C7:
04096                       00000FCA            .C4:
04097                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04098 0FCA           8B46         FE            mov	ax,-2[bp]
04099 0FCD           85C0                       test	ax,ax
04100 0FCF           75           09            jne 	.C9
04101                       00000FD1            .CA:
04102                                           ! Debug: list int = const $15 (used reg = )
04103 0FD1           B8                   0015  mov	ax,*$15
04104 0FD4           50                         push	ax
04105                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04106 0FD5           E8         0264            call	_keyboard_panic
04107 0FD8           44                         inc	sp
04108 0FD9           44                         inc	sp
04109                                           !BCC_EOS
04110                                           ! 1178     if ((inb(0x60) != 0xfa)) {
04111                       00000FDA            .C9:
04112                                           ! Debug: list int = const $60 (used reg = )
04113 0FDA           B8                   0060  mov	ax,*$60
04114 0FDD           50                         push	ax
04115                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04116 0FDE           E8         F561            call	_inb
04117 0FE1           44                         inc	sp
04118 0FE2           44                         inc	sp
04119                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04120 0FE3           3C                     FA  cmp	al,#$FA
04121 0FE5           74           09            je  	.CB
04122                       00000FE7            .CC:
04123                                           ! 1179         keyboard_panic(993);
04124                                           ! Debug: list int = const $3E1 (used reg = )
04125 0FE7           B8                   03E1  mov	ax,#$3E1
04126 0FEA           50                         push	ax
04127                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04128 0FEB           E8         024E            call	_keyboard_panic
04129 0FEE           44                         inc	sp
04130 0FEF           44                         inc	sp
04131                                           !BCC_EOS
04132                                           ! 1180     }
04133                                           ! 1181     max=0xffff;
04134                       00000FF0            .CB:
04135                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04136 0FF0           B8                   FFFF  mov	ax,#$FFFF
04137 0FF3           8946         FE            mov	-2[bp],ax
04138                                           !BCC_EOS
04139                                           ! 1182     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04140 0FF6           EB           0E            jmp .CE
04141                       00000FF8            .CF:
04142                                           ! Debug: list int = const $31 (used reg = )
04143 0FF8           B8                   0031  mov	ax,*$31
04144 0FFB           50                         push	ax
04145                                           ! Debug: list int = const $80 (used reg = )
04146 0FFC           B8                   0080  mov	ax,#$80
04147 0FFF           50                         push	ax
04148                                           ! Debug: func () void = outb+0 (used reg = )
04149 1000           E8         F555            call	_outb
04150 1003           83C4                   04  add	sp,*4
04151                                           !BCC_EOS
04152                                           ! 1183     if (max==0x0) keyboard_panic(31);
04153                       00001006            .CE:
04154                                           ! Debug: list int = const $64 (used reg = )
04155 1006           B8                   0064  mov	ax,*$64
04156 1009           50                         push	ax
04157                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04158 100A           E8         F535            call	_inb
04159 100D           44                         inc	sp
04160 100E           44                         inc	sp
04161                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04162 100F           24                     01  and	al,*1
04163                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04164 1011           84C0                       test	al,al
04165 1013           75           0B            jne 	.D0
04166                       00001015            .D1:
04167                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04168 1015           8B46         FE            mov	ax,-2[bp]
04169 1018           48                         dec	ax
04170 1019           8946         FE            mov	-2[bp],ax
04171                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04172 101C           85C0                       test	ax,ax
04173 101E           75           D8            jne	.CF
04174                       00001020            .D0:
04175                       00001020            .CD:
04176                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04177 1020           8B46         FE            mov	ax,-2[bp]
04178 1023           85C0                       test	ax,ax
04179 1025           75           09            jne 	.D2
04180                       00001027            .D3:
04181                                           ! Debug: list int = const $1F (used reg = )
04182 1027           B8                   001F  mov	ax,*$1F
04183 102A           50                         push	ax
04184                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04185 102B           E8         020E            call	_keyboard_panic
04186 102E           44                         inc	sp
04187 102F           44                         inc	sp
04188                                           !BCC_EOS
04189                                           ! 1184     if ((inb(0x60) != 0xaa)) {
04190                       00001030            .D2:
04191                                           ! Debug: list int = const $60 (used reg = )
04192 1030           B8                   0060  mov	ax,*$60
04193 1033           50                         push	ax
04194                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04195 1034           E8         F50B            call	_inb
04196 1037           44                         inc	sp
04197 1038           44                         inc	sp
04198                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04199 1039           3C                     AA  cmp	al,#$AA
04200 103B           74           09            je  	.D4
04201                       0000103D            .D5:
04202                                           ! 1185         keyboard_panic(994);
04203                                           ! Debug: list int = const $3E2 (used reg = )
04204 103D           B8                   03E2  mov	ax,#$3E2
04205 1040           50                         push	ax
04206                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04207 1041           E8         01F8            call	_keyboard_panic
04208 1044           44                         inc	sp
04209 1045           44                         inc	sp
04210                                           !BCC_EOS
04211                                           ! 1186     }
04212                                           ! 1187     outb(0x60, 0xf5);
04213                       00001046            .D4:
04214                                           ! Debug: list int = const $F5 (used reg = )
04215 1046           B8                   00F5  mov	ax,#$F5
04216 1049           50                         push	ax
04217                                           ! Debug: list int = const $60 (used reg = )
04218 104A           B8                   0060  mov	ax,*$60
04219 104D           50                         push	ax
04220                                           ! Debug: func () void = outb+0 (used reg = )
04221 104E           E8         F507            call	_outb
04222 1051           83C4                   04  add	sp,*4
04223                                           !BCC_EOS
04224                                           ! 1188     max=0xffff;
04225                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04226 1054           B8                   FFFF  mov	ax,#$FFFF
04227 1057           8946         FE            mov	-2[bp],ax
04228                                           !BCC_EOS
04229                                           ! 1189     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04230 105A           EB           0E            jmp .D7
04231                       0000105C            .D8:
04232                                           ! Debug: list int = const $40 (used reg = )
04233 105C           B8                   0040  mov	ax,*$40
04234 105F           50                         push	ax
04235                                           ! Debug: list int = const $80 (used reg = )
04236 1060           B8                   0080  mov	ax,#$80
04237 1063           50                         push	ax
04238                                           ! Debug: func () void = outb+0 (used reg = )
04239 1064           E8         F4F1            call	_outb
04240 1067           83C4                   04  add	sp,*4
04241                                           !BCC_EOS
04242                                           ! 1190     if (max==0x0) keyboard_panic(40);
04243                       0000106A            .D7:
04244                                           ! Debug: list int = const $64 (used reg = )
04245 106A           B8                   0064  mov	ax,*$64
04246 106D           50                         push	ax
04247                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04248 106E           E8         F4D1            call	_inb
04249 1071           44                         inc	sp
04250 1072           44                         inc	sp
04251                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04252 1073           24                     02  and	al,*2
04253 1075           84C0                       test	al,al
04254 1077           74           0B            je  	.D9
04255                       00001079            .DA:
04256                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04257 1079           8B46         FE            mov	ax,-2[bp]
04258 107C           48                         dec	ax
04259 107D           8946         FE            mov	-2[bp],ax
04260                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04261 1080           85C0                       test	ax,ax
04262 1082           75           D8            jne	.D8
04263                       00001084            .D9:
04264                       00001084            .D6:
04265                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04266 1084           8B46         FE            mov	ax,-2[bp]
04267 1087           85C0                       test	ax,ax
04268 1089           75           09            jne 	.DB
04269                       0000108B            .DC:
04270                                           ! Debug: list int = const $28 (used reg = )
04271 108B           B8                   0028  mov	ax,*$28
04272 108E           50                         push	ax
04273                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04274 108F           E8         01AA            call	_keyboard_panic
04275 1092           44                         inc	sp
04276 1093           44                         inc	sp
04277                                           !BCC_EOS
04278                                           ! 1191     max=0xffff;
04279                       00001094            .DB:
04280                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04281 1094           B8                   FFFF  mov	ax,#$FFFF
04282 1097           8946         FE            mov	-2[bp],ax
04283                                           !BCC_EOS
04284                                           ! 1192     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04285 109A           EB           0E            jmp .DE
04286                       0000109C            .DF:
04287                                           ! Debug: list int = const $41 (used reg = )
04288 109C           B8                   0041  mov	ax,*$41
04289 109F           50                         push	ax
04290                                           ! Debug: list int = const $80 (used reg = )
04291 10A0           B8                   0080  mov	ax,#$80
04292 10A3           50                         push	ax
04293                                           ! Debug: func () void = outb+0 (used reg = )
04294 10A4           E8         F4B1            call	_outb
04295 10A7           83C4                   04  add	sp,*4
04296                                           !BCC_EOS
04297                                           ! 1193     if (max==0x0) keyboard_panic(41);
04298                       000010AA            .DE:
04299                                           ! Debug: list int = const $64 (used reg = )
04300 10AA           B8                   0064  mov	ax,*$64
04301 10AD           50                         push	ax
04302                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04303 10AE           E8         F491            call	_inb
04304 10B1           44                         inc	sp
04305 10B2           44                         inc	sp
04306                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04307 10B3           24                     01  and	al,*1
04308                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04309 10B5           84C0                       test	al,al
04310 10B7           75           0B            jne 	.E0
04311                       000010B9            .E1:
04312                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04313 10B9           8B46         FE            mov	ax,-2[bp]
04314 10BC           48                         dec	ax
04315 10BD           8946         FE            mov	-2[bp],ax
04316                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04317 10C0           85C0                       test	ax,ax
04318 10C2           75           D8            jne	.DF
04319                       000010C4            .E0:
04320                       000010C4            .DD:
04321                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04322 10C4           8B46         FE            mov	ax,-2[bp]
04323 10C7           85C0                       test	ax,ax
04324 10C9           75           09            jne 	.E2
04325                       000010CB            .E3:
04326                                           ! Debug: list int = const $29 (used reg = )
04327 10CB           B8                   0029  mov	ax,*$29
04328 10CE           50                         push	ax
04329                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04330 10CF           E8         016A            call	_keyboard_panic
04331 10D2           44                         inc	sp
04332 10D3           44                         inc	sp
04333                                           !BCC_EOS
04334                                           ! 1194     if ((inb(0x60) != 0xfa)) {
04335                       000010D4            .E2:
04336                                           ! Debug: list int = const $60 (used reg = )
04337 10D4           B8                   0060  mov	ax,*$60
04338 10D7           50                         push	ax
04339                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04340 10D8           E8         F467            call	_inb
04341 10DB           44                         inc	sp
04342 10DC           44                         inc	sp
04343                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04344 10DD           3C                     FA  cmp	al,#$FA
04345 10DF           74           09            je  	.E4
04346                       000010E1            .E5:
04347                                           ! 1195         keyboard_panic(995);
04348                                           ! Debug: list int = const $3E3 (used reg = )
04349 10E1           B8                   03E3  mov	ax,#$3E3
04350 10E4           50                         push	ax
04351                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04352 10E5           E8         0154            call	_keyboard_panic
04353 10E8           44                         inc	sp
04354 10E9           44                         inc	sp
04355                                           !BCC_EOS
04356                                           ! 1196     }
04357                                           ! 1197     outb(0x64, 0x60);
04358                       000010EA            .E4:
04359                                           ! Debug: list int = const $60 (used reg = )
04360 10EA           B8                   0060  mov	ax,*$60
04361 10ED           50                         push	ax
04362                                           ! Debug: list int = const $64 (used reg = )
04363 10EE           B8                   0064  mov	ax,*$64
04364 10F1           50                         push	ax
04365                                           ! Debug: func () void = outb+0 (used reg = )
04366 10F2           E8         F463            call	_outb
04367 10F5           83C4                   04  add	sp,*4
04368                                           !BCC_EOS
04369                                           ! 1198     max=0xffff;
04370                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04371 10F8           B8                   FFFF  mov	ax,#$FFFF
04372 10FB           8946         FE            mov	-2[bp],ax
04373                                           !BCC_EOS
04374                                           ! 1199     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04375 10FE           EB           0E            jmp .E7
04376                       00001100            .E8:
04377                                           ! Debug: list int = const $50 (used reg = )
04378 1100           B8                   0050  mov	ax,*$50
04379 1103           50                         push	ax
04380                                           ! Debug: list int = const $80 (used reg = )
04381 1104           B8                   0080  mov	ax,#$80
04382 1107           50                         push	ax
04383                                           ! Debug: func () void = outb+0 (used reg = )
04384 1108           E8         F44D            call	_outb
04385 110B           83C4                   04  add	sp,*4
04386                                           !BCC_EOS
04387                                           ! 1200     if (max==0x0) keyboard_panic(50);
04388                       0000110E            .E7:
04389                                           ! Debug: list int = const $64 (used reg = )
04390 110E           B8                   0064  mov	ax,*$64
04391 1111           50                         push	ax
04392                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04393 1112           E8         F42D            call	_inb
04394 1115           44                         inc	sp
04395 1116           44                         inc	sp
04396                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04397 1117           24                     02  and	al,*2
04398 1119           84C0                       test	al,al
04399 111B           74           0B            je  	.E9
04400                       0000111D            .EA:
04401                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04402 111D           8B46         FE            mov	ax,-2[bp]
04403 1120           48                         dec	ax
04404 1121           8946         FE            mov	-2[bp],ax
04405                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04406 1124           85C0                       test	ax,ax
04407 1126           75           D8            jne	.E8
04408                       00001128            .E9:
04409                       00001128            .E6:
04410                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04411 1128           8B46         FE            mov	ax,-2[bp]
04412 112B           85C0                       test	ax,ax
04413 112D           75           09            jne 	.EB
04414                       0000112F            .EC:
04415                                           ! 1200 
04416                                           ! Debug: list int = const $32 (used reg = )
04417 112F           B8                   0032  mov	ax,*$32
04418 1132           50                         push	ax
04419                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04420 1133           E8         0106            call	_keyboard_panic
04421 1136           44                         inc	sp
04422 1137           44                         inc	sp
04423                                           !BCC_EOS
04424                                           ! 1201     outb(0x60, 0x61);
04425                       00001138            .EB:
04426                                           ! Debug: list int = const $61 (used reg = )
04427 1138           B8                   0061  mov	ax,*$61
04428 113B           50                         push	ax
04429                                           ! Debug: list int = const $60 (used reg = )
04430 113C           B8                   0060  mov	ax,*$60
04431 113F           50                         push	ax
04432                                           ! Debug: func () void = outb+0 (used reg = )
04433 1140           E8         F415            call	_outb
04434 1143           83C4                   04  add	sp,*4
04435                                           !BCC_EOS
04436                                           ! 1202     max=0xffff;
04437                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04438 1146           B8                   FFFF  mov	ax,#$FFFF
04439 1149           8946         FE            mov	-2[bp],ax
04440                                           !BCC_EOS
04441                                           ! 1203     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04442 114C           EB           0E            jmp .EE
04443                       0000114E            .EF:
04444                                           ! Debug: list int = const $60 (used reg = )
04445 114E           B8                   0060  mov	ax,*$60
04446 1151           50                         push	ax
04447                                           ! Debug: list int = const $80 (used reg = )
04448 1152           B8                   0080  mov	ax,#$80
04449 1155           50                         push	ax
04450                                           ! Debug: func () void = outb+0 (used reg = )
04451 1156           E8         F3FF            call	_outb
04452 1159           83C4                   04  add	sp,*4
04453                                           !BCC_EOS
04454                                           ! 1204     if (max==0x0) keyboard_panic(60);
04455                       0000115C            .EE:
04456                                           ! Debug: list int = const $64 (used reg = )
04457 115C           B8                   0064  mov	ax,*$64
04458 115F           50                         push	ax
04459                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04460 1160           E8         F3DF            call	_inb
04461 1163           44                         inc	sp
04462 1164           44                         inc	sp
04463                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04464 1165           24                     02  and	al,*2
04465 1167           84C0                       test	al,al
04466 1169           74           0B            je  	.F0
04467                       0000116B            .F1:
04468                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04469 116B           8B46         FE            mov	ax,-2[bp]
04470 116E           48                         dec	ax
04471 116F           8946         FE            mov	-2[bp],ax
04472                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04473 1172           85C0                       test	ax,ax
04474 1174           75           D8            jne	.EF
04475                       00001176            .F0:
04476                       00001176            .ED:
04477                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04478 1176           8B46         FE            mov	ax,-2[bp]
04479 1179           85C0                       test	ax,ax
04480 117B           75           09            jne 	.F2
04481                       0000117D            .F3:
04482                                           ! Debug: list int = const $3C (used reg = )
04483 117D           B8                   003C  mov	ax,*$3C
04484 1180           50                         push	ax
04485                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04486 1181           E8         00B8            call	_keyboard_panic
04487 1184           44                         inc	sp
04488 1185           44                         inc	sp
04489                                           !BCC_EOS
04490                                           ! 1205     outb(0x60, 0xf4);
04491                       00001186            .F2:
04492                                           ! Debug: list int = const $F4 (used reg = )
04493 1186           B8                   00F4  mov	ax,#$F4
04494 1189           50                         push	ax
04495                                           ! Debug: list int = const $60 (used reg = )
04496 118A           B8                   0060  mov	ax,*$60
04497 118D           50                         push	ax
04498                                           ! Debug: func () void = outb+0 (used reg = )
04499 118E           E8         F3C7            call	_outb
04500 1191           83C4                   04  add	sp,*4
04501                                           !BCC_EOS
04502                                           ! 1206     max=0xffff;
04503                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04504 1194           B8                   FFFF  mov	ax,#$FFFF
04505 1197           8946         FE            mov	-2[bp],ax
04506                                           !BCC_EOS
04507                                           ! 1207     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04508 119A           EB           0E            jmp .F5
04509                       0000119C            .F6:
04510                                           ! Debug: list int = const $70 (used reg = )
04511 119C           B8                   0070  mov	ax,*$70
04512 119F           50                         push	ax
04513                                           ! Debug: list int = const $80 (used reg = )
04514 11A0           B8                   0080  mov	ax,#$80
04515 11A3           50                         push	ax
04516                                           ! Debug: func () void = outb+0 (used reg = )
04517 11A4           E8         F3B1            call	_outb
04518 11A7           83C4                   04  add	sp,*4
04519                                           !BCC_EOS
04520                                           ! 1208     if (max==0x0) keyboard_panic(70);
04521                       000011AA            .F5:
04522                                           ! Debug: list int = const $64 (used reg = )
04523 11AA           B8                   0064  mov	ax,*$64
04524 11AD           50                         push	ax
04525                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04526 11AE           E8         F391            call	_inb
04527 11B1           44                         inc	sp
04528 11B2           44                         inc	sp
04529                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04530 11B3           24                     02  and	al,*2
04531 11B5           84C0                       test	al,al
04532 11B7           74           0B            je  	.F7
04533                       000011B9            .F8:
04534                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04535 11B9           8B46         FE            mov	ax,-2[bp]
04536 11BC           48                         dec	ax
04537 11BD           8946         FE            mov	-2[bp],ax
04538                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04539 11C0           85C0                       test	ax,ax
04540 11C2           75           D8            jne	.F6
04541                       000011C4            .F7:
04542                       000011C4            .F4:
04543                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04544 11C4           8B46         FE            mov	ax,-2[bp]
04545 11C7           85C0                       test	ax,ax
04546 11C9           75           09            jne 	.F9
04547                       000011CB            .FA:
04548                                           ! Debug: list int = const $46 (used reg = )
04549 11CB           B8                   0046  mov	ax,*$46
04550 11CE           50                         push	ax
04551                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04552 11CF           E8         006A            call	_keyboard_panic
04553 11D2           44                         inc	sp
04554 11D3           44                         inc	sp
04555                                           !BCC_EOS
04556                                           ! 1209     max=0xffff;
04557                       000011D4            .F9:
04558                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04559 11D4           B8                   FFFF  mov	ax,#$FFFF
04560 11D7           8946         FE            mov	-2[bp],ax
04561                                           !BCC_EOS
04562                                           ! 1210     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04563 11DA           EB           0E            jmp .FC
04564                       000011DC            .FD:
04565                                           ! Debug: list int = const $71 (used reg = )
04566 11DC           B8                   0071  mov	ax,*$71
04567 11DF           50                         push	ax
04568                                           ! Debug: list int = const $80 (used reg = )
04569 11E0           B8                   0080  mov	ax,#$80
04570 11E3           50                         push	ax
04571                                           ! Debug: func () void = outb+0 (used reg = )
04572 11E4           E8         F371            call	_outb
04573 11E7           83C4                   04  add	sp,*4
04574                                           !BCC_EOS
04575                                           ! 1211     if (max==0x0) keyboard_panic(70);
04576                       000011EA            .FC:
04577                                           ! Debug: list int = const $64 (used reg = )
04578 11EA           B8                   0064  mov	ax,*$64
04579 11ED           50                         push	ax
04580                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04581 11EE           E8         F351            call	_inb
04582 11F1           44                         inc	sp
04583 11F2           44                         inc	sp
04584                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04585 11F3           24                     01  and	al,*1
04586                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04587 11F5           84C0                       test	al,al
04588 11F7           75           0B            jne 	.FE
04589                       000011F9            .FF:
04590                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04591 11F9           8B46         FE            mov	ax,-2[bp]
04592 11FC           48                         dec	ax
04593 11FD           8946         FE            mov	-2[bp],ax
04594                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04595 1200           85C0                       test	ax,ax
04596 1202           75           D8            jne	.FD
04597                       00001204            .FE:
04598                       00001204            .FB:
04599                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04600 1204           8B46         FE            mov	ax,-2[bp]
04601 1207           85C0                       test	ax,ax
04602 1209           75           09            jne 	.100
04603                       0000120B            .101:
04604                                           ! Debug: list int = const $46 (used reg = )
04605 120B           B8                   0046  mov	ax,*$46
04606 120E           50                         push	ax
04607                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04608 120F           E8         002A            call	_keyboard_panic
04609 1212           44                         inc	sp
04610 1213           44                         inc	sp
04611                                           !BCC_EOS
04612                                           ! 1212     if ((inb(0x60) != 0xfa)) {
04613                       00001214            .100:
04614                                           ! Debug: list int = const $60 (used reg = )
04615 1214           B8                   0060  mov	ax,*$60
04616 1217           50                         push	ax
04617                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04618 1218           E8         F327            call	_inb
04619 121B           44                         inc	sp
04620 121C           44                         inc	sp
04621                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04622 121D           3C                     FA  cmp	al,#$FA
04623 121F           74           09            je  	.102
04624                       00001221            .103:
04625                                           ! 1213         keyboard_panic(996);
04626                                           ! Debug: list int = const $3E4 (used reg = )
04627 1221           B8                   03E4  mov	ax,#$3E4
04628 1224           50                         push	ax
04629                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04630 1225           E8         0014            call	_keyboard_panic
04631 1228           44                         inc	sp
04632 1229           44                         inc	sp
04633                                           !BCC_EOS
04634                                           ! 1214     }
04635                                           ! 1215     outb(0x80, 0x77);
04636                       0000122A            .102:
04637                                           ! Debug: list int = const $77 (used reg = )
04638 122A           B8                   0077  mov	ax,*$77
04639 122D           50                         push	ax
04640                                           ! Debug: list int = const $80 (used reg = )
04641 122E           B8                   0080  mov	ax,#$80
04642 1231           50                         push	ax
04643                                           ! Debug: func () void = outb+0 (used reg = )
04644 1232           E8         F323            call	_outb
04645 1235           83C4                   04  add	sp,*4
04646                                           !BCC_EOS
04647                                           ! 1216 }
04648 1238           89EC                       mov	sp,bp
04649 123A           5D                         pop	bp
04650 123B           C3                         ret
04651                                           ! 1217   void
04652                                           ! 1218 keyboard_panic(status)
04653                                           ! 1219   Bit16u status;
04654                                           export	_keyboard_panic
04655                       0000123C            _keyboard_panic:
04656                                           !BCC_EOS
04657                                           ! 1220 {
04658                                           ! 1221   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04659 123C           55                         push	bp
04660 123D           89E5                       mov	bp,sp
04661                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04662 123F           FF76         04            push	4[bp]
04663                                           ! Debug: list * char = .104+0 (used reg = )
04664 1242           BB                   D9C5  mov	bx,#.104
04665 1245           53                         push	bx
04666                                           ! Debug: list int = const 7 (used reg = )
04667 1246           B8                   0007  mov	ax,*7
04668 1249           50                         push	ax
04669                                           ! Debug: func () void = bios_printf+0 (used reg = )
04670 124A           E8         F75A            call	_bios_printf
04671 124D           89EC                       mov	sp,bp
04672                                           !BCC_EOS
04673                                           ! 1222 }
04674 124F           5D                         pop	bp
04675 1250           C3                         ret
04676                                           ! 1223   void
04677                                           ! Register BX used in function keyboard_panic
04678                                           ! 1224 shutdown_status_panic(status)
04679                                           ! 1225   Bit16u status;
04680                                           export	_shutdown_status_panic
04681                       00001251            _shutdown_status_panic:
04682                                           !BCC_EOS
04683                                           ! 1226 {
04684                                           ! 1227   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04685 1251           55                         push	bp
04686 1252           89E5                       mov	bp,sp
04687                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04688 1254           8A46         04            mov	al,4[bp]
04689 1257           30E4                       xor	ah,ah
04690 1259           50                         push	ax
04691                                           ! Debug: list * char = .105+0 (used reg = )
04692 125A           BB                   D9A0  mov	bx,#.105
04693 125D           53                         push	bx
04694                                           ! Debug: list int = const 7 (used reg = )
04695 125E           B8                   0007  mov	ax,*7
04696 1261           50                         push	ax
04697                                           ! Debug: func () void = bios_printf+0 (used reg = )
04698 1262           E8         F742            call	_bios_printf
04699 1265           89EC                       mov	sp,bp
04700                                           !BCC_EOS
04701                                           ! 1228 }
04702 1267           5D                         pop	bp
04703 1268           C3                         ret
04704                                           ! 1229 void s3_resume_panic()
04705                                           ! Register BX used in function shutdown_status_panic
04706                                           ! 1230 {
04707                                           export	_s3_resume_panic
04708                       00001269            _s3_resume_panic:
04709                                           ! 1231   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04710 1269           55                         push	bp
04711 126A           89E5                       mov	bp,sp
04712                                           ! Debug: list * char = .106+0 (used reg = )
04713 126C           BB                   D986  mov	bx,#.106
04714 126F           53                         push	bx
04715                                           ! Debug: list int = const 7 (used reg = )
04716 1270           B8                   0007  mov	ax,*7
04717 1273           50                         push	ax
04718                                           ! Debug: func () void = bios_printf+0 (used reg = )
04719 1274           E8         F730            call	_bios_printf
04720 1277           89EC                       mov	sp,bp
04721                                           !BCC_EOS
04722                                           ! 1232 }
04723 1279           5D                         pop	bp
04724 127A           C3                         ret
04725                                           ! 1233 void
04726                                           ! Register BX used in function s3_resume_panic
04727                                           ! 1234 print_bios_banner()
04728                                           ! 1235 {
04729                                           export	_print_bios_banner
04730                       0000127B            _print_bios_banner:
04731                                           ! 1236   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "10/11/09", bios_cvs_version_string);
04732 127B           55                         push	bp
04733 127C           89E5                       mov	bp,sp
04734                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04735 127E           BB                   0194  mov	bx,#_bios_cvs_version_string
04736 1281           53                         push	bx
04737                                           ! Debug: list * char = .108+0 (used reg = )
04738 1282           BB                   D959  mov	bx,#.108
04739 1285           53                         push	bx
04740                                           ! Debug: list * char = .107+0 (used reg = )
04741 1286           BB                   D962  mov	bx,#.107
04742 1289           53                         push	bx
04743                                           ! Debug: list int = const 2 (used reg = )
04744 128A           B8                   0002  mov	ax,*2
04745 128D           50                         push	ax
04746                                           ! Debug: func () void = bios_printf+0 (used reg = )
04747 128E           E8         F716            call	_bios_printf
04748 1291           89EC                       mov	sp,bp
04749                                           !BCC_EOS
04750                                           ! 1237   bios_printf(2, "apmbios " "pcibios " "eltorito " "\n\n");
04751                                           ! Debug: list * char = .109+0 (used reg = )
04752 1293           BB                   D93D  mov	bx,#.109
04753 1296           53                         push	bx
04754                                           ! Debug: list int = const 2 (used reg = )
04755 1297           B8                   0002  mov	ax,*2
04756 129A           50                         push	ax
04757                                           ! Debug: func () void = bios_printf+0 (used reg = )
04758 129B           E8         F709            call	_bios_printf
04759 129E           89EC                       mov	sp,bp
04760                                           !BCC_EOS
04761                                           ! 1238 }
04762 12A0           5D                         pop	bp
04763 12A1           C3                         ret
04764                                           ! 1239 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04765                                           ! Register BX used in function print_bios_banner
04766                                           
04767                       000012A2            _drivetypes:
04768                       000012A2            .10A:
04769 12A2                        00            .byte	0
04770 12A3                  00000009            .blkb	9
04771                       000012AC            .10B:
04772 12AC                        46            .ascii	"Floppy"
04773 12B2                        00            .byte	0
04774 12B3                  00000003            .blkb	3
04775                       000012B6            .10C:
04776 12B6                        48            .ascii	"Hard Disk"
04777 12BF                        00            .byte	0
04778                       000012C0            .10D:
04779 12C0                        43            .ascii	"CD-Rom"
04780 12C6                        00            .byte	0
04781 12C7                  00000003            .blkb	3
04782                       000012CA            .10E:
04783 12CA                        4E            .ascii	"Network"
04784 12D1                        00            .byte	0
04785 12D2                  00000002            .blkb	2
04786                                           !BCC_EOS
04787                                           ! 1240 static void
04788                                           ! 1241 init_boot_vectors()
04789                                           ! 1242 {
04790                                           
04791                       000012D4            _init_boot_vectors:
04792                                           ! 1243   ipl_entry_t e;
04793                                           !BCC_EOS
04794                                           ! 1244   Bit16u count = 0;
04795 12D4           55                         push	bp
04796 12D5           89E5                       mov	bp,sp
04797 12D7           83C4                   EE  add	sp,*-$12
04798                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04799 12DA           31C0                       xor	ax,ax
04800 12DC           8946         EE            mov	-$12[bp],ax
04801                                           !BCC_EOS
04802                                           ! 1245   Bit16u ss = get_SS();
04803 12DF           4C                         dec	sp
04804 12E0           4C                         dec	sp
04805                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04806 12E1           E8         F36D            call	_get_SS
04807                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04808 12E4           8946         EC            mov	-$14[bp],ax
04809                                           !BCC_EOS
04810                                           ! 1246   memsetb(0x9ff0, 0x0000, 0, 0xff);
04811                                           ! Debug: list int = const $FF (used reg = )
04812 12E7           B8                   00FF  mov	ax,#$FF
04813 12EA           50                         push	ax
04814                                           ! Debug: list int = const 0 (used reg = )
04815 12EB           31C0                       xor	ax,ax
04816 12ED           50                         push	ax
04817                                           ! Debug: list int = const 0 (used reg = )
04818 12EE           31C0                       xor	ax,ax
04819 12F0           50                         push	ax
04820                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04821 12F1           B8                   9FF0  mov	ax,#$9FF0
04822 12F4           50                         push	ax
04823                                           ! Debug: func () void = memsetb+0 (used reg = )
04824 12F5           E8         ED08            call	_memsetb
04825 12F8           83C4                   08  add	sp,*8
04826                                           !BCC_EOS
04827                                           ! 1247   write_word(0x9ff0, 0x0084, 0xFFFF);
04828                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04829 12FB           B8                   FFFF  mov	ax,#$FFFF
04830 12FE           50                         push	ax
04831                                           ! Debug: list int = const $84 (used reg = )
04832 12FF           B8                   0084  mov	ax,#$84
04833 1302           50                         push	ax
04834                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04835 1303           B8                   9FF0  mov	ax,#$9FF0
04836 1306           50                         push	ax
04837                                           ! Debug: func () void = write_word+0 (used reg = )
04838 1307           E8         F32C            call	_write_word
04839 130A           83C4                   06  add	sp,*6
04840                                           !BCC_EOS
04841                                           ! 1248   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04842                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04843 130D           B8                   0001  mov	ax,*1
04844 1310           8946         F0            mov	-$10[bp],ax
04845                                           !BCC_EOS
04846                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04847 1313           31C0                       xor	ax,ax
04848 1315           8946         F2            mov	-$E[bp],ax
04849                                           !BCC_EOS
04850                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04851 1318           31C0                       xor	ax,ax
04852 131A           31DB                       xor	bx,bx
04853 131C           8946         F4            mov	-$C[bp],ax
04854 131F           895E         F6            mov	-$A[bp],bx
04855                                           !BCC_EOS
04856                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04857 1322           31C0                       xor	ax,ax
04858 1324           31DB                       xor	bx,bx
04859 1326           8946         F8            mov	-8[bp],ax
04860 1329           895E         FA            mov	-6[bp],bx
04861                                           !BCC_EOS
04862                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04863 132C           31C0                       xor	ax,ax
04864 132E           31DB                       xor	bx,bx
04865 1330           8946         FC            mov	-4[bp],ax
04866 1333           895E         FE            mov	-2[bp],bx
04867                                           !BCC_EOS
04868                                           ! 1249   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04869                                           ! Debug: list int = const $10 (used reg = )
04870 1336           B8                   0010  mov	ax,*$10
04871 1339           50                         push	ax
04872                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04873 133A           8D5E         F0            lea	bx,-$10[bp]
04874 133D           53                         push	bx
04875                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04876 133E           FF76         EC            push	-$14[bp]
04877                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04878 1341           8B46         EE            mov	ax,-$12[bp]
04879 1344           B1                     04  mov	cl,*4
04880 1346           D3E0                       shl	ax,cl
04881                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04882                                           ! Debug: expression subtree swapping
04883                                           ! Debug: list unsigned int = ax+0 (used reg = )
04884 1348           50                         push	ax
04885                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04886 1349           B8                   9FF0  mov	ax,#$9FF0
04887 134C           50                         push	ax
04888                                           ! Debug: func () void = memcpyb+0 (used reg = )
04889 134D           E8         ECD4            call	_memcpyb
04890 1350           83C4                   0A  add	sp,*$A
04891                                           !BCC_EOS
04892                                           ! 1250   count++;
04893                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04894 1353           8B46         EE            mov	ax,-$12[bp]
04895 1356           40                         inc	ax
04896 1357           8946         EE            mov	-$12[bp],ax
04897                                           !BCC_EOS
04898                                           ! 1251   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04899                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
04900 135A           B8                   0002  mov	ax,*2
04901 135D           8946         F0            mov	-$10[bp],ax
04902                                           !BCC_EOS
04903                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04904 1360           31C0                       xor	ax,ax
04905 1362           8946         F2            mov	-$E[bp],ax
04906                                           !BCC_EOS
04907                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04908 1365           31C0                       xor	ax,ax
04909 1367           31DB                       xor	bx,bx
04910 1369           8946         F4            mov	-$C[bp],ax
04911 136C           895E         F6            mov	-$A[bp],bx
04912                                           !BCC_EOS
04913                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04914 136F           31C0                       xor	ax,ax
04915 1371           31DB                       xor	bx,bx
04916 1373           8946         F8            mov	-8[bp],ax
04917 1376           895E         FA            mov	-6[bp],bx
04918                                           !BCC_EOS
04919                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04920 1379           31C0                       xor	ax,ax
04921 137B           31DB                       xor	bx,bx
04922 137D           8946         FC            mov	-4[bp],ax
04923 1380           895E         FE            mov	-2[bp],bx
04924                                           !BCC_EOS
04925                                           ! 1252   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04926                                           ! Debug: list int = const $10 (used reg = )
04927 1383           B8                   0010  mov	ax,*$10
04928 1386           50                         push	ax
04929                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04930 1387           8D5E         F0            lea	bx,-$10[bp]
04931 138A           53                         push	bx
04932                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04933 138B           FF76         EC            push	-$14[bp]
04934                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04935 138E           8B46         EE            mov	ax,-$12[bp]
04936 1391           B1                     04  mov	cl,*4
04937 1393           D3E0                       shl	ax,cl
04938                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04939                                           ! Debug: expression subtree swapping
04940                                           ! Debug: list unsigned int = ax+0 (used reg = )
04941 1395           50                         push	ax
04942                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04943 1396           B8                   9FF0  mov	ax,#$9FF0
04944 1399           50                         push	ax
04945                                           ! Debug: func () void = memcpyb+0 (used reg = )
04946 139A           E8         EC87            call	_memcpyb
04947 139D           83C4                   0A  add	sp,*$A
04948                                           !BCC_EOS
04949                                           ! 1253   count++;
04950                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04951 13A0           8B46         EE            mov	ax,-$12[bp]
04952 13A3           40                         inc	ax
04953 13A4           8946         EE            mov	-$12[bp],ax
04954                                           !BCC_EOS
04955                                           ! 1254   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04956                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
04957 13A7           B8                   0003  mov	ax,*3
04958 13AA           8946         F0            mov	-$10[bp],ax
04959                                           !BCC_EOS
04960                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04961 13AD           31C0                       xor	ax,ax
04962 13AF           8946         F2            mov	-$E[bp],ax
04963                                           !BCC_EOS
04964                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04965 13B2           31C0                       xor	ax,ax
04966 13B4           31DB                       xor	bx,bx
04967 13B6           8946         F4            mov	-$C[bp],ax
04968 13B9           895E         F6            mov	-$A[bp],bx
04969                                           !BCC_EOS
04970                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04971 13BC           31C0                       xor	ax,ax
04972 13BE           31DB                       xor	bx,bx
04973 13C0           8946         F8            mov	-8[bp],ax
04974 13C3           895E         FA            mov	-6[bp],bx
04975                                           !BCC_EOS
04976                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04977 13C6           31C0                       xor	ax,ax
04978 13C8           31DB                       xor	bx,bx
04979 13CA           8946         FC            mov	-4[bp],ax
04980 13CD           895E         FE            mov	-2[bp],bx
04981                                           !BCC_EOS
04982                                           ! 1255   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04983                                           ! Debug: list int = const $10 (used reg = )
04984 13D0           B8                   0010  mov	ax,*$10
04985 13D3           50                         push	ax
04986                                           ! Debug: list * struct  e = S+$18-$12 (used reg = )
04987 13D4           8D5E         F0            lea	bx,-$10[bp]
04988 13D7           53                         push	bx
04989                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04990 13D8           FF76         EC            push	-$14[bp]
04991                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04992 13DB           8B46         EE            mov	ax,-$12[bp]
04993 13DE           B1                     04  mov	cl,*4
04994 13E0           D3E0                       shl	ax,cl
04995                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04996                                           ! Debug: expression subtree swapping
04997                                           ! Debug: list unsigned int = ax+0 (used reg = )
04998 13E2           50                         push	ax
04999                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05000 13E3           B8                   9FF0  mov	ax,#$9FF0
05001 13E6           50                         push	ax
05002                                           ! Debug: func () void = memcpyb+0 (used reg = )
05003 13E7           E8         EC3A            call	_memcpyb
05004 13EA           83C4                   0A  add	sp,*$A
05005                                           !BCC_EOS
05006                                           ! 1256   count++;
05007                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05008 13ED           8B46         EE            mov	ax,-$12[bp]
05009 13F0           40                         inc	ax
05010 13F1           8946         EE            mov	-$12[bp],ax
05011                                           !BCC_EOS
05012                                           ! 1257   write_word(0x9ff0, 0x0080, count);
05013                                           ! Debug: list unsigned short count = [S+$16-$14] (used reg = )
05014 13F4           FF76         EE            push	-$12[bp]
05015                                           ! Debug: list int = const $80 (used reg = )
05016 13F7           B8                   0080  mov	ax,#$80
05017 13FA           50                         push	ax
05018                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05019 13FB           B8                   9FF0  mov	ax,#$9FF0
05020 13FE           50                         push	ax
05021                                           ! Debug: func () void = write_word+0 (used reg = )
05022 13FF           E8         F234            call	_write_word
05023 1402           83C4                   06  add	sp,*6
05024                                           !BCC_EOS
05025                                           ! 1258   write_word(0x9ff0, 0x0082, 0xffff);
05026                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05027 1405           B8                   FFFF  mov	ax,#$FFFF
05028 1408           50                         push	ax
05029                                           ! Debug: list int = const $82 (used reg = )
05030 1409           B8                   0082  mov	ax,#$82
05031 140C           50                         push	ax
05032                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05033 140D           B8                   9FF0  mov	ax,#$9FF0
05034 1410           50                         push	ax
05035                                           ! Debug: func () void = write_word+0 (used reg = )
05036 1411           E8         F222            call	_write_word
05037 1414           83C4                   06  add	sp,*6
05038                                           !BCC_EOS
05039                                           ! 1259 }
05040 1417           89EC                       mov	sp,bp
05041 1419           5D                         pop	bp
05042 141A           C3                         ret
05043                                           ! 1260 static Bit8u
05044                                           ! Register BX used in function init_boot_vectors
05045                                           ! 1261 get_boot_vector(i, e)
05046                                           ! 1262 Bit16u i; ipl_entry_t *e;
05047                       0000141B            _get_boot_vector:
05048                                           !BCC_EOS
05049                                           !BCC_EOS
05050                                           ! 1263 {
05051                                           ! 1264   Bit16u count;
05052                                           !BCC_EOS
05053                                           ! 1265   Bit16u ss = get_SS();
05054 141B           55                         push	bp
05055 141C           89E5                       mov	bp,sp
05056 141E           83C4                   FC  add	sp,*-4
05057                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05058 1421           E8         F22D            call	_get_SS
05059                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05060 1424           8946         FC            mov	-4[bp],ax
05061                                           !BCC_EOS
05062                                           ! 1266   count = read_word(0x9ff0, 0x0080);
05063                                           ! Debug: list int = const $80 (used reg = )
05064 1427           B8                   0080  mov	ax,#$80
05065 142A           50                         push	ax
05066                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05067 142B           B8                   9FF0  mov	ax,#$9FF0
05068 142E           50                         push	ax
05069                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05070 142F           E8         F1D9            call	_read_word
05071 1432           83C4                   04  add	sp,*4
05072                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05073 1435           8946         FE            mov	-2[bp],ax
05074                                           !BCC_EOS
05075                                           ! 1267   if (i >= count) return 0;
05076                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05077 1438           8B46         04            mov	ax,4[bp]
05078 143B           3B46         FE            cmp	ax,-2[bp]
05079 143E           72           06            jb  	.10F
05080                       00001440            .110:
05081 1440           30C0                       xor	al,al
05082 1442           89EC                       mov	sp,bp
05083 1444           5D                         pop	bp
05084 1445           C3                         ret
05085                                           !BCC_EOS
05086                                           ! 1268   memcpyb(ss, e, 0x9ff0, 0x0000 + i * sizeof (*e), sizeof (*e));
05087                       00001446            .10F:
05088                                           ! Debug: list int = const $10 (used reg = )
05089 1446           B8                   0010  mov	ax,*$10
05090 1449           50                         push	ax
05091                                           ! Debug: mul int = const $10 to unsigned short i = [S+8+2] (used reg = )
05092 144A           8B46         04            mov	ax,4[bp]
05093 144D           B1                     04  mov	cl,*4
05094 144F           D3E0                       shl	ax,cl
05095                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05096                                           ! Debug: expression subtree swapping
05097                                           ! Debug: list unsigned int = ax+0 (used reg = )
05098 1451           50                         push	ax
05099                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05100 1452           B8                   9FF0  mov	ax,#$9FF0
05101 1455           50                         push	ax
05102                                           ! Debug: list * struct  e = [S+$C+4] (used reg = )
05103 1456           FF76         06            push	6[bp]
05104                                           ! Debug: list unsigned short ss = [S+$E-6] (used reg = )
05105 1459           FF76         FC            push	-4[bp]
05106                                           ! Debug: func () void = memcpyb+0 (used reg = )
05107 145C           E8         EBC5            call	_memcpyb
05108 145F           83C4                   0A  add	sp,*$A
05109                                           !BCC_EOS
05110                                           ! 1269   re
05111                                           ! 1269 turn 1;
05112 1462           B0                     01  mov	al,*1
05113 1464           89EC                       mov	sp,bp
05114 1466           5D                         pop	bp
05115 1467           C3                         ret
05116                                           !BCC_EOS
05117                                           ! 1270 }
05118                                           ! 1271   void
05119                                           ! 1272 interactive_bootkey()
05120                                           ! 1273 {
05121                                           export	_interactive_bootkey
05122                       00001468            _interactive_bootkey:
05123                                           ! 1274   ipl_entry_t e;
05124                                           !BCC_EOS
05125                                           ! 1275   Bit16u count;
05126                                           !BCC_EOS
05127                                           ! 1276   char description[33];
05128                                           !BCC_EOS
05129                                           ! 1277   Bit8u scan_code;
05130                                           !BCC_EOS
05131                                           ! 1278   Bit8u i;
05132                                           !BCC_EOS
05133                                           ! 1279   Bit16u ss = get_SS();
05134 1468           55                         push	bp
05135 1469           89E5                       mov	bp,sp
05136 146B           83C4                   C8  add	sp,*-$38
05137                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05138 146E           E8         F1E0            call	_get_SS
05139                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05140 1471           8946         C8            mov	-$38[bp],ax
05141                                           !BCC_EOS
05142                                           ! 1280   Bit16u valid_choice = 0;
05143 1474           4C                         dec	sp
05144 1475           4C                         dec	sp
05145                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05146 1476           31C0                       xor	ax,ax
05147 1478           8946         C6            mov	-$3A[bp],ax
05148                                           !BCC_EOS
05149                                           ! 1281   while (check_for_keystroke())
05150                                           ! 1282     get_keystroke();
05151 147B           EB           03            jmp .112
05152                       0000147D            .113:
05153                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05154 147D           E8         F4EE            call	_get_keystroke
05155                                           !BCC_EOS
05156                                           ! 1283   bios_printf(2, "Press F12 for boot menu.\n\n");
05157                       00001480            .112:
05158                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05159 1480           E8         F4DD            call	_check_for_keystroke
05160 1483           84C0                       test	al,al
05161 1485           75           F6            jne	.113
05162                       00001487            .114:
05163                       00001487            .111:
05164                                           ! Debug: list * char = .115+0 (used reg = )
05165 1487           BB                   D922  mov	bx,#.115
05166 148A           53                         push	bx
05167                                           ! Debug: list int = const 2 (used reg = )
05168 148B           B8                   0002  mov	ax,*2
05169 148E           50                         push	ax
05170                                           ! Debug: func () void = bios_printf+0 (used reg = )
05171 148F           E8         F515            call	_bios_printf
05172 1492           83C4                   04  add	sp,*4
05173                                           !BCC_EOS
05174                                           ! 1284   delay_ticks_and_check_for_keystroke(11, 5);
05175                                           ! Debug: list int = const 5 (used reg = )
05176 1495           B8                   0005  mov	ax,*5
05177 1498           50                         push	ax
05178                                           ! Debug: list int = const $B (used reg = )
05179 1499           B8                   000B  mov	ax,*$B
05180 149C           50                         push	ax
05181                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05182 149D           E8         F4D6            call	_delay_ticks_and_check_for_keystroke
05183 14A0           83C4                   04  add	sp,*4
05184                                           !BCC_EOS
05185                                           ! 1285   if (check_for_keystroke())
05186                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05187 14A3           E8         F4BA            call	_check_for_keystroke
05188 14A6           84C0                       test	al,al
05189 14A8         0F84         01B1            beq 	.116
05190                       000014AC            .117:
05191                                           ! 1286   {
05192                                           ! 1287     scan_code = get_keystroke();
05193                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05194 14AC           E8         F4BF            call	_get_keystroke
05195                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05196 14AF           8846         CC            mov	-$34[bp],al
05197                                           !BCC_EOS
05198                                           ! 1288     if (scan_code == 0x86)
05199                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05200 14B2           8A46         CC            mov	al,-$34[bp]
05201 14B5           3C                     86  cmp	al,#$86
05202 14B7         0F85         01A2            bne 	.118
05203                       000014BB            .119:
05204                                           ! 1289     {
05205                                           ! 1290       while (check_for_keystroke())
05206                                           ! 1291         get_keystroke();
05207 14BB           EB           03            jmp .11B
05208                       000014BD            .11C:
05209                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05210 14BD           E8         F4AE            call	_get_keystroke
05211                                           !BCC_EOS
05212                                           ! 1292       bios_printf(2, "Select boot device:\n\n");
05213                       000014C0            .11B:
05214                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05215 14C0           E8         F49D            call	_check_for_keystroke
05216 14C3           84C0                       test	al,al
05217 14C5           75           F6            jne	.11C
05218                       000014C7            .11D:
05219                       000014C7            .11A:
05220                                           ! Debug: list * char = .11E+0 (used reg = )
05221 14C7           BB                   D90C  mov	bx,#.11E
05222 14CA           53                         push	bx
05223                                           ! Debug: list int = const 2 (used reg = )
05224 14CB           B8                   0002  mov	ax,*2
05225 14CE           50                         push	ax
05226                                           ! Debug: func () void = bios_printf+0 (used reg = )
05227 14CF           E8         F4D5            call	_bios_printf
05228 14D2           83C4                   04  add	sp,*4
05229                                           !BCC_EOS
05230                                           ! 1293       count = read_word(0x9ff0, 0x0080);
05231                                           ! Debug: list int = const $80 (used reg = )
05232 14D5           B8                   0080  mov	ax,#$80
05233 14D8           50                         push	ax
05234                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05235 14D9           B8                   9FF0  mov	ax,#$9FF0
05236 14DC           50                         push	ax
05237                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05238 14DD           E8         F12B            call	_read_word
05239 14E0           83C4                   04  add	sp,*4
05240                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05241 14E3           8946         EE            mov	-$12[bp],ax
05242                                           !BCC_EOS
05243                                           ! 1294       for (i = 0; i < count; i++)
05244                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05245 14E6           30C0                       xor	al,al
05246 14E8           8846         CB            mov	-$35[bp],al
05247                                           !BCC_EOS
05248                                           !BCC_EOS
05249                                           ! 1295       {
05250 14EB           E9         00FC            br 	.121
05251                       000014EE            .122:
05252                                           ! 1296         memcpyb(ss, &e, 0x9ff0, 0x0000 + i * sizeof (e), sizeof (e));
05253                                           ! Debug: list int = const $10 (used reg = )
05254 14EE           B8                   0010  mov	ax,*$10
05255 14F1           50                         push	ax
05256                                           ! Debug: mul int = const $10 to unsigned char i = [S+$3E-$37] (used reg = )
05257 14F2           8A46         CB            mov	al,-$35[bp]
05258 14F5           30E4                       xor	ah,ah
05259 14F7           B1                     04  mov	cl,*4
05260 14F9           D3E0                       shl	ax,cl
05261                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05262                                           ! Debug: expression subtree swapping
05263                                           ! Debug: list unsigned int = ax+0 (used reg = )
05264 14FB           50                         push	ax
05265                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05266 14FC           B8                   9FF0  mov	ax,#$9FF0
05267 14FF           50                         push	ax
05268                                           ! Debug: list * struct  e = S+$42-$12 (used reg = )
05269 1500           8D5E         F0            lea	bx,-$10[bp]
05270 1503           53                         push	bx
05271                                           ! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
05272 1504           FF76         C8            push	-$38[bp]
05273                                           ! Debug: func () void = memcpyb+0 (used reg = )
05274 1507           E8         EB1A            call	_memcpyb
05275 150A           83C4                   0A  add	sp,*$A
05276                                           !BCC_EOS
05277                                           ! 1297         bios_printf(2, "%d. ", i+1);
05278                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05279 150D           8A46         CB            mov	al,-$35[bp]
05280 1510           30E4                       xor	ah,ah
05281                                           ! Debug: list unsigned int = ax+1 (used reg = )
05282 1512           40                         inc	ax
05283 1513           50                         push	ax
05284                                           ! Debug: list * char = .123+0 (used reg = )
05285 1514           BB                   D907  mov	bx,#.123
05286 1517           53                         push	bx
05287                                           ! Debug: list int = const 2 (used reg = )
05288 1518           B8                   0002  mov	ax,*2
05289 151B           50                         push	ax
05290                                           ! Debug: func () void = bios_printf+0 (used reg = )
05291 151C           E8         F488            call	_bios_printf
05292 151F           83C4                   06  add	sp,*6
05293                                           !BCC_EOS
05294                                           ! 1298         switch(e.type)
05295 1522           8B46         F0            mov	ax,-$10[bp]
05296                                           ! 1299         {
05297 1525           E9         009F            br 	.126
05298                                           ! 1300           case 0x01:
05299                                           ! 1301           case 0x02:
05300                       00001528            .127:
05301                                           ! 1302           case 0x03:
05302                       00001528            .128:
05303                                           ! 1303             bios_printf(2, "%s\n", drivetypes[e.type]);
05304                       00001528            .129:
05305                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05306 1528           8B5E         F0            mov	bx,-$10[bp]
05307 152B           89DA                       mov	dx,bx
05308 152D           D1E3                       shl	bx,*1
05309 152F           D1E3                       shl	bx,*1
05310 1531           01D3                       add	bx,dx
05311 1533           D1E3                       shl	bx,*1
05312                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05313                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05314 1535           81C3                 12A2  add	bx,#_drivetypes
05315 1539           53                         push	bx
05316                                           ! Debug: list * char = .12A+0 (used reg = )
05317 153A           BB                   D903  mov	bx,#.12A
05318 153D           53                         push	bx
05319                                           ! Debug: list int = const 2 (used reg = )
05320 153E           B8                   0002  mov	ax,*2
05321 1541           50                         push	ax
05322                                           ! Debug: func () void = bios_printf+0 (used reg = )
05323 1542           E8         F462            call	_bios_printf
05324 1545           83C4                   06  add	sp,*6
05325                                           !BCC_EOS
05326                                           ! 1304             break;
05327 1548           E9         0098            br 	.124
05328                                           !BCC_EOS
05329                                           ! 1305           case 0x80:
05330                                           ! 1306             bios_printf(2, "%s", drivetypes[4]);
05331                       0000154B            .12B:
05332                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05333 154B           BB                   12CA  mov	bx,#_drivetypes+$28
05334 154E           53                         push	bx
05335                                           ! Debug: list * char = .12C+0 (used reg = )
05336 154F           BB                   D900  mov	bx,#.12C
05337 1552           53                         push	bx
05338                                           ! Debug: list int = const 2 (used reg = )
05339 1553           B8                   0002  mov	ax,*2
05340 1556           50                         push	ax
05341                                           ! Debug: func () void = bios_printf+0 (used reg = )
05342 1557           E8         F44D            call	_bios_printf
05343 155A           83C4                   06  add	sp,*6
05344                                           !BCC_EOS
05345                                           ! 1307             if (e.description != 0)
05346                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05347                                           ! Debug: expression subtree swapping
05348 155D           31C0                       xor	ax,ax
05349 155F           31DB                       xor	bx,bx
05350 1561           53                         push	bx
05351 1562           50                         push	ax
05352 1563           8B46         F8            mov	ax,-8[bp]
05353 1566           8B5E         FA            mov	bx,-6[bp]
05354 1569           8D7E         C2            lea	di,-2+..FFFF[bp]
05355 156C           E8         EB5C            call	lcmpul
05356 156F           8D66         C6            lea	sp,2+..FFFF[bp]
05357 1572           74           41            je  	.12D
05358                       00001574            .12E:
05359                                           ! 1308             {
05360                                           ! 1309               memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05361                                           ! Debug: list int = const $20 (used reg = )
05362 1574           B8                   0020  mov	ax,*$20
05363 1577           50                         push	ax
05364                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$3E-$A] (used reg = )
05365                                           ! Debug: expression subtree swapping
05366 1578           B8                   FFFF  mov	ax,#$FFFF
05367 157B           31DB                       xor	bx,bx
05368 157D           8D7E         F8            lea	di,-8[bp]
05369 1580           E8         EB38            call	landul
05370                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05371                                           ! Debug: list unsigned short = ax+0 (used reg = )
05372 1583           50                         push	ax
05373                                           ! Debug: sr int = const $10 to unsigned long e = [S+$40-$A] (used reg = )
05374 1584           8B46         F8            mov	ax,-8[bp]
05375 1587           8B5E         FA            mov	bx,-6[bp]
05376 158A           93                         xchg	bx,ax
05377 158B           31DB                       xor	bx,bx
05378                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05379                                           ! Debug: list unsigned short = ax+0 (used reg = )
05380 158D           50                         push	ax
05381                                           ! Debug: list * [$21] char description = S+$42-$35 (used reg = )
05382 158E           8D5E         CD            lea	bx,-$33[bp]
05383 1591           53                         push	bx
05384                                           ! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
05385 1592           FF76         C8            push	-$38[bp]
05386                                           ! Debug: func () void = memcpyb+0 (used reg = )
05387 1595           E8         EA8C            call	_memcpyb
05388 1598           83C4                   0A  add	sp,*$A
05389                                           !BCC_EOS
05390                                           ! 1310               description[32] = 0;
05391                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05392 159B           30C0                       xor	al,al
05393 159D           8846         ED            mov	-$13[bp],al
05394                                           !BCC_EOS
05395                                           ! 1311               bios_printf(2, " [%S]", ss, description);
05396                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05397 15A0           8D5E         CD            lea	bx,-$33[bp]
05398 15A3           53                         push	bx
05399                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05400 15A4           FF76         C8            push	-$38[bp]
05401                                           ! Debug: list * char = .12F+0 (used reg = )
05402 15A7           BB                   D8FA  mov	bx,#.12F
05403 15AA           53                         push	bx
05404                                           ! Debug: list int = const 2 (used reg = )
05405 15AB           B8                   0002  mov	ax,*2
05406 15AE           50                         push	ax
05407                                           ! Debug: func () void = bios_printf+0 (used reg = )
05408 15AF           E8         F3F5            call	_bios_printf
05409 15B2           83C4                   08  add	sp,*8
05410                                           !BCC_EOS
05411                                           ! 1312            }
05412                                           ! 1313            bios_printf(2, "\n");
05413                       000015B5            .12D:
05414                                           ! Debug: list * char = .130+0 (used reg = )
05415 15B5           BB                   D8F8  mov	bx,#.130
05416 15B8           53                         push	bx
05417                                           ! Debug: list int = const 2 (used reg = )
05418 15B9           B8                   0002  mov	ax,*2
05419 15BC           50                         push	ax
05420                                           ! Debug: func () void = bios_printf+0 (used reg = )
05421 15BD           E8         F3E7            call	_bios_printf
05422 15C0           83C4                   04  add	sp,*4
05423                                           !BCC_EOS
05424                                           ! 1314            break;
05425 15C3           EB           1E            jmp .124
05426                                           !BCC_EOS
05427                                           ! 1315         }
05428                                           ! 1316       }
05429 15C5           EB           1C            jmp .124
05430                       000015C7            .126:
05431 15C7           2D                   0001  sub	ax,*1
05432 15CA         0F84         FF5A            beq 	.127
05433 15CE           2D                   0001  sub	ax,*1
05434 15D1         0F84         FF53            beq 	.128
05435 15D5           2D                   0001  sub	ax,*1
05436 15D8         0F84         FF4C            beq 	.129
05437 15DC           2D                   007D  sub	ax,*$7D
05438 15DF         0F84         FF68            beq 	.12B
05439                       000015E3            .124:
05440                       FFFFFFC4            ..FFFF	=	-$3C
05441                                           ! 1317       count++;
05442                       000015E3            .120:
05443                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05444 15E3           8A46         CB            mov	al,-$35[bp]
05445 15E6           40                         inc	ax
05446 15E7           8846         CB            mov	-$35[bp],al
05447                       000015EA            .121:
05448                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05449 15EA           8A46         CB            mov	al,-$35[bp]
05450 15ED           30E4                       xor	ah,ah
05451 15EF           3B46         EE            cmp	ax,-$12[bp]
05452 15F2         0F82         FEF8            blo 	.122
05453                       000015F6            .131:
05454                       000015F6            .11F:
05455                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05456 15F6           8B46         EE            mov	ax,-$12[bp]
05457 15F9           40                         inc	ax
05458 15FA           8946         EE            mov	-$12[bp],ax
05459                                           !BCC_EOS
05460                                           ! 1318       while (!valid_choice) {
05461 15FD           EB           49            jmp .133
05462                       000015FF            .134:
05463                                           ! 1319         scan_code = get_keystroke();
05464                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05465 15FF           E8         F36C            call	_get_keystroke
05466                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05467 1602           8846         CC            mov	-$34[bp],al
05468                                           !BCC_EOS
05469                                           ! 1320         if (scan_code == 0x01 || scan_code == 0x58)
05470                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05471 1605           8A46         CC            mov	al,-$34[bp]
05472 1608           3C                     01  cmp	al,*1
05473 160A           74           07            je  	.136
05474                       0000160C            .137:
05475                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05476 160C           8A46         CC            mov	al,-$34[bp]
05477 160F           3C                     58  cmp	al,*$58
05478 1611           75           08            jne 	.135
05479                       00001613            .136:
05480                                           ! 1321         {
05481                                           ! 1322           valid_choice = 1;
05482                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05483 1613           B8                   0001  mov	ax,*1
05484 1616           8946         C6            mov	-$3A[bp],ax
05485                                           !BCC_EOS
05486                                           ! 1323         }
05487                                           ! 1324         else if (scan_code <= count)
05488 1619           EB           2D            jmp .138
05489                       0000161B            .135:
05490                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05491 161B           8A46         CC            mov	al,-$34[bp]
05492 161E           30E4                       xor	ah,ah
05493 1620           3B46         EE            cmp	ax,-$12[bp]
05494 1623           77           23            ja  	.139
05495                       00001625            .13A:
05496                                           ! 1325         {
05497                                           ! 1326           valid_choice = 1;
05498                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05499 1625           B8                   0001  mov	ax,*1
05500 1628           8946         C6            mov	-$3A[bp],ax
05501                                           !BCC_EOS
05502                                           ! 1327           scan_code -= 1;
05503                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05504 162B           8A46         CC            mov	al,-$34[bp]
05505 162E           30E4                       xor	ah,ah
05506 1630           48                         dec	ax
05507 1631           8846         CC            mov	-$34[bp],al
05508                                           !BCC_EOS
05509                                           ! 1328           write_word(0x9ff0, 0x0084, scan_code);
05510                                           ! Debug: list unsigned char scan_code = [S+$3C-$36] (used reg = )
05511 1634           8A46         CC            mov	al,-$34[bp]
05512 1637           30E4                       xor	ah,ah
05513 1639           50                         push	ax
05514                                           ! Debug: list int = const $84 (used reg = )
05515 163A           B8                   0084  mov	ax,#$84
05516 163D           50                         push	ax
05517                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05518 163E           B8                   9FF0  mov	ax,#$9FF0
05519 1641           50                         push	ax
05520                                           ! Debug: func () void = write_word+0 (used reg = )
05521 1642           E8         EFF1            call	_write_word
05522 1645           83C4                   06  add	sp,*6
05523                                           !BCC_EOS
05524                                           ! 1329         }
05525                                           ! 1330       }
05526                       00001648            .139:
05527                       00001648            .138:
05528                                           ! 1331       bios_printf(2, "\n");
05529                       00001648            .133:
05530 1648           8B46         C6            mov	ax,-$3A[bp]
05531 164B           85C0                       test	ax,ax
05532 164D           74           B0            je 	.134
05533                       0000164F            .13B:
05534                       0000164F            .132:
05535                                           ! Debug: list * char = .13C+0 (used reg = )
05536 164F           BB                   D8F6  mov	bx,#.13C
05537 1652           53                         push	bx
05538                                           ! Debug: list int = const 2 (used reg = )
05539 1653           B8                   0002  mov	ax,*2
05540 1656           50                         push	ax
05541                                           ! Debug: func () void = bios_printf+0 (used reg = )
05542 1657           E8         F34D            call	_bios_printf
05543 165A           83C4                   04  add	sp,*4
05544                                           !BCC_EOS
05545                                           ! 1332     }
05546                                           ! 1333   }
05547                       0000165D            .118:
05548                                           ! 1334 }
05549                       0000165D            .116:
05550 165D           89EC                       mov	sp,bp
05551 165F           5D                         pop	bp
05552 1660           C3                         ret
05553                                           ! 1335 void
05554                                           ! Register BX used in function interactive_bootkey
05555                                           ! 1336 print_boot_device(e)
05556                                           ! 1337   ipl_entry_t *e;
05557                                           export	_print_boot_device
05558                       00001661            _print_boot_device:
05559                                           !BCC_EOS
05560                                           ! 1338 {
05561                                           ! 1339   Bit16u type;
05562                                           !BCC_EOS
05563                                           ! 1340   char description[33];
05564                                           !BCC_EOS
05565                                           ! 1341   Bit16u ss = get_SS();
05566 1661           55                         push	bp
05567 1662           89E5                       mov	bp,sp
05568 1664           83C4                   DA  add	sp,*-$26
05569                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05570 1667           E8         EFE7            call	_get_SS
05571                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05572 166A           8946         DA            mov	-$26[bp],ax
05573                                           !BCC_EOS
05574                                           ! 1342   type = e->type;
05575 166D           8B5E         04            mov	bx,4[bp]
05576                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05577 1670           8B1F                       mov	bx,[bx]
05578 1672           895E         FE            mov	-2[bp],bx
05579                                           !BCC_EOS
05580                                           ! 1343   if (type == 0x80) type = 0x4;
05581                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05582 1675           8B46         FE            mov	ax,-2[bp]
05583 1678           3D                   0080  cmp	ax,#$80
05584 167B           75           06            jne 	.13D
05585                       0000167D            .13E:
05586                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05587 167D           B8                   0004  mov	ax,*4
05588 1680           8946         FE            mov	-2[bp],ax
05589                                           !BCC_EOS
05590                                           ! 1344   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05591                       00001683            .13D:
05592                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05593 1683           8B46         FE            mov	ax,-2[bp]
05594 1686           85C0                       test	ax,ax
05595 1688           74           08            je  	.140
05596                       0000168A            .141:
05597                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05598 168A           8B46         FE            mov	ax,-2[bp]
05599 168D           3D                   0004  cmp	ax,*4
05600 1690           76           0E            jbe 	.13F
05601                       00001692            .140:
05602                                           ! Debug: list * char = .142+0 (used reg = )
05603 1692           BB                   D8E6  mov	bx,#.142
05604 1695           53                         push	bx
05605                                           ! Debug: list int = const 7 (used reg = )
05606 1696           B8                   0007  mov	ax,*7
05607 1699           50                         push	ax
05608                                           ! Debug: func () void = bios_printf+0 (used reg = )
05609 169A           E8         F30A            call	_bios_printf
05610 169D           83C4                   04  add	sp,*4
05611                                           !BCC_EOS
05612                                           ! 1345   bios_printf(2, "Booting from %s", drivetypes[type]);
05613                       000016A0            .13F:
05614                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05615 16A0           8B5E         FE            mov	bx,-2[bp]
05616 16A3           89DA                       mov	dx,bx
05617 16A5           D1E3                       shl	bx,*1
05618 16A7           D1E3                       shl	bx,*1
05619 16A9           01D3                       add	bx,dx
05620 16AB           D1E3                       shl	bx,*1
05621                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05622                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05623 16AD           81C3                 12A2  add	bx,#_drivetypes
05624 16B1           53                         push	bx
05625                                           ! Debug: list * char = .143+0 (used reg = )
05626 16B2           BB                   D8D6  mov	bx,#.143
05627 16B5           53                         push	bx
05628                                           ! Debug: list int = const 2 (used reg = )
05629 16B6           B8                   0002  mov	ax,*2
05630 16B9           50                         push	ax
05631                                           ! Debug: func () void = bios_printf+0 (used reg = )
05632 16BA           E8         F2EA            call	_bios_printf
05633 16BD           83C4                   06  add	sp,*6
05634                                           !BCC_EOS
05635                                           ! 1346   if (type == 4 && e->description != 0) {
05636                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05637 16C0           8B46         FE            mov	ax,-2[bp]
05638 16C3           3D                   0004  cmp	ax,*4
05639 16C6           75           6A            jne 	.144
05640                       000016C8            .146:
05641 16C8           8B5E         04            mov	bx,4[bp]
05642                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05643                                           ! Debug: expression subtree swapping
05644 16CB           31C0                       xor	ax,ax
05645 16CD           31F6                       xor	si,si
05646 16CF           56                         push	si
05647 16D0           50                         push	ax
05648 16D1           8B47         08            mov	ax,8[bx]
05649 16D4           8B5F         0A            mov	bx,$A[bx]
05650 16D7           8D7E         D6            lea	di,-$2A[bp]
05651 16DA           E8         E9EE            call	lcmpul
05652 16DD           8D66         DA            lea	sp,-$26[bp]
05653 16E0           74           50            je  	.144
05654                       000016E2            .145:
05655                                           ! 1347     memcpyb(ss, &descrip
05656                                           ! 1347 tion, (Bit16u)(e->description >> 16), (Bit16u)(e->description & 0xffff), 32);
05657                                           ! Debug: list int = const $20 (used reg = )
05658 16E2           B8                   0020  mov	ax,*$20
05659 16E5           50                         push	ax
05660 16E6           8B5E         04            mov	bx,4[bp]
05661                                           ! Debug: and unsigned long = const $FFFF to unsigned long = [bx+8] (used reg = )
05662                                           ! Debug: expression subtree swapping
05663 16E9           FF77         0A            push	$A[bx]
05664 16EC           FF77         08            push	8[bx]
05665 16EF           B8                   FFFF  mov	ax,#$FFFF
05666 16F2           31DB                       xor	bx,bx
05667 16F4           8D7E         D4            lea	di,-$2C[bp]
05668 16F7           E8         E9C1            call	landul
05669 16FA           83C4                   04  add	sp,*4
05670                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05671                                           ! Debug: list unsigned short = ax+0 (used reg = )
05672 16FD           50                         push	ax
05673 16FE           8B5E         04            mov	bx,4[bp]
05674                                           ! Debug: sr int = const $10 to unsigned long = [bx+8] (used reg = )
05675 1701           8B47         08            mov	ax,8[bx]
05676 1704           8B5F         0A            mov	bx,$A[bx]
05677 1707           93                         xchg	bx,ax
05678 1708           31DB                       xor	bx,bx
05679                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05680                                           ! Debug: list unsigned short = ax+0 (used reg = )
05681 170A           50                         push	ax
05682                                           ! Debug: list * [$21] char description = S+$2E-$25 (used reg = )
05683 170B           8D5E         DD            lea	bx,-$23[bp]
05684 170E           53                         push	bx
05685                                           ! Debug: list unsigned short ss = [S+$30-$28] (used reg = )
05686 170F           FF76         DA            push	-$26[bp]
05687                                           ! Debug: func () void = memcpyb+0 (used reg = )
05688 1712           E8         E90F            call	_memcpyb
05689 1715           83C4                   0A  add	sp,*$A
05690                                           !BCC_EOS
05691                                           ! 1348     description[32] = 0;
05692                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05693 1718           30C0                       xor	al,al
05694 171A           8846         FD            mov	-3[bp],al
05695                                           !BCC_EOS
05696                                           ! 1349     bios_printf(2, " [%S]", ss, description);
05697                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05698 171D           8D5E         DD            lea	bx,-$23[bp]
05699 1720           53                         push	bx
05700                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05701 1721           FF76         DA            push	-$26[bp]
05702                                           ! Debug: list * char = .147+0 (used reg = )
05703 1724           BB                   D8D0  mov	bx,#.147
05704 1727           53                         push	bx
05705                                           ! Debug: list int = const 2 (used reg = )
05706 1728           B8                   0002  mov	ax,*2
05707 172B           50                         push	ax
05708                                           ! Debug: func () void = bios_printf+0 (used reg = )
05709 172C           E8         F278            call	_bios_printf
05710 172F           83C4                   08  add	sp,*8
05711                                           !BCC_EOS
05712                                           ! 1350   }
05713                                           ! 1351   bios_printf(2, "...\n");
05714                       00001732            .144:
05715                                           ! Debug: list * char = .148+0 (used reg = )
05716 1732           BB                   D8CB  mov	bx,#.148
05717 1735           53                         push	bx
05718                                           ! Debug: list int = const 2 (used reg = )
05719 1736           B8                   0002  mov	ax,*2
05720 1739           50                         push	ax
05721                                           ! Debug: func () void = bios_printf+0 (used reg = )
05722 173A           E8         F26A            call	_bios_printf
05723 173D           83C4                   04  add	sp,*4
05724                                           !BCC_EOS
05725                                           ! 1352 }
05726 1740           89EC                       mov	sp,bp
05727 1742           5D                         pop	bp
05728 1743           C3                         ret
05729                                           ! 1353   void
05730                                           ! Register BX used in function print_boot_device
05731                                           ! 1354 print_boot_failure(type, reason)
05732                                           ! 1355   Bit16u type; Bit8u reason;
05733                                           export	_print_boot_failure
05734                       00001744            _print_boot_failure:
05735                                           !BCC_EOS
05736                                           !BCC_EOS
05737                                           ! 1356 {
05738                                           ! 1357   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05739 1744           55                         push	bp
05740 1745           89E5                       mov	bp,sp
05741                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05742 1747           8B46         04            mov	ax,4[bp]
05743 174A           85C0                       test	ax,ax
05744 174C           74           08            je  	.14A
05745                       0000174E            .14B:
05746                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05747 174E           8B46         04            mov	ax,4[bp]
05748 1751           3D                   0003  cmp	ax,*3
05749 1754           76           0D            jbe 	.149
05750                       00001756            .14A:
05751                                           ! Debug: list * char = .14C+0 (used reg = )
05752 1756           BB                   D8BB  mov	bx,#.14C
05753 1759           53                         push	bx
05754                                           ! Debug: list int = const 7 (used reg = )
05755 175A           B8                   0007  mov	ax,*7
05756 175D           50                         push	ax
05757                                           ! Debug: func () void = bios_printf+0 (used reg = )
05758 175E           E8         F246            call	_bios_printf
05759 1761           89EC                       mov	sp,bp
05760                                           !BCC_EOS
05761                                           ! 1358   bios_printf(2, "Boot failed");
05762                       00001763            .149:
05763                                           ! Debug: list * char = .14D+0 (used reg = )
05764 1763           BB                   D8AF  mov	bx,#.14D
05765 1766           53                         push	bx
05766                                           ! Debug: list int = const 2 (used reg = )
05767 1767           B8                   0002  mov	ax,*2
05768 176A           50                         push	ax
05769                                           ! Debug: func () void = bios_printf+0 (used reg = )
05770 176B           E8         F239            call	_bios_printf
05771 176E           89EC                       mov	sp,bp
05772                                           !BCC_EOS
05773                                           ! 1359   if (type < 4) {
05774                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05775 1770           8B46         04            mov	ax,4[bp]
05776 1773           3D                   0004  cmp	ax,*4
05777 1776           73           23            jae 	.14E
05778                       00001778            .14F:
05779                                           ! 1360     if (reason==0)
05780                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05781 1778           8A46         06            mov	al,6[bp]
05782 177B           84C0                       test	al,al
05783 177D           75           0F            jne 	.150
05784                       0000177F            .151:
05785                                           ! 1361       bios_printf(2, ": not a bootable disk");
05786                                           ! Debug: list * char = .152+0 (used reg = )
05787 177F           BB                   D899  mov	bx,#.152
05788 1782           53                         push	bx
05789                                           ! Debug: list int = const 2 (used reg = )
05790 1783           B8                   0002  mov	ax,*2
05791 1786           50                         push	ax
05792                                           ! Debug: func () void = bios_printf+0 (used reg = )
05793 1787           E8         F21D            call	_bios_printf
05794 178A           89EC                       mov	sp,bp
05795                                           !BCC_EOS
05796                                           ! 1362     else
05797                                           ! 1363       bios_printf(2, ": could not read the boot disk");
05798 178C           EB           0D            jmp .153
05799                       0000178E            .150:
05800                                           ! Debug: list * char = .154+0 (used reg = )
05801 178E           BB                   D87A  mov	bx,#.154
05802 1791           53                         push	bx
05803                                           ! Debug: list int = const 2 (used reg = )
05804 1792           B8                   0002  mov	ax,*2
05805 1795           50                         push	ax
05806                                           ! Debug: func () void = bios_printf+0 (used reg = )
05807 1796           E8         F20E            call	_bios_printf
05808 1799           89EC                       mov	sp,bp
05809                                           !BCC_EOS
05810                                           ! 1364   }
05811                       0000179B            .153:
05812                                           ! 1365   bios_printf(2, "\n\n");
05813                       0000179B            .14E:
05814                                           ! Debug: list * char = .155+0 (used reg = )
05815 179B           BB                   D877  mov	bx,#.155
05816 179E           53                         push	bx
05817                                           ! Debug: list int = const 2 (used reg = )
05818 179F           B8                   0002  mov	ax,*2
05819 17A2           50                         push	ax
05820                                           ! Debug: func () void = bios_printf+0 (used reg = )
05821 17A3           E8         F201            call	_bios_printf
05822 17A6           89EC                       mov	sp,bp
05823                                           !BCC_EOS
05824                                           ! 1366 }
05825 17A8           5D                         pop	bp
05826 17A9           C3                         ret
05827                                           ! 1367   void
05828                                           ! Register BX used in function print_boot_failure
05829                                           ! 1368 print_cdromboot_failure( code )
05830                                           ! 1369   Bit16u code;
05831                                           export	_print_cdromboot_failure
05832                       000017AA            _print_cdromboot_failure:
05833                                           !BCC_EOS
05834                                           ! 1370 {
05835                                           ! 1371   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05836 17AA           55                         push	bp
05837 17AB           89E5                       mov	bp,sp
05838                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05839 17AD           FF76         04            push	4[bp]
05840                                           ! Debug: list * char = .156+0 (used reg = )
05841 17B0           BB                   D857  mov	bx,#.156
05842 17B3           53                         push	bx
05843                                           ! Debug: list int = const 6 (used reg = )
05844 17B4           B8                   0006  mov	ax,*6
05845 17B7           50                         push	ax
05846                                           ! Debug: func () void = bios_printf+0 (used reg = )
05847 17B8           E8         F1EC            call	_bios_printf
05848 17BB           89EC                       mov	sp,bp
05849                                           !BCC_EOS
05850                                           ! 1372   return;
05851 17BD           5D                         pop	bp
05852 17BE           C3                         ret
05853                                           !BCC_EOS
05854                                           ! 1373 }
05855                                           ! 1374 void
05856                                           ! Register BX used in function print_cdromboot_failure
05857                                           ! 1375 nmi_handler_msg()
05858                                           ! 1376 {
05859                                           export	_nmi_handler_msg
05860                       000017BF            _nmi_handler_msg:
05861                                           ! 1377   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05862 17BF           55                         push	bp
05863 17C0           89E5                       mov	bp,sp
05864                                           ! Debug: list * char = .157+0 (used reg = )
05865 17C2           BB                   D843  mov	bx,#.157
05866 17C5           53                         push	bx
05867                                           ! Debug: list int = const 7 (used reg = )
05868 17C6           B8                   0007  mov	ax,*7
05869 17C9           50                         push	ax
05870                                           ! Debug: func () void = bios_printf+0 (used reg = )
05871 17CA           E8         F1DA            call	_bios_printf
05872 17CD           89EC                       mov	sp,bp
05873                                           !BCC_EOS
05874                                           ! 1378 }
05875 17CF           5D                         pop	bp
05876 17D0           C3                         ret
05877                                           ! 1379 void
05878                                           ! Register BX used in function nmi_handler_msg
05879                                           ! 1380 int18_panic_msg()
05880                                           ! 1381 {
05881                                           export	_int18_panic_msg
05882                       000017D1            _int18_panic_msg:
05883                                           ! 1382   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05884 17D1           55                         push	bp
05885 17D2           89E5                       mov	bp,sp
05886                                           ! Debug: list * char = .158+0 (used reg = )
05887 17D4           BB                   D82E  mov	bx,#.158
05888 17D7           53                         push	bx
05889                                           ! Debug: list int = const 7 (used reg = )
05890 17D8           B8                   0007  mov	ax,*7
05891 17DB           50                         push	ax
05892                                           ! Debug: func () void = bios_printf+0 (used reg = )
05893 17DC           E8         F1C8            call	_bios_printf
05894 17DF           89EC                       mov	sp,bp
05895                                           !BCC_EOS
05896                                           ! 1383 }
05897 17E1           5D                         pop	bp
05898 17E2           C3                         ret
05899                                           ! 1384 void
05900                                           ! Register BX used in function int18_panic_msg
05901                                           ! 1385 log_bios_start()
05902                                           ! 1386 {
05903                                           export	_log_bios_start
05904                       000017E3            _log_bios_start:
05905                                           ! 1387   bios_printf(4, "%s\n", bios_cvs_version_string);
05906 17E3           55                         push	bp
05907 17E4           89E5                       mov	bp,sp
05908                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
05909 17E6           BB                   0194  mov	bx,#_bios_cvs_version_string
05910 17E9           53                         push	bx
05911                                           ! Debug: list * char = .159+0 (used reg = )
05912 17EA           BB                   D82A  mov	bx,#.159
05913 17ED           53                         push	bx
05914                                           ! Debug: list int = const 4 (used reg = )
05915 17EE           B8                   0004  mov	ax,*4
05916 17F1           50                         push	ax
05917                                           ! Debug: func () void = bios_printf+0 (used reg = )
05918 17F2           E8         F1B2            call	_bios_printf
05919 17F5           89EC                       mov	sp,bp
05920                                           !BCC_EOS
05921                                           ! 1388 }
05922 17F7           5D                         pop	bp
05923 17F8           C3                         ret
05924                                           ! 1389   bx_bool
05925                                           ! Register BX used in function log_bios_start
05926                                           ! 1390 set_enable_a20(val)
05927                                           ! 1391   bx_bool val;
05928                                           export	_set_enable_a20
05929                       000017F9            _set_enable_a20:
05930                                           !BCC_EOS
05931                                           ! 1392 {
05932                                           ! 1393   Bit8u oldval;
05933                                           !BCC_EOS
05934                                           ! 1394   oldval = inb(0x92);
05935 17F9           55                         push	bp
05936 17FA           89E5                       mov	bp,sp
05937 17FC           4C                         dec	sp
05938 17FD           4C                         dec	sp
05939                                           ! Debug: list int = const $92 (used reg = )
05940 17FE           B8                   0092  mov	ax,#$92
05941 1801           50                         push	ax
05942                                           ! Debug: func () unsigned char = inb+0 (used reg = )
05943 1802           E8         ED3D            call	_inb
05944 1805           44                         inc	sp
05945 1806           44                         inc	sp
05946                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
05947 1807           8846         FF            mov	-1[bp],al
05948                                           !BCC_EOS
05949                                           ! 1395   if (val)
05950 180A           8B46         04            mov	ax,4[bp]
05951 180D           85C0                       test	ax,ax
05952 180F           74           14            je  	.15A
05953                       00001811            .15B:
05954                                           ! 1396     outb(0x92, oldval | 0x02);
05955                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05956 1811           8A46         FF            mov	al,-1[bp]
05957 1814           0C                     02  or	al,*2
05958                                           ! Debug: list unsigned char = al+0 (used reg = )
05959 1816           30E4                       xor	ah,ah
05960 1818           50                         push	ax
05961                                           ! Debug: list int = const $92 (used reg = )
05962 1819           B8                   0092  mov	ax,#$92
05963 181C           50                         push	ax
05964                                           ! Debug: func () void = outb+0 (used reg = )
05965 181D           E8         ED38            call	_outb
05966 1820           83C4                   04  add	sp,*4
05967                                           !BCC_EOS
05968                                           ! 1397   else
05969                                           ! 1398     outb(0x92, oldval & 0xfd);
05970 1823           EB           12            jmp .15C
05971                       00001825            .15A:
05972                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
05973 1825           8A46         FF            mov	al,-1[bp]
05974 1828           24                     FD  and	al,#$FD
05975                                           ! Debug: list unsigned char = al+0 (used reg = )
05976 182A           30E4                       xor	ah,ah
05977 182C           50                         push	ax
05978                                           ! Debug: list int = const $92 (used reg = )
05979 182D           B8                   0092  mov	ax,#$92
05980 1830           50                         push	ax
05981                                           ! Debug: func () void = outb+0 (used reg = )
05982 1831           E8         ED24            call	_outb
05983 1834           83C4                   04  add	sp,*4
05984                                           !BCC_EOS
05985                                           ! 1399   return((oldval & 0x02) != 0);
05986                       00001837            .15C:
05987                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05988 1837           8A46         FF            mov	al,-1[bp]
05989 183A           24                     02  and	al,*2
05990                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
05991 183C           84C0                       test	al,al
05992 183E           74           04            je 	.15D
05993 1840           B0                     01  mov	al,*1
05994 1842           EB           02            jmp	.15E
05995                       00001844            .15D:
05996 1844           30C0                       xor	al,al
05997                       00001846            .15E:
05998                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
05999 1846           30E4                       xor	ah,ah
06000 1848           89EC                       mov	sp,bp
06001 184A           5D                         pop	bp
06002 184B           C3                         ret
06003                                           !BCC_EOS
06004                                           ! 1400 }
06005                                           ! 1401   void
06006                                           ! 1402 debugger_on()
06007                                           ! 1403 {
06008                                           export	_debugger_on
06009                       0000184C            _debugger_on:
06010                                           ! 1404   outb(0xfedc, 0x01);
06011 184C           55                         push	bp
06012 184D           89E5                       mov	bp,sp
06013                                           ! Debug: list int = const 1 (used reg = )
06014 184F           B8                   0001  mov	ax,*1
06015 1852           50                         push	ax
06016                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06017 1853           B8                   FEDC  mov	ax,#$FEDC
06018 1856           50                         push	ax
06019                                           ! Debug: func () void = outb+0 (used reg = )
06020 1857           E8         ECFE            call	_outb
06021 185A           89EC                       mov	sp,bp
06022                                           !BCC_EOS
06023                                           ! 1405 }
06024 185C           5D                         pop	bp
06025 185D           C3                         ret
06026                                           ! 1406   void
06027                                           ! 1407 debugger_off()
06028                                           ! 1408 {
06029                                           export	_debugger_off
06030                       0000185E            _debugger_off:
06031                                           ! 1409   outb(0xfedc, 0x00);
06032 185E           55                         push	bp
06033 185F           89E5                       mov	bp,sp
06034                                           ! Debug: list int = const 0 (used reg = )
06035 1861           31C0                       xor	ax,ax
06036 1863           50                         push	ax
06037                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06038 1864           B8                   FEDC  mov	ax,#$FEDC
06039 1867           50                         push	ax
06040                                           ! Debug: func () void = outb+0 (used reg = )
06041 1868           E8         ECED            call	_outb
06042 186B           89EC                       mov	sp,bp
06043                                           !BCC_EOS
06044                                           ! 1410 }
06045 186D           5D                         pop	bp
06046 186E           C3                         ret
06047                                           ! 1411 int
06048                                           ! 1412 s3_resume()
06049                                           ! 1413 {
06050                                           export	_s3_resume
06051                       0000186F            _s3_resume:
06052                                           ! 1414     Bit32u s3_wakeup_vector;
06053                                           !BCC_EOS
06054                                           ! 1415     Bit8u s3_resume_flag;
06055                                           !BCC_EOS
06056                                           ! 1416     s3_resume_flag = read_byte(0x40, 0xb0);
06057 186F           55                         push	bp
06058 1870           89E5                       mov	bp,sp
06059 1872           83C4                   FA  add	sp,*-6
06060                                           ! Debug: list int = const $B0 (used reg = )
06061 1875           B8                   00B0  mov	ax,#$B0
06062 1878           50                         push	ax
06063                                           ! Debug: list int = const $40 (used reg = )
06064 1879           B8                   0040  mov	ax,*$40
06065 187C           50                         push	ax
06066                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06067 187D           E8         ED78            call	_read_byte
06068 1880           83C4                   04  add	sp,*4
06069                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06070 1883           8846         FB            mov	-5[bp],al
06071                                           !BCC_EOS
06072                                           ! 1417     s3_wakeup_vector = read_dword(0x40, 0xb2);
06073                                           ! Debug: list int = const $B2 (used reg = )
06074 1886           B8                   00B2  mov	ax,#$B2
06075 1889           50                         push	ax
06076                                           ! Debug: list int = const $40 (used reg = )
06077 188A           B8                   0040  mov	ax,*$40
06078 188D           50                         push	ax
06079                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
06080 188E           E8         E7F2            call	_read_dword
06081 1891           89D3                       mov	bx,dx
06082 1893           83C4                   04  add	sp,*4
06083                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06084 1896           8946         FC            mov	-4[bp],ax
06085 1899           895E         FE            mov	-2[bp],bx
06086                                           !BCC_EOS
06087                                           ! 1418     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06088                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06089 189C           FF76         FE            push	-2[bp]
06090 189F           FF76         FC            push	-4[bp]
06091                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06092 18A2           8A46         FB            mov	al,-5[bp]
06093 18A5           30E4                       xor	ah,ah
06094 18A7           50                         push	ax
06095                                           ! Debug: list * char = .15F+0 (used reg = )
06096 18A8           BB                   D80F  mov	bx,#.15F
06097 18AB           53                         push	bx
06098                                           ! Debug: list int = const 4 (used reg = )
06099 18AC           B8                   0004  mov	ax,*4
06100 18AF           50                         push	ax
06101                                           ! Debug: func () void = bios_printf+0 (used reg = )
06102 18B0           E8         F0F4            call	_bios_printf
06103 18B3           83C4                   0A  add	sp,*$A
06104                                           !BCC_EOS
06105                                           ! 1419     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06106                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06107 18B6           8A46         FB            mov	al,-5[bp]
06108 18B9           3C                     FE  cmp	al,#$FE
06109 18BB           75           0B            jne 	.161
06110                       000018BD            .162:
06111 18BD           8B46         FC            mov	ax,-4[bp]
06112 18C0           8B5E         FE            mov	bx,-2[bp]
06113 18C3           E8         E84E            call	ltstl
06114 18C6           75           06            jne 	.160
06115                       000018C8            .161:
06116                                           ! 1420      return 0;
06117 18C8           31C0                       xor	ax,ax
06118 18CA           89EC                       mov	sp,bp
06119 18CC           5D                         pop	bp
06120 18CD           C3                         ret
06121                                           !BCC_EOS
06122                                           ! 1421     write_byte(0x40, 0xb0, 0);
06123                       000018CE            .160:
06124                                           ! Debug: list int = const 0 (used reg = )
06125 18CE           31C0                       xor	ax,ax
06126 18D0           50                         push	ax
06127                                           ! Debug: list int = const $B0 (used reg = )
06128 18D1           B8                   00B0  mov	ax,#$B0
06129 18D4           50                         push	ax
06130                                           ! Debug: list int = const $40 (used reg = )
06131 18D5           B8                   0040  mov	ax,*$40
06132 18D8           50                         push	ax
06133                                           ! Debug: func () void = write_byte+0 (used reg = )
06134 18D9           E8         ED42            call	_write_byte
06135 18DC           83C4                   06  add	sp,*6
06136                                           !BCC_EOS
06137                                           ! 1422     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06138                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06139                                           ! Debug: expression subtree swapping
06140 18DF           B8                   000F  mov	ax,*$F
06141 18E2           31DB                       xor	bx,bx
06142 18E4           8D7E         FC            lea	di,-4[bp]
06143 18E7           E8         E7D1            call	landul
06144                                           ! Debug: list unsigned long = bx+0 (used reg = )
06145 18EA           53                         push	bx
06146 18EB           50                         push	ax
06147                                           ! Debug: list int = const $B6 (used reg = )
06148 18EC           B8                   00B6  mov	ax,#$B6
06149 18EF           50                         push	ax
06150                                           ! Debug: list int = const $40 (used reg = )
06151 18F0           B8                   0040  mov	ax,*$40
06152 18F3           50                         push	ax
06153                                           ! Debug: func () void = write_word+0 (used reg = )
06154 18F4           E8         ED3F            call	_write_word
06155 18F7           83C4                   08  add	sp,*8
06156                                           !BCC_EOS
06157                                           ! 1423     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06158                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06159 18FA           8B46         FC            mov	ax,-4[bp]
06160 18FD           8B5E         FE            mov	bx,-2[bp]
06161 1900           BF                   0004  mov	di,*4
06162 1903           E8         E823            call	lsrul
06163                                           ! Debug: list unsigned long = bx+0 (used reg = )
06164 1906           53                         push	bx
06165 1907           50                         push	ax
06166                                           ! Debug: list int = const $B8 (used reg = )
06167 1908           B8                   00B8  mov	ax,#$B8
06168 190B           50                         push	ax
06169                                           ! Debug: list int = const $40 (used reg = )
06170 190C           B8                   0040  mov	ax,*$40
06171 190F           50                         push	ax
06172                                           ! Debug: func () void = write_word+0 (used reg = )
06173 1910           E8         ED23            call	_write_word
06174 1913           83C4                   08  add	sp,*8
06175                                           !BCC_EOS
06176                                           ! 1424     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06177                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06178                                           ! Debug: expression subtree swapping
06179 1916           B8                   000F  mov	ax,*$F
06180 1919           31DB                       xor	bx,bx
06181 191B           8D7E         FC            lea	di,-4[bp]
06182 191E           E8         E79A            call	landul
06183                                           ! Debug: list unsigned long = bx+0 (used reg = )
06184 1921           53                         push	bx
06185 1922           50                         push	ax
06186                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06187 1923           8B46         FC            mov	ax,-4[bp]
06188 1926           8B5E         FE            mov	bx,-2[bp]
06189 1929           BF                   0004  mov	di,*4
06190 192C           E8         E7FA            call	lsrul
06191                                           ! Debug: list unsigned long = bx+0 (used reg = )
06192 192F           53                         push	bx
06193 1930           50                         push	ax
06194                                           ! Debug: list * char = .163+0 (used reg = )
06195 1931           BB                   D7F6  mov	bx,#.163
06196 1934           53                         push	bx
06197                                           ! Debug: list int = const 4 (used reg = )
06198 1935           B8                   0004  mov	ax,*4
06199 1938           50                         push	ax
06200                                           ! Debug: func () void = bios_printf+0 (used reg = )
06201 1939           E8         F06B            call	_bios_printf
06202 193C           83C4                   0C  add	sp,*$C
06203                                           !BCC_EOS
06204                                           ! 1425 #asm
06205                                           !BCC_EOS
06206                                           !BCC_ASM
06207                       00000001            _s3_resume.s3_resume_flag	set	1
06208                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06209                       00000002            _s3_resume.s3_wakeup_vector	set	2
06210                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06211 193F           FF2E       04B6                jmpf [0x04b6]
06212                                           ! 1427 endasm
06213                                           !BCC_ENDASM
06214                                           !BCC_EOS
06215                                           ! 1428     return 1;
06216 1943           B8                   0001  mov	ax,*1
06217 1946           89EC                       mov	sp,bp
06218 1948           5D                         pop	bp
06219 1949           C3                         ret
06220                                           !BCC_EOS
06221                                           ! 1429 }
06222                                           ! 1430 void ata_init( )
06223                                           ! Register BX used in function s3_resume
06224                                           ! 1431 {
06225                                           export	_ata_init
06226                       0000194A            _ata_init:
06227                                           ! 1432   Bit16u ebda_seg=read_word(0x0040,0x000E);
06228 194A           55                         push	bp
06229 194B           89E5                       mov	bp,sp
06230 194D           4C                         dec	sp
06231 194E           4C                         dec	sp
06232                                           ! Debug: list int = const $E (used reg = )
06233 194F           B8                   000E  mov	ax,*$E
06234 1952           50                         push	ax
06235                                           ! Debug: list int = const $40 (used reg = )
06236 1953           B8                   0040  mov	ax,*$40
06237 1956           50                         push	ax
06238                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06239 1957           E8         ECB1            call	_read_word
06240 195A           83C4                   04  add	sp,*4
06241                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06242 195D           8946         FE            mov	-2[bp],ax
06243                                           !BCC_EOS
06244                                           ! 1433   Bit8u channel, device;
06245                                           !BCC_EOS
06246                                           ! 1434   for (channel=0; channel<4; channel++) {
06247 1960           4C                         dec	sp
06248 1961           4C                         dec	sp
06249                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06250 1962           30C0                       xor	al,al
06251 1964           8846         FD            mov	-3[bp],al
06252                                           !BCC_EOS
06253                                           !BCC_EOS
06254 1967           E9         0077            br 	.166
06255                       0000196A            .167:
06256                                           ! 1435     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06257                                           ! Debug: list int = const 0 (used reg = )
06258 196A           31C0                       xor	ax,ax
06259 196C           50                         push	ax
06260                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06261 196D           8A46         FD            mov	al,-3[bp]
06262 1970           30E4                       xor	ah,ah
06263 1972           B1                     03  mov	cl,*3
06264 1974           D3E0                       shl	ax,cl
06265 1976           89C3                       mov	bx,ax
06266                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06267                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06268 1978           81C3                 0122  add	bx,#$122
06269 197C           53                         push	bx
06270                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06271 197D           FF76         FE            push	-2[bp]
06272                                           ! Debug: func () void = write_byte+0 (used reg = )
06273 1980           E8         EC9B            call	_write_byte
06274 1983           83C4                   06  add	sp,*6
06275                                           !BCC_EOS
06276                                           ! 1436     write_word(ebda_seg,&((ebd
06277                                           ! 1436 a_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06278                                           ! Debug: list int = const 0 (used reg = )
06279 1986           31C0                       xor	ax,ax
06280 1988           50                         push	ax
06281                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06282 1989           8A46         FD            mov	al,-3[bp]
06283 198C           30E4                       xor	ah,ah
06284 198E           B1                     03  mov	cl,*3
06285 1990           D3E0                       shl	ax,cl
06286 1992           89C3                       mov	bx,ax
06287                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06288                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06289 1994           81C3                 0124  add	bx,#$124
06290 1998           53                         push	bx
06291                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06292 1999           FF76         FE            push	-2[bp]
06293                                           ! Debug: func () void = write_word+0 (used reg = )
06294 199C           E8         EC97            call	_write_word
06295 199F           83C4                   06  add	sp,*6
06296                                           !BCC_EOS
06297                                           ! 1437     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06298                                           ! Debug: list int = const 0 (used reg = )
06299 19A2           31C0                       xor	ax,ax
06300 19A4           50                         push	ax
06301                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06302 19A5           8A46         FD            mov	al,-3[bp]
06303 19A8           30E4                       xor	ah,ah
06304 19AA           B1                     03  mov	cl,*3
06305 19AC           D3E0                       shl	ax,cl
06306 19AE           89C3                       mov	bx,ax
06307                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06308                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06309 19B0           81C3                 0126  add	bx,#$126
06310 19B4           53                         push	bx
06311                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06312 19B5           FF76         FE            push	-2[bp]
06313                                           ! Debug: func () void = write_word+0 (used reg = )
06314 19B8           E8         EC7B            call	_write_word
06315 19BB           83C4                   06  add	sp,*6
06316                                           !BCC_EOS
06317                                           ! 1438     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06318                                           ! Debug: list int = const 0 (used reg = )
06319 19BE           31C0                       xor	ax,ax
06320 19C0           50                         push	ax
06321                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06322 19C1           8A46         FD            mov	al,-3[bp]
06323 19C4           30E4                       xor	ah,ah
06324 19C6           B1                     03  mov	cl,*3
06325 19C8           D3E0                       shl	ax,cl
06326 19CA           89C3                       mov	bx,ax
06327                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06328                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06329 19CC           81C3                 0128  add	bx,#$128
06330 19D0           53                         push	bx
06331                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06332 19D1           FF76         FE            push	-2[bp]
06333                                           ! Debug: func () void = write_byte+0 (used reg = )
06334 19D4           E8         EC47            call	_write_byte
06335 19D7           83C4                   06  add	sp,*6
06336                                           !BCC_EOS
06337                                           ! 1439   }
06338                                           ! 1440   for (device=0; device<(4*2); device++) {
06339                       000019DA            .165:
06340                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06341 19DA           8A46         FD            mov	al,-3[bp]
06342 19DD           40                         inc	ax
06343 19DE           8846         FD            mov	-3[bp],al
06344                       000019E1            .166:
06345                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06346 19E1           8A46         FD            mov	al,-3[bp]
06347 19E4           3C                     04  cmp	al,*4
06348 19E6           72           82            jb 	.167
06349                       000019E8            .168:
06350                       000019E8            .164:
06351                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06352 19E8           30C0                       xor	al,al
06353 19EA           8846         FC            mov	-4[bp],al
06354                                           !BCC_EOS
06355                                           !BCC_EOS
06356 19ED           E9         01C0            br 	.16B
06357                       000019F0            .16C:
06358                                           ! 1441     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06359                                           ! Debug: list int = const 0 (used reg = )
06360 19F0           31C0                       xor	ax,ax
06361 19F2           50                         push	ax
06362                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06363 19F3           8A46         FC            mov	al,-4[bp]
06364 19F6           30E4                       xor	ah,ah
06365 19F8           B9                   001E  mov	cx,*$1E
06366 19FB           F7E9                       imul	cx
06367 19FD           89C3                       mov	bx,ax
06368                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06369                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06370 19FF           81C3                 0142  add	bx,#$142
06371 1A03           53                         push	bx
06372                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06373 1A04           FF76         FE            push	-2[bp]
06374                                           ! Debug: func () void = write_byte+0 (used reg = )
06375 1A07           E8         EC14            call	_write_byte
06376 1A0A           83C4                   06  add	sp,*6
06377                                           !BCC_EOS
06378                                           ! 1442     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06379                                           ! Debug: list int = const 0 (used reg = )
06380 1A0D           31C0                       xor	ax,ax
06381 1A0F           50                         push	ax
06382                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06383 1A10           8A46         FC            mov	al,-4[bp]
06384 1A13           30E4                       xor	ah,ah
06385 1A15           B9                   001E  mov	cx,*$1E
06386 1A18           F7E9                       imul	cx
06387 1A1A           89C3                       mov	bx,ax
06388                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06389                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06390 1A1C           81C3                 0143  add	bx,#$143
06391 1A20           53                         push	bx
06392                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06393 1A21           FF76         FE            push	-2[bp]
06394                                           ! Debug: func () void = write_byte+0 (used reg = )
06395 1A24           E8         EBF7            call	_write_byte
06396 1A27           83C4                   06  add	sp,*6
06397                                           !BCC_EOS
06398                                           ! 1443     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06399                                           ! Debug: list int = const 0 (used reg = )
06400 1A2A           31C0                       xor	ax,ax
06401 1A2C           50                         push	ax
06402                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06403 1A2D           8A46         FC            mov	al,-4[bp]
06404 1A30           30E4                       xor	ah,ah
06405 1A32           B9                   001E  mov	cx,*$1E
06406 1A35           F7E9                       imul	cx
06407 1A37           89C3                       mov	bx,ax
06408                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06409                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06410 1A39           81C3                 0144  add	bx,#$144
06411 1A3D           53                         push	bx
06412                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06413 1A3E           FF76         FE            push	-2[bp]
06414                                           ! Debug: func () void = write_byte+0 (used reg = )
06415 1A41           E8         EBDA            call	_write_byte
06416 1A44           83C4                   06  add	sp,*6
06417                                           !BCC_EOS
06418                                           ! 1444     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06419                                           ! Debug: list int = const 0 (used reg = )
06420 1A47           31C0                       xor	ax,ax
06421 1A49           50                         push	ax
06422                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06423 1A4A           8A46         FC            mov	al,-4[bp]
06424 1A4D           30E4                       xor	ah,ah
06425 1A4F           B9                   001E  mov	cx,*$1E
06426 1A52           F7E9                       imul	cx
06427 1A54           89C3                       mov	bx,ax
06428                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06429                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06430 1A56           81C3                 0145  add	bx,#$145
06431 1A5A           53                         push	bx
06432                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06433 1A5B           FF76         FE            push	-2[bp]
06434                                           ! Debug: func () void = write_byte+0 (used reg = )
06435 1A5E           E8         EBBD            call	_write_byte
06436 1A61           83C4                   06  add	sp,*6
06437                                           !BCC_EOS
06438                                           ! 1445     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06439                                           ! Debug: list int = const 0 (used reg = )
06440 1A64           31C0                       xor	ax,ax
06441 1A66           50                         push	ax
06442                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06443 1A67           8A46         FC            mov	al,-4[bp]
06444 1A6A           30E4                       xor	ah,ah
06445 1A6C           B9                   001E  mov	cx,*$1E
06446 1A6F           F7E9                       imul	cx
06447 1A71           89C3                       mov	bx,ax
06448                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06449                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06450 1A73           81C3                 0146  add	bx,#$146
06451 1A77           53                         push	bx
06452                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06453 1A78           FF76         FE            push	-2[bp]
06454                                           ! Debug: func () void = write_byte+0 (used reg = )
06455 1A7B           E8         EBA0            call	_write_byte
06456 1A7E           83C4                   06  add	sp,*6
06457                                           !BCC_EOS
06458                                           ! 1446     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06459                                           ! Debug: list int = const 0 (used reg = )
06460 1A81           31C0                       xor	ax,ax
06461 1A83           50                         push	ax
06462                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06463 1A84           8A46         FC            mov	al,-4[bp]
06464 1A87           30E4                       xor	ah,ah
06465 1A89           B9                   001E  mov	cx,*$1E
06466 1A8C           F7E9                       imul	cx
06467 1A8E           89C3                       mov	bx,ax
06468                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06469                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06470 1A90           81C3                 0148  add	bx,#$148
06471 1A94           53                         push	bx
06472                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06473 1A95           FF76         FE            push	-2[bp]
06474                                           ! Debug: func () void = write_word+0 (used reg = )
06475 1A98           E8         EB9B            call	_write_word
06476 1A9B           83C4                   06  add	sp,*6
06477                                           !BCC_EOS
06478                                           ! 1447     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06479                                           ! Debug: list int = const 0 (used reg = )
06480 1A9E           31C0                       xor	ax,ax
06481 1AA0           50                         push	ax
06482                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06483 1AA1           8A46         FC            mov	al,-4[bp]
06484 1AA4           30E4                       xor	ah,ah
06485 1AA6           B9                   001E  mov	cx,*$1E
06486 1AA9           F7E9                       imul	cx
06487 1AAB           89C3                       mov	bx,ax
06488                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06489                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06490 1AAD           81C3                 014A  add	bx,#$14A
06491 1AB1           53                         push	bx
06492                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06493 1AB2           FF76         FE            push	-2[bp]
06494                                           ! Debug: func () void = write_byte+0 (used reg = )
06495 1AB5           E8         EB66            call	_write_byte
06496 1AB8           83C4                   06  add	sp,*6
06497                                           !BCC_EOS
06498                                           ! 1448     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06499                                           ! Debug: list int = const 0 (used reg = )
06500 1ABB           31C0                       xor	ax,ax
06501 1ABD           50                         push	ax
06502                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06503 1ABE           8A46         FC            mov	al,-4[bp]
06504 1AC1           30E4                       xor	ah,ah
06505 1AC3           B9                   001E  mov	cx,*$1E
06506 1AC6           F7E9                       imul	cx
06507 1AC8           89C3                       mov	bx,ax
06508                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06509                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06510 1ACA           81C3                 014C  add	bx,#$14C
06511 1ACE           53                         push	bx
06512                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06513 1ACF           FF76         FE            push	-2[bp]
06514                                           ! Debug: func () void = write_word+0 (used reg = )
06515 1AD2           E8         EB61            call	_write_word
06516 1AD5           83C4                   06  add	sp,*6
06517                                           !BCC_EOS
06518                                           ! 1449     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
06519                                           ! Debug: list int = const 0 (used reg = )
06520 1AD8           31C0                       xor	ax,ax
06521 1ADA           50                         push	ax
06522                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06523 1ADB           8A46         FC            mov	al,-4[bp]
06524 1ADE           30E4                       xor	ah,ah
06525 1AE0           B9                   001E  mov	cx,*$1E
06526 1AE3           F7E9                       imul	cx
06527 1AE5           89C3                       mov	bx,ax
06528                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06529                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06530 1AE7           81C3                 014E  add	bx,#$14E
06531 1AEB           53                         push	bx
06532                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06533 1AEC           FF76         FE            push	-2[bp]
06534                                           ! Debug: func () void = write_word+0 (used reg = )
06535 1AEF           E8         EB44            call	_write_word
06536 1AF2           83C4                   06  add	sp,*6
06537                                           !BCC_EOS
06538                                           ! 1450     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06539                                           ! Debug: list int = const 0 (used reg = )
06540 1AF5           31C0                       xor	ax,ax
06541 1AF7           50                         push	ax
06542                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06543 1AF8           8A46         FC            mov	al,-4[bp]
06544 1AFB           30E4                       xor	ah,ah
06545 1AFD           B9                   001E  mov	cx,*$1E
06546 1B00           F7E9                       imul	cx
06547 1B02           89C3                       mov	bx,ax
06548                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06549                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06550 1B04           81C3                 0150  add	bx,#$150
06551 1B08           53                         push	bx
06552                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06553 1B09           FF76         FE            push	-2[bp]
06554                                           ! Debug: func () void = write_word+0 (used reg = )
06555 1B0C           E8         EB27            call	_write_word
06556 1B0F           83C4                   06  add	sp,*6
06557                                           !BCC_EOS
06558                                           ! 1451     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06559                                           ! Debug: list int = const 0 (used reg = )
06560 1B12           31C0                       xor	ax,ax
06561 1B14           50                         push	ax
06562                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06563 1B15           8A46         FC            mov	al,-4[bp]
06564 1B18           30E4                       xor	ah,ah
06565 1B1A           B9                   001E  mov	cx,*$1E
06566 1B1D           F7E9                       imul	cx
06567 1B1F           89C3                       mov	bx,ax
06568                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06569                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06570 1B21           81C3                 0152  add	bx,#$152
06571 1B25           53                         push	bx
06572                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06573 1B26           FF76         FE            push	-2[bp]
06574                                           ! Debug: func () void = write_word+0 (used reg = )
06575 1B29           E8         EB0A            call	_write_word
06576 1B2C           83C4                   06  add	sp,*6
06577                                           !BCC_EOS
06578                                           ! 1452     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06579                                           ! Debug: list int = const 0 (used reg = )
06580 1B2F           31C0                       xor	ax,ax
06581 1B31           50                         push	ax
06582                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06583 1B32           8A46         FC            mov	al,-4[bp]
06584 1B35           30E4                       xor	ah,ah
06585 1B37           B9                   001E  mov	cx,*$1E
06586 1B3A           F7E9                       imul	cx
06587 1B3C           89C3                       mov	bx,ax
06588                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06589                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06590 1B3E           81C3                 0154  add	bx,#$154
06591 1B42           53                         push	bx
06592                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06593 1B43           FF76         FE            push	-2[bp]
06594                                           ! Debug: func () void = write_word+0 (used reg = )
06595 1B46           E8         EAED            call	_write_word
06596 1B49           83C4                   06  add	sp,*6
06597                                           !BCC_EOS
06598                                           ! 1453     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06599                                           ! Debug: list int = const 0 (used reg = )
06600 1B4C           31C0                       xor	ax,ax
06601 1B4E           50                         push	ax
06602                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06603 1B4F           8A46         FC            mov	al,-4[bp]
06604 1B52           30E4                       xor	ah,ah
06605 1B54           B9                   001E  mov	cx,*$1E
06606 1B57           F7E9                       imul	cx
06607 1B59           89C3                       mov	bx,ax
06608                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06609                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06610 1B5B           81C3                 0156  add	bx,#$156
06611 1B5F           53                         push	bx
06612                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06613 1B60           FF76         FE            push	-2[bp]
06614                                           ! Debug: func () void = write_word+0 (used reg = )
06615 1B63           E8         EAD0            call	_write_word
06616 1B66           83C4                   06  add	sp,*6
06617                                           !BCC_EOS
06618                                           ! 1454     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06619                                           ! Debug: list long = const 0 (used reg = )
06620 1B69           31C0                       xor	ax,ax
06621 1B6B           31DB                       xor	bx,bx
06622 1B6D           53                         push	bx
06623 1B6E           50                         push	ax
06624                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06625 1B6F           8A46         FC            mov	al,-4[bp]
06626 1B72           30E4                       xor	ah,ah
06627 1B74           B9                   001E  mov	cx,*$1E
06628 1B77           F7E9                       imul	cx
06629 1B79           89C3                       mov	bx,ax
06630                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06631                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06632 1B7B           81C3                 0158  add	bx,#$158
06633 1B7F           53                         push	bx
06634                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06635 1B80           FF76         FE            push	-2[bp]
06636                                           ! Debug: func () void = write_dword+0 (used reg = )
06637 1B83           E8         E515            call	_write_dword
06638 1B86           83C4                   08  add	sp,*8
06639                                           !BCC_EOS
06640                                           ! 1455     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06641                                           ! Debug: list long = const 0 (used reg = )
06642 1B89           31C0                       xor	ax,ax
06643 1B8B           31DB                       xor	bx,bx
06644 1B8D           53                         push	bx
06645 1B8E           50                         push	ax
06646                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06647 1B8F           8A46         FC            mov	al,-4[bp]
06648 1B92           30E4                       xor	ah,ah
06649 1B94           B9                   001E  mov	cx,*$1E
06650 1B97           F7E9                       imul	cx
06651 1B99           89C3                       mov	bx,ax
06652                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06653                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06654 1B9B           81C3                 015C  add	bx,#$15C
06655 1B9F           53                         push	bx
06656                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06657 1BA0           FF76         FE            push	-2[bp]
06658                                           ! Debug: func () void = write_dword+0 (used reg = )
06659 1BA3           E8         E4F5            call	_write_dword
06660 1BA6           83C4                   08  add	sp,*8
06661                                           !BCC_EOS
06662                                           ! 1456   }
06663                                           ! 1457   for (device=0; device<(4*2); device++) {
06664                       00001BA9            .16A:
06665                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06666 1BA9           8A46         FC            mov	al,-4[bp]
06667 1BAC           40                         inc	ax
06668 1BAD           8846         FC            mov	-4[bp],al
06669                       00001BB0            .16B:
06670                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06671 1BB0           8A46         FC            mov	al,-4[bp]
06672 1BB3           3C                     08  cmp	al,*8
06673 1BB5         0F82         FE37            blo 	.16C
06674                       00001BB9            .16D:
06675                       00001BB9            .169:
06676                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06677 1BB9           30C0                       xor	al,al
06678 1BBB           8846         FC            mov	-4[bp],al
06679                                           !BCC_EOS
06680                                           !BCC_EOS
06681 1BBE           EB           39            jmp .170
06682                       00001BC0            .171:
06683                                           ! 1458     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06684                                           ! Debug: list int = const 8 (used reg = )
06685 1BC0           B8                   0008  mov	ax,*8
06686 1BC3           50                         push	ax
06687                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06688 1BC4           8A46         FC            mov	al,-4[bp]
06689 1BC7           30E4                       xor	ah,ah
06690 1BC9           89C3                       mov	bx,ax
06691                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06692                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06693 1BCB           81C3                 0233  add	bx,#$233
06694 1BCF           53                         push	bx
06695                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06696 1BD0           FF76         FE            push	-2[bp]
06697                                           ! Debug: func () void = write_byte+0 (used reg = )
06698 1BD3           E8         EA48            call	_write_byte
06699 1BD6           83C4                   06  add	sp,*6
06700                                           !BCC_EOS
06701                                           ! 1459     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06702                                           ! Debug: list int = const 8 (used reg = )
06703 1BD9           B8                   0008  mov	ax,*8
06704 1BDC           50                         push	ax
06705                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06706 1BDD           8A46         FC            mov	al,-4[bp]
06707 1BE0           30E4                       xor	ah,ah
06708 1BE2           89C3                       mov	bx,ax
06709                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06710                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06711 1BE4           81C3                 023C  add	bx,#$23C
06712 1BE8           53                         push	bx
06713                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06714 1BE9           FF76         FE            push	-2[bp]
06715                                           ! Debug: func () void = write_byte+0 (used reg = )
06716 1BEC           E8         EA2F            call	_write_byte
06717 1BEF           83C4                   06  add	sp,*6
06718                                           !BCC_EOS
06719                                           ! 1460   }
06720                                           ! 1461   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06721                       00001BF2            .16F:
06722                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06723 1BF2           8A46         FC            mov	al,-4[bp]
06724 1BF5           40                         inc	ax
06725 1BF6           8846         FC            mov	-4[bp],al
06726                       00001BF9            .170:
06727                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06728 1BF9           8A46         FC            mov	al,-4[bp]
06729 1BFC           3C                     08  cmp	al,*8
06730 1BFE           72           C0            jb 	.171
06731                       00001C00            .172:
06732                       00001C00            .16E:
06733                                           ! Debug: list int = const 0 (used reg = )
06734 1C00           31C0                       xor	ax,ax
06735 1C02           50                         push	ax
06736                                           ! Debug: list * unsigned char = const $232 (used reg = )
06737 1C03           B8                   0232  mov	ax,#$232
06738 1C06           50                         push	ax
06739                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06740 1C07           FF76         FE            push	-2[bp]
06741                                           ! Debug: func () void = write_byte+0 (used reg = )
06742 1C0A           E8         EA11            call	_write_byte
06743 1C0D           83C4                   06  add	sp,*6
06744                                           !BCC_EOS
06745                                           ! 1462   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06746                                           ! Debug: list int = const 0 (used reg = )
06747 1C10           31C0                       xor	ax,ax
06748 1C12           50                         push	ax
06749                                           ! Debug: list * unsigned char = const $23B (used reg = )
06750 1C13           B8                   023B  mov	ax,#$23B
06751 1C16           50                         push	ax
06752                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06753 1C17           FF76         FE            push	-2[bp]
06754                                           ! Debug: func () void = write_byte+0 (used reg = )
06755 1C1A           E8         EA01            call	_write_byte
06756 1C1D           83C4                   06  add	sp,*6
06757                                           !BCC_EOS
06758                                           ! 1463 }
06759 1C20           89EC                       mov	sp,bp
06760 1C22           5D                         pop	bp
06761 1C23           C3                         ret
06762                                           ! 1464 int await_ide();
06763                                           ! Register BX used in function ata_init
06764                                           !BCC_EOS
06765                                           ! 1465 static int await_ide(when_done,base,timeout)
06766                                           ! 1466   Bit8u when_done;
06767                       00001C24            _await_ide:
06768                                           !BCC_EOS
06769                                           ! 1467   Bit16u base;
06770                                           !BCC_EOS
06771                                           ! 1468   Bit16u timeout;
06772                                           !BCC_EOS
06773                                           ! 1469 {
06774                                           ! 1470   Bit32u time=0,last=0;
06775 1C24           55                         push	bp
06776 1C25           89E5                       mov	bp,sp
06777 1C27           83C4                   FC  add	sp,*-4
06778                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06779 1C2A           31C0                       xor	ax,ax
06780 1C2C           31DB                       xor	bx,bx
06781 1C2E           8946         FC            mov	-4[bp],ax
06782 1C31           895E         FE            mov	-2[bp],bx
06783 1C34           83C4                   FC  add	sp,*-4
06784                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
06785 1C37           31C0                       xor	ax,ax
06786 1C39           31DB                       xor	bx,bx
06787 1C3B           8946         F8            mov	-8[bp],ax
06788 1C3E           895E         FA            mov	-6[bp],bx
06789                                           !BCC_EOS
06790                                           ! 1471   Bit16u status;
06791                                           !BCC_EOS
06792                                           ! 1472   Bit8u result;
06793                                           !BCC_EOS
06794                                           ! 1473   status = inb(base + 7);
06795 1C41           83C4                   FC  add	sp,*-4
06796                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
06797 1C44           8B46         06            mov	ax,6[bp]
06798                                           ! Debug: list unsigned int = ax+7 (used reg = )
06799 1C47           05                   0007  add	ax,*7
06800 1C4A           50                         push	ax
06801                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06802 1C4B           E8         E8F4            call	_inb
06803 1C4E           44                         inc	sp
06804 1C4F           44                         inc	sp
06805                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
06806 1C50           30E4                       xor	ah,ah
06807 1C52           8946         F6            mov	-$A[bp],ax
06808                                           !BCC_EOS
06809                                           ! 1474   for(;;) {
06810                                           !BCC_EOS
06811                                           !BCC_EOS
06812                       00001C55            .175:
06813                                           ! 1475     status = inb(base+7);
06814                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
06815 1C55           8B46         06            mov	ax,6[bp]
06816                                           ! Debug: list unsigned int = ax+7 (used reg = )
06817 1C58           05                   0007  add	ax,*7
06818 1C5B           50                         push	ax
06819                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06820 1C5C           E8         E8E3            call	_inb
06821 1C5F           44                         inc	sp
06822 1C60           44                         inc	sp
06823                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
06824 1C61           30E4                       xor	ah,ah
06825 1C63           8946         F6            mov	-$A[bp],ax
06826                                           !BCC_EOS
06827                                           ! 1476     time++;
06828                                           ! Debug: postinc unsigned long time = [S+$E-6] (used reg = )
06829 1C66           8B46         FC            mov	ax,-4[bp]
06830 1C69           8B76         FE            mov	si,-2[bp]
06831 1C6C           8D5E         FC            lea	bx,-4[bp]
06832 1C6F           E8         E49D            call	lincl
06833                                           !BCC_EOS
06834                                           ! 1477     if (whe
06835                                           ! 1477 n_done == 1)
06836                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$E+2] (used reg = )
06837 1C72           8A46         04            mov	al,4[bp]
06838 1C75           3C                     01  cmp	al,*1
06839 1C77           75           0B            jne 	.176
06840                       00001C79            .177:
06841                                           ! 1478       result = status & 0x80;
06842                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06843 1C79           8A46         F6            mov	al,-$A[bp]
06844 1C7C           24                     80  and	al,#$80
06845                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06846 1C7E           8846         F5            mov	-$B[bp],al
06847                                           !BCC_EOS
06848                                           ! 1479     else if (when_done == 2)
06849 1C81           E9         0094            br 	.178
06850                       00001C84            .176:
06851                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$E+2] (used reg = )
06852 1C84           8A46         04            mov	al,4[bp]
06853 1C87           3C                     02  cmp	al,*2
06854 1C89           75           15            jne 	.179
06855                       00001C8B            .17A:
06856                                           ! 1480       result = !(status & 0x80);
06857                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06858 1C8B           8A46         F6            mov	al,-$A[bp]
06859 1C8E           24                     80  and	al,#$80
06860 1C90           84C0                       test	al,al
06861 1C92           75           04            jne 	.17B
06862                       00001C94            .17C:
06863 1C94           B0                     01  mov	al,*1
06864 1C96           EB           02            jmp	.17D
06865                       00001C98            .17B:
06866 1C98           30C0                       xor	al,al
06867                       00001C9A            .17D:
06868                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06869 1C9A           8846         F5            mov	-$B[bp],al
06870                                           !BCC_EOS
06871                                           ! 1481     else if (when_done == 3)
06872 1C9D           E9         0078            br 	.17E
06873                       00001CA0            .179:
06874                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$E+2] (used reg = )
06875 1CA0           8A46         04            mov	al,4[bp]
06876 1CA3           3C                     03  cmp	al,*3
06877 1CA5           75           1D            jne 	.17F
06878                       00001CA7            .180:
06879                                           ! 1482       result = !(status & 0x80) && (status & 0x08);
06880                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06881 1CA7           8A46         F6            mov	al,-$A[bp]
06882 1CAA           24                     80  and	al,#$80
06883 1CAC           84C0                       test	al,al
06884 1CAE           75           0D            jne 	.181
06885                       00001CB0            .183:
06886                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
06887 1CB0           8A46         F6            mov	al,-$A[bp]
06888 1CB3           24                     08  and	al,*8
06889 1CB5           84C0                       test	al,al
06890 1CB7           74           04            je  	.181
06891                       00001CB9            .182:
06892 1CB9           B0                     01  mov	al,*1
06893 1CBB           EB           02            jmp	.184
06894                       00001CBD            .181:
06895 1CBD           30C0                       xor	al,al
06896                       00001CBF            .184:
06897                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06898 1CBF           8846         F5            mov	-$B[bp],al
06899                                           !BCC_EOS
06900                                           ! 1483     else if (when_done == 4)
06901 1CC2           EB           54            jmp .185
06902                       00001CC4            .17F:
06903                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$E+2] (used reg = )
06904 1CC4           8A46         04            mov	al,4[bp]
06905 1CC7           3C                     04  cmp	al,*4
06906 1CC9           75           1D            jne 	.186
06907                       00001CCB            .187:
06908                                           ! 1484       result = !(status & 0x80) && !(status & 0x08);
06909                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06910 1CCB           8A46         F6            mov	al,-$A[bp]
06911 1CCE           24                     80  and	al,#$80
06912 1CD0           84C0                       test	al,al
06913 1CD2           75           0D            jne 	.188
06914                       00001CD4            .18A:
06915                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
06916 1CD4           8A46         F6            mov	al,-$A[bp]
06917 1CD7           24                     08  and	al,*8
06918 1CD9           84C0                       test	al,al
06919 1CDB           75           04            jne 	.188
06920                       00001CDD            .189:
06921 1CDD           B0                     01  mov	al,*1
06922 1CDF           EB           02            jmp	.18B
06923                       00001CE1            .188:
06924 1CE1           30C0                       xor	al,al
06925                       00001CE3            .18B:
06926                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06927 1CE3           8846         F5            mov	-$B[bp],al
06928                                           !BCC_EOS
06929                                           ! 1485     else if (when_done == 5)
06930 1CE6           EB           30            jmp .18C
06931                       00001CE8            .186:
06932                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$E+2] (used reg = )
06933 1CE8           8A46         04            mov	al,4[bp]
06934 1CEB           3C                     05  cmp	al,*5
06935 1CED           75           1D            jne 	.18D
06936                       00001CEF            .18E:
06937                                           ! 1486       result = !(status & 0x80) && (status & 0x40);
06938                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
06939 1CEF           8A46         F6            mov	al,-$A[bp]
06940 1CF2           24                     80  and	al,#$80
06941 1CF4           84C0                       test	al,al
06942 1CF6           75           0D            jne 	.18F
06943                       00001CF8            .191:
06944                                           ! Debug: and int = const $40 to unsigned short status = [S+$E-$C] (used reg = )
06945 1CF8           8A46         F6            mov	al,-$A[bp]
06946 1CFB           24                     40  and	al,*$40
06947 1CFD           84C0                       test	al,al
06948 1CFF           74           04            je  	.18F
06949                       00001D01            .190:
06950 1D01           B0                     01  mov	al,*1
06951 1D03           EB           02            jmp	.192
06952                       00001D05            .18F:
06953 1D05           30C0                       xor	al,al
06954                       00001D07            .192:
06955                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
06956 1D07           8846         F5            mov	-$B[bp],al
06957                                           !BCC_EOS
06958                                           ! 1487     else if (when_done == 0)
06959 1D0A           EB           0C            jmp .193
06960                       00001D0C            .18D:
06961                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$E+2] (used reg = )
06962 1D0C           8A46         04            mov	al,4[bp]
06963 1D0F           84C0                       test	al,al
06964 1D11           75           05            jne 	.194
06965                       00001D13            .195:
06966                                           ! 1488       result = 0;
06967                                           ! Debug: eq int = const 0 to unsigned char result = [S+$E-$D] (used reg = )
06968 1D13           30C0                       xor	al,al
06969 1D15           8846         F5            mov	-$B[bp],al
06970                                           !BCC_EOS
06971                                           ! 1489     if (result) return 0;
06972                       00001D18            .194:
06973                       00001D18            .193:
06974                       00001D18            .18C:
06975                       00001D18            .185:
06976                       00001D18            .17E:
06977                       00001D18            .178:
06978 1D18           8A46         F5            mov	al,-$B[bp]
06979 1D1B           84C0                       test	al,al
06980 1D1D           74           06            je  	.196
06981                       00001D1F            .197:
06982 1D1F           31C0                       xor	ax,ax
06983 1D21           89EC                       mov	sp,bp
06984 1D23           5D                         pop	bp
06985 1D24           C3                         ret
06986                                           !BCC_EOS
06987                                           ! 1490     if (time>>16 != last)
06988                       00001D25            .196:
06989                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
06990 1D25           8B46         FC            mov	ax,-4[bp]
06991 1D28           8B5E         FE            mov	bx,-2[bp]
06992 1D2B           93                         xchg	bx,ax
06993 1D2C           31DB                       xor	bx,bx
06994                                           ! Debug: ne unsigned long last = [S+$E-$A] to unsigned long = bx+0 (used reg = )
06995 1D2E           8D7E         F8            lea	di,-8[bp]
06996 1D31           E8         E397            call	lcmpul
06997 1D34           74           0F            je  	.198
06998                       00001D36            .199:
06999                                           ! 1491     {
07000                                           ! 1492       last = time >>16;
07001                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
07002 1D36           8B46         FC            mov	ax,-4[bp]
07003 1D39           8B5E         FE            mov	bx,-2[bp]
07004 1D3C           93                         xchg	bx,ax
07005 1D3D           31DB                       xor	bx,bx
07006                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$E-$A] (used reg = )
07007 1D3F           8946         F8            mov	-8[bp],ax
07008 1D42           895E         FA            mov	-6[bp],bx
07009                                           !BCC_EOS
07010                                           ! 1493       ;
07011                                           !BCC_EOS
07012                                           ! 1494     }
07013                                           ! 1495     if (status & 0x01)
07014                       00001D45            .198:
07015                                           ! Debug: and int = const 1 to unsigned short status = [S+$E-$C] (used reg = )
07016 1D45           8A46         F6            mov	al,-$A[bp]
07017 1D48           24                     01  and	al,*1
07018 1D4A           84C0                       test	al,al
07019 1D4C           74           07            je  	.19A
07020                       00001D4E            .19B:
07021                                           ! 1496     {
07022                                           ! 1497       ;
07023                                           !BCC_EOS
07024                                           ! 1498       return -1;
07025 1D4E           B8                   FFFF  mov	ax,*-1
07026 1D51           89EC                       mov	sp,bp
07027 1D53           5D                         pop	bp
07028 1D54           C3                         ret
07029                                           !BCC_EOS
07030                                           ! 1499     }
07031                                           ! 1500     if ((timeout == 0) || ((time>>11) > timeout)) break;
07032                       00001D55            .19A:
07033                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07034 1D55           8B46         08            mov	ax,8[bp]
07035 1D58           85C0                       test	ax,ax
07036 1D5A           74           26            je  	.19D
07037                       00001D5C            .19E:
07038                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07039 1D5C           8B46         08            mov	ax,8[bp]
07040 1D5F           31DB                       xor	bx,bx
07041 1D61           53                         push	bx
07042 1D62           50                         push	ax
07043                                           ! Debug: sr int = const $B to unsigned long time = [S+$12-6] (used reg = )
07044 1D63           8B46         FC            mov	ax,-4[bp]
07045 1D66           8B5E         FE            mov	bx,-2[bp]
07046 1D69           88E0                       mov	al,ah
07047 1D6B           88DC                       mov	ah,bl
07048 1D6D           88FB                       mov	bl,bh
07049 1D6F           28FF                       sub	bh,bh
07050 1D71           BF                   0003  mov	di,*3
07051 1D74           E8         E3B2            call	lsrul
07052                                           ! Debug: gt unsigned long (temp) = [S+$12-$12] to unsigned long = bx+0 (used reg = )
07053 1D77           8D7E         F0            lea	di,-$10[bp]
07054 1D7A           E8         E34E            call	lcmpul
07055 1D7D           8D66         F4            lea	sp,-$C[bp]
07056 1D80           76           02            jbe 	.19C
07057                       00001D82            .19D:
07058 1D82           EB           03            jmp .173
07059                                           !BCC_EOS
07060                                           ! 1501   }
07061                       00001D84            .19C:
07062                                           ! 1502   bios_printf(4, "IDE time out\n");
07063                       00001D84            .174:
07064 1D84           E9         FECE            br 	.175
07065                       00001D87            .173:
07066                                           ! Debug: list * char = .19F+0 (used reg = )
07067 1D87           BB                   D7E8  mov	bx,#.19F
07068 1D8A           53                         push	bx
07069                                           ! Debug: list int = const 4 (used reg = )
07070 1D8B           B8                   0004  mov	ax,*4
07071 1D8E           50                         push	ax
07072                                           ! Debug: func () void = bios_printf+0 (used reg = )
07073 1D8F           E8         EC15            call	_bios_printf
07074 1D92           83C4                   04  add	sp,*4
07075                                           !BCC_EOS
07076                                           ! 1503   return -1;
07077 1D95           B8                   FFFF  mov	ax,*-1
07078 1D98           89EC                       mov	sp,bp
07079 1D9A           5D                         pop	bp
07080 1D9B           C3                         ret
07081                                           !BCC_EOS
07082                                           ! 1504 }
07083                                           ! 1505 void ata_detect( )
07084                                           ! Register BX used in function await_ide
07085                                           ! 1506 {
07086                                           export	_ata_detect
07087                       00001D9C            _ata_detect:
07088                                           ! 1507   Bit16u ebda_seg=read_word(0x0040,0x000E);
07089 1D9C           55                         push	bp
07090 1D9D           89E5                       mov	bp,sp
07091 1D9F           4C                         dec	sp
07092 1DA0           4C                         dec	sp
07093                                           ! Debug: list int = const $E (used reg = )
07094 1DA1           B8                   000E  mov	ax,*$E
07095 1DA4           50                         push	ax
07096                                           ! Debug: list int = const $40 (used reg = )
07097 1DA5           B8                   0040  mov	ax,*$40
07098 1DA8           50                         push	ax
07099                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07100 1DA9           E8         E85F            call	_read_word
07101 1DAC           83C4                   04  add	sp,*4
07102                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07103 1DAF           8946         FE            mov	-2[bp],ax
07104                                           !BCC_EOS
07105                                           ! 1508   Bit8u hdcount, cdcount, device, type;
07106                                           !BCC_EOS
07107                                           ! 1509   Bit8u buffer[0x0200];
07108                                           !BCC_EOS
07109                                           ! 1510   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07110 1DB2           81C4                 FDFC  add	sp,#-$204
07111                                           ! Debug: list int = const 0 (used reg = )
07112 1DB6           31C0                       xor	ax,ax
07113 1DB8           50                         push	ax
07114                                           ! Debug: list * unsigned char = const $122 (used reg = )
07115 1DB9           B8                   0122  mov	ax,#$122
07116 1DBC           50                         push	ax
07117                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07118 1DBD           FF76         FE            push	-2[bp]
07119                                           ! Debug: func () void = write_byte+0 (used reg = )
07120 1DC0           E8         E85B            call	_write_byte
07121 1DC3           83C4                   06  add	sp,*6
07122                                           !BCC_EOS
07123                                           ! 1511   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07124                                           ! Debug: list int = const $1F0 (used reg = )
07125 1DC6           B8                   01F0  mov	ax,#$1F0
07126 1DC9           50                         push	ax
07127                                           ! Debug: list * unsigned short = const $124 (used reg = )
07128 1DCA           B8                   0124  mov	ax,#$124
07129 1DCD           50                         push	ax
07130                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07131 1DCE           FF76         FE            push	-2[bp]
07132                                           ! Debug: func () void = write_word+0 (used reg = )
07133 1DD1           E8         E862            call	_write_word
07134 1DD4           83C4                   06  add	sp,*6
07135                                           !BCC_EOS
07136                                           ! 1512   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
07137                                           ! Debug: list int = const $3F0 (used reg = )
07138 1DD7           B8                   03F0  mov	ax,#$3F0
07139 1DDA           50                         push	ax
07140                                           ! Debug: list * unsigned short = const $126 (used reg = )
07141 1DDB           B8                   0126  mov	ax,#$126
07142 1DDE           50                         push	ax
07143                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07144 1DDF           FF76         FE            push	-2[bp]
07145                                           ! Debug: func () void = write_word+0 (used reg = )
07146 1DE2           E8         E851            call	_write_word
07147 1DE5           83C4                   06  add	sp,*6
07148                                           !BCC_EOS
07149                                           ! 1513   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07150                                           ! Debug: list int = const $E (used reg = )
07151 1DE8           B8                   000E  mov	ax,*$E
07152 1DEB           50                         push	ax
07153                                           ! Debug: list * unsigned char = const $128 (used reg = )
07154 1DEC           B8                   0128  mov	ax,#$128
07155 1DEF           50                         push	ax
07156                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07157 1DF0           FF76         FE            push	-2[bp]
07158                                           ! Debug: func () void = write_byte+0 (used reg = )
07159 1DF3           E8         E828            call	_write_byte
07160 1DF6           83C4                   06  add	sp,*6
07161                                           !BCC_EOS
07162                                           ! 1514   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
07163                                           ! Debug: list int = const 0 (used reg = )
07164 1DF9           31C0                       xor	ax,ax
07165 1DFB           50                         push	ax
07166                                           ! Debug: list * unsigned char = const $12A (used reg = )
07167 1DFC           B8                   012A  mov	ax,#$12A
07168 1DFF           50                         push	ax
07169                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07170 1E00           FF76         FE            push	-2[bp]
07171                                           ! Debug: func () void = write_byte+0 (used reg = )
07172 1E03           E8         E818            call	_write_byte
07173 1E06           83C4                   06  add	sp,*6
07174                                           !BCC_EOS
07175                                           ! 1515   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07176                                           ! Debug: list int = const $170 (used reg = )
07177 1E09           B8                   0170  mov	ax,#$170
07178 1E0C           50                         push	ax
07179                                           ! Debug: list * unsigned short = const $12C (used reg = )
07180 1E0D           B8                   012C  mov	ax,#$12C
07181 1E10           50                         push	ax
07182                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07183 1E11           FF76         FE            push	-2[bp]
07184                                           ! Debug: func () void = write_word+0 (used reg = )
07185 1E14           E8         E81F            call	_write_word
07186 1E17           83C4                   06  add	sp,*6
07187                                           !BCC_EOS
07188                                           ! 1516   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07189                                           ! Debug: list int = const $370 (used reg = )
07190 1E1A           B8                   0370  mov	ax,#$370
07191 1E1D           50                         push	ax
07192                                           ! Debug: list * unsigned short = const $12E (used reg = )
07193 1E1E           B8                   012E  mov	ax,#$12E
07194 1E21           50                         push	ax
07195                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07196 1E22           FF76         FE            push	-2[bp]
07197                                           ! Debug: func () void = write_word+0 (used reg = )
07198 1E25           E8         E80E            call	_write_word
07199 1E28           83C4                   06  add	sp,*6
07200                                           !BCC_EOS
07201                                           ! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07202                                           ! Debug: list int = const $F (used reg = )
07203 1E2B           B8                   000F  mov	ax,*$F
07204 1E2E           50                         push	ax
07205                                           ! Debug: list * unsigned char = const $130 (used reg = )
07206 1E2F           B8                   0130  mov	ax,#$130
07207 1E32           50                         push	ax
07208                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07209 1E33           FF76         FE            push	-2[bp]
07210                                           ! Debug: func () void = write_byte+0 (used reg = )
07211 1E36           E8         E7E5            call	_write_byte
07212 1E39           83C4                   06  add	sp,*6
07213                                           !BCC_EOS
07214                                           ! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07215                                           ! Debug: list int = const 0 (used reg = )
07216 1E3C           31C0                       xor	ax,ax
07217 1E3E           50                         push	ax
07218                                           ! Debug: list * unsigned char = const $132 (used reg = )
07219 1E3F           B8                   0132  mov	ax,#$132
07220 1E42           50                         push	ax
07221                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07222 1E43           FF76         FE            push	-2[bp]
07223                                           ! Debug: func () void = write_byte+0 (used reg = )
07224 1E46           E8         E7D5            call	_write_byte
07225 1E49           83C4                   06  add	sp,*6
07226                                           !BCC_EOS
07227                                           ! 1519   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07228                                           ! Debug: list int = const $1E8 (used reg = )
07229 1E4C           B8                   01E8  mov	ax,#$1E8
07230 1E4F           50                         push	ax
07231                                           ! Debug: list * unsigned short = const $134 (used reg = )
07232 1E50           B8                   0134  mov	ax,#$134
07233 1E53           50                         push	ax
07234                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07235 1E54           FF76         FE            push	-2[bp]
07236                                           ! Debug: func () void = write_word+0 (used reg = )
07237 1E57           E8         E7DC            call	_write_word
07238 1E5A           83C4                   06  add	sp,*6
07239                                           !BCC_EOS
07240                                           ! 1520   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07241                                           ! Debug: list int = const $3E0 (used reg = )
07242 1E5D           B8                   03E0  mov	ax,#$3E0
07243 1E60           50                         push	ax
07244                                           ! Debug: list * unsigned short = const $136 (used reg = )
07245 1E61           B8                   0136  mov	ax,#$136
07246 1E64           50                         push	ax
07247                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07248 1E65           FF76         FE            push	-2[bp]
07249                                           ! Debug: func () void = write_word+0 (used reg = )
07250 1E68           E8         E7CB            call	_write_word
07251 1E6B           83C4                   06  add	sp,*6
07252                                           !BCC_EOS
07253                                           ! 1521   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07254                                           ! Debug: list int = const $C (used reg = )
07255 1E6E           B8                   000C  mov	ax,*$C
07256 1E71           50                         push	ax
07257                                           ! Debug: list * unsigned char = const $138 (used reg = )
07258 1E72           B8                   0138  mov	ax,#$138
07259 1E75           50                         push	ax
07260                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07261 1E76           FF76         FE            push	-2[bp]
07262                                           ! Debug: func () void = write_byte+0 (used reg = )
07263 1E79           E8         E7A2            call	_write_byte
07264 1E7C           83C4                   06  add	sp,*6
07265                                           !BCC_EOS
07266                                           ! 1522   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07267                                           ! Debug: list int = const 0 (used reg = )
07268 1E7F           31C0                       xor	ax,ax
07269 1E81           50                         push	ax
07270                                           ! Debug: list * unsigned char = const $13A (used reg = )
07271 1E82           B8                   013A  mov	ax,#$13A
07272 1E85           50                         push	ax
07273                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07274 1E86           FF76         FE            push	-2[bp]
07275                                           ! Debug: func () void = write_byte+0 (used reg = )
07276 1E89           E8         E792            call	_write_byte
07277 1E8C           83C4                   06  add	sp,*6
07278                                           !BCC_EOS
07279                                           ! 1523   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07280                                           ! Debug: list int = const $168 (used reg = )
07281 1E8F           B8                   0168  mov	ax,#$168
07282 1E92           50                         push	ax
07283                                           ! Debug: list * unsigned short = const $13C (used reg = )
07284 1E93           B8                   013C  mov	ax,#$13C
07285 1E96           50                         push	ax
07286                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07287 1E97           FF76         FE            push	-2[bp]
07288                                           ! Debug: func () void = write_word+0 (used reg = )
07289 1E9A           E8         E799            call	_write_word
07290 1E9D           83C4                   06  add	sp,*6
07291                                           !BCC_EOS
07292                                           ! 1524   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07293                                           ! Debug: list int = const $360 (used reg = )
07294 1EA0           B8                   0360  mov	ax,#$360
07295 1EA3           50                         push	ax
07296                                           ! Debug: list * unsigned short = const $13E (used reg = )
07297 1EA4           B8                   013E  mov	ax,#$13E
07298 1EA7           50                         push	ax
07299                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07300 1EA8           FF76         FE            push	-2[bp]
07301                                           ! Debug: func () void = write_word+0 (used reg = )
07302 1EAB           E8         E788            call	_write_word
07303 1EAE           83C4                   06  add	sp,*6
07304                                           !BCC_EOS
07305                                           ! 1525   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07306                                           ! Debug: list int = const $B (used reg = )
07307 1EB1           B8                   000B  mov	ax,*$B
07308 1EB4           50                         push	ax
07309                                           ! Debug: list * unsigned char = const $140 (used reg = )
07310 1EB5           B8                   0140  mov	ax,#$140
07311 1EB8           50                         push	ax
07312                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07313 1EB9           FF76         FE            push	-2[bp]
07314                                           ! Debug: func () void = write_byte+0 (used reg = )
07315 1EBC           E8         E75F            call	_write_byte
07316 1EBF           83C4                   06  add	sp,*6
07317                                           !BCC_EOS
07318                                           ! 1526   hdcount=cdcount=0;
07319                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07320 1EC2           30C0                       xor	al,al
07321 1EC4           8846         FC            mov	-4[bp],al
07322                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07323 1EC7           8846         FD            mov	-3[bp],al
07324                                           !BCC_EOS
07325                                           ! 1527   for(device=0; device<(4*2); device++) {
07326                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07327 1ECA           30C0                       xor	al,al
07328 1ECC           8846         FB            mov	-5[bp],al
07329                                           !BCC_EOS
07330                                           !BCC_EOS
07331 1ECF           E9         0DA5            br 	.1A2
07332                       00001ED2            .1A3:
07333                                           ! 1528     Bit16u iobas
07334                                           ! 1528 e1, iobase2;
07335                                           !BCC_EOS
07336                                           ! 1529     Bit8u channel, slave, shift;
07337                                           !BCC_EOS
07338                                           ! 1530     Bit8u sc, sn, cl, ch, st;
07339                                           !BCC_EOS
07340                                           ! 1531     channel = device / 2;
07341 1ED2           83C4                   F4  add	sp,*-$C
07342                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07343 1ED5           8A46         FB            mov	al,-5[bp]
07344 1ED8           30E4                       xor	ah,ah
07345 1EDA           D1E8                       shr	ax,*1
07346                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07347 1EDC           8886       FDF5            mov	-$20B[bp],al
07348                                           !BCC_EOS
07349                                           ! 1532     slave = device % 2;
07350                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07351 1EE0           8A46         FB            mov	al,-5[bp]
07352 1EE3           30E4                       xor	ah,ah
07353 1EE5           24                     01  and	al,*1
07354                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07355 1EE7           8886       FDF4            mov	-$20C[bp],al
07356                                           !BCC_EOS
07357                                           ! 1533     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07358                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07359 1EEB           8A86       FDF5            mov	al,-$20B[bp]
07360 1EEF           30E4                       xor	ah,ah
07361 1EF1           B1                     03  mov	cl,*3
07362 1EF3           D3E0                       shl	ax,cl
07363 1EF5           89C3                       mov	bx,ax
07364                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07365                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07366 1EF7           81C3                 0124  add	bx,#$124
07367 1EFB           53                         push	bx
07368                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07369 1EFC           FF76         FE            push	-2[bp]
07370                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07371 1EFF           E8         E709            call	_read_word
07372 1F02           83C4                   04  add	sp,*4
07373                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07374 1F05           8986       FDF8            mov	-$208[bp],ax
07375                                           !BCC_EOS
07376                                           ! 1534     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07377                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07378 1F09           8A86       FDF5            mov	al,-$20B[bp]
07379 1F0D           30E4                       xor	ah,ah
07380 1F0F           B1                     03  mov	cl,*3
07381 1F11           D3E0                       shl	ax,cl
07382 1F13           89C3                       mov	bx,ax
07383                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07384                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07385 1F15           81C3                 0126  add	bx,#$126
07386 1F19           53                         push	bx
07387                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07388 1F1A           FF76         FE            push	-2[bp]
07389                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07390 1F1D           E8         E6EB            call	_read_word
07391 1F20           83C4                   04  add	sp,*4
07392                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07393 1F23           8986       FDF6            mov	-$20A[bp],ax
07394                                           !BCC_EOS
07395                                           ! 1535     outb(iobase2+6, 0x08 | 0x02);
07396                                           ! Debug: list int = const $A (used reg = )
07397 1F27           B8                   000A  mov	ax,*$A
07398 1F2A           50                         push	ax
07399                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07400 1F2B           8B86       FDF6            mov	ax,-$20A[bp]
07401                                           ! Debug: list unsigned int = ax+6 (used reg = )
07402 1F2F           05                   0006  add	ax,*6
07403 1F32           50                         push	ax
07404                                           ! Debug: func () void = outb+0 (used reg = )
07405 1F33           E8         E622            call	_outb
07406 1F36           83C4                   04  add	sp,*4
07407                                           !BCC_EOS
07408                                           ! 1536     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07409 1F39           8A86       FDF4            mov	al,-$20C[bp]
07410 1F3D           84C0                       test	al,al
07411 1F3F           74           04            je  	.1A4
07412                       00001F41            .1A5:
07413 1F41           B0                     B0  mov	al,#$B0
07414 1F43           EB           02            jmp .1A6
07415                       00001F45            .1A4:
07416 1F45           B0                     A0  mov	al,#$A0
07417                       00001F47            .1A6:
07418                                           ! Debug: list char = al+0 (used reg = )
07419 1F47           30E4                       xor	ah,ah
07420 1F49           50                         push	ax
07421                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07422 1F4A           8B86       FDF8            mov	ax,-$208[bp]
07423                                           ! Debug: list unsigned int = ax+6 (used reg = )
07424 1F4E           05                   0006  add	ax,*6
07425 1F51           50                         push	ax
07426                                           ! Debug: func () void = outb+0 (used reg = )
07427 1F52           E8         E603            call	_outb
07428 1F55           83C4                   04  add	sp,*4
07429                                           !BCC_EOS
07430                                           ! 1537     outb(iobase1+2, 0x55);
07431                                           ! Debug: list int = const $55 (used reg = )
07432 1F58           B8                   0055  mov	ax,*$55
07433 1F5B           50                         push	ax
07434                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07435 1F5C           8B86       FDF8            mov	ax,-$208[bp]
07436                                           ! Debug: list unsigned int = ax+2 (used reg = )
07437 1F60           40                         inc	ax
07438 1F61           40                         inc	ax
07439 1F62           50                         push	ax
07440                                           ! Debug: func () void = outb+0 (used reg = )
07441 1F63           E8         E5F2            call	_outb
07442 1F66           83C4                   04  add	sp,*4
07443                                           !BCC_EOS
07444                                           ! 1538     outb(iobase1+3, 0xaa);
07445                                           ! Debug: list int = const $AA (used reg = )
07446 1F69           B8                   00AA  mov	ax,#$AA
07447 1F6C           50                         push	ax
07448                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07449 1F6D           8B86       FDF8            mov	ax,-$208[bp]
07450                                           ! Debug: list unsigned int = ax+3 (used reg = )
07451 1F71           05                   0003  add	ax,*3
07452 1F74           50                         push	ax
07453                                           ! Debug: func () void = outb+0 (used reg = )
07454 1F75           E8         E5E0            call	_outb
07455 1F78           83C4                   04  add	sp,*4
07456                                           !BCC_EOS
07457                                           ! 1539     outb(iobase1+2, 0xaa);
07458                                           ! Debug: list int = const $AA (used reg = )
07459 1F7B           B8                   00AA  mov	ax,#$AA
07460 1F7E           50                         push	ax
07461                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07462 1F7F           8B86       FDF8            mov	ax,-$208[bp]
07463                                           ! Debug: list unsigned int = ax+2 (used reg = )
07464 1F83           40                         inc	ax
07465 1F84           40                         inc	ax
07466 1F85           50                         push	ax
07467                                           ! Debug: func () void = outb+0 (used reg = )
07468 1F86           E8         E5CF            call	_outb
07469 1F89           83C4                   04  add	sp,*4
07470                                           !BCC_EOS
07471                                           ! 1540     outb(iobase1+3, 0x55);
07472                                           ! Debug: list int = const $55 (used reg = )
07473 1F8C           B8                   0055  mov	ax,*$55
07474 1F8F           50                         push	ax
07475                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07476 1F90           8B86       FDF8            mov	ax,-$208[bp]
07477                                           ! Debug: list unsigned int = ax+3 (used reg = )
07478 1F94           05                   0003  add	ax,*3
07479 1F97           50                         push	ax
07480                                           ! Debug: func () void = outb+0 (used reg = )
07481 1F98           E8         E5BD            call	_outb
07482 1F9B           83C4                   04  add	sp,*4
07483                                           !BCC_EOS
07484                                           ! 1541     outb(iobase1+2, 0x55);
07485                                           ! Debug: list int = const $55 (used reg = )
07486 1F9E           B8                   0055  mov	ax,*$55
07487 1FA1           50                         push	ax
07488                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07489 1FA2           8B86       FDF8            mov	ax,-$208[bp]
07490                                           ! Debug: list unsigned int = ax+2 (used reg = )
07491 1FA6           40                         inc	ax
07492 1FA7           40                         inc	ax
07493 1FA8           50                         push	ax
07494                                           ! Debug: func () void = outb+0 (used reg = )
07495 1FA9           E8         E5AC            call	_outb
07496 1FAC           83C4                   04  add	sp,*4
07497                                           !BCC_EOS
07498                                           ! 1542     outb(iobase1+3, 0xaa);
07499                                           ! Debug: list int = const $AA (used reg = )
07500 1FAF           B8                   00AA  mov	ax,#$AA
07501 1FB2           50                         push	ax
07502                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07503 1FB3           8B86       FDF8            mov	ax,-$208[bp]
07504                                           ! Debug: list unsigned int = ax+3 (used reg = )
07505 1FB7           05                   0003  add	ax,*3
07506 1FBA           50                         push	ax
07507                                           ! Debug: func () void = outb+0 (used reg = )
07508 1FBB           E8         E59A            call	_outb
07509 1FBE           83C4                   04  add	sp,*4
07510                                           !BCC_EOS
07511                                           ! 1543     sc = inb(iobase1+2);
07512                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07513 1FC1           8B86       FDF8            mov	ax,-$208[bp]
07514                                           ! Debug: list unsigned int = ax+2 (used reg = )
07515 1FC5           40                         inc	ax
07516 1FC6           40                         inc	ax
07517 1FC7           50                         push	ax
07518                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07519 1FC8           E8         E577            call	_inb
07520 1FCB           44                         inc	sp
07521 1FCC           44                         inc	sp
07522                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07523 1FCD           8886       FDF2            mov	-$20E[bp],al
07524                                           !BCC_EOS
07525                                           ! 1544     sn = inb(iobase1+3);
07526                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07527 1FD1           8B86       FDF8            mov	ax,-$208[bp]
07528                                           ! Debug: list unsigned int = ax+3 (used reg = )
07529 1FD5           05                   0003  add	ax,*3
07530 1FD8           50                         push	ax
07531                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07532 1FD9           E8         E566            call	_inb
07533 1FDC           44                         inc	sp
07534 1FDD           44                         inc	sp
07535                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07536 1FDE           8886       FDF1            mov	-$20F[bp],al
07537                                           !BCC_EOS
07538                                           ! 1545     if ( (sc == 0x55) && (sn == 0xaa) ) {
07539                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07540 1FE2           8A86       FDF2            mov	al,-$20E[bp]
07541 1FE6           3C                     55  cmp	al,*$55
07542 1FE8         0F85         014F            bne 	.1A7
07543                       00001FEC            .1A9:
07544                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07545 1FEC           8A86       FDF1            mov	al,-$20F[bp]
07546 1FF0           3C                     AA  cmp	al,#$AA
07547 1FF2         0F85         0145            bne 	.1A7
07548                       00001FF6            .1A8:
07549                                           ! 1546       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07550                                           ! Debug: list int = const 1 (used reg = )
07551 1FF6           B8                   0001  mov	ax,*1
07552 1FF9           50                         push	ax
07553                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07554 1FFA           8A46         FB            mov	al,-5[bp]
07555 1FFD           30E4                       xor	ah,ah
07556 1FFF           B9                   001E  mov	cx,*$1E
07557 2002           F7E9                       imul	cx
07558 2004           89C3                       mov	bx,ax
07559                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07560                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07561 2006           81C3                 0142  add	bx,#$142
07562 200A           53                         push	bx
07563                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07564 200B           FF76         FE            push	-2[bp]
07565                                           ! Debug: func () void = write_byte+0 (used reg = )
07566 200E           E8         E60D            call	_write_byte
07567 2011           83C4                   06  add	sp,*6
07568                                           !BCC_EOS
07569                                           ! 1547       ata_reset(device);
07570                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07571 2014           8A46         FB            mov	al,-5[bp]
07572 2017           30E4                       xor	ah,ah
07573 2019           50                         push	ax
07574                                           ! Debug: func () void = ata_reset+0 (used reg = )
07575 201A           E8         0CAF            call	_ata_reset
07576 201D           44                         inc	sp
07577 201E           44                         inc	sp
07578                                           !BCC_EOS
07579                                           ! 1548       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07580 201F           8A86       FDF4            mov	al,-$20C[bp]
07581 2023           84C0                       test	al,al
07582 2025           74           04            je  	.1AA
07583                       00002027            .1AB:
07584 2027           B0                     B0  mov	al,#$B0
07585 2029           EB           02            jmp .1AC
07586                       0000202B            .1AA:
07587 202B           B0                     A0  mov	al,#$A0
07588                       0000202D            .1AC:
07589                                           ! Debug: list char = al+0 (used reg = )
07590 202D           30E4                       xor	ah,ah
07591 202F           50                         push	ax
07592                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07593 2030           8B86       FDF8            mov	ax,-$208[bp]
07594                                           ! Debug: list unsigned int = ax+6 (used reg = )
07595 2034           05                   0006  add	ax,*6
07596 2037           50                         push	ax
07597                                           ! Debug: func () void = outb+0 (used reg = )
07598 2038           E8         E51D            call	_outb
07599 203B           83C4                   04  add	sp,*4
07600                                           !BCC_EOS
07601                                           ! 1549       sc = inb(iobase1+2);
07602                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07603 203E           8B86       FDF8            mov	ax,-$208[bp]
07604                                           ! Debug: list unsigned int = ax+2 (used reg = )
07605 2042           40                         inc	ax
07606 2043           40                         inc	ax
07607 2044           50                         push	ax
07608                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07609 2045           E8         E4FA            call	_inb
07610 2048           44                         inc	sp
07611 2049           44                         inc	sp
07612                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07613 204A           8886       FDF2            mov	-$20E[bp],al
07614                                           !BCC_EOS
07615                                           ! 1550       sn = inb(iobase1+3);
07616                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07617 204E           8B86       FDF8            mov	ax,-$208[bp]
07618                                           ! Debug: list unsigned int = ax+3 (used reg = )
07619 2052           05                   0003  add	ax,*3
07620 2055           50                         push	ax
07621                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07622 2056           E8         E4E9            call	_inb
07623 2059           44                         inc	sp
07624 205A           44                         inc	sp
07625                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07626 205B           8886       FDF1            mov	-$20F[bp],al
07627                                           !BCC_EOS
07628                                           ! 1551       if ((sc==0x01) && (sn==0x01)) {
07629                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07630 205F           8A86       FDF2            mov	al,-$20E[bp]
07631 2063           3C                     01  cmp	al,*1
07632 2065         0F85         00D2            bne 	.1AD
07633                       00002069            .1AF:
07634                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07635 2069           8A86       FDF1            mov	al,-$20F[bp]
07636 206D           3C                     01  cmp	al,*1
07637 206F         0F85         00C8            bne 	.1AD
07638                       00002073            .1AE:
07639                                           ! 1552         cl = inb(iobase1+4);
07640                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07641 2073           8B86       FDF8            mov	ax,-$208[bp]
07642                                           ! Debug: list unsigned int = ax+4 (used reg = )
07643 2077           05                   0004  add	ax,*4
07644 207A           50                         push	ax
07645                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07646 207B           E8         E4C4            call	_inb
07647 207E           44                         inc	sp
07648 207F           44                         inc	sp
07649                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07650 2080           8886       FDF0            mov	-$210[bp],al
07651                                           !BCC_EOS
07652                                           ! 1553         ch = inb(iobase1+5);
07653                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07654 2084           8B86       FDF8            mov	ax,-$208[bp]
07655                                           ! Debug: list unsigned int = ax+5 (used reg = )
07656 2088           05                   0005  add	ax,*5
07657 208B           50                         push	ax
07658                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07659 208C           E8         E4B3            call	_inb
07660 208F           44                         inc	sp
07661 2090           44                         inc	sp
07662                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07663 2091           8886       FDEF            mov	-$211[bp],al
07664                                           !BCC_EOS
07665                                           ! 1554         st = inb(iobase1+7);
07666                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07667 2095           8B86       FDF8            mov	ax,-$208[bp]
07668                                           ! Debug: list unsigned int = ax+7 (used reg = )
07669 2099           05                   0007  add	ax,*7
07670 209C           50                         push	ax
07671                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07672 209D           E8         E4A2            call	_inb
07673 20A0           44                         inc	sp
07674 20A1           44                         inc	sp
07675                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07676 20A2           8886       FDEE            mov	-$212[bp],al
07677                                           !BCC_EOS
07678                                           ! 1555         if ((cl==0x14) && (ch==0xeb)) {
07679                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07680 20A6           8A86       FDF0            mov	al,-$210[bp]
07681 20AA           3C                     14  cmp	al,*$14
07682 20AC           75           28            jne 	.1B0
07683                       000020AE            .1B2:
07684                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07685 20AE           8A86       FDEF            mov	al,-$211[bp]
07686 20B2           3C                     EB  cmp	al,#$EB
07687 20B4           75           20            jne 	.1B0
07688                       000020B6            .1B1:
07689                                           ! 1556           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07690                                           ! Debug: list int = const 3 (used reg = )
07691 20B6           B8                   0003  mov	ax,*3
07692 20B9           50                         push	ax
07693                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07694 20BA           8A46         FB            mov	al,-5[bp]
07695 20BD           30E4                       xor	ah,ah
07696 20BF           B9                   001E  mov	cx,*$1E
07697 20C2           F7E9                       imul	cx
07698 20C4           89C3                       mov	bx,ax
07699                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07700                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07701 20C6           81C3                 0142  add	bx,#$142
07702 20CA           53                         push	bx
07703                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07704 20CB           FF76         FE            push	-2[bp]
07705                                           ! Debug: func () void = write_byte+0 (used reg = )
07706 20CE           E8         E54D            call	_write_byte
07707 20D1           83C4                   06  add	sp,*6
07708                                           !BCC_EOS
07709                                           ! 1557         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07710 20D4           EB           65            jmp .1B3
07711                       000020D6            .1B0:
07712                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07713 20D6           8A86       FDF0            mov	al,-$210[bp]
07714 20DA           84C0                       test	al,al
07715 20DC           75           30            jne 	.1B4
07716                       000020DE            .1B7:
07717                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07718 20DE           8A86       FDEF            mov	al,-$211[bp]
07719 20E2           84C0                       test	al,al
07720 20E4           75           28            jne 	.1B4
07721                       000020E6            .1B6:
07722                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07723 20E6           8A86       FDEE            mov	al,-$212[bp]
07724 20EA           84C0                       test	al,al
07725 20EC           74           20            je  	.1B4
07726                       000020EE            .1B5:
07727                                           ! 1558           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07728                                           ! Debug: list int = const 2 (used reg = )
07729 20EE           B8                   0002  mov	ax,*2
07730 20F1           50                         push	ax
07731                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07732 20F2           8A46         FB            mov	al,-5[bp]
07733 20F5           30E4                       xor	ah,ah
07734 20F7           B9                   001E  mov	cx,*$1E
07735 20FA           F7E9                       imul	cx
07736 20FC           89C3                       mov	bx,ax
07737                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07738                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07739 20FE           81C3                 0142  add	bx,#$142
07740 2102           53                         push	bx
07741                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07742 2103           FF76         FE            push	-2[bp]
07743                                           ! Debug: func () void = write_byte+0 (used reg = )
07744 2106           E8         E515            call	_write_byte
07745 2109           83C4                   06  add	sp,*6
07746                                           !BCC_EOS
07747                                           ! 1559         } else if ((cl==0xff) && (ch==0xff)) {
07748 210C           EB           2D            jmp .1B8
07749                       0000210E            .1B4:
07750                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
07751 210E           8A86       FDF0            mov	al,-$210[bp]
07752 2112           3C                     FF  cmp	al,#$FF
07753 2114           75           25            jne 	.1B9
07754                       00002116            .1BB:
07755                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
07756 2116           8A86       FDEF            mov	al,-$211[bp]
07757 211A           3C                     FF  cmp	al,#$FF
07758 211C           75           1D            jne 	.1B9
07759                       0000211E            .1BA:
07760                                           ! 1560           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
07761                                           ! Debug: list int = const 0 (used reg = )
07762 211E           31C0                       xor	ax,ax
07763 2120           50                         push	ax
07764                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07765 2121           8A46         FB            mov	al,-5[bp]
07766 2124           30E4                       xor	ah,ah
07767 2126           B9                   001E  mov	cx,*$1E
07768 2129           F7E9                       imul	cx
07769 212B           89C3                       mov	bx,ax
07770                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07771                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07772 212D           81C3                 0142  add	bx,#$142
07773 2131           53                         push	bx
07774                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07775 2132           FF76         FE            push	-2[bp]
07776                                           ! Debug: func () void = write_byte+0 (used reg = )
07777 2135           E8         E4E6            call	_write_byte
07778 2138           83C4                   06  add	sp,*6
07779                                           !BCC_EOS
07780                                           ! 1561         }
07781                                           ! 1562       }
07782                       0000213B            .1B9:
07783                       0000213B            .1B8:
07784                       0000213B            .1B3:
07785                                           ! 1563     }
07786                       0000213B            .1AD:
07787                                           ! 1564     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07788                       0000213B            .1A7:
07789                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07790 213B           8A46         FB            mov	al,-5[bp]
07791 213E           30E4                       xor	ah,ah
07792 2140           B9                   001E  mov	cx,*$1E
07793 2143           F7E9                       imul	cx
07794 2145           89C3                       mov	bx,ax
07795                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07796                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07797 2147           81C3                 0142  add	bx,#$142
07798 214B           53                         push	bx
07799                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07800 214C           FF76         FE            push	-2[bp]
07801                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07802 214F           E8         E4A6            call	_read_byte
07803 2152           83C4                   04  add	sp,*4
07804                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07805 2155           8846         FA            mov	-6[bp],al
07806                                           !BCC_EOS
07807                                           ! 1565     if(type == 0x02) {
07808                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07809 2158           8A46         FA            mov	al,-6[bp]
07810 215B           3C                     02  cmp	al,*2
07811 215D         0F85         05A8            bne 	.1BC
07812                       00002161            .1BD:
07813                                           ! 1566       Bit32u sectors_low, sectors_high;
07814                                           !BCC_EOS
07815                                           ! 1567       Bit16u cylinders, heads, spt, blksize;
07816                                           !BCC_EOS
07817                                           ! 1568       Bit8u translation, removable, mode;
07818                                           !BCC_EOS
07819                                           ! 1569       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07820 2161           83C4                   EC  add	sp,*-$14
07821                                           ! Debug: list int = const $FF (used reg = )
07822 2164           B8                   00FF  mov	ax,#$FF
07823 2167           50                         push	ax
07824                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07825 2168           8A46         FB            mov	al,-5[bp]
07826 216B           30E4                       xor	ah,ah
07827 216D           B9                   001E  mov	cx,*$1E
07828 2170           F7E9                       imul	cx
07829 2172           89C3                       mov	bx,ax
07830                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07831                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07832 2174           81C3                 0143  add	bx,#$143
07833 2178           53                         push	bx
07834                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
07835 2179           FF76         FE            push	-2[bp]
07836                                           ! Debug: func () void = write_byte+0 (used reg = )
07837 217C           E8         E49F            call	_write_byte
07838 217F           83C4                   06  add	sp,*6
07839                                           !BCC_EOS
07840                                           ! 1570       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
07841                                           ! Debug: list int = const 0 (used reg = )
07842 2182           31C0                       xor	ax,ax
07843 2184           50                         push	ax
07844                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07845 2185           8A46         FB            mov	al,-5[bp]
07846 2188           30E4                       xor	ah,ah
07847 218A           B9                   001E  mov	cx,*$1E
07848 218D           F7E9                       imul	cx
07849 218F           89C3                       mov	bx,ax
07850                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07851                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
07852 2191           81C3                 0146  add	bx,#$146
07853 2195           53                         push	bx
07854                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
07855 2196           FF76         FE            push	-2[bp]
07856                                           ! Debug: func () void = write_byte+0 (used reg = )
07857 2199           E8         E482            call	_write_byte
07858 219C           83C4                   06  add	sp,*6
07859                                           !BCC_EOS
07860                                           ! 1571       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07861                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
07862 219F           8D9E       FDFA            lea	bx,-$206[bp]
07863 21A3           53                         push	bx
07864                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07865 21A4           E8         E4AA            call	_get_SS
07866                                           ! Debug: list unsigned short = ax+0 (used reg = )
07867 21A7           50                         push	ax
07868                                           ! Debug: list long = const 0 (used reg = )
07869 21A8           31C0                       xor	ax,ax
07870 21AA           31DB                       xor	bx,bx
07871 21AC           53                         push	bx
07872 21AD           50                         push	ax
07873                                           ! Debug: list long = const 0 (used reg = )
07874 21AE           31C0                       xor	ax,ax
07875 21B0           31DB                       xor	bx,bx
07876 21B2           53                         push	bx
07877 21B3           50                         push	ax
07878                                           ! Debug: list int = const 0 (used reg = )
07879 21B4           31C0                       xor	ax,ax
07880 21B6           50                         push	ax
07881                                           ! Debug: list int = const 0 (used reg = )
07882 21B7           31C0                       xor	ax,ax
07883 21B9           50                         push	ax
07884                                           ! Debug: list int = const 0 (used reg = )
07885 21BA           31C0                       xor	ax,ax
07886 21BC           50                         push	ax
07887                                           ! Debug: list int = const 1 (used reg = )
07888 21BD           B8                   0001  mov	ax,*1
07889 21C0           50                         push	ax
07890                                           ! Debug: list int = const $EC (used reg = )
07891 21C1           B8                   00EC  mov	ax,#$EC
07892 21C4           50                         push	ax
07893                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
07894 21C5           8A46         FB            mov	al,-5[bp]
07895 21C8           30E4                       xor	ah,ah
07896 21CA           50                         push	ax
07897                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
07898 21CB           E8         0C56            call	_ata_cmd_data_in
07899 21CE           83C4                   18  add	sp,*$18
07900                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07901 21D1           85C0                       test	ax,ax
07902 21D3           74           0E            je  	.1BE
07903                       000021D5            .1BF:
07904                                           ! 1572         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07905                                           ! Debug: list * char = .1C0+0 (used reg = )
07906 21D5           BB                   D7BF  mov	bx,#.1C0
07907 21D8           53                         push	bx
07908                                           ! Debug: list int = const 7 (used reg = )
07909 21D9           B8                   0007  mov	ax,*7
07910 21DC           50                         push	ax
07911                                           ! Debug: func () void = bios_printf+0 (used reg = )
07912 21DD           E8         E7C7            call	_bios_printf
07913 21E0           83C4                   04  add	sp,*4
07914                                           !BCC_EOS
07915                                           ! 1573       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
07916                       000021E3            .1BE:
07917                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
07918 21E3           8D9E       FDFA            lea	bx,-$206[bp]
07919 21E7           53                         push	bx
07920                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07921 21E8           E8         E466            call	_get_SS
07922                                           ! Debug: list unsigned short = ax+0 (used reg = )
07923 21EB           50                         push	ax
07924                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07925 21EC           E8         E409            call	_read_byte
07926 21EF           83C4                   04  add	sp,*4
07927                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07928 21F2           24                     80  and	al,#$80
07929 21F4           84C0                       test	al,al
07930 21F6           74           04            je  	.1C1
07931                       000021F8            .1C2:
07932 21F8           B0                     01  mov	al,*1
07933 21FA           EB           02            jmp .1C3
07934                       000021FC            .1C1:
07935 21FC           30C0                       xor	al,al
07936                       000021FE            .1C3:
07937                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
07938 21FE           8886       FDDC            mov	-$224[bp],al
07939                                           !BCC_EOS
07940                                           ! 1574       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 
07941                                           ! 1574 0x00;
07942                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
07943 2202           8D9E       FE5A            lea	bx,-$1A6[bp]
07944 2206           53                         push	bx
07945                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07946 2207           E8         E447            call	_get_SS
07947                                           ! Debug: list unsigned short = ax+0 (used reg = )
07948 220A           50                         push	ax
07949                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07950 220B           E8         E3EA            call	_read_byte
07951 220E           83C4                   04  add	sp,*4
07952 2211           84C0                       test	al,al
07953 2213           74           04            je  	.1C4
07954                       00002215            .1C5:
07955 2215           B0                     01  mov	al,*1
07956 2217           EB           02            jmp .1C6
07957                       00002219            .1C4:
07958 2219           30C0                       xor	al,al
07959                       0000221B            .1C6:
07960                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07961 221B           8886       FDDB            mov	-$225[bp],al
07962                                           !BCC_EOS
07963                                           ! 1575       blksize = read_word(get_SS(),buffer+10);
07964                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
07965 221F           8D9E       FE04            lea	bx,-$1FC[bp]
07966 2223           53                         push	bx
07967                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07968 2224           E8         E42A            call	_get_SS
07969                                           ! Debug: list unsigned short = ax+0 (used reg = )
07970 2227           50                         push	ax
07971                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07972 2228           E8         E3E0            call	_read_word
07973 222B           83C4                   04  add	sp,*4
07974                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
07975 222E           8986       FDDE            mov	-$222[bp],ax
07976                                           !BCC_EOS
07977                                           ! 1576       cylinders = read_word(get_SS(),buffer+(1*2));
07978                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07979 2232           8D9E       FDFC            lea	bx,-$204[bp]
07980 2236           53                         push	bx
07981                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07982 2237           E8         E417            call	_get_SS
07983                                           ! Debug: list unsigned short = ax+0 (used reg = )
07984 223A           50                         push	ax
07985                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07986 223B           E8         E3CD            call	_read_word
07987 223E           83C4                   04  add	sp,*4
07988                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
07989 2241           8986       FDE4            mov	-$21C[bp],ax
07990                                           !BCC_EOS
07991                                           ! 1577       heads = read_word(get_SS(),buffer+(3*2));
07992                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
07993 2245           8D9E       FE00            lea	bx,-$200[bp]
07994 2249           53                         push	bx
07995                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07996 224A           E8         E404            call	_get_SS
07997                                           ! Debug: list unsigned short = ax+0 (used reg = )
07998 224D           50                         push	ax
07999                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08000 224E           E8         E3BA            call	_read_word
08001 2251           83C4                   04  add	sp,*4
08002                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08003 2254           8986       FDE2            mov	-$21E[bp],ax
08004                                           !BCC_EOS
08005                                           ! 1578       spt = read_word(get_SS(),buffer+(6*2));
08006                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08007 2258           8D9E       FE06            lea	bx,-$1FA[bp]
08008 225C           53                         push	bx
08009                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08010 225D           E8         E3F1            call	_get_SS
08011                                           ! Debug: list unsigned short = ax+0 (used reg = )
08012 2260           50                         push	ax
08013                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08014 2261           E8         E3A7            call	_read_word
08015 2264           83C4                   04  add	sp,*4
08016                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08017 2267           8986       FDE0            mov	-$220[bp],ax
08018                                           !BCC_EOS
08019                                           ! 1579       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08020                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08021 226B           8D9E       FEA0            lea	bx,-$160[bp]
08022 226F           53                         push	bx
08023                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08024 2270           E8         E3DE            call	_get_SS
08025                                           ! Debug: list unsigned short = ax+0 (used reg = )
08026 2273           50                         push	ax
08027                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08028 2274           E8         E394            call	_read_word
08029 2277           83C4                   04  add	sp,*4
08030                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08031 227A           25                   0400  and	ax,#$400
08032 227D           85C0                       test	ax,ax
08033 227F           74           34            je  	.1C7
08034                       00002281            .1C8:
08035                                           ! 1580         sectors_low = read_dword(get_SS(),buffer+(100*2));
08036                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08037 2281           8D9E       FEC2            lea	bx,-$13E[bp]
08038 2285           53                         push	bx
08039                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08040 2286           E8         E3C8            call	_get_SS
08041                                           ! Debug: list unsigned short = ax+0 (used reg = )
08042 2289           50                         push	ax
08043                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08044 228A           E8         DDF6            call	_read_dword
08045 228D           89D3                       mov	bx,dx
08046 228F           83C4                   04  add	sp,*4
08047                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08048 2292           8986       FDEA            mov	-$216[bp],ax
08049 2296           899E       FDEC            mov	-$214[bp],bx
08050                                           !BCC_EOS
08051                                           ! 1581         sectors_high = read_dword(get_SS(),buffer+(102*2));
08052                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08053 229A           8D9E       FEC6            lea	bx,-$13A[bp]
08054 229E           53                         push	bx
08055                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08056 229F           E8         E3AF            call	_get_SS
08057                                           ! Debug: list unsigned short = ax+0 (used reg = )
08058 22A2           50                         push	ax
08059                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08060 22A3           E8         DDDD            call	_read_dword
08061 22A6           89D3                       mov	bx,dx
08062 22A8           83C4                   04  add	sp,*4
08063                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08064 22AB           8986       FDE6            mov	-$21A[bp],ax
08065 22AF           899E       FDE8            mov	-$218[bp],bx
08066                                           !BCC_EOS
08067                                           ! 1582       } else {
08068 22B3           EB           25            jmp .1C9
08069                       000022B5            .1C7:
08070                                           ! 1583         sectors_low = read_dword(get_SS(),buffer+(60*2));
08071                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08072 22B5           8D9E       FE72            lea	bx,-$18E[bp]
08073 22B9           53                         push	bx
08074                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08075 22BA           E8         E394            call	_get_SS
08076                                           ! Debug: list unsigned short = ax+0 (used reg = )
08077 22BD           50                         push	ax
08078                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08079 22BE           E8         DDC2            call	_read_dword
08080 22C1           89D3                       mov	bx,dx
08081 22C3           83C4                   04  add	sp,*4
08082                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08083 22C6           8986       FDEA            mov	-$216[bp],ax
08084 22CA           899E       FDEC            mov	-$214[bp],bx
08085                                           !BCC_EOS
08086                                           ! 1584         sectors_high = 0;
08087                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08088 22CE           31C0                       xor	ax,ax
08089 22D0           31DB                       xor	bx,bx
08090 22D2           8986       FDE6            mov	-$21A[bp],ax
08091 22D6           899E       FDE8            mov	-$218[bp],bx
08092                                           !BCC_EOS
08093                                           ! 1585       }
08094                                           ! 1586       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08095                       000022DA            .1C9:
08096                                           ! Debug: list int = const $FF (used reg = )
08097 22DA           B8                   00FF  mov	ax,#$FF
08098 22DD           50                         push	ax
08099                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08100 22DE           8A46         FB            mov	al,-5[bp]
08101 22E1           30E4                       xor	ah,ah
08102 22E3           B9                   001E  mov	cx,*$1E
08103 22E6           F7E9                       imul	cx
08104 22E8           89C3                       mov	bx,ax
08105                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08106                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08107 22EA           81C3                 0143  add	bx,#$143
08108 22EE           53                         push	bx
08109                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08110 22EF           FF76         FE            push	-2[bp]
08111                                           ! Debug: func () void = write_byte+0 (used reg = )
08112 22F2           E8         E329            call	_write_byte
08113 22F5           83C4                   06  add	sp,*6
08114                                           !BCC_EOS
08115                                           ! 1587       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08116                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08117 22F8           8A86       FDDC            mov	al,-$224[bp]
08118 22FC           30E4                       xor	ah,ah
08119 22FE           50                         push	ax
08120                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08121 22FF           8A46         FB            mov	al,-5[bp]
08122 2302           30E4                       xor	ah,ah
08123 2304           B9                   001E  mov	cx,*$1E
08124 2307           F7E9                       imul	cx
08125 2309           89C3                       mov	bx,ax
08126                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08127                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08128 230B           81C3                 0144  add	bx,#$144
08129 230F           53                         push	bx
08130                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08131 2310           FF76         FE            push	-2[bp]
08132                                           ! Debug: func () void = write_byte+0 (used reg = )
08133 2313           E8         E308            call	_write_byte
08134 2316           83C4                   06  add	sp,*6
08135                                           !BCC_EOS
08136                                           ! 1588       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08137                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08138 2319           8A86       FDDB            mov	al,-$225[bp]
08139 231D           30E4                       xor	ah,ah
08140 231F           50                         push	ax
08141                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08142 2320           8A46         FB            mov	al,-5[bp]
08143 2323           30E4                       xor	ah,ah
08144 2325           B9                   001E  mov	cx,*$1E
08145 2328           F7E9                       imul	cx
08146 232A           89C3                       mov	bx,ax
08147                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08148                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08149 232C           81C3                 0146  add	bx,#$146
08150 2330           53                         push	bx
08151                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08152 2331           FF76         FE            push	-2[bp]
08153                                           ! Debug: func () void = write_byte+0 (used reg = )
08154 2334           E8         E2E7            call	_write_byte
08155 2337           83C4                   06  add	sp,*6
08156                                           !BCC_EOS
08157                                           ! 1589       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08158                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08159 233A           FFB6       FDDE            push	-$222[bp]
08160                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08161 233E           8A46         FB            mov	al,-5[bp]
08162 2341           30E4                       xor	ah,ah
08163 2343           B9                   001E  mov	cx,*$1E
08164 2346           F7E9                       imul	cx
08165 2348           89C3                       mov	bx,ax
08166                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08167                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08168 234A           81C3                 0148  add	bx,#$148
08169 234E           53                         push	bx
08170                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08171 234F           FF76         FE            push	-2[bp]
08172                                           ! Debug: func () void = write_word+0 (used reg = )
08173 2352           E8         E2E1            call	_write_word
08174 2355           83C4                   06  add	sp,*6
08175                                           !BCC_EOS
08176                                           ! 1590       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08177                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08178 2358           FFB6       FDE2            push	-$21E[bp]
08179                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08180 235C           8A46         FB            mov	al,-5[bp]
08181 235F           30E4                       xor	ah,ah
08182 2361           B9                   001E  mov	cx,*$1E
08183 2364           F7E9                       imul	cx
08184 2366           89C3                       mov	bx,ax
08185                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08186                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08187 2368           81C3                 0152  add	bx,#$152
08188 236C           53                         push	bx
08189                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08190 236D           FF76         FE            push	-2[bp]
08191                                           ! Debug: func () void = write_word+0 (used reg = )
08192 2370           E8         E2C3            call	_write_word
08193 2373           83C4                   06  add	sp,*6
08194                                           !BCC_EOS
08195                                           ! 1591       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
08196                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08197 2376           FFB6       FDE4            push	-$21C[bp]
08198                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08199 237A           8A46         FB            mov	al,-5[bp]
08200 237D           30E4                       xor	ah,ah
08201 237F           B9                   001E  mov	cx,*$1E
08202 2382           F7E9                       imul	cx
08203 2384           89C3                       mov	bx,ax
08204                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08205                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08206 2386           81C3                 0154  add	bx,#$154
08207 238A           53                         push	bx
08208                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08209 238B           FF76         FE            push	-2[bp]
08210                                           ! Debug: func () void = write_word+0 (used reg = )
08211 238E           E8         E2A5            call	_write_word
08212 2391           83C4                   06  add	sp,*6
08213                                           !BCC_EOS
08214                                           ! 1592       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08215                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08216 2394           FFB6       FDE0            push	-$220[bp]
08217                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08218 2398           8A46         FB            mov	al,-5[bp]
08219 239B           30E4                       xor	ah,ah
08220 239D           B9                   001E  mov	cx,*$1E
08221 23A0           F7E9                       imul	cx
08222 23A2           89C3                       mov	bx,ax
08223                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08224                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08225 23A4           81C3                 0156  add	bx,#$156
08226 23A8           53                         push	bx
08227                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08228 23A9           FF76         FE            push	-2[bp]
08229                                           ! Debug: func () void = write_word+0 (used reg = )
08230 23AC           E8         E287            call	_write_word
08231 23AF           83C4                   06  add	sp,*6
08232                                           !BCC_EOS
08233                                           ! 1593       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08234                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08235 23B2           FFB6       FDEC            push	-$214[bp]
08236 23B6           FFB6       FDEA            push	-$216[bp]
08237                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08238 23BA           8A46         FB            mov	al,-5[bp]
08239 23BD           30E4                       xor	ah,ah
08240 23BF           B9                   001E  mov	cx,*$1E
08241 23C2           F7E9                       imul	cx
08242 23C4           89C3                       mov	bx,ax
08243                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08244                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08245 23C6           81C3                 0158  add	bx,#$158
08246 23CA           53                         push	bx
08247                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08248 23CB           FF76         FE            push	-2[bp]
08249                                           ! Debug: func () void = write_dword+0 (used reg = )
08250 23CE           E8         DCCA            call	_write_dword
08251 23D1           83C4                   08  add	sp,*8
08252                                           !BCC_EOS
08253                                           ! 1594       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08254                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08255 23D4           FFB6       FDE8            push	-$218[bp]
08256 23D8           FFB6       FDE6            push	-$21A[bp]
08257                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08258 23DC           8A46         FB            mov	al,-5[bp]
08259 23DF           30E4                       xor	ah,ah
08260 23E1           B9                   001E  mov	cx,*$1E
08261 23E4           F7E9                       imul	cx
08262 23E6           89C3                       mov	bx,ax
08263                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08264                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08265 23E8           81C3                 015C  add	bx,#$15C
08266 23EC           53                         push	bx
08267                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08268 23ED           FF76         FE            push	-2[bp]
08269                                           ! Debug: func () void = write_dword+0 (used reg = )
08270 23F0           E8         DCA8            call	_write_dword
08271 23F3           83C4                   08  add	sp,*8
08272                                           !BCC_EOS
08273                                           ! 1595       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
08274                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08275 23F6           FFB6       FDE0            push	-$220[bp]
08276                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08277 23FA           FFB6       FDE2            push	-$21E[bp]
08278                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08279 23FE           FFB6       FDE4            push	-$21C[bp]
08280                                           ! Debug: list unsigned char slave = [S+$22E-$20E] (used reg = )
08281 2402           8A86       FDF4            mov	al,-$20C[bp]
08282 2406           30E4                       xor	ah,ah
08283 2408           50                         push	ax
08284                                           ! Debug: list unsigned char channel = [S+$230-$20D] (used reg = )
08285 2409           8A86       FDF5            mov	al,-$20B[bp]
08286 240D           30E4                       xor	ah,ah
08287 240F           50                         push	ax
08288                                           ! Debug: list * char = .1CA+0 (used reg = )
08289 2410           BB                   D79A  mov	bx,#.1CA
08290 2413           53                         push	bx
08291                                           ! Debug: list int = const 4 (used reg = )
08292 2414           B8                   0004  mov	ax,*4
08293 2417           50                         push	ax
08294                                           ! Debug: func () void = bios_printf+0 (used reg = )
08295 2418           E8         E58C            call	_bios_printf
08296 241B           83C4                   0E  add	sp,*$E
08297                                           !BCC_EOS
08298                                           ! 1596       translation = inb_cmos(0x39 + channel/2);
08299                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08300 241E           8A86       FDF5            mov	al,-$20B[bp]
08301 2422           30E4                       xor	ah,ah
08302 2424           D1E8                       shr	ax,*1
08303                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08304                                           ! Debug: expression subtree swapping
08305                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08306 2426           05                   0039  add	ax,*$39
08307 2429           50                         push	ax
08308                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08309 242A           E8         E15A            call	_inb_cmos
08310 242D           44                         inc	sp
08311 242E           44                         inc	sp
08312                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08313 242F           8886       FDDD            mov	-$223[bp],al
08314                                           !BCC_EOS
08315                                           ! 1597       for (shift=device%4; shift>0; shift--) translation >>= 2;
08316                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08317 2433           8A46         FB            mov	al,-5[bp]
08318 2436           30E4                       xor	ah,ah
08319 2438           24                     03  and	al,*3
08320                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08321 243A           8886       FDF3            mov	-$20D[bp],al
08322                                           !BCC_EOS
08323                                           !BCC_EOS
08324 243E           EB           17            jmp .1CD
08325                       00002440            .1CE:
08326                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08327 2440           8A86       FDDD            mov	al,-$223[bp]
08328 2444           30E4                       xor	ah,ah
08329 2446           D1E8                       shr	ax,*1
08330 2448           D1E8                       shr	ax,*1
08331 244A           8886       FDDD            mov	-$223[bp],al
08332                                           !BCC_EOS
08333                                           ! 1598       translation &= 0x03;
08334                       0000244E            .1CC:
08335                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08336 244E           8A86       FDF3            mov	al,-$20D[bp]
08337 2452           48                         dec	ax
08338 2453           8886       FDF3            mov	-$20D[bp],al
08339                       00002457            .1CD:
08340                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08341 2457           8A86       FDF3            mov	al,-$20D[bp]
08342 245B           84C0                       test	al,al
08343 245D           75           E1            jne	.1CE
08344                       0000245F            .1CF:
08345                       0000245F            .1CB:
08346                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08347 245F           8A86       FDDD            mov	al,-$223[bp]
08348 2463           24                     03  and	al,*3
08349 2465           8886       FDDD            mov	-$223[bp],al
08350                                           !BCC_EOS
08351                                           ! 1599       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08352                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08353 2469           8A86       FDDD            mov	al,-$223[bp]
08354 246D           30E4                       xor	ah,ah
08355 246F           50                         push	ax
08356                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08357 2470           8A46         FB            mov	al,-5[bp]
08358 2473           30E4                       xor	ah,ah
08359 2475           B9                   001E  mov	cx,*$1E
08360 2478           F7E9                       imul	cx
08361 247A           89C3                       mov	bx,ax
08362                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08363                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08364 247C           81C3                 014A  add	bx,#$14A
08365 2480           53                         push	bx
08366                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08367 2481           FF76         FE            push	-2[bp]
08368                                           ! Debug: func () void = write_byte+0 (used reg = )
08369 2484           E8         E197            call	_write_byte
08370 2487           83C4                   06  add	sp,*6
08371                                           !BCC_EOS
08372                                           ! 1600       switch (translation) {
08373 248A           8A86       FDDD            mov	al,-$223[bp]
08374 248E           EB           42            jmp .1D2
08375                                           ! 1601         case 0:
08376                                           ! 1602           bios_printf(4, "none");
08377                       00002490            .1D3:
08378                                           ! Debug: list * char = .1D4+0 (used reg = )
08379 2490           BB                   D795  mov	bx,#.1D4
08380 2493           53                         push	bx
08381                                           ! Debug: list int = const 4 (used reg = )
08382 2494           B8                   0004  mov	ax,*4
08383 2497           50                         push	ax
08384                                           ! Debug: func () void = bios_printf+0 (used reg = )
08385 2498           E8         E50C            call	_bios_printf
08386 249B           83C4                   04  add	sp,*4
08387                                           !BCC_EOS
08388                                           ! 1603           break;
08389 249E           EB           42            jmp .1D0
08390                                           !BCC_EOS
08391                                           ! 1604         case 1:
08392                                           ! 1605           bios_printf(4, "lba");
08393                       000024A0            .1D5:
08394                                           ! Debug: list * char = .1D6+0 (used reg = )
08395 24A0           BB                   D791  mov	bx,#.1D6
08396 24A3           53                         push	bx
08397                                           ! Debug: list int = const 4 (used reg = )
08398 24A4           B8                   0004  mov	ax,*4
08399 24A7           50                         push	ax
08400                                           ! Debug: func () void = bios_printf+0 (used reg = )
08401 24A8           E8         E4FC            call	_bios_printf
08402 24AB           83C4                   04  add	sp,*4
08403                                           !BCC_EOS
08404                                           ! 1606           break;
08405 24AE           EB           32            jmp .1D0
08406                                           !BCC_EOS
08407                                           ! 1607         case 2:
08408                                           ! 1608           bios_printf(4, "large");
08409                       000024B0            .1D7:
08410                                           ! Debug: list * char = .1D8+0 (used reg = )
08411 24B0           BB                   D78B  mov	bx,#.1D8
08412 24B3           53                         push	bx
08413                                           ! Debug: list int = const 4 (used reg = )
08414 24B4           B8                   0004  mov	ax,*4
08415 24B7           50                         push	ax
08416                                           ! Debug: func () void = bios_printf+0 (used reg = )
08417 24B8           E8         E4EC            call	_bios_printf
08418 24BB           83C4                   04  add	sp,*4
08419                                           !BCC_EOS
08420                                           ! 1609           break;
08421 24BE           EB           22            jmp .1D0
08422                                           !BCC_EOS
08423                                           ! 1610         case 3:
08424                                           ! 1611           bios_printf(4, "r-echs");
08425                       000024C0            .1D9:
08426                                           ! Debug: list * char = .1DA+0 (used reg = )
08427 24C0           BB                   D784  mov	bx,#.1DA
08428 24C3           53                         push	bx
08429                                           ! Debug: list int = const 4 (used reg = )
08430 24C4           B8                   0004  mov	ax,*4
08431 24C7           50                         push	ax
08432                                           ! Debug: func () void = bios_printf+0 (used reg = )
08433 24C8           E8         E4DC            call	_bios_printf
08434 24CB           83C4                   04  add	sp,*4
08435                                           !BCC_EOS
08436                                           ! 1612           break;
08437 24CE           EB           12            jmp .1D0
08438                                           !BCC_EOS
08439                                           ! 1613       }
08440                                           ! 1614       switch (translation) {
08441 24D0           EB           10            jmp .1D0
08442                       000024D2            .1D2:
08443 24D2           2C                     00  sub	al,*0
08444 24D4           74           BA            je 	.1D3
08445 24D6           2C                     01  sub	al,*1
08446 24D8           74           C6            je 	.1D5
08447 24DA           2C                     01  sub	al,*1
08448 24DC           74           D2            je 	.1D7
08449 24DE           2C                     01  sub	al,*1
08450 24E0           74           DE            je 	.1D9
08451                       000024E2            .1D0:
08452                       FFFFFDD8            ..FFFE	=	-$228
08453 24E2           8A86       FDDD            mov	al,-$223[bp]
08454 24E6           E9         0161            br 	.1DD
08455                                           ! 1615         case 0:
08456                                           ! 1616           break;
08457                       000024E9            .1DE:
08458 24E9           E9         0174            br 	.1DB
08459                                           !BCC_EOS
08460                                           ! 1617         case 1:
08461                                           ! 1618           spt = 63;
08462                       000024EC            .1DF:
08463                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08464 24EC           B8                   003F  mov	ax,*$3F
08465 24EF           8986       FDE0            mov	-$220[bp],ax
08466                                           !BCC_EOS
08467                                           ! 1619           sectors_low 
08468                                           ! 1619 /= 63;
08469                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08470 24F3           B8                   003F  mov	ax,*$3F
08471 24F6           31DB                       xor	bx,bx
08472 24F8           53                         push	bx
08473 24F9           50                         push	ax
08474 24FA           8B86       FDEA            mov	ax,-$216[bp]
08475 24FE           8B9E       FDEC            mov	bx,-$214[bp]
08476 2502           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08477 2506           E8         DC65            call	ldivul
08478 2509           8986       FDEA            mov	-$216[bp],ax
08479 250D           899E       FDEC            mov	-$214[bp],bx
08480 2511           83C4                   04  add	sp,*4
08481                                           !BCC_EOS
08482                                           ! 1620           heads = sectors_low / 1024;
08483                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08484 2514           B8                   0400  mov	ax,#$400
08485 2517           31DB                       xor	bx,bx
08486 2519           53                         push	bx
08487 251A           50                         push	ax
08488 251B           8B86       FDEA            mov	ax,-$216[bp]
08489 251F           8B9E       FDEC            mov	bx,-$214[bp]
08490 2523           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08491 2527           E8         DC44            call	ldivul
08492 252A           83C4                   04  add	sp,*4
08493                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08494 252D           8986       FDE2            mov	-$21E[bp],ax
08495                                           !BCC_EOS
08496                                           ! 1621           if (heads>128) heads = 255;
08497                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08498 2531           8B86       FDE2            mov	ax,-$21E[bp]
08499 2535           3D                   0080  cmp	ax,#$80
08500 2538           76           09            jbe 	.1E0
08501                       0000253A            .1E1:
08502                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08503 253A           B8                   00FF  mov	ax,#$FF
08504 253D           8986       FDE2            mov	-$21E[bp],ax
08505                                           !BCC_EOS
08506                                           ! 1622           else if (heads>64) heads = 128;
08507 2541           EB           3D            jmp .1E2
08508                       00002543            .1E0:
08509                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08510 2543           8B86       FDE2            mov	ax,-$21E[bp]
08511 2547           3D                   0040  cmp	ax,*$40
08512 254A           76           09            jbe 	.1E3
08513                       0000254C            .1E4:
08514                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08515 254C           B8                   0080  mov	ax,#$80
08516 254F           8986       FDE2            mov	-$21E[bp],ax
08517                                           !BCC_EOS
08518                                           ! 1623           else if (heads>32) heads = 64;
08519 2553           EB           2B            jmp .1E5
08520                       00002555            .1E3:
08521                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08522 2555           8B86       FDE2            mov	ax,-$21E[bp]
08523 2559           3D                   0020  cmp	ax,*$20
08524 255C           76           09            jbe 	.1E6
08525                       0000255E            .1E7:
08526                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08527 255E           B8                   0040  mov	ax,*$40
08528 2561           8986       FDE2            mov	-$21E[bp],ax
08529                                           !BCC_EOS
08530                                           ! 1624           else if (heads>16) heads = 32;
08531 2565           EB           19            jmp .1E8
08532                       00002567            .1E6:
08533                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08534 2567           8B86       FDE2            mov	ax,-$21E[bp]
08535 256B           3D                   0010  cmp	ax,*$10
08536 256E           76           09            jbe 	.1E9
08537                       00002570            .1EA:
08538                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08539 2570           B8                   0020  mov	ax,*$20
08540 2573           8986       FDE2            mov	-$21E[bp],ax
08541                                           !BCC_EOS
08542                                           ! 1625           else heads=16;
08543 2577           EB           07            jmp .1EB
08544                       00002579            .1E9:
08545                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08546 2579           B8                   0010  mov	ax,*$10
08547 257C           8986       FDE2            mov	-$21E[bp],ax
08548                                           !BCC_EOS
08549                                           ! 1626           cylinders = sectors_low / heads;
08550                       00002580            .1EB:
08551                       00002580            .1E8:
08552                       00002580            .1E5:
08553                       00002580            .1E2:
08554                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08555 2580           8B86       FDE2            mov	ax,-$21E[bp]
08556 2584           31DB                       xor	bx,bx
08557                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08558 2586           53                         push	bx
08559 2587           50                         push	ax
08560 2588           8B86       FDEA            mov	ax,-$216[bp]
08561 258C           8B9E       FDEC            mov	bx,-$214[bp]
08562 2590           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08563 2594           E8         DBD7            call	ldivul
08564 2597           83C4                   04  add	sp,*4
08565                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08566 259A           8986       FDE4            mov	-$21C[bp],ax
08567                                           !BCC_EOS
08568                                           ! 1627           break;
08569 259E           E9         00BF            br 	.1DB
08570                                           !BCC_EOS
08571                                           ! 1628         case 3:
08572                                           ! 1629           if (heads==16) {
08573                       000025A1            .1EC:
08574                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08575 25A1           8B86       FDE2            mov	ax,-$21E[bp]
08576 25A5           3D                   0010  cmp	ax,*$10
08577 25A8           75           72            jne 	.1ED
08578                       000025AA            .1EE:
08579                                           ! 1630             if(cylinders>61439) cylinders=61439;
08580                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08581 25AA           8B86       FDE4            mov	ax,-$21C[bp]
08582 25AE           31DB                       xor	bx,bx
08583                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08584 25B0           53                         push	bx
08585 25B1           50                         push	ax
08586 25B2           B8                   EFFF  mov	ax,#$EFFF
08587 25B5           31DB                       xor	bx,bx
08588 25B7           53                         push	bx
08589 25B8           50                         push	ax
08590 25B9           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08591 25BD           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08592 25C1           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08593 25C5           E8         DB03            call	lcmpul
08594 25C8           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08595 25CC           76           07            jbe 	.1EF
08596                       000025CE            .1F0:
08597                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08598 25CE           B8                   EFFF  mov	ax,#$EFFF
08599 25D1           8986       FDE4            mov	-$21C[bp],ax
08600                                           !BCC_EOS
08601                                           ! 1631             heads=15;
08602                       000025D5            .1EF:
08603                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08604 25D5           B8                   000F  mov	ax,*$F
08605 25D8           8986       FDE2            mov	-$21E[bp],ax
08606                                           !BCC_EOS
08607                                           ! 1632             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08608                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08609 25DC           8B86       FDE4            mov	ax,-$21C[bp]
08610 25E0           31DB                       xor	bx,bx
08611                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08612 25E2           53                         push	bx
08613 25E3           50                         push	ax
08614 25E4           B8                   0010  mov	ax,*$10
08615 25E7           31DB                       xor	bx,bx
08616 25E9           53                         push	bx
08617 25EA           50                         push	ax
08618 25EB           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08619 25EF           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08620 25F3           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08621 25F7           E8         DAEF            call	lmulul
08622 25FA           83C4                   08  add	sp,*8
08623                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08624 25FD           53                         push	bx
08625 25FE           50                         push	ax
08626 25FF           B8                   000F  mov	ax,*$F
08627 2602           31DB                       xor	bx,bx
08628 2604           53                         push	bx
08629 2605           50                         push	ax
08630 2606           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08631 260A           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08632 260E           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08633 2612           E8         DB59            call	ldivul
08634 2615           83C4                   08  add	sp,*8
08635                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08636                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08637 2618           8986       FDE4            mov	-$21C[bp],ax
08638                                           !BCC_EOS
08639                                           ! 1633           }
08640                                           ! 1634         case 2:
08641                       0000261C            .1ED:
08642                                           ! 1635           while(cylinders > 1024) {
08643                       0000261C            .1F1:
08644 261C           EB           1F            jmp .1F3
08645                       0000261E            .1F4:
08646                                           ! 1636             cylinders >>= 1;
08647                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08648 261E           8B86       FDE4            mov	ax,-$21C[bp]
08649 2622           D1E8                       shr	ax,*1
08650 2624           8986       FDE4            mov	-$21C[bp],ax
08651                                           !BCC_EOS
08652                                           ! 1637             heads <<= 1;
08653                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08654 2628           8B86       FDE2            mov	ax,-$21E[bp]
08655 262C           D1E0                       shl	ax,*1
08656 262E           8986       FDE2            mov	-$21E[bp],ax
08657                                           !BCC_EOS
08658                                           ! 1638             if (heads > 127) break;
08659                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08660 2632           8B86       FDE2            mov	ax,-$21E[bp]
08661 2636           3D                   007F  cmp	ax,*$7F
08662 2639           76           02            jbe 	.1F5
08663                       0000263B            .1F6:
08664 263B           EB           09            jmp .1F2
08665                                           !BCC_EOS
08666                                           ! 1639           }
08667                       0000263D            .1F5:
08668                                           ! 1640           break;
08669                       0000263D            .1F3:
08670                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08671 263D           8B86       FDE4            mov	ax,-$21C[bp]
08672 2641           3D                   0400  cmp	ax,#$400
08673 2644           77           D8            ja 	.1F4
08674                       00002646            .1F7:
08675                       00002646            .1F2:
08676 2646           EB           18            jmp .1DB
08677                                           !BCC_EOS
08678                                           ! 1641       }
08679                                           ! 1642       if (cylinders > 1024) cylinders=1024;
08680 2648           EB           16            jmp .1DB
08681                       0000264A            .1DD:
08682 264A           2C                     00  sub	al,*0
08683 264C         0F84         FE99            beq 	.1DE
08684 2650           2C                     01  sub	al,*1
08685 2652         0F84         FE96            beq 	.1DF
08686 2656           2C                     01  sub	al,*1
08687 2658           74           C2            je 	.1F1
08688 265A           2C                     01  sub	al,*1
08689 265C         0F84         FF41            beq 	.1EC
08690                       00002660            .1DB:
08691                       FFFFFDD8            ..FFFD	=	-$228
08692                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08693 2660           8B86       FDE4            mov	ax,-$21C[bp]
08694 2664           3D                   0400  cmp	ax,#$400
08695 2667           76           07            jbe 	.1F8
08696                       00002669            .1F9:
08697                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08698 2669           B8                   0400  mov	ax,#$400
08699 266C           8986       FDE4            mov	-$21C[bp],ax
08700                                           !BCC_EOS
08701                                           ! 1643       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08702                       00002670            .1F8:
08703                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08704 2670           FFB6       FDE0            push	-$220[bp]
08705                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08706 2674           FFB6       FDE2            push	-$21E[bp]
08707                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08708 2678           FFB6       FDE4            push	-$21C[bp]
08709                                           ! Debug: list * char = .1FA+0 (used reg = )
08710 267C           BB                   D774  mov	bx,#.1FA
08711 267F           53                         push	bx
08712                                           ! Debug: list int = const 4 (used reg = )
08713 2680           B8                   0004  mov	ax,*4
08714 2683           50                         push	ax
08715                                           ! Debug: func () void = bios_printf+0 (used reg = )
08716 2684           E8         E320            call	_bios_printf
08717 2687           83C4                   0A  add	sp,*$A
08718                                           !BCC_EOS
08719                                           ! 1644       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08720                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08721 268A           FFB6       FDE2            push	-$21E[bp]
08722                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08723 268E           8A46         FB            mov	al,-5[bp]
08724 2691           30E4                       xor	ah,ah
08725 2693           B9                   001E  mov	cx,*$1E
08726 2696           F7E9                       imul	cx
08727 2698           89C3                       mov	bx,ax
08728                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08729                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08730 269A           81C3                 014C  add	bx,#$14C
08731 269E           53                         push	bx
08732                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08733 269F           FF76         FE            push	-2[bp]
08734                                           ! Debug: func () void = write_word+0 (used reg = )
08735 26A2           E8         DF91            call	_write_word
08736 26A5           83C4                   06  add	sp,*6
08737                                           !BCC_EOS
08738                                           ! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
08739                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08740 26A8           FFB6       FDE4            push	-$21C[bp]
08741                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08742 26AC           8A46         FB            mov	al,-5[bp]
08743 26AF           30E4                       xor	ah,ah
08744 26B1           B9                   001E  mov	cx,*$1E
08745 26B4           F7E9                       imul	cx
08746 26B6           89C3                       mov	bx,ax
08747                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08748                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
08749 26B8           81C3                 014E  add	bx,#$14E
08750 26BC           53                         push	bx
08751                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08752 26BD           FF76         FE            push	-2[bp]
08753                                           ! Debug: func () void = write_word+0 (used reg = )
08754 26C0           E8         DF73            call	_write_word
08755 26C3           83C4                   06  add	sp,*6
08756                                           !BCC_EOS
08757                                           ! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
08758                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08759 26C6           FFB6       FDE0            push	-$220[bp]
08760                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08761 26CA           8A46         FB            mov	al,-5[bp]
08762 26CD           30E4                       xor	ah,ah
08763 26CF           B9                   001E  mov	cx,*$1E
08764 26D2           F7E9                       imul	cx
08765 26D4           89C3                       mov	bx,ax
08766                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08767                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
08768 26D6           81C3                 0150  add	bx,#$150
08769 26DA           53                         push	bx
08770                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08771 26DB           FF76         FE            push	-2[bp]
08772                                           ! Debug: func () void = write_word+0 (used reg = )
08773 26DE           E8         DF55            call	_write_word
08774 26E1           83C4                   06  add	sp,*6
08775                                           !BCC_EOS
08776                                           ! 1647       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
08777                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
08778 26E4           8A46         FB            mov	al,-5[bp]
08779 26E7           30E4                       xor	ah,ah
08780 26E9           50                         push	ax
08781                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
08782 26EA           8A46         FD            mov	al,-3[bp]
08783 26ED           30E4                       xor	ah,ah
08784 26EF           89C3                       mov	bx,ax
08785                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08786                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
08787 26F1           81C3                 0233  add	bx,#$233
08788 26F5           53                         push	bx
08789                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08790 26F6           FF76         FE            push	-2[bp]
08791                                           ! Debug: func () void = write_byte+0 (used reg = )
08792 26F9           E8         DF22            call	_write_byte
08793 26FC           83C4                   06  add	sp,*6
08794                                           !BCC_EOS
08795                                           ! 1648       hdcount++;
08796                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
08797 26FF           8A46         FD            mov	al,-3[bp]
08798 2702           40                         inc	ax
08799 2703           8846         FD            mov	-3[bp],al
08800                                           !BCC_EOS
08801                                           ! 1649     }
08802 2706           83C4                   14  add	sp,*$14
08803                                           ! 1650     if(type == 0x03) {
08804                       00002709            .1BC:
08805                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
08806 2709           8A46         FA            mov	al,-6[bp]
08807 270C           3C                     03  cmp	al,*3
08808 270E         0F85         0180            bne 	.1FB
08809                       00002712            .1FC:
08810                                           ! 1651       Bit8u type, removable, mode;
08811                                           !BCC_EOS
08812                                           ! 1652       Bit16u blksize;
08813                                           !BCC_EOS
08814                                           ! 1653       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
08815 2712           83C4                   FA  add	sp,*-6
08816                                           ! Debug: list int = const 5 (used reg = )
08817 2715           B8                   0005  mov	ax,*5
08818 2718           50                         push	ax
08819                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08820 2719           8A46         FB            mov	al,-5[bp]
08821 271C           30E4                       xor	ah,ah
08822 271E           B9                   001E  mov	cx,*$1E
08823 2721           F7E9                       imul	cx
08824 2723           89C3                       mov	bx,ax
08825                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08826                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08827 2725           81C3                 0143  add	bx,#$143
08828 2729           53                         push	bx
08829                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08830 272A           FF76         FE            push	-2[bp]
08831                                           ! Debug: func () void = write_byte+0 (used reg = )
08832 272D           E8         DEEE            call	_write_byte
08833 2730           83C4                   06  add	sp,*6
08834                                           !BCC_EOS
08835                                           ! 1654       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08836                                           ! Debug: list int = const 0 (used reg = )
08837 2733           31C0                       xor	ax,ax
08838 2735           50                         push	ax
08839                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08840 2736           8A46         FB            mov	al,-5[bp]
08841 2739           30E4                       xor	ah,ah
08842 273B           B9                   001E  mov	cx,*$1E
08843 273E           F7E9                       imul	cx
08844 2740           89C3                       mov	bx,ax
08845                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08846                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08847 2742           81C3                 0146  add	bx,#$146
08848 2746           53                         push	bx
08849                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08850 2747           FF76         FE            push	-2[bp]
08851                                           ! Debug: func () void = write_byte+0 (used reg = )
08852 274A           E8         DED1            call	_write_byte
08853 274D           83C4                   06  add	sp,*6
08854                                           !BCC_EOS
08855                                           ! 1655       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08856                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08857 2750           8D9E       FDFA            lea	bx,-$206[bp]
08858 2754           53                         push	bx
08859                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08860 2755           E8         DEF9            call	_get_SS
08861                                           ! Debug: list unsigned short = ax+0 (used reg = )
08862 2758           50                         push	ax
08863                                           ! Debug: list long = const 0 (used reg = )
08864 2759           31C0                       xor	ax,ax
08865 275B           31DB                       xor	bx,bx
08866 275D           53                         push	bx
08867 275E           50                         push	ax
08868                                           ! Debug: list long = const 0 (used reg = )
08869 275F           31C0                       xor	ax,ax
08870 2761           31DB                       xor	bx,bx
08871 2763           53                         push	bx
08872 2764           50                         push	ax
08873                                           ! Debug: list int = const 0 (used reg = )
08874 2765           31C0                       xor	ax,ax
08875 2767           50                         push	ax
08876                                           ! Debug: list int = const 0 (used reg = )
08877 2768           31C0                       xor	ax,ax
08878 276A           50                         push	ax
08879                                           ! Debug: list int = const 0 (used reg = )
08880 276B           31C0                       xor	ax,ax
08881 276D           50                         push	ax
08882                                           ! Debug: list int = const 1 (used reg = )
08883 276E           B8                   0001  mov	ax,*1
08884 2771           50                         push	ax
08885                                           ! Debug: list int = const $A1 (used reg = )
08886 2772           B8                   00A1  mov	ax,#$A1
08887 2775           50                         push	ax
08888                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
08889 2776           8A46         FB            mov	al,-5[bp]
08890 2779           30E4                       xor	ah,ah
08891 277B           50                         push	ax
08892                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08893 277C           E8         06A5            call	_ata_cmd_data_in
08894 277F           83C4                   18  add	sp,*$18
08895                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08896 2782           85C0                       test	ax,ax
08897 2784           74           0E            je  	.1FD
08898                       00002786            .1FE:
08899                                           ! 1656         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08900                                           ! Debug: list * char = .1FF+0 (used reg = )
08901 2786           BB                   D749  mov	bx,#.1FF
08902 2789           53                         push	bx
08903                                           ! Debug: list int = const 7 (used reg = )
08904 278A           B8                   0007  mov	ax,*7
08905 278D           50                         push	ax
08906                                           ! Debug: func () void = bios_printf+0 (used reg = )
08907 278E           E8         E216            call	_bios_printf
08908 2791           83C4                   04  add	sp,*4
08909                                           !BCC_EOS
08910                                           ! 1657       type = read_byte(get_SS(),buffer+1) & 0x1f;
08911                       00002794            .1FD:
08912                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
08913 2794           8D9E       FDFB            lea	bx,-$205[bp]
08914 2798           53                         push	bx
08915                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08916 2799           E8         DEB5            call	_get_SS
08917                                           ! Debug: list unsigned short = ax+0 (used reg = )
08918 279C           50                         push	ax
08919                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08920 279D           E8         DE58            call	_read_byte
08921 27A0           83C4                   04  add	sp,*4
08922                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08923 27A3           24                     1F  and	al,*$1F
08924                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
08925 27A5           8886       FDED            mov	-$213[bp],al
08926                                           !BCC_EOS
08927                                           ! 1658       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08928                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08929 27A9           8D9E       FDFA            lea	bx,-$206[bp]
08930 27AD           53                         push	bx
08931                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08932 27AE           E8         DEA0            call	_get_SS
08933                                           ! Debug: list unsigned short = ax+0 (used reg = )
08934 27B1           50                         push	ax
08935                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08936 27B2           E8         DE43            call	_read_byte
08937 27B5           83C4                   04  add	sp,*4
08938                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08939 27B8           24                     80  and	al,#$80
08940 27BA           84C0                       test	al,al
08941 27BC           74           04            je  	.200
08942                       000027BE            .201:
08943 27BE           B0                     01  mov	al,*1
08944 27C0           EB           02            jmp .202
08945                       000027C2            .200:
08946 27C2           30C0                       xor	al,al
08947                       000027C4            .202:
08948                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
08949 27C4           8886       FDEC            mov	-$214[bp],al
08950                                           !BCC_EOS
08951                                           ! 1659       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08952                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
08953 27C8           8D9E       FE5A            lea	bx,-$1A6[bp]
08954 27CC           53                         push	bx
08955                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08956 27CD           E8         DE81            call	_get_SS
08957                                           ! Debug: list unsigned short = ax+0 (used reg = )
08958 27D0           50                         push	ax
08959                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08960 27D1           E8         DE24            call	_read_byte
08961 27D4           83C4                   04  add	sp,*4
08962 27D7           84C0                       test	al,al
08963 27D9           74           04            je  	.203
08964                       000027DB            .204:
08965 27DB           B0                     01  mov	al,*1
08966 27DD           EB           02            jmp .205
08967                       000027DF            .203:
08968 27DF           30C0                       xor	al,al
08969                       000027E1            .205:
08970                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
08971 27E1           8886       FDEB            mov	-$215[bp],al
08972                                           !BCC_EOS
08973                                           ! 1660       blksize = 2048;
08974                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
08975 27E5           B8                   0800  mov	ax,#$800
08976 27E8           8986       FDE8            mov	-$218[bp],ax
08977                                           !BCC_EOS
08978                                           ! 1661       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
08979                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
08980 27EC           8A86       FDED            mov	al,-$213[bp]
08981 27F0           30E4                       xor	ah,ah
08982 27F2           50                         push	ax
08983                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08984 27F3           8A46         FB            mov	al,-5[bp]
08985 27F6           30E4                       xor	ah,ah
08986 27F8           B9                   001E  mov	cx,*$1E
08987 27FB           F7E9                       imul	cx
08988 27FD           89C3                       mov	bx,ax
08989                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08990                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08991 27FF           81C3                 0143  add	bx,#$143
08992 2803           53                         push	bx
08993                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08994 2804           FF76         FE            push	-2[bp]
08995                                           ! Debug: func () void = write_byte+0 (used reg = )
08996 2807           E8         DE14            call	_write_byte
08997 280A           83C4                   06  add	sp,*6
08998                                           !BCC_EOS
08999                                           ! 1662       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09000                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09001 280D           8A86       FDEC            mov	al,-$214[bp]
09002 2811           30E4                       xor	ah,ah
09003 2813           50                         push	ax
09004                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09005 2814           8A46         FB            mov	al,-5[bp]
09006 2817           30E4                       xor	ah,ah
09007 2819           B9                   001E  mov	cx,*$1E
09008 281C           F7E9                       imul	cx
09009 281E           89C3                       mov	bx,ax
09010                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09011                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09012 2820           81C3                 0144  add	bx,#$144
09013 2824           53                         push	bx
09014                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09015 2825           FF76         FE            push	-2[bp]
09016                                           ! Debug: func () void = write_byte+0 (used reg = )
09017 2828           E8         DDF3            call	_write_byte
09018 282B           83C4                   06  add	sp,*6
09019                                           !BCC_EOS
09020                                           ! 1663       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09021                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09022 282E           8A86       FDEB            mov	al,-$215[bp]
09023 2832           30E4                       xor	ah,ah
09024 2834           50                         push	ax
09025                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09026 2835           8A46         FB            mov	al,-5[bp]
09027 2838           30E4                       xor	ah,ah
09028 283A           B9                   001E  mov	cx,*$1E
09029 283D           F7E9                       imul	cx
09030 283F           89C3                       mov	bx,ax
09031                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09032                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09033 2841           81C3                 0146  add	bx,#$146
09034 2845           53                         push	bx
09035                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09036 2846           FF76         FE            push	-2[bp]
09037                                           ! Debug: func () void = write_byte+0 (used reg = )
09038 2849           E8         DDD2            call	_write_byte
09039 284C           83C4                   06  add	sp,*6
09040                                           !BCC_EOS
09041                                           ! 1664       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.dev
09042                                           ! 1664 ices[device].blksize, blksize);
09043                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09044 284F           FFB6       FDE8            push	-$218[bp]
09045                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09046 2853           8A46         FB            mov	al,-5[bp]
09047 2856           30E4                       xor	ah,ah
09048 2858           B9                   001E  mov	cx,*$1E
09049 285B           F7E9                       imul	cx
09050 285D           89C3                       mov	bx,ax
09051                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09052                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09053 285F           81C3                 0148  add	bx,#$148
09054 2863           53                         push	bx
09055                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09056 2864           FF76         FE            push	-2[bp]
09057                                           ! Debug: func () void = write_word+0 (used reg = )
09058 2867           E8         DDCC            call	_write_word
09059 286A           83C4                   06  add	sp,*6
09060                                           !BCC_EOS
09061                                           ! 1665       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09062                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09063 286D           8A46         FB            mov	al,-5[bp]
09064 2870           30E4                       xor	ah,ah
09065 2872           50                         push	ax
09066                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09067 2873           8A46         FC            mov	al,-4[bp]
09068 2876           30E4                       xor	ah,ah
09069 2878           89C3                       mov	bx,ax
09070                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09071                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09072 287A           81C3                 023C  add	bx,#$23C
09073 287E           53                         push	bx
09074                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09075 287F           FF76         FE            push	-2[bp]
09076                                           ! Debug: func () void = write_byte+0 (used reg = )
09077 2882           E8         DD99            call	_write_byte
09078 2885           83C4                   06  add	sp,*6
09079                                           !BCC_EOS
09080                                           ! 1666       cdcount++;
09081                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09082 2888           8A46         FC            mov	al,-4[bp]
09083 288B           40                         inc	ax
09084 288C           8846         FC            mov	-4[bp],al
09085                                           !BCC_EOS
09086                                           ! 1667     }
09087 288F           83C4                   06  add	sp,*6
09088                                           ! 1668     {
09089                       00002892            .1FB:
09090                                           ! 1669       Bit32u sizeinmb;
09091                                           !BCC_EOS
09092                                           ! 1670       Bit16u ataversion;
09093                                           !BCC_EOS
09094                                           ! 1671       Bit8u c, i, version, model[41];
09095                                           !BCC_EOS
09096                                           ! 1672       switch (type) {
09097 2892           83C4                   CE  add	sp,*-$32
09098 2895           8A46         FA            mov	al,-6[bp]
09099 2898           E9         020B            br 	.208
09100                                           ! 1673         case 0x02:
09101                                           ! 1674           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
09102                       0000289B            .209:
09103                                           ! 1675             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09104                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09105 289B           8A46         FB            mov	al,-5[bp]
09106 289E           30E4                       xor	ah,ah
09107 28A0           B9                   001E  mov	cx,*$1E
09108 28A3           F7E9                       imul	cx
09109 28A5           89C3                       mov	bx,ax
09110                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09111                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09112 28A7           81C3                 0158  add	bx,#$158
09113 28AB           53                         push	bx
09114                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09115 28AC           FF76         FE            push	-2[bp]
09116                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09117 28AF           E8         D7D1            call	_read_dword
09118 28B2           89D3                       mov	bx,dx
09119 28B4           83C4                   04  add	sp,*4
09120                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09121 28B7           88E0                       mov	al,ah
09122 28B9           88DC                       mov	ah,bl
09123 28BB           88FB                       mov	bl,bh
09124 28BD           28FF                       sub	bh,bh
09125 28BF           BF                   0003  mov	di,*3
09126 28C2           E8         D864            call	lsrul
09127 28C5           53                         push	bx
09128 28C6           50                         push	ax
09129                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09130 28C7           8A46         FB            mov	al,-5[bp]
09131 28CA           30E4                       xor	ah,ah
09132 28CC           B9                   001E  mov	cx,*$1E
09133 28CF           F7E9                       imul	cx
09134 28D1           89C3                       mov	bx,ax
09135                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09136                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09137 28D3           81C3                 015C  add	bx,#$15C
09138 28D7           53                         push	bx
09139                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09140 28D8           FF76         FE            push	-2[bp]
09141                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09142 28DB           E8         D7A5            call	_read_dword
09143 28DE           89D3                       mov	bx,dx
09144 28E0           83C4                   04  add	sp,*4
09145                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09146 28E3           B1                     05  mov	cl,*5
09147 28E5           D3E0                       shl	ax,cl
09148 28E7           93                         xchg	bx,ax
09149 28E8           31C0                       xor	ax,ax
09150                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09151 28EA           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09152 28EE           E8         D816            call	lorul
09153 28F1           83C4                   04  add	sp,*4
09154                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09155 28F4           8986       FDEA            mov	-$216[bp],ax
09156 28F8           899E       FDEC            mov	-$214[bp],bx
09157                                           !BCC_EOS
09158                                           ! 1676         case 0x03:
09159                                           ! 1677           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09160                       000028FC            .20A:
09161                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09162 28FC           8D9E       FE9A            lea	bx,-$166[bp]
09163 2900           53                         push	bx
09164                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09165 2901           E8         DD4D            call	_get_SS
09166                                           ! Debug: list unsigned short = ax+0 (used reg = )
09167 2904           50                         push	ax
09168                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09169 2905           E8         DCF0            call	_read_byte
09170 2908           83C4                   04  add	sp,*4
09171 290B           50                         push	ax
09172                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09173 290C           8D9E       FE9B            lea	bx,-$165[bp]
09174 2910           53                         push	bx
09175                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09176 2911           E8         DD3D            call	_get_SS
09177                                           ! Debug: list unsigned short = ax+0 (used reg = )
09178 2914           50                         push	ax
09179                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09180 2915           E8         DCE0            call	_read_byte
09181 2918           83C4                   04  add	sp,*4
09182                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09183 291B           30E4                       xor	ah,ah
09184                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09185 291D           88C4                       mov	ah,al
09186 291F           30C0                       xor	al,al
09187                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09188 2921           0A86       FDBA            or	al,0+..FFFC[bp]
09189 2925           44                         inc	sp
09190 2926           44                         inc	sp
09191                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09192 2927           8986       FDE8            mov	-$218[bp],ax
09193                                           !BCC_EOS
09194                                           ! 1678           for(version=15;version>0;version--) {
09195                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09196 292B           B0                     0F  mov	al,*$F
09197 292D           8886       FDE5            mov	-$21B[bp],al
09198                                           !BCC_EOS
09199                                           !BCC_EOS
09200 2931           EB           22            jmp .20D
09201                       00002933            .20E:
09202                                           ! 1679             if((ataversion&(1<<version))!=0)
09203                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09204 2933           8A86       FDE5            mov	al,-$21B[bp]
09205 2937           30E4                       xor	ah,ah
09206 2939           89C3                       mov	bx,ax
09207 293B           B8                   0001  mov	ax,*1
09208 293E           89D9                       mov	cx,bx
09209 2940           D3E0                       shl	ax,cl
09210                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09211                                           ! Debug: expression subtree swapping
09212 2942           2386       FDE8            and	ax,-$218[bp]
09213                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09214 2946           85C0                       test	ax,ax
09215 2948           74           02            je  	.20F
09216                       0000294A            .210:
09217                                           ! 1680             break;
09218 294A           EB           11            jmp .20B
09219                                           !BCC_EOS
09220                                           ! 1681           }
09221                       0000294C            .20F:
09222                                           ! 1682           for(i=0;i<20;i++) {
09223                       0000294C            .20C:
09224                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09225 294C           8A86       FDE5            mov	al,-$21B[bp]
09226 2950           48                         dec	ax
09227 2951           8886       FDE5            mov	-$21B[bp],al
09228                       00002955            .20D:
09229                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09230 2955           8A86       FDE5            mov	al,-$21B[bp]
09231 2959           84C0                       test	al,al
09232 295B           75           D6            jne	.20E
09233                       0000295D            .211:
09234                       0000295D            .20B:
09235                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09236 295D           30C0                       xor	al,al
09237 295F           8886       FDE6            mov	-$21A[bp],al
09238                                           !BCC_EOS
09239                                           !BCC_EOS
09240 2963           EB           7B            jmp .214
09241                       00002965            .215:
09242                                           ! 1683             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09243                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09244 2965           8A86       FDE6            mov	al,-$21A[bp]
09245 2969           30E4                       xor	ah,ah
09246 296B           D1E0                       shl	ax,*1
09247                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09248 296D           89EB                       mov	bx,bp
09249 296F           01C3                       add	bx,ax
09250                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09251                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09252                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09253                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09254 2971           81C3                 FE31  add	bx,#-$1CF
09255 2975           53                         push	bx
09256                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09257 2976           E8         DCD8            call	_get_SS
09258                                           ! Debug: list unsigned short = ax+0 (used reg = )
09259 2979           50                         push	ax
09260                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09261 297A           E8         DC7B            call	_read_byte
09262 297D           83C4                   04  add	sp,*4
09263                                           ! Debug: list unsigned char = al+0 (used reg = )
09264 2980           30E4                       xor	ah,ah
09265 2982           50                         push	ax
09266                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09267 2983           8A86       FDE6            mov	al,-$21A[bp]
09268 2987           30E4                       xor	ah,ah
09269 2989           D1E0                       shl	ax,*1
09270                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09271 298B           89EB                       mov	bx,bp
09272 298D           01C3                       add	bx,ax
09273                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09274                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09275 298F           81C3                 FDBC  add	bx,#-$244
09276 2993           53                         push	bx
09277                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09278 2994           E8         DCBA            call	_get_SS
09279                                           ! Debug: list unsigned short = ax+0 (used reg = )
09280 2997           50                         push	ax
09281                                           ! Debug: func () void = write_byte+0 (used reg = )
09282 2998           E8         DC83            call	_write_byte
09283 299B           83C4                   06  add	sp,*6
09284                                           !BCC_EOS
09285                                           ! 1684             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09286                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09287 299E           8A86       FDE6            mov	al,-$21A[bp]
09288 29A2           30E4                       xor	ah,ah
09289 29A4           D1E0                       shl	ax,*1
09290                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09291 29A6           89EB                       mov	bx,bp
09292 29A8           01C3                       add	bx,ax
09293                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09294                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09295                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09296 29AA           81C3                 FE30  add	bx,#-$1D0
09297 29AE           53                         push	bx
09298                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09299 29AF           E8         DC9F            call	_get_SS
09300                                           ! Debug: list unsigned short = ax+0 (used reg = )
09301 29B2           50                         push	ax
09302                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09303 29B3           E8         DC42            call	_read_byte
09304 29B6           83C4                   04  add	sp,*4
09305                                           ! Debug: list unsigned char = al+0 (used reg = )
09306 29B9           30E4                       xor	ah,ah
09307 29BB           50                         push	ax
09308                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09309 29BC           8A86       FDE6            mov	al,-$21A[bp]
09310 29C0           30E4                       xor	ah,ah
09311 29C2           D1E0                       shl	ax,*1
09312                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09313 29C4           89EB                       mov	bx,bp
09314 29C6           01C3                       add	bx,ax
09315                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09316                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09317                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09318 29C8           81C3                 FDBD  add	bx,#-$243
09319 29CC           53                         push	bx
09320                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09321 29CD           E8         DC81            call	_get_SS
09322                                           ! Debug: list unsigned short = ax+0 (used reg = )
09323 29D0           50                         push	ax
09324                                           ! Debug: func () void = write_byte+0 (used reg = )
09325 29D1           E8         DC4A            call	_write_byte
09326 29D4           83C4                   06  add	sp,*6
09327                                           !BCC_EOS
09328                                           ! 1685           }
09329                                           ! 1686           write_byte(get_SS(),model+40,0x00);
09330                       000029D7            .213:
09331                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09332 29D7           8A86       FDE6            mov	al,-$21A[bp]
09333 29DB           40                         inc	ax
09334 29DC           8886       FDE6            mov	-$21A[bp],al
09335                       000029E0            .214:
09336                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09337 29E0           8A86       FDE6            mov	al,-$21A[bp]
09338 29E4           3C                     14  cmp	al,*$14
09339 29E6         0F82         FF7B            blo 	.215
09340                       000029EA            .216:
09341                       000029EA            .212:
09342                                           ! Debug: list int = const 0 (used reg = )
09343 29EA           31C0                       xor	ax,ax
09344 29EC           50                         push	ax
09345                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09346 29ED           8D9E       FDE4            lea	bx,-$21C[bp]
09347 29F1           53                         push	bx
09348                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09349 29F2           E8         DC5C            call	_get_SS
09350                                           ! Debug: list unsigned short = ax+0 (used reg = )
09351 29F5           50                         push	ax
09352                                           ! Debug: func () void = write_byte+0 (used reg = )
09353 29F6           E8         DC25            call	_write_byte
09354 29F9           83C4                   06  add	sp,*6
09355                                           !BCC_EOS
09356                                           ! 1687           for(i=39;i>0;i--){
09357                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09358 29FC           B0                     27  mov	al,*$27
09359 29FE           8886       FDE6            mov	-$21A[bp],al
09360                                           !BCC_EOS
09361                                           !BCC_EOS
09362 2A02           EB           46            jmp .219
09363                       00002A04            .21A:
09364                                           ! 1688             if(read_byte(get_SS(),model+i)==0x20)
09365                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09366 2A04           8A86       FDE6            mov	al,-$21A[bp]
09367 2A08           30E4                       xor	ah,ah
09368 2A0A           89EB                       mov	bx,bp
09369 2A0C           01C3                       add	bx,ax
09370                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09371                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09372 2A0E           81C3                 FDBC  add	bx,#-$244
09373 2A12           53                         push	bx
09374                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09375 2A13           E8         DC3B            call	_get_SS
09376                                           ! Debug: list unsigned short = ax+0 (used reg = )
09377 2A16           50                         push	ax
09378                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09379 2A17           E8         DBDE            call	_read_byte
09380 2A1A           83C4                   04  add	sp,*4
09381                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09382 2A1D           3C                     20  cmp	al,*$20
09383 2A1F           75           1E            jne 	.21B
09384                       00002A21            .21C:
09385                                           ! 1689               write_byte(get_SS(),model+i,0x00);
09386                                           ! Debug: list int = const 0 (used reg = )
09387 2A21           31C0                       xor	ax,ax
09388 2A23           50                         push	ax
09389                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09390 2A24           8A86       FDE6            mov	al,-$21A[bp]
09391 2A28           30E4                       xor	ah,ah
09392 2A2A           89EB                       mov	bx,bp
09393 2A2C           01C3                       add	bx,ax
09394                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09395                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09396 2A2E           81C3                 FDBC  add	bx,#-$244
09397 2A32           53                         push	bx
09398                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09399 2A33           E8         DC1B            call	_get_SS
09400                                           ! Debug: list unsigned short = ax+0 (used reg = )
09401 2A36           50                         push	ax
09402                                           ! Debug: func () void = write_byte+0 (used reg = )
09403 2A37           E8         DBE4            call	_write_byte
09404 2A3A           83C4                   06  add	sp,*6
09405                                           !BCC_EOS
09406                                           ! 1690             else break;
09407 2A3D           EB           02            jmp .21D
09408                       00002A3F            .21B:
09409 2A3F           EB           11            jmp .217
09410                                           !BCC_EOS
09411                                           ! 1691           }
09412                       00002A41            .21D:
09413                                           ! 1692           if (i>36) {
09414                       00002A41            .218:
09415                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09416 2A41           8A86       FDE6            mov	al,-$21A[bp]
09417 2A45           48                         dec	ax
09418 2A46           8886       FDE6            mov	-$21A[bp],al
09419                       00002A4A            .219:
09420                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09421 2A4A           8A86       FDE6            mov	al,-$21A[bp]
09422 2A4E           84C0                       test	al,al
09423 2A50           75           B2            jne	.21A
09424                       00002A52            .21E:
09425                       00002A52            .217:
09426                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09427 2A52           8A86       FDE6            mov	al,-$21A[bp]
09428 2A56           3C                     24  cmp	al,*$24
09429 2A58           76           48            jbe 	.21F
09430                       00002A5A            .220:
09431                                           ! 1693             write_byte(get_SS(),model+36,0x00);
09432                                           ! Debug: list int = const 0 (used reg = )
09433 2A5A           31C0                       xor	ax,ax
09434 2A5C           50                         push	ax
09435                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09436 2A5D           8D9E       FDE0            lea	bx,-$220[bp]
09437 2A61           53                         push	bx
09438                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09439 2A62           E8         DBEC            call	_get_SS
09440                                           ! Debug: list unsigned short = ax+0 (used reg = )
09441 2A65           50                         push	ax
09442                                           ! Debug: func () void = write_byte+0 (used reg = )
09443 2A66           E8         DBB5            call	_write_byte
09444 2A69           83C4                   06  add	sp,*6
09445                                           !BCC_EOS
09446                                           ! 1694             for(i=35;i>32;i--){
09447                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09448 2A6C           B0                     23  mov	al,*$23
09449 2A6E           8886       FDE6            mov	-$21A[bp],al
09450                                           !BCC_EOS
09451                                           !BCC_EOS
09452 2A72           EB           26            jmp .223
09453                       00002A74            .224:
09454                                           ! 1695               write_byte(get_SS(),model+i,0x2E);
09455                                           ! Debug: list int = const $2E (used reg = )
09456 2A74           B8                   002E  mov	ax,*$2E
09457 2A77           50                         push	ax
09458                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09459 2A78           8A86       FDE6            mov	al,-$21A[bp]
09460 2A7C           30E4                       xor	ah,ah
09461 2A7E           89EB                       mov	bx,bp
09462 2A80           01C3                       add	bx,ax
09463                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09464                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09465 2A82           81C3                 FDBC  add	bx,#-$244
09466 2A86           53                         push	bx
09467                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09468 2A87           E8         DBC7            call	_get_SS
09469                                           ! Debug: list unsigned short = ax+0 (used reg = )
09470 2A8A           50                         push	ax
09471                                           ! Debug: func () void = write_byte+0 (used reg = )
09472 2A8B           E8         DB90            call	_write_byte
09473 2A8E           83C4                   06  add	sp,*6
09474                                           !BCC_EOS
09475                                           ! 1696             }
09476                                           ! 1697           }
09477                       00002A91            .222:
09478                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09479 2A91           8A86       FDE6            mov	al,-$21A[bp]
09480 2A95           48                         dec	ax
09481 2A96           8886       FDE6            mov	-$21A[bp],al
09482                       00002A9A            .223:
09483                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09484 2A9A           8A86       FDE6            mov	al,-$21A[bp]
09485 2A9E           3C                     20  cmp	al,*$20
09486 2AA0           77           D2            ja 	.224
09487                       00002AA2            .225:
09488                       00002AA2            .221:
09489                                           ! 1698           break;
09490                       00002AA2            .21F:
09491 2AA2           EB           0E            jmp .206
09492                                           !BCC_EOS
09493                                           ! 1699       }
09494                                           ! 1700       switch (type) {
09495 2AA4           EB           0C            jmp .206
09496                       00002AA6            .208:
09497 2AA6           2C                     02  sub	al,*2
09498 2AA8         0F84         FDEF            beq 	.209
09499 2AAC           2C                     01  sub	al,*1
09500 2AAE         0F84         FE4A            beq 	.20A
09501                       00002AB2            .206:
09502                       FFFFFDBA            ..FFFC	=	-$246
09503 2AB2           8A46         FA            mov	al,-6[bp]
09504 2AB5           E9         01A2            br 	.228
09505                                           ! 1701         case 0x02:
09506                                           ! 1702           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09507                       00002AB8            .229:
09508 2AB8           8A86       FDF4            mov	al,-$20C[bp]
09509 2ABC           84C0                       test	al,al
09510 2ABE           74           05            je  	.22D
09511                       00002AC0            .22E:
09512 2AC0           BB                   D737  mov	bx,#.22B
09513 2AC3           EB           03            jmp .22F
09514                       00002AC5            .22D:
09515 2AC5           BB                   D730  mov	bx,#.22C
09516                       00002AC8            .22F:
09517                                           ! Debug: list * char = bx+0 (used reg = )
09518 2AC8           53                         push	bx
09519                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09520 2AC9           8A86       FDF5            mov	al,-$20B[bp]
09521 2ACD           30E4                       xor	ah,ah
09522 2ACF           50                         push	ax
09523                                           ! Debug: list * char = .22A+0 (used reg = )
09524 2AD0           BB                   D73E  mov	bx,#.22A
09525 2AD3           53                         push	bx
09526                                           ! Debug: list int = const 2 (used reg = )
09527 2AD4           B8                   0002  mov	ax,*2
09528 2AD7           50                         push	ax
09529                                           ! Debug: func () void = bios_printf+0 (used reg = )
09530 2AD8           E8         DECC            call	_bios_printf
09531 2ADB           83C4                   08  add	sp,*8
09532                                           !BCC_EOS
09533                                           ! 1703           i=0;
09534                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09535 2ADE           30C0                       xor	al,al
09536 2AE0           8886       FDE6            mov	-$21A[bp],al
09537                                           !BCC_EOS
09538                                           ! 1704           while(c=read_byte(get_SS(),model+i++))
09539                                           ! 1705             bios_printf(2, "%c",c);
09540 2AE4           EB           15            jmp .231
09541                       00002AE6            .232:
09542                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09543 2AE6           8A86       FDE7            mov	al,-$219[bp]
09544 2AEA           30E4                       xor	ah,ah
09545 2AEC           50                         push	ax
09546                                           ! Debug: list * char = .233+0 (used reg = )
09547 2AED           BB                   D72D  mov	bx,#.233
09548 2AF0           53                         push	bx
09549                                           ! Debug: list int = const 2 (used reg = )
09550 2AF1           B8                   0002  mov	ax,*2
09551 2AF4           50                         push	ax
09552                                           ! Debug: func () void = bios_printf+0 (used reg = )
09553 2AF5           E8         DEAF            call	_bios_printf
09554 2AF8           83C4                   06  add	sp,*6
09555                                           !BCC_EOS
09556                                           ! 1706           if (sizeinmb < (1UL<<16))
09557                       00002AFB            .231:
09558                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09559 2AFB           8A86       FDE6            mov	al,-$21A[bp]
09560 2AFF           40                         inc	ax
09561 2B00           8886       FDE6            mov	-$21A[bp],al
09562                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09563 2B04           48                         dec	ax
09564 2B05           30E4                       xor	ah,ah
09565 2B07           89EB                       mov	bx,bp
09566 2B09           01C3                       add	bx,ax
09567                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09568                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09569 2B0B           81C3                 FDBC  add	bx,#-$244
09570 2B0F           53                         push	bx
09571                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09572 2B10           E8         DB3E            call	_get_SS
09573                                           ! Debug: list unsigned short = ax+0 (used reg = )
09574 2B13           50                         push	ax
09575                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09576 2B14           E8         DAE1            call	_read_byte
09577 2B17           83C4                   04  add	sp,*4
09578                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09579 2B1A           8886       FDE7            mov	-$219[bp],al
09580 2B1E           84C0                       test	al,al
09581 2B20           75           C4            jne	.232
09582                       00002B22            .234:
09583                       00002B22            .230:
09584                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09585 2B22           31C0                       xor	ax,ax
09586 2B24           BB                   0001  mov	bx,*1
09587 2B27           8DBE       FDEA            lea	di,-$216[bp]
09588 2B2B           E8         D59D            call	lcmpul
09589 2B2E           76           1B            jbe 	.235
09590                       00002B30            .236:
09591                                           ! 1707             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09592                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
09593 2B30           FFB6       FDEA            push	-$216[bp]
09594                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09595 2B34           8A86       FDE5            mov	al,-$21B[bp]
09596 2B38           30E4                       xor	ah,ah
09597 2B3A           50                         push	ax
09598                                           ! Debug: list * char = .237+0 (used reg = )
09599 2B3B           BB                   D70D  mov	bx,#.237
09600 2B3E           53                         push	bx
09601                                           ! Debug: list int = const 2 (used reg = )
09602 2B3F           B8                   0002  mov	ax,*2
09603 2B42           50                         push	ax
09604                                           ! Debug: func () void = bios_printf+0 (used reg = )
09605 2B43           E8         DE61            call	_bios_printf
09606 2B46           83C4                   08  add	sp,*8
09607                                           !BCC_EOS
09608                                           ! 1708           else
09609                                           ! 1709             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09610 2B49           EB           2C            jmp .238
09611                       00002B4B            .235:
09612                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09613 2B4B           8B86       FDEA            mov	ax,-$216[bp]
09614 2B4F           8B9E       FDEC            mov	bx,-$214[bp]
09615 2B53           88E0                       mov	al,ah
09616 2B55           88DC                       mov	ah,bl
09617 2B57           88FB                       mov	bl,bh
09618 2B59           28FF                       sub	bh,bh
09619 2B5B           BF                   0002  mov	di,*2
09620 2B5E           E8         D5C8            call	lsrul
09621                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09622                                           ! Debug: list unsigned short = ax+0 (used reg = )
09623 2B61           50                         push	ax
09624                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09625 2B62           8A86       FDE5            mov	al,-$21B[bp]
09626 2B66           30E4                       xor	ah,ah
09627 2B68           50                         push	ax
09628                                           ! Debug: list * char = .239+0 (used reg = )
09629 2B69           BB                   D6ED  mov	bx,#.239
09630 2B6C           53                         push	bx
09631                                           ! Debug: list int = const 2 (used reg = )
09632 2B6D           B8                   0002  mov	ax,*2
09633 2B70           50                         push	ax
09634                                           ! Debug: func () void = bios_printf+0 (used reg = )
09635 2B71           E8         DE33            call	_bios_printf
09636 2B74           83C4                   08  add	sp,*8
09637                                           !BCC_EOS
09638                                           ! 1710           break;
09639                       00002B77            .238:
09640 2B77           E9         00F0            br 	.226
09641                                           !BCC_EOS
09642                                           ! 1711         case 0x03:
09643                                           ! 1712           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09644                       00002B7A            .23A:
09645 2B7A           8A86       FDF4            mov	al,-$20C[bp]
09646 2B7E           84C0                       test	al,al
09647 2B80           74           05            je  	.23E
09648                       00002B82            .23F:
09649 2B82           BB                   D6DB  mov	bx,#.23C
09650 2B85           EB           03            jmp .240
09651                       00002B87            .23E:
09652 2B87           BB                   D6D4  mov	bx,#.23D
09653                       00002B8A            .240:
09654                                           ! Debug: list * char = bx+0 (used reg = )
09655 2B8A           53                         push	bx
09656                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09657 2B8B           8A86       FDF5            mov	al,-$20B[bp]
09658 2B8F           30E4                       xor	ah,ah
09659 2B91           50                         push	ax
09660                                           ! Debug: list * char = .23B+0 (used reg = )
09661 2B92           BB                   D6E2  mov	bx,#.23B
09662 2B95           53                         push	bx
09663                                           ! Debug: list int = const 2 (used reg = )
09664 2B96           B8                   0002  mov	ax,*2
09665 2B99           50                         push	ax
09666                                           ! Debug: func () void = bios_printf+0 (used reg = )
09667 2B9A           E8         DE0A            call	_bios_printf
09668 2B9D           83C4                   08  add	sp,*8
09669                                           !BCC_EOS
09670                                           ! 1713           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09671                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09672 2BA0           30C0                       xor	al,al
09673 2BA2           8886       FDE6            mov	-$21A[bp],al
09674                                           !BCC_EOS
09675 2BA6           EB           15            jmp .242
09676                       00002BA8            .243:
09677                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09678 2BA8           8A86       FDE7            mov	al,-$219[bp]
09679 2BAC           30E4                       xor	ah,ah
09680 2BAE           50                         push	ax
09681                                           ! Debug: list * char = .244+0 (used reg = )
09682 2BAF           BB                   D6D1  mov	bx,#.244
09683 2BB2           53                         push	bx
09684                                           ! Debug: list int = const 2 (used reg = )
09685 2BB3           B8                   0002  mov	ax,*2
09686 2BB6           50                         push	ax
09687                                           ! Debug: func () void = bios_printf+0 (used reg = )
09688 2BB7           E8         DDED            call	_bios_printf
09689 2BBA           83C4                   06  add	sp,*6
09690                                           !BCC_EOS
09691                                           ! 1714           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].de
09692                       00002BBD            .242:
09693                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09694 2BBD           8A86       FDE6            mov	al,-$21A[bp]
09695 2BC1           40                         inc	ax
09696 2BC2           8886       FDE6            mov	-$21A[bp],al
09697                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09698 2BC6           48                         dec	ax
09699 2BC7           30E4                       xor	ah,ah
09700 2BC9           89EB                       mov	bx,bp
09701 2BCB           01C3                       add	bx,ax
09702                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09703                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09704 2BCD           81C3                 FDBC  add	bx,#-$244
09705 2BD1           53                         push	bx
09706                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09707 2BD2           E8         DA7C            call	_get_SS
09708                                           ! Debug: list unsigned short = ax+0 (used reg = )
09709 2BD5           50                         push	ax
09710                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09711 2BD6           E8         DA1F            call	_read_byte
09712 2BD9           83C4                   04  add	sp,*4
09713                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09714 2BDC           8886       FDE7            mov	-$219[bp],al
09715 2BE0           84C0                       test	al,al
09716 2BE2           75           C4            jne	.243
09717                       00002BE4            .245:
09718                       00002BE4            .241:
09719                                           ! 1714 vice)==0x05)
09720                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09721 2BE4           8A46         FB            mov	al,-5[bp]
09722 2BE7           30E4                       xor	ah,ah
09723 2BE9           B9                   001E  mov	cx,*$1E
09724 2BEC           F7E9                       imul	cx
09725 2BEE           89C3                       mov	bx,ax
09726                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09727                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09728 2BF0           81C3                 0143  add	bx,#$143
09729 2BF4           53                         push	bx
09730                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09731 2BF5           FF76         FE            push	-2[bp]
09732                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09733 2BF8           E8         D9FD            call	_read_byte
09734 2BFB           83C4                   04  add	sp,*4
09735                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
09736 2BFE           3C                     05  cmp	al,*5
09737 2C00           75           17            jne 	.246
09738                       00002C02            .247:
09739                                           ! 1715             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09740                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09741 2C02           8A86       FDE5            mov	al,-$21B[bp]
09742 2C06           30E4                       xor	ah,ah
09743 2C08           50                         push	ax
09744                                           ! Debug: list * char = .248+0 (used reg = )
09745 2C09           BB                   D6B7  mov	bx,#.248
09746 2C0C           53                         push	bx
09747                                           ! Debug: list int = const 2 (used reg = )
09748 2C0D           B8                   0002  mov	ax,*2
09749 2C10           50                         push	ax
09750                                           ! Debug: func () void = bios_printf+0 (used reg = )
09751 2C11           E8         DD93            call	_bios_printf
09752 2C14           83C4                   06  add	sp,*6
09753                                           !BCC_EOS
09754                                           ! 1716           else
09755                                           ! 1717             bios_printf(2, " ATAPI-%d Device\n",version);
09756 2C17           EB           15            jmp .249
09757                       00002C19            .246:
09758                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09759 2C19           8A86       FDE5            mov	al,-$21B[bp]
09760 2C1D           30E4                       xor	ah,ah
09761 2C1F           50                         push	ax
09762                                           ! Debug: list * char = .24A+0 (used reg = )
09763 2C20           BB                   D6A5  mov	bx,#.24A
09764 2C23           53                         push	bx
09765                                           ! Debug: list int = const 2 (used reg = )
09766 2C24           B8                   0002  mov	ax,*2
09767 2C27           50                         push	ax
09768                                           ! Debug: func () void = bios_printf+0 (used reg = )
09769 2C28           E8         DD7C            call	_bios_printf
09770 2C2B           83C4                   06  add	sp,*6
09771                                           !BCC_EOS
09772                                           ! 1718           break;
09773                       00002C2E            .249:
09774 2C2E           EB           3A            jmp .226
09775                                           !BCC_EOS
09776                                           ! 1719         case 0x01:
09777                                           ! 1720           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09778                       00002C30            .24B:
09779 2C30           8A86       FDF4            mov	al,-$20C[bp]
09780 2C34           84C0                       test	al,al
09781 2C36           74           05            je  	.24F
09782                       00002C38            .250:
09783 2C38           BB                   D684  mov	bx,#.24D
09784 2C3B           EB           03            jmp .251
09785                       00002C3D            .24F:
09786 2C3D           BB                   D67D  mov	bx,#.24E
09787                       00002C40            .251:
09788                                           ! Debug: list * char = bx+0 (used reg = )
09789 2C40           53                         push	bx
09790                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09791 2C41           8A86       FDF5            mov	al,-$20B[bp]
09792 2C45           30E4                       xor	ah,ah
09793 2C47           50                         push	ax
09794                                           ! Debug: list * char = .24C+0 (used reg = )
09795 2C48           BB                   D68B  mov	bx,#.24C
09796 2C4B           53                         push	bx
09797                                           ! Debug: list int = const 2 (used reg = )
09798 2C4C           B8                   0002  mov	ax,*2
09799 2C4F           50                         push	ax
09800                                           ! Debug: func () void = bios_printf+0 (used reg = )
09801 2C50           E8         DD54            call	_bios_printf
09802 2C53           83C4                   08  add	sp,*8
09803                                           !BCC_EOS
09804                                           ! 1721           break;
09805 2C56           EB           12            jmp .226
09806                                           !BCC_EOS
09807                                           ! 1722       }
09808                                           ! 1723     }
09809 2C58           EB           10            jmp .226
09810                       00002C5A            .228:
09811 2C5A           2C                     01  sub	al,*1
09812 2C5C           74           D2            je 	.24B
09813 2C5E           2C                     01  sub	al,*1
09814 2C60         0F84         FE54            beq 	.229
09815 2C64           2C                     01  sub	al,*1
09816 2C66         0F84         FF10            beq 	.23A
09817                       00002C6A            .226:
09818                       FFFFFDBA            ..FFFB	=	-$246
09819 2C6A           83C4                   32  add	sp,*$32
09820                                           ! 1724   }
09821 2C6D           83C4                   0C  add	sp,*$C
09822                                           ! 1725   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
09823                       00002C70            .1A1:
09824                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
09825 2C70           8A46         FB            mov	al,-5[bp]
09826 2C73           40                         inc	ax
09827 2C74           8846         FB            mov	-5[bp],al
09828                       00002C77            .1A2:
09829                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
09830 2C77           8A46         FB            mov	al,-5[bp]
09831 2C7A           3C                     08  cmp	al,*8
09832 2C7C         0F82         F252            blo 	.1A3
09833                       00002C80            .252:
09834                       00002C80            .1A0:
09835                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09836 2C80           8A46         FD            mov	al,-3[bp]
09837 2C83           30E4                       xor	ah,ah
09838 2C85           50                         push	ax
09839                                           ! Debug: list * unsigned char = const $232 (used reg = )
09840 2C86           B8                   0232  mov	ax,#$232
09841 2C89           50                         push	ax
09842                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09843 2C8A           FF76         FE            push	-2[bp]
09844                                           ! Debug: func () void = write_byte+0 (used reg = )
09845 2C8D           E8         D98E            call	_write_byte
09846 2C90           83C4                   06  add	sp,*6
09847                                           !BCC_EOS
09848                                           ! 1726   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
09849                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
09850 2C93           8A46         FC            mov	al,-4[bp]
09851 2C96           30E4                       xor	ah,ah
09852 2C98           50                         push	ax
09853                                           ! Debug: list * unsigned char = const $23B (used reg = )
09854 2C99           B8                   023B  mov	ax,#$23B
09855 2C9C           50                         push	ax
09856                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09857 2C9D           FF76         FE            push	-2[bp]
09858                                           ! Debug: func () void = write_byte+0 (used reg = )
09859 2CA0           E8         D97B            call	_write_byte
09860 2CA3           83C4                   06  add	sp,*6
09861                                           !BCC_EOS
09862                                           ! 1727   write_byte(0x40,0x75, hdcount);
09863                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09864 2CA6           8A46         FD            mov	al,-3[bp]
09865 2CA9           30E4                       xor	ah,ah
09866 2CAB           50                         push	ax
09867                                           ! Debug: list int = const $75 (used reg = )
09868 2CAC           B8                   0075  mov	ax,*$75
09869 2CAF           50                         push	ax
09870                                           ! Debug: list int = const $40 (used reg = )
09871 2CB0           B8                   0040  mov	ax,*$40
09872 2CB3           50                         push	ax
09873                                           ! Debug: func () void = write_byte+0 (used reg = )
09874 2CB4           E8         D967            call	_write_byte
09875 2CB7           83C4                   06  add	sp,*6
09876                                           !BCC_EOS
09877                                           ! 1728   bios_printf(2, "\n");
09878                                           ! Debug: list * char = .253+0 (used reg = )
09879 2CBA           BB                   D67B  mov	bx,#.253
09880 2CBD           53                         push	bx
09881                                           ! Debug: list int = const 2 (used reg = )
09882 2CBE           B8                   0002  mov	ax,*2
09883 2CC1           50                         push	ax
09884                                           ! Debug: func () void = bios_printf+0 (used reg = )
09885 2CC2           E8         DCE2            call	_bios_printf
09886 2CC5           83C4                   04  add	sp,*4
09887                                           !BCC_EOS
09888                                           ! 1729 }
09889 2CC8           89EC                       mov	sp,bp
09890 2CCA           5D                         pop	bp
09891 2CCB           C3                         ret
09892                                           ! 1730 void ata_reset(device)
09893                                           ! Register BX used in function ata_detect
09894                                           ! 1731 Bit16u device;
09895                                           export	_ata_reset
09896                       00002CCC            _ata_reset:
09897                                           !BCC_EOS
09898                                           ! 1732 {
09899                                           ! 1733   Bit16u ebda_seg=read_word(0x0040,0x000E);
09900 2CCC           55                         push	bp
09901 2CCD           89E5                       mov	bp,sp
09902 2CCF           4C                         dec	sp
09903 2CD0           4C                         dec	sp
09904                                           ! Debug: list int = const $E (used reg = )
09905 2CD1           B8                   000E  mov	ax,*$E
09906 2CD4           50                         push	ax
09907                                           ! Debug: list int = const $40 (used reg = )
09908 2CD5           B8                   0040  mov	ax,*$40
09909 2CD8           50                         push	ax
09910                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09911 2CD9           E8         D92F            call	_read_word
09912 2CDC           83C4                   04  add	sp,*4
09913                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
09914 2CDF           8946         FE            mov	-2[bp],ax
09915                                           !BCC_EOS
09916                                           ! 1734   Bit16u iobase1, iobase2;
09917                                           !BCC_EOS
09918                                           ! 1735   Bit8u channel, slave, sn, sc;
09919                                           !BCC_EOS
09920                                           ! 1736   Bit8u type;
09921                                           !BCC_EOS
09922                                           ! 1737   Bit16u max;
09923                                           !BCC_EOS
09924                                           ! 1738   channel = device / 2;
09925 2CE2           83C4                   F4  add	sp,*-$C
09926                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09927 2CE5           8B46         04            mov	ax,4[bp]
09928 2CE8           D1E8                       shr	ax,*1
09929                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
09930 2CEA           8846         F9            mov	-7[bp],al
09931                                           !BCC_EOS
09932                                           ! 1739   slave = device % 2;
09933                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09934 2CED           8B46         04            mov	ax,4[bp]
09935 2CF0           24                     01  and	al,*1
09936                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
09937 2CF2           8846         F8            mov	-8[bp],al
09938                                           !BCC_EOS
09939                                           ! 1740   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
09940                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09941 2CF5           8A46         F9            mov	al,-7[bp]
09942 2CF8           30E4                       xor	ah,ah
09943 2CFA           B1                     03  mov	cl,*3
09944 2CFC           D3E0                       shl	ax,cl
09945 2CFE           89C3                       mov	bx,ax
09946                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09947                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
09948 2D00           81C3                 0124  add	bx,#$124
09949 2D04           53                         push	bx
09950                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09951 2D05           FF76         FE            push	-2[bp]
09952                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09953 2D08           E8         D900            call	_read_word
09954 2D0B           83C4                   04  add	sp,*4
09955                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
09956 2D0E           8946         FC            mov	-4[bp],ax
09957                                           !BCC_EOS
09958                                           ! 1741   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
09959                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09960 2D11           8A46         F9            mov	al,-7[bp]
09961 2D14           30E4                       xor	ah,ah
09962 2D16           B1                     03  mov	cl,*3
09963 2D18           D3E0                       shl	ax,cl
09964 2D1A           89C3                       mov	bx,ax
09965                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09966                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
09967 2D1C           81C3                 0126  add	bx,#$126
09968 2D20           53                         push	bx
09969                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09970 2D21           FF76         FE            push	-2[bp]
09971                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09972 2D24           E8         D8E4            call	_read_word
09973 2D27           83C4                   04  add	sp,*4
09974                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
09975 2D2A           8946         FA            mov	-6[bp],ax
09976                                           !BCC_EOS
09977                                           ! 1742   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09978                                           ! Debug: list int = const $E (used reg = )
09979 2D2D           B8                   000E  mov	ax,*$E
09980 2D30           50                         push	ax
09981                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
09982 2D31           8B46         FA            mov	ax,-6[bp]
09983                                           ! Debug: list unsigned int = ax+6 (used reg = )
09984 2D34           05                   0006  add	ax,*6
09985 2D37           50                         push	ax
09986                                           ! Debug: func () void = outb+0 (used reg = )
09987 2D38           E8         D81D            call	_outb
09988 2D3B           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1743   await_ide(1, iobase1, 20);
09991                                           ! Debug: list int = const $14 (used reg = )
09992 2D3E           B8                   0014  mov	ax,*$14
09993 2D41           50                         push	ax
09994                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
09995 2D42           FF76         FC            push	-4[bp]
09996                                           ! Debug: list int = const 1 (used reg = )
09997 2D45           B8                   0001  mov	ax,*1
09998 2D48           50                         push	ax
09999                                           ! Debug: func () int = await_ide+0 (used reg = )
10000 2D49           E8         EED8            call	_await_ide
10001 2D4C           83C4                   06  add	sp,*6
10002                                           !BCC_EOS
10003                                           ! 1744   outb(iobase2+6, 0x08 | 0x02);
10004                                           ! Debug: list int = const $A (used reg = )
10005 2D4F           B8                   000A  mov	ax,*$A
10006 2D52           50                         push	ax
10007                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10008 2D53           8B46         FA            mov	ax,-6[bp]
10009                                           ! Debug: list unsigned int = ax+6 (used reg = )
10010 2D56           05                   0006  add	ax,*6
10011 2D59           50                         push	ax
10012                                           ! Debug: func () void = outb+0 (used reg = )
10013 2D5A           E8         D7FB            call	_outb
10014 2D5D           83C4                   04  add	sp,*4
10015                                           !BCC_EOS
10016                                           ! 1745   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
10017                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10018 2D60           8B46         04            mov	ax,4[bp]
10019 2D63           B9                   001E  mov	cx,*$1E
10020 2D66           F7E9                       imul	cx
10021 2D68           89C3                       mov	bx,ax
10022                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
10023                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
10024 2D6A           81C3                 0142  add	bx,#$142
10025 2D6E           53                         push	bx
10026                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10027 2D6F           FF76         FE            push	-2[bp]
10028                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10029 2D72           E8         D883            call	_read_byte
10030 2D75           83C4                   04  add	sp,*4
10031                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
10032 2D78           8846         F5            mov	-$B[bp],al
10033                                           !BCC_EOS
10034                                           ! 1746   if (type != 0x00) {
10035                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
10036 2D7B           8A46         F5            mov	al,-$B[bp]
10037 2D7E           84C0                       test	al,al
10038 2D80         0F84         0084            beq 	.254
10039                       00002D84            .255:
10040                                           ! 1747     outb(iobase1+6, slave?0xb0:0xa0);
10041 2D84           8A46         F8            mov	al,-8[bp]
10042 2D87           84C0                       test	al,al
10043 2D89           74           04            je  	.256
10044                       00002D8B            .257:
10045 2D8B           B0                     B0  mov	al,#$B0
10046 2D8D           EB           02            jmp .258
10047                       00002D8F            .256:
10048 2D8F           B0                     A0  mov	al,#$A0
10049                       00002D91            .258:
10050                                           ! Debug: list char = al+0 (used reg = )
10051 2D91           30E4                       xor	ah,ah
10052 2D93           50                         push	ax
10053                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10054 2D94           8B46         FC            mov	ax,-4[bp]
10055                                           ! Debug: list unsigned int = ax+6 (used reg = )
10056 2D97           05                   0006  add	ax,*6
10057 2D9A           50                         push	ax
10058                                           ! Debug: func () void = outb+0 (used reg = )
10059 2D9B           E8         D7BA            call	_outb
10060 2D9E           83C4                   04  add	sp,*4
10061                                           !BCC_EOS
10062                                           ! 1748     sc = inb(iobase1+2);
10063                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10064 2DA1           8B46         FC            mov	ax,-4[bp]
10065                                           ! Debug: list unsigned int = ax+2 (used reg = )
10066 2DA4           40                         inc	ax
10067 2DA5           40                         inc	ax
10068 2DA6           50                         push	ax
10069                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10070 2DA7           E8         D798            call	_inb
10071 2DAA           44                         inc	sp
10072 2DAB           44                         inc	sp
10073                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10074 2DAC           8846         F6            mov	-$A[bp],al
10075                                           !BCC_EOS
10076                                           ! 1749     sn = inb(iobase1+3);
10077                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10078 2DAF           8B46         FC            mov	ax,-4[bp]
10079                                           ! Debug: list unsigned int = ax+3 (used reg = )
10080 2DB2           05                   0003  add	ax,*3
10081 2DB5           50                         push	ax
10082                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10083 2DB6           E8         D789            call	_inb
10084 2DB9           44                         inc	sp
10085 2DBA           44                         inc	sp
10086                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10087 2DBB           8846         F7            mov	-9[bp],al
10088                                           !BCC_EOS
10089                                           ! 1750     if ( (sc==0x01) && (sn==0x01) ) {
10090                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10091 2DBE           8A46         F6            mov	al,-$A[bp]
10092 2DC1           3C                     01  cmp	al,*1
10093 2DC3           75           32            jne 	.259
10094                       00002DC5            .25B:
10095                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10096 2DC5           8A46         F7            mov	al,-9[bp]
10097 2DC8           3C                     01  cmp	al,*1
10098 2DCA           75           2B            jne 	.259
10099                       00002DCC            .25A:
10100                                           ! 1751       if (type == 0x02)
10101                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10102 2DCC           8A46         F5            mov	al,-$B[bp]
10103 2DCF           3C                     02  cmp	al,*2
10104 2DD1           75           13            jne 	.25C
10105                       00002DD3            .25D:
10106                                           ! 1752         await_ide(5, iobase1, 32000u);
10107                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10108 2DD3           B8                   7D00  mov	ax,#$7D00
10109 2DD6           50                         push	ax
10110                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10111 2DD7           FF76         FC            push	-4[bp]
10112                                           ! Debug: list int = const 5 (used reg = )
10113 2DDA           B8                   0005  mov	ax,*5
10114 2DDD           50                         push	ax
10115                                           ! Debug: func () int = await_ide+0 (used reg = )
10116 2DDE           E8         EE43            call	_await_ide
10117 2DE1           83C4                   06  add	sp,*6
10118                                           !BCC_EOS
10119                                           ! 1753       else
10120                                           ! 1754         await_ide(2, iobase1, 32000u);
10121 2DE4           EB           11            jmp .25E
10122                       00002DE6            .25C:
10123                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10124 2DE6           B8                   7D00  mov	ax,#$7D00
10125 2DE9           50                         push	ax
10126                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10127 2DEA           FF76         FC            push	-4[bp]
10128                                           ! Debug: list int = const 2 (used reg = )
10129 2DED           B8                   0002  mov	ax,*2
10130 2DF0           50                         push	ax
10131                                           ! Debug: func () int = await_ide+0 (used reg = )
10132 2DF1           E8         EE30            call	_await_ide
10133 2DF4           83C4                   06  add	sp,*6
10134                                           !BCC_EOS
10135                                           ! 1755     }
10136                       00002DF7            .25E:
10137                                           ! 1756     await_ide(2, iobase1, 32000u);
10138                       00002DF7            .259:
10139                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10140 2DF7           B8                   7D00  mov	ax,#$7D00
10141 2DFA           50                         push	ax
10142                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10143 2DFB           FF76         FC            push	-4[bp]
10144                                           ! Debug: list int = const 2 (used reg = )
10145 2DFE           B8                   0002  mov	ax,*2
10146 2E01           50                         push	ax
10147                                           ! Debug: func () int = await_ide+0 (used reg = )
10148 2E02           E8         EE1F            call	_await_ide
10149 2E05           83C4                   06  add	sp,*6
10150                                           !BCC_EOS
10151                                           ! 1757   }
10152                                           ! 1758   outb(iobase2+6, 0x08);
10153                       00002E08            .254:
10154                                           ! Debug: list int = const 8 (used reg = )
10155 2E08           B8                   0008  mov	ax,*8
10156 2E0B           50                         push	ax
10157                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10158 2E0C           8B46         FA            mov	ax,-6[bp]
10159                                           ! Debug: list unsigned int = ax+6 (used reg = )
10160 2E0F           05                   0006  add	ax,*6
10161 2E12           50                         push	ax
10162                                           ! Debug: func () void = outb+0 (used reg = )
10163 2E13           E8         D742            call	_outb
10164 2E16           83C4                   04  add	sp,*4
10165                                           !BCC_EOS
10166                                           ! 1759 }
10167 2E19           89EC                       mov	sp,bp
10168 2E1B           5D                         pop	bp
10169 2E1C           C3                         ret
10170                                           ! 1760 Bit16u ata_cmd_non_data()
10171                                           ! Register BX used in function ata_reset
10172                                           ! 1761 {return 0;}
10173                                           export	_ata_cmd_non_data
10174                       00002E1D            _ata_cmd_non_data:
10175 2E1D           55                         push	bp
10176 2E1E           89E5                       mov	bp,sp
10177 2E20           31C0                       xor	ax,ax
10178 2E22           5D                         pop	bp
10179 2E23           C3                         ret
10180                                           !BCC_EOS
10181                                           ! 1762 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10182                                           ! 1763 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10183                                           export	_ata_cmd_data_in
10184                       00002E24            _ata_cmd_data_in:
10185                                           !BCC_EOS
10186                                           ! 1764 Bit32u lba_low, lba_high;
10187                                           !BCC_EOS
10188                                           ! 1765 {
10189                                           ! 1766   Bit16u ebda_seg=read_word(0x0040,0x000E);
10190 2E24           55                         push	bp
10191 2E25           89E5                       mov	bp,sp
10192 2E27           4C                         dec	sp
10193 2E28           4C                         dec	sp
10194                                           ! Debug: list int = const $E (used reg = )
10195 2E29           B8                   000E  mov	ax,*$E
10196 2E2C           50                         push	ax
10197                                           ! Debug: list int = const $40 (used reg = )
10198 2E2D           B8                   0040  mov	ax,*$40
10199 2E30           50                         push	ax
10200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10201 2E31           E8         D7D7            call	_read_word
10202 2E34           83C4                   04  add	sp,*4
10203                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10204 2E37           8946         FE            mov	-2[bp],ax
10205                                           !BCC_EOS
10206                                           ! 1767   Bit16u iobase1, iobase2, blksize;
10207                                           !BCC_EOS
10208                                           ! 1768   Bit8u channel, slave;
10209                                           !BCC_EOS
10210                                           ! 1769   Bit8u status, current, mode;
10211                                           !BCC_EOS
10212                                           ! 1770   channel = device / 2;
10213 2E3A           83C4                   F4  add	sp,*-$C
10214                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10215 2E3D           8B46         04            mov	ax,4[bp]
10216 2E40           D1E8                       shr	ax,*1
10217                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10218 2E42           8846         F7            mov	-9[bp],al
10219                                           !BCC_EOS
10220                                           ! 1771   slave = device % 2;
10221                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10222 2E45           8B46         04            mov	ax,4[bp]
10223 2E48           24                     01  and	al,*1
10224                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10225 2E4A           8846         F6            mov	-$A[bp],al
10226                                           !BCC_EOS
10227                                           ! 1772   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10228                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10229 2E4D           8A46         F7            mov	al,-9[bp]
10230 2E50           30E4                       xor	ah,ah
10231 2E52           B1                     03  mov	cl,*3
10232 2E54           D3E0                       shl	ax,cl
10233 2E56           89C3                       mov	bx,ax
10234                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10235                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10236 2E58           81C3                 0124  add	bx,#$124
10237 2E5C           53                         push	bx
10238                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10239 2E5D           FF76         FE            push	-2[bp]
10240                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10241 2E60           E8         D7A8            call	_read_word
10242 2E63           83C4                   04  add	sp,*4
10243                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10244 2E66           8946         FC            mov	-4[bp],ax
10245                                           !BCC_EOS
10246                                           ! 1773   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10247                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10248 2E69           8A46         F7            mov	al,-9[bp]
10249 2E6C           30E4                       xor	ah,ah
10250 2E6E           B1                     03  mov	cl,*3
10251 2E70           D3E0                       shl	ax,cl
10252 2E72           89C3                       mov	bx,ax
10253                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10254                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10255 2E74           81C3                 0126  add	bx,#$126
10256 2E78           53                         push	bx
10257                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10258 2E79           FF76         FE            push	-2[bp]
10259                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10260 2E7C           E8         D78C            call	_read_word
10261 2E7F           83C4                   04  add	sp,*4
10262                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10263 2E82           8946         FA            mov	-6[bp],ax
10264                                           !BCC_EOS
10265                                           ! 1774   mode = read_byte(ebda_seg, &((ebda_data_t *) 0
10266                                           ! 1774 )->ata.devices[device].mode);
10267                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10268 2E85           8B46         04            mov	ax,4[bp]
10269 2E88           B9                   001E  mov	cx,*$1E
10270 2E8B           F7E9                       imul	cx
10271 2E8D           89C3                       mov	bx,ax
10272                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10273                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10274 2E8F           81C3                 0146  add	bx,#$146
10275 2E93           53                         push	bx
10276                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10277 2E94           FF76         FE            push	-2[bp]
10278                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10279 2E97           E8         D75E            call	_read_byte
10280 2E9A           83C4                   04  add	sp,*4
10281                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10282 2E9D           8846         F3            mov	-$D[bp],al
10283                                           !BCC_EOS
10284                                           ! 1775   blksize = 0x200;
10285                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10286 2EA0           B8                   0200  mov	ax,#$200
10287 2EA3           8946         F8            mov	-8[bp],ax
10288                                           !BCC_EOS
10289                                           ! 1776   if (mode == 0x01) blksize>>=2;
10290                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10291 2EA6           8A46         F3            mov	al,-$D[bp]
10292 2EA9           3C                     01  cmp	al,*1
10293 2EAB           75           0C            jne 	.25F
10294                       00002EAD            .260:
10295                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10296 2EAD           8B46         F8            mov	ax,-8[bp]
10297 2EB0           D1E8                       shr	ax,*1
10298 2EB2           D1E8                       shr	ax,*1
10299 2EB4           8946         F8            mov	-8[bp],ax
10300                                           !BCC_EOS
10301                                           ! 1777   else blksize>>=1;
10302 2EB7           EB           08            jmp .261
10303                       00002EB9            .25F:
10304                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10305 2EB9           8B46         F8            mov	ax,-8[bp]
10306 2EBC           D1E8                       shr	ax,*1
10307 2EBE           8946         F8            mov	-8[bp],ax
10308                                           !BCC_EOS
10309                                           ! 1778   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10310                       00002EC1            .261:
10311                                           ! Debug: list int = const 0 (used reg = )
10312 2EC1           31C0                       xor	ax,ax
10313 2EC3           50                         push	ax
10314                                           ! Debug: list * unsigned short = const $254 (used reg = )
10315 2EC4           B8                   0254  mov	ax,#$254
10316 2EC7           50                         push	ax
10317                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10318 2EC8           FF76         FE            push	-2[bp]
10319                                           ! Debug: func () void = write_word+0 (used reg = )
10320 2ECB           E8         D768            call	_write_word
10321 2ECE           83C4                   06  add	sp,*6
10322                                           !BCC_EOS
10323                                           ! 1779   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10324                                           ! Debug: list long = const 0 (used reg = )
10325 2ED1           31C0                       xor	ax,ax
10326 2ED3           31DB                       xor	bx,bx
10327 2ED5           53                         push	bx
10328 2ED6           50                         push	ax
10329                                           ! Debug: list * unsigned long = const $256 (used reg = )
10330 2ED7           B8                   0256  mov	ax,#$256
10331 2EDA           50                         push	ax
10332                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10333 2EDB           FF76         FE            push	-2[bp]
10334                                           ! Debug: func () void = write_dword+0 (used reg = )
10335 2EDE           E8         D1BA            call	_write_dword
10336 2EE1           83C4                   08  add	sp,*8
10337                                           !BCC_EOS
10338                                           ! 1780   current = 0;
10339                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10340 2EE4           30C0                       xor	al,al
10341 2EE6           8846         F4            mov	-$C[bp],al
10342                                           !BCC_EOS
10343                                           ! 1781   status = inb(iobase1 + 7);
10344                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10345 2EE9           8B46         FC            mov	ax,-4[bp]
10346                                           ! Debug: list unsigned int = ax+7 (used reg = )
10347 2EEC           05                   0007  add	ax,*7
10348 2EEF           50                         push	ax
10349                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10350 2EF0           E8         D64F            call	_inb
10351 2EF3           44                         inc	sp
10352 2EF4           44                         inc	sp
10353                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10354 2EF5           8846         F5            mov	-$B[bp],al
10355                                           !BCC_EOS
10356                                           ! 1782   if (status & 0x80) return 1;
10357                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10358 2EF8           8A46         F5            mov	al,-$B[bp]
10359 2EFB           24                     80  and	al,#$80
10360 2EFD           84C0                       test	al,al
10361 2EFF           74           07            je  	.262
10362                       00002F01            .263:
10363 2F01           B8                   0001  mov	ax,*1
10364 2F04           89EC                       mov	sp,bp
10365 2F06           5D                         pop	bp
10366 2F07           C3                         ret
10367                                           !BCC_EOS
10368                                           ! 1783   outb(iobase2 + 6, 0x08 | 0x02);
10369                       00002F08            .262:
10370                                           ! Debug: list int = const $A (used reg = )
10371 2F08           B8                   000A  mov	ax,*$A
10372 2F0B           50                         push	ax
10373                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10374 2F0C           8B46         FA            mov	ax,-6[bp]
10375                                           ! Debug: list unsigned int = ax+6 (used reg = )
10376 2F0F           05                   0006  add	ax,*6
10377 2F12           50                         push	ax
10378                                           ! Debug: func () void = outb+0 (used reg = )
10379 2F13           E8         D642            call	_outb
10380 2F16           83C4                   04  add	sp,*4
10381                                           !BCC_EOS
10382                                           ! 1784   if (sector == 0) {
10383                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10384 2F19           8B46         0E            mov	ax,$E[bp]
10385 2F1C           85C0                       test	ax,ax
10386 2F1E         0F85         0167            bne 	.264
10387                       00002F22            .265:
10388                                           ! 1785     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
10389                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10390 2F22           8B46         08            mov	ax,8[bp]
10391 2F25           3D                   0100  cmp	ax,#$100
10392 2F28           72           04            jb 	.26A
10393 2F2A           B0                     01  mov	al,*1
10394 2F2C           EB           02            jmp	.26B
10395                       00002F2E            .26A:
10396 2F2E           30C0                       xor	al,al
10397                       00002F30            .26B:
10398                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10399 2F30           30E4                       xor	ah,ah
10400 2F32           99                         cwd
10401 2F33           89D3                       mov	bx,dx
10402 2F35           E8         D1DC            call	ltstl
10403 2F38           75           32            jne 	.267
10404                       00002F3A            .269:
10405 2F3A           8B46         14            mov	ax,$14[bp]
10406 2F3D           8B5E         16            mov	bx,$16[bp]
10407 2F40           E8         D1D1            call	ltstl
10408 2F43           75           27            jne 	.267
10409                       00002F45            .268:
10410                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10411 2F45           8B46         08            mov	ax,8[bp]
10412 2F48           31DB                       xor	bx,bx
10413                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10414                                           ! Debug: expression subtree swapping
10415 2F4A           8D7E         10            lea	di,$10[bp]
10416 2F4D           E8         D173            call	laddul
10417                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10418 2F50           53                         push	bx
10419 2F51           50                         push	ax
10420 2F52           31C0                       xor	ax,ax
10421 2F54           BB                   1000  mov	bx,#$1000
10422 2F57           53                         push	bx
10423 2F58           50                         push	ax
10424 2F59           8B46         EE            mov	ax,-$12[bp]
10425 2F5C           8B5E         F0            mov	bx,-$10[bp]
10426 2F5F           8D7E         EA            lea	di,-$16[bp]
10427 2F62           E8         D166            call	lcmpul
10428 2F65           8D66         F2            lea	sp,-$E[bp]
10429 2F68         0F82         00BC            blo 	.266
10430                       00002F6C            .267:
10431                                           ! 1786       outb(iobase1 + 1, 0x00);
10432                                           ! Debug: list int = const 0 (used reg = )
10433 2F6C           31C0                       xor	ax,ax
10434 2F6E           50                         push	ax
10435                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10436 2F6F           8B46         FC            mov	ax,-4[bp]
10437                                           ! Debug: list unsigned int = ax+1 (used reg = )
10438 2F72           40                         inc	ax
10439 2F73           50                         push	ax
10440                                           ! Debug: func () void = outb+0 (used reg = )
10441 2F74           E8         D5E1            call	_outb
10442 2F77           83C4                   04  add	sp,*4
10443                                           !BCC_EOS
10444                                           ! 1787       outb(iobase1 + 2, (count >> 8) & 0xff);
10445                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10446 2F7A           8B46         08            mov	ax,8[bp]
10447 2F7D           88E0                       mov	al,ah
10448 2F7F           30E4                       xor	ah,ah
10449                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10450                                           ! Debug: list unsigned char = al+0 (used reg = )
10451 2F81           30E4                       xor	ah,ah
10452 2F83           50                         push	ax
10453                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10454 2F84           8B46         FC            mov	ax,-4[bp]
10455                                           ! Debug: list unsigned int = ax+2 (used reg = )
10456 2F87           40                         inc	ax
10457 2F88           40                         inc	ax
10458 2F89           50                         push	ax
10459                                           ! Debug: func () void = outb+0 (used reg = )
10460 2F8A           E8         D5CB            call	_outb
10461 2F8D           83C4                   04  add	sp,*4
10462                                           !BCC_EOS
10463                                           ! 1788       outb(iobase1 + 3, lba_low >> 24);
10464                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10465 2F90           8B46         10            mov	ax,$10[bp]
10466 2F93           8B5E         12            mov	bx,$12[bp]
10467 2F96           93                         xchg	bx,ax
10468 2F97           88E0                       mov	al,ah
10469 2F99           30E4                       xor	ah,ah
10470 2F9B           31DB                       xor	bx,bx
10471                                           ! Debug: list unsigned long = bx+0 (used reg = )
10472 2F9D           53                         push	bx
10473 2F9E           50                         push	ax
10474                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10475 2F9F           8B46         FC            mov	ax,-4[bp]
10476                                           ! Debug: list unsigned int = ax+3 (used reg = )
10477 2FA2           05                   0003  add	ax,*3
10478 2FA5           50                         push	ax
10479                                           ! Debug: func () void = outb+0 (used reg = )
10480 2FA6           E8         D5AF            call	_outb
10481 2FA9           83C4                   06  add	sp,*6
10482                                           !BCC_EOS
10483                                           ! 1789       outb(iobase1 + 4, lba_high & 0xff);
10484                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10485                                           ! Debug: expression subtree swapping
10486 2FAC           B8                   00FF  mov	ax,#$FF
10487 2FAF           31DB                       xor	bx,bx
10488 2FB1           8D7E         14            lea	di,$14[bp]
10489 2FB4           E8         D104            call	landul
10490                                           ! Debug: list unsigned long = bx+0 (used reg = )
10491 2FB7           53                         push	bx
10492 2FB8           50                         push	ax
10493                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10494 2FB9           8B46         FC            mov	ax,-4[bp]
10495                                           ! Debug: list unsigned int = ax+4 (used reg = )
10496 2FBC           05                   0004  add	ax,*4
10497 2FBF           50                         push	ax
10498                                           ! Debug: func () void = outb+0 (used reg = )
10499 2FC0           E8         D595            call	_outb
10500 2FC3           83C4                   06  add	sp,*6
10501                                           !BCC_EOS
10502                                           ! 1790       outb(iobase1 + 5, lba_high >> 8);
10503                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10504 2FC6           8B46         14            mov	ax,$14[bp]
10505 2FC9           8B5E         16            mov	bx,$16[bp]
10506 2FCC           88E0                       mov	al,ah
10507 2FCE           88DC                       mov	ah,bl
10508 2FD0           88FB                       mov	bl,bh
10509 2FD2           28FF                       sub	bh,bh
10510                                           ! Debug: list unsigned long = bx+0 (used reg = )
10511 2FD4           53                         push	bx
10512 2FD5           50                         push	ax
10513                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10514 2FD6           8B46         FC            mov	ax,-4[bp]
10515                                           ! Debug: list unsigned int = ax+5 (used reg = )
10516 2FD9           05                   0005  add	ax,*5
10517 2FDC           50                         push	ax
10518                                           ! Debug: func () void = outb+0 (used reg = )
10519 2FDD           E8         D578            call	_outb
10520 2FE0           83C4                   06  add	sp,*6
10521                                           !BCC_EOS
10522                                           ! 1791       command |= 0x04;
10523                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10524 2FE3           8B46         06            mov	ax,6[bp]
10525 2FE6           0C                     04  or	al,*4
10526 2FE8           8946         06            mov	6[bp],ax
10527                                           !BCC_EOS
10528                                           ! 1792       count &= (1UL << 8) - 1;
10529                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10530 2FEB           8B46         08            mov	ax,8[bp]
10531 2FEE           31DB                       xor	bx,bx
10532 2FF0           53                         push	bx
10533 2FF1           50                         push	ax
10534 2FF2           B8                   00FF  mov	ax,#$FF
10535 2FF5           31DB                       xor	bx,bx
10536 2FF7           53                         push	bx
10537 2FF8           50                         push	ax
10538 2FF9           8B46         EE            mov	ax,-$12[bp]
10539 2FFC           8B5E         F0            mov	bx,-$10[bp]
10540 2FFF           8D7E         EA            lea	di,-$16[bp]
10541 3002           E8         D0B6            call	landul
10542 3005           8946         08            mov	8[bp],ax
10543 3008           83C4                   08  add	sp,*8
10544                                           !BCC_EOS
10545                                           ! 1793       lba_low &= (1UL << 24) - 1;
10546                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10547 300B           B8                   FFFF  mov	ax,#$FFFF
10548 300E           BB                   00FF  mov	bx,#$FF
10549 3011           53                         push	bx
10550 3012           50                         push	ax
10551 3013           8B46         10            mov	ax,$10[bp]
10552 3016           8B5E         12            mov	bx,$12[bp]
10553 3019           8D7E         EE            lea	di,-$12[bp]
10554 301C           E8         D09C            call	landul
10555 301F           8946         10            mov	$10[bp],ax
10556 3022           895E         12            mov	$12[bp],bx
10557 3025           83C4                   04  add	sp,*4
10558                                           !BCC_EOS
10559                                           ! 1794     }
10560                                           ! 1795     sector = (Bit16u) (lba_low & 0x000000ffL);
10561                       00003028            .266:
10562                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10563                                           ! Debug: expression subtree swapping
10564 3028           B8                   00FF  mov	ax,#$FF
10565 302B           31DB                       xor	bx,bx
10566 302D           8D7E         10            lea	di,$10[bp]
10567 3030           E8         D088            call	landul
10568                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10569                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10570 3033           8946         0E            mov	$E[bp],ax
10571                                           !BCC_EOS
10572                                           ! 1796     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10573                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10574 3036           8B46         10            mov	ax,$10[bp]
10575 3039           8B5E         12            mov	bx,$12[bp]
10576 303C           88E0                       mov	al,ah
10577 303E           88DC                       mov	ah,bl
10578 3040           88FB                       mov	bl,bh
10579 3042           28FF                       sub	bh,bh
10580                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10581 3044           53                         push	bx
10582 3045           50                         push	ax
10583 3046           B8                   FFFF  mov	ax,#$FFFF
10584 3049           31DB                       xor	bx,bx
10585 304B           53                         push	bx
10586 304C           50                         push	ax
10587 304D           8B46         EE            mov	ax,-$12[bp]
10588 3050           8B5E         F0            mov	bx,-$10[bp]
10589 3053           8D7E         EA            lea	di,-$16[bp]
10590 3056           E8         D062            call	landul
10591 3059           83C4                   08  add	sp,*8
10592                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10593                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10594 305C           8946         0A            mov	$A[bp],ax
10595                                           !BCC_EOS
10596                                           ! 1797     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10597                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10598 305F           8B46         10            mov	ax,$10[bp]
10599 3062           8B5E         12            mov	bx,$12[bp]
10600 3065           93                         xchg	bx,ax
10601 3066           88E0                       mov	al,ah
10602 3068           30E4                       xor	ah,ah
10603 306A           31DB                       xor	bx,bx
10604                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10605 306C           53                         push	bx
10606 306D           50                         push	ax
10607 306E           B8                   000F  mov	ax,*$F
10608 3071           31DB                       xor	bx,bx
10609 3073           53                         push	bx
10610 3074           50                         push	ax
10611 3075           8B46         EE            mov	ax,-$12[bp]
10612 3078           8B5E         F0            mov	bx,-$10[bp]
10613 307B           8D7E         EA            lea	di,-$16[bp]
10614 307E           E8         D03A            call	landul
10615 3081           83C4                   08  add	sp,*8
10616                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10617                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10618 3084           0C                     40  or	al,*$40
10619                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10620 3086           8946         0C            mov	$C[bp],ax
10621                                           !BCC_EOS
10622                                           ! 1798   }
10623                                           ! 1799   outb(iobase1 + 1, 0x00);
10624                       00003089            .264:
10625                                           ! Debug: list int = const 0 (used reg = )
10626 3089           31C0                       xor	ax,ax
10627 308B           50                         push	ax
10628                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10629 308C           8B46         FC            mov	ax,-4[bp]
10630                                           ! Debug: list unsigned int = ax+1 (used reg = )
10631 308F           40                         inc	ax
10632 3090           50                         push	ax
10633                                           ! Debug: func () void = outb+0 (used reg = )
10634 3091           E8         D4C4            call	_outb
10635 3094           83C4                   04  add	sp,*4
10636                                           !BCC_EOS
10637                                           ! 1800   outb(iobase1 + 2, count);
10638                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10639 3097           FF76         08            push	8[bp]
10640                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10641 309A           8B46         FC            mov	ax,-4[bp]
10642                                           ! Debug: list unsigned int = ax+2 (used reg = )
10643 309D           40                         inc	ax
10644 309E           40                         inc	ax
10645 309F           50                         push	ax
10646                                           ! Debug: func () void = outb+0 (used reg = )
10647 30A0           E8         D4B5            call	_outb
10648 30A3           83C4                   04  add	sp,*4
10649                                           !BCC_EOS
10650                                           ! 1801   outb(iobase1 + 3, sector);
10651                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10652 30A6           FF76         0E            push	$E[bp]
10653                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10654 30A9           8B46         FC            mov	ax,-4[bp]
10655                                           ! Debug: list unsigned int = ax+3 (used reg = )
10656 30AC           05                   0003  add	ax,*3
10657 30AF           50                         push	ax
10658                                           ! Debug: func () void = outb+0 (used reg = )
10659 30B0           E8         D4A5            call	_outb
10660 30B3           83C4                   04  add	sp,*4
10661                                           !BCC_EOS
10662                                           ! 1802   outb(iobase1 + 4, cylinder & 0x00ff);
10663                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10664 30B6           8A46         0A            mov	al,$A[bp]
10665                                           ! Debug: list unsigned char = al+0 (used reg = )
10666 30B9           30E4                       xor	ah,ah
10667 30BB           50                         push	ax
10668                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10669 30BC           8B46         FC            mov	ax,-4[bp]
10670                                           ! Debug: list unsigned int = ax+4 (used reg = )
10671 30BF           05                   0004  add	ax,*4
10672 30C2           50                         push	ax
10673                                           ! Debug: func () void = outb+0 (used reg = )
10674 30C3           E8         D492            call	_outb
10675 30C6           83C4                   04  add	sp,*4
10676                                           !BCC_EOS
10677                                           ! 1803   outb(iobase1 + 5, cylinder >> 8);
10678                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10679 30C9           8B46         0A            mov	ax,$A[bp]
10680 30CC           88E0                       mov	al,ah
10681 30CE           30E4                       xor	ah,ah
10682                                           ! Debug: list unsigned int = ax+0 (used reg = )
10683 30D0           50                         push	ax
10684                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10685 30D1           8B46         FC            mov	ax,-4[bp]
10686                                           ! Debug: list unsigned int = ax+5 (used reg = )
10687 30D4           05                   0005  add	ax,*5
10688 30D7           50                         push	ax
10689                                           ! Debug: func () void = outb+0 (used reg = )
10690 30D8           E8         D47D            call	_outb
10691 30DB           83C4                   04  add	sp,*4
10692                                           !BCC_EOS
10693                                           ! 1804   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10694 30DE           8A46         F6            mov	al,-$A[bp]
10695 30E1           84C0                       test	al,al
10696 30E3           74           04            je  	.26D
10697                       000030E5            .26E:
10698 30E5           B0                     B0  mov	al,#$B0
10699 30E7           EB           02            jmp .26F
10700                       000030E9            .26D:
10701 30E9           B0                     A0  mov	al,#$A0
10702                       000030EB            .26F:
10703                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10704 30EB           0A46         0C            or	al,$C[bp]
10705                                           ! Debug: list unsigned char = al+0 (used reg = )
10706 30EE           30E4                       xor	ah,ah
10707 30F0           50                         push	ax
10708                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10709 30F1           8B46         FC            mov	ax,-4[bp]
10710                                           ! Debug: list unsigned int = ax+6 (used reg = )
10711 30F4           05                   0006  add	ax,*6
10712 30F7           50                         push	ax
10713                                           ! Debug: func () void = outb+0 (used reg = )
10714 30F8           E8         D45D            call	_outb
10715 30FB           83C4                   04  add	sp,*4
10716                                           !BCC_EOS
10717                                           ! 1805   outb(iobase1 + 7, command);
10718                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10719 30FE           FF76         06            push	6[bp]
10720                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10721 3101           8B46         FC            mov	ax,-4[bp]
10722                                           ! Debug: list unsigned int = ax+7 (used reg = )
10723 3104           05                   0007  add	ax,*7
10724 3107           50                         push	ax
10725                                           ! Debug: func () void = outb+0 (used reg = )
10726 3108           E8         D44D            call	_outb
10727 310B           83C4                   04  add	sp,*4
10728                                           !BCC_EOS
10729                                           ! 1806   await_ide(3, iobase1, 32000u);
10730                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10731 310E           B8                   7D00  mov	ax,#$7D00
10732 3111           50                         push	ax
10733                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10734 3112           FF76         FC            push	-4[bp]
10735                                           ! Debug: list int = const 3 (used reg = )
10736 3115           B8                   0003  mov	ax,*3
10737 3118           50                         push	ax
10738                                           ! Debug: func () int = await_ide+0 (used reg = )
10739 3119           E8         EB08            call	_await_ide
10740 311C           83C4                   06  add	sp,*6
10741                                           !BCC_EOS
10742                                           ! 1807   status = inb(iobase1 + 7);
10743                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10744 311F           8B46         FC            mov	ax,-4[bp]
10745                                           ! Debug: list unsigned int = ax+7 (used reg = )
10746 3122           05                   0007  add	ax,*7
10747 3125           50                         push	ax
10748                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10749 3126           E8         D419            call	_inb
10750 3129           44                         inc	sp
10751 312A           44                         inc	sp
10752                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10753 312B           8846         F5            mov	-$B[bp],al
10754                                           !BCC_EOS
10755                                           ! 1808   if (status & 0x01) {
10756                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10757 312E           8A46         F5            mov	al,-$B[bp]
10758 3131           24                     01  and	al,*1
10759 3133           84C0                       test	al,al
10760 3135           74           09            je  	.270
10761                       00003137            .271:
10762                                           ! 1809     ;
10763                                           !BCC_EOS
10764                                           ! 1810     return 2;
10765 3137           B8                   0002  mov	ax,*2
10766 313A           89EC                       mov	sp,bp
10767 313C           5D                         pop	bp
10768 313D           C3                         ret
10769                                           !BCC_EOS
10770                                           ! 1811   } else if ( !(status & 0x08) ) {
10771 313E           EB           10            jmp .272
10772                       00003140            .270:
10773                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10774 3140           8A46         F5            mov	al,-$B[bp]
10775 3143           24                     08  and	al,*8
10776 3145           84C0                       test	al,al
10777 3147           75           07            jne 	.273
10778                       00003149            .274:
10779                                           ! 1812     ;
10780                                           !BCC_EOS
10781                                           ! 1813     return 3;
10782 3149           B8                   0003  mov	ax,*3
10783 314C           89EC                       mov	sp,bp
10784 314E           5D                         pop	bp
10785 314F           C3                         ret
10786                                           !BCC_EOS
10787                                           ! 1814   }
10788                                           ! 1815 #asm
10789                       00003150            .273:
10790                       00003150            .272:
10791                                           !BCC_EOS
10792                                           !BCC_ASM
10793                       00000016            _ata_cmd_data_in.count	set	$16
10794                       00000008            .ata_cmd_data_in.count	set	8
10795                       00000026            _ata_cmd_data_in.segment	set	$26
10796                       00000018            .ata_cmd_data_in.segment	set	$18
10797                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10798                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10799                       00000005            _ata_cmd_data_in.channel	set	5
10800                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10801                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10802                       00000010            .ata_cmd_data_in.lba_low	set	$10
10803                       00000022            _ata_cmd_data_in.lba_high	set	$22
10804                       00000014            .ata_cmd_data_in.lba_high	set	$14
10805                       0000001C            _ata_cmd_data_in.sector	set	$1C
10806                       0000000E            .ata_cmd_data_in.sector	set	$E
10807                       00000006            _ata_cmd_data_in.blksize	set	6
10808                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10809                       0000001A            _ata_cmd_data_in.head	set	$1A
10810                       0000000C            .ata_cmd_data_in.head	set	$C
10811                       00000018            _ata_cmd_data_in.cylinder	set	$18
10812                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10813                       00000012            _ata_cmd_data_in.device	set	$12
10814                       00000004            .ata_cmd_data_in.device	set	4
10815                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10816                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10817                       00000003            _ata_cmd_data_in.status	set	3
10818                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10819                       00000002            _ata_cmd_data_in.current	set	2
10820                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10821                       00000014            _ata_cmd_data_in.command	set	$14
10822                       00000006            .ata_cmd_data_in.command	set	6
10823                       00000001            _ata_cmd_data_in.mode	set	1
10824                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10825                       00000008            _ata_cmd_data_in.iobase2	set	8
10826                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10827                       00000028            _ata_cmd_data_in.offset	set	$28
10828                       0000001A            .ata_cmd_data_in.offset	set	$1A
10829                       00000004            _ata_cmd_data_in.slave	set	4
10830                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10831 3150           FB                                 sti ;; enable higher priority interrupts
10832                                           ! 1817 endasm
10833                                           !BCC_ENDASM
10834                                           !BCC_EOS
10835                                           ! 1818   while (1) {
10836                       00003151            .277:
10837                                           ! 1819 #asm
10838                                           !BCC_EOS
10839                                           !BCC_ASM
10840                       00000016            _ata_cmd_data_in.count	set	$16
10841                       00000008            .ata_cmd_data_in.count	set	8
10842                       00000026            _ata_cmd_data_in.segment	set	$26
10843                       00000018            .ata_cmd_data_in.segment	set	$18
10844                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10845                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10846                       00000005            _ata_cmd_data_in.channel	set	5
10847                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10848                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10849                       00000010            .ata_cmd_data_in.lba_low	set	$10
10850                       00000022            _ata_cmd_data_in.lba_high	set	$22
10851                       00000014            .ata_cmd_data_in.lba_high	set	$14
10852                       0000001C            _ata_cmd_data_in.sector	set	$1C
10853                       0000000E            .ata_cmd_data_in.sector	set	$E
10854                       00000006            _ata_cmd_data_in.blksize	set	6
10855                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10856                       0000001A            _ata_cmd_data_in.head	set	$1A
10857                       0000000C            .ata_cmd_data_in.head	set	$C
10858                       00000018            _ata_cmd_data_in.cylinder	set	$18
10859                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10860                       00000012            _ata_cmd_data_in.device	set	$12
10861                       00000004            .ata_cmd_data_in.device	set	4
10862                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10863                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10864                       00000003            _ata_cmd_data_in.status	set	3
10865                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10866                       00000002            _ata_cmd_data_in.current	set	2
10867                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10868                       00000014            _ata_cmd_data_in.command	set	$14
10869                       00000006            .ata_cmd_data_in.command	set	6
10870                       00000001            _ata_cmd_data_in.mode	set	1
10871                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10872                       00000008            _ata_cmd_data_in.iobase2	set	8
10873                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10874                       00000028            _ata_cmd_data_in.offset	set	$28
10875                       0000001A            .ata_cmd_data_in.offset	set	$1A
10876                       00000004            _ata_cmd_data_in.slave	set	4
10877                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10878 3151           55                                 push bp
10879 3152           89E5                               mov bp, sp
10880 3154           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
10881 3157           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10882 315A           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10883                                                   ;; adjust if there will be an overrun. 2K max sector size
10884 315D           81FF                 F800          cmp di, #0xf800 ;;
10885 3161           76           07                    jbe ata_in_no_adjust
10886                       00003163            ata_in_adjust:
10887 3163           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10888 3167           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10889                       0000316A            ata_in_no_adjust:
10890 316A           8EC0                               mov es, ax ;; segment in es
10891 316C           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10892 316F           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10893 3172           80FC                   01          cmp ah, #0x01
10894 3175           74           04                    je ata_in_32
10895                       00003177            ata_in_16:
10896 3177           F3                                 rep
10897 3178           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10898 3179           EB           03                    jmp ata_in_done
10899                       0000317B            ata_in_32:
10900 317B           F3                                 rep
10901 317C     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10902                       0000317E            ata_in_done:
10903 317E           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
10904 3181           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
10905 3184           5D                                 pop bp
10906                                           ! 1848 endasm
10907                                           !BCC_ENDASM
10908                                           !BCC_EOS
10909                                           ! 1849     current++;
10910                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
10911 3185           8A46         F4            mov	al,-$C[bp]
10912 3188           40                         inc	ax
10913 3189           8846         F4            mov	-$C[bp],al
10914                                           !BCC_EOS
10915                                           ! 1850     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
10916                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
10917 318C           8A46         F4            mov	al,-$C[bp]
10918 318F           30E4                       xor	ah,ah
10919 3191           50                         push	ax
10920                                           ! Debug: list * unsigned short = const $254 (used reg = )
10921 3192           B8                   0254  mov	ax,#$254
10922 3195           50                         push	ax
10923                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10924 3196           FF76         FE            push	-2[bp]
10925                                           ! Debug: func () void = write_word+0 (used reg = )
10926 3199           E8         D49A            call	_write_word
10927 319C           83C4                   06  add	sp,*6
10928                                           !BCC_EOS
10929                                           ! 1851     count--;
10930                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
10931 319F           8B46         08            mov	ax,8[bp]
10932 31A2           48                         dec	ax
10933 31A3           8946         08            mov	8[bp],ax
10934                                           !BCC_EOS
10935                                           ! 1852     await_ide(2, iobase1, 32000u);
10936                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10937 31A6           B8                   7D00  mov	ax,#$7D00
10938 31A9           50                         push	ax
10939                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10940 31AA           FF76         FC            push	-4[bp]
10941                                           ! Debug: list int = const 2 (used reg = )
10942 31AD           B8                   0002  mov	ax,*2
10943 31B0           50                         push	ax
10944                                           ! Debug: func () int = await_ide+0 (used reg = )
10945 31B1           E8         EA70            call	_await_ide
10946 31B4           83C4                   06  add	sp,*6
10947                                           !BCC_EOS
10948                                           ! 1853     status = inb(iobase1 + 7);
10949                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10950 31B7           8B46         FC            mov	ax,-4[bp]
10951                                           ! Debug: list unsigned int = ax+7 (used reg = )
10952 31BA           05                   0007  add	ax,*7
10953 31BD           50                         push	ax
10954                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10955 31BE           E8         D381            call	_inb
10956 31C1           44                         inc	sp
10957 31C2           44                         inc	sp
10958                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10959 31C3           8846         F5            mov	-$B[bp],al
10960                                           !BCC_EOS
10961                                           ! 1854     if (count == 0) {
10962                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
10963 31C6           8B46         08            mov	ax,8[bp]
10964 31C9           85C0                       test	ax,ax
10965 31CB           75           14            jne 	.278
10966                       000031CD            .279:
10967                                           ! 1855       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10968                                           ! 1856           != 0x40 ) {
10969                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10970 31CD           8A46         F5            mov	al,-$B[bp]
10971 31D0           24                     C9  and	al,#$C9
10972                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10973 31D2           3C                     40  cmp	al,*$40
10974 31D4           74           07            je  	.27A
10975                       000031D6            .27B:
10976                                           ! 1857         ;
10977                                           !BCC_EOS
10978                                           ! 1858         return 4;
10979 31D6           B8                   0004  mov	ax,*4
10980 31D9           89EC                       mov	sp,bp
10981 31DB           5D                         pop	bp
10982 31DC           C3                         ret
10983                                           !BCC_EOS
10984                                           ! 1859       }
10985                                           ! 1860       break;
10986                       000031DD            .27A:
10987 31DD           EB           17            jmp .275
10988                                           !BCC_EOS
10989                                           ! 1861     }
10990                                           ! 1862     else {
10991 31DF           EB           12            jmp .27C
10992                       000031E1            .278:
10993                                           ! 1863       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10994                                           ! 1864           != (0x40 | 0x08) ) {
10995                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10996 31E1           8A46         F5            mov	al,-$B[bp]
10997 31E4           24                     C9  and	al,#$C9
10998                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10999 31E6           3C                     48  cmp	al,*$48
11000 31E8           74           07            je  	.27D
11001                       000031EA            .27E:
11002                                           ! 1865         ;
11003                                           !BCC_EOS
11004                                           ! 1866         return 5;
11005 31EA           B8                   0005  mov	ax,*5
11006 31ED           89EC                       mov	sp,bp
11007 31EF           5D                         pop	bp
11008 31F0           C3                         ret
11009                                           !BCC_EOS
11010                                           ! 1867       }
11011                                           ! 1868       continue;
11012                       000031F1            .27D:
11013 31F1           EB           00            jmp .276
11014                                           !BCC_EOS
11015                                           ! 1869     }
11016                                           ! 1870   }
11017                       000031F3            .27C:
11018                                           ! 1871   outb(iobase2+6, 0x08);
11019                       000031F3            .276:
11020 31F3           E9         FF5B            jmp	.277
11021                       000031F6            .27F:
11022                       000031F6            .275:
11023                                           ! Debug: list int = const 8 (used reg = )
11024 31F6           B8                   0008  mov	ax,*8
11025 31F9           50                         push	ax
11026                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11027 31FA           8B46         FA            mov	ax,-6[bp]
11028                                           ! Debug: list unsigned int = ax+6 (used reg = )
11029 31FD           05                   0006  add	ax,*6
11030 3200           50                         push	ax
11031                                           ! Debug: func () void = outb+0 (used reg = )
11032 3201           E8         D354            call	_outb
11033 3204           83C4                   04  add	sp,*4
11034                                           !BCC_EOS
11035                                           ! 1872   return 0;
11036 3207           31C0                       xor	ax,ax
11037 3209           89EC                       mov	sp,bp
11038 320B           5D                         pop	bp
11039 320C           C3                         ret
11040                                           !BCC_EOS
11041                                           ! 1873 }
11042                                           ! 1874 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
11043                                           ! Register BX used in function ata_cmd_data_in
11044                                           ! 1875 Bit16u device, command, count, cylinder, head, sector, segment, offset;
11045                                           export	_ata_cmd_data_out
11046                       0000320D            _ata_cmd_data_out:
11047                                           !BCC_EOS
11048                                           ! 1876 Bit32u lba_low, lba_high;
11049                                           !BCC_EOS
11050                                           ! 1877 {
11051                                           ! 1878   Bit16u ebda_seg=read_word(0x0040,0x000E);
11052 320D           55                         push	bp
11053 320E           89E5                       mov	bp,sp
11054 3210           4C                         dec	sp
11055 3211           4C                         dec	sp
11056                                           ! Debug: list int = const $E (used reg = )
11057 3212           B8                   000E  mov	ax,*$E
11058 3215           50                         push	ax
11059                                           ! Debug: list int = const $40 (used reg = )
11060 3216           B8                   0040  mov	ax,*$40
11061 3219           50                         push	ax
11062                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11063 321A           E8         D3EE            call	_read_word
11064 321D           83C4                   04  add	sp,*4
11065                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11066 3220           8946         FE            mov	-2[bp],ax
11067                                           !BCC_EOS
11068                                           ! 1879   Bit16u iobase1, iobase2, blksize;
11069                                           !BCC_EOS
11070                                           ! 1880   Bit8u channel, slave;
11071                                           !BCC_EOS
11072                                           ! 1881   Bit8u status, current, mode;
11073                                           !BCC_EOS
11074                                           ! 1882   channel = device / 2;
11075 3223           83C4                   F4  add	sp,*-$C
11076                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11077 3226           8B46         04            mov	ax,4[bp]
11078 3229           D1E8                       shr	ax,*1
11079                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
11080 322B           8846         F7            mov	-9[bp],al
11081                                           !BCC_EOS
11082                                           ! 1883   slave = device % 2;
11083                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11084 322E           8B46         04            mov	ax,4[bp]
11085 3231           24                     01  and	al,*1
11086                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11087 3233           8846         F6            mov	-$A[bp],al
11088                                           !BCC_EOS
11089                                           ! 1884   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11090                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11091 3236           8A46         F7            mov	al,-9[bp]
11092 3239           30E4                       xor	ah,ah
11093 323B           B1                     03  mov	cl,*3
11094 323D           D3E0                       shl	ax,cl
11095 323F           89C3                       mov	bx,ax
11096                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11097                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11098 3241           81C3                 0124  add	bx,#$124
11099 3245           53                         push	bx
11100                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11101 3246           FF76         FE            push	-2[bp]
11102                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11103 3249           E8         D3BF            call	_read_word
11104 324C           83C4                   04  add	sp,*4
11105                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11106 324F           8946         FC            mov	-4[bp],ax
11107                                           !BCC_EOS
11108                                           ! 1885   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11109                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11110 3252           8A46         F7            mov	al,-9[bp]
11111 3255           30E4                       xor	ah,ah
11112 3257           B1                     03  mov	cl,*3
11113 3259           D3E0                       shl	ax,cl
11114 325B           89C3                       mov	bx,ax
11115                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11116                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11117 325D           81C3                 0126  add	bx,#$126
11118 3261           53                         push	bx
11119                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11120 3262           FF76         FE            push	-2[bp]
11121                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11122 3265           E8         D3A3            call	_read_word
11123 3268           83C4                   04  add	sp,*4
11124                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11125 326B           8946         FA            mov	-6[bp],ax
11126                                           !BCC_EOS
11127                                           ! 1886   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11128                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11129 326E           8B46         04            mov	ax,4[bp]
11130 3271           B9                   001E  mov	cx,*$1E
11131 3274           F7E9                       imul	cx
11132 3276           89C3                       mov	bx,ax
11133                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11134                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11135 3278           81C3                 0146  add	bx,#$146
11136 327C           53                         push	bx
11137                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11138 327D           FF76         FE            push	-2[bp]
11139                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11140 3280           E8         D375            call	_read_byte
11141 3283           83C4                   04  add	sp,*4
11142                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11143 3286           8846         F3            mov	-$D[bp],al
11144                                           !BCC_EOS
11145                                           ! 1887   blksize = 0x200;
11146                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11147 3289           B8                   0200  mov	ax,#$200
11148 328C           8946         F8            mov	-8[bp],ax
11149                                           !BCC_EOS
11150                                           ! 1888   if (mode == 0x01) blksize>>=2;
11151                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11152 328F           8A46         F3            mov	al,-$D[bp]
11153 3292           3C                     01  cmp	al,*1
11154 3294           75           0C            jne 	.280
11155                       00003296            .281:
11156                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11157 3296           8B46         F8            mov	ax,-8[bp]
11158 3299           D1E8                       shr	ax,*1
11159 329B           D1E8                       shr	ax,*1
11160 329D           8946         F8            mov	-8[bp],ax
11161                                           !BCC_EOS
11162                                           ! 1889   else blksize>>=1;
11163 32A0           EB           08            jmp .282
11164                       000032A2            .280:
11165                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11166 32A2           8B46         F8            mov	ax,-8[bp]
11167 32A5           D1E8                       shr	ax,*1
11168 32A7           8946         F8            mov	-8[bp],ax
11169                                           !BCC_EOS
11170                                           ! 1890   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11171                       000032AA            .282:
11172                                           ! Debug: list int = const 0 (used reg = )
11173 32AA           31C0                       xor	ax,ax
11174 32AC           50                         push	ax
11175                                           ! Debug: list * unsigned short = const $254 (used reg = )
11176 32AD           B8                   0254  mov	ax,#$254
11177 32B0           50                         push	ax
11178                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11179 32B1           FF76         FE            push	-2[bp]
11180                                           ! Debug: func () void = write_word+0 (used reg = )
11181 32B4           E8         D37F            call	_write_word
11182 32B7           83C4                   06  add	sp,*6
11183                                           !BCC_EOS
11184                                           ! 1891   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11185                                           ! Debug: list long = const 0 (used reg = )
11186 32BA           31C0                       xor	ax,ax
11187 32BC           31DB                       xor	bx,bx
11188 32BE           53                         push	bx
11189 32BF           50                         push	ax
11190                                           ! Debug: list * unsigned long = const $256 (used reg = )
11191 32C0           B8                   0256  mov	ax,#$256
11192 32C3           50                         push	ax
11193                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11194 32C4           FF76         FE            push	-2[bp]
11195                                           ! Debug: func () void = write_dword+0 (used reg = )
11196 32C7           E8         CDD1            call	_write_dword
11197 32CA           83C4                   08  add	sp,*8
11198                                           !BCC_EOS
11199                                           ! 1892   current = 0;
11200                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11201 32CD           30C0                       xor	al,al
11202 32CF           8846         F4            mov	-$C[bp],al
11203                                           !BCC_EOS
11204                                           ! 1893   status = inb(iobase1 + 7);
11205                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11206 32D2           8B46         FC            mov	ax,-4[bp]
11207                                           ! Debug: list unsigned int = ax+7 (used reg = )
11208 32D5           05                   0007  add	ax,*7
11209 32D8           50                         push	ax
11210                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11211 32D9           E8         D266            call	_inb
11212 32DC           44                         inc	sp
11213 32DD           44                         inc	sp
11214                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11215 32DE           8846         F5            mov	-$B[bp],al
11216                                           !BCC_EOS
11217                                           ! 1894   if (status & 0x80) return 1;
11218                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11219 32E1           8A46         F5            mov	al,-$B[bp]
11220 32E4           24                     80  and	al,#$80
11221 32E6           84C0                       test	al,al
11222 32E8           74           07            je  	.283
11223                       000032EA            .284:
11224 32EA           B8                   0001  mov	ax,*1
11225 32ED           89EC                       mov	sp,bp
11226 32EF           5D                         pop	bp
11227 32F0           C3                         ret
11228                                           !BCC_EOS
11229                                           ! 1895   outb(iobase2 + 6, 0x08 | 0x02);
11230                       000032F1            .283:
11231                                           ! Debug: list int = const $A (used reg = )
11232 32F1           B8                   000A  mov	ax,*$A
11233 32F4           50                         push	ax
11234                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11235 32F5           8B46         FA            mov	ax,-6[bp]
11236                                           ! Debug: list unsigned int = ax+6 (used reg = )
11237 32F8           05                   0006  add	ax,*6
11238 32FB           50                         push	ax
11239                                           ! Debug: func () void = outb+0 (used reg = )
11240 32FC           E8         D259            call	_outb
11241 32FF           83C4                   04  add	sp,*4
11242                                           !BCC_EOS
11243                                           ! 1896   if (sector == 0) {
11244                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11245 3302           8B46         0E            mov	ax,$E[bp]
11246 3305           85C0                       test	ax,ax
11247 3307         0F85         0167            bne 	.285
11248                       0000330B            .286:
11249                                           ! 1897     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11250                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11251 330B           8B46         08            mov	ax,8[bp]
11252 330E           3D                   0100  cmp	ax,#$100
11253 3311           72           04            jb 	.28B
11254 3313           B0                     01  mov	al,*1
11255 3315           EB           02            jmp	.28C
11256                       00003317            .28B:
11257 3317           30C0                       xor	al,al
11258                       00003319            .28C:
11259                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11260 3319           30E4                       xor	ah,ah
11261 331B           99                         cwd
11262 331C           89D3                       mov	bx,dx
11263 331E           E8         CDF3            call	ltstl
11264 3321           75           32            jne 	.288
11265                       00003323            .28A:
11266 3323           8B46         14            mov	ax,$14[bp]
11267 3326           8B5E         16            mov	bx,$16[bp]
11268 3329           E8         CDE8            call	ltstl
11269 332C           75           27            jne 	.288
11270                       0000332E            .289:
11271                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11272 332E           8B46         08            mov	ax,8[bp]
11273 3331           31DB                       xor	bx,bx
11274                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11275                                           ! Debug: expression subtree swapping
11276 3333           8D7E         10            lea	di,$10[bp]
11277 3336           E8         CD8A            call	laddul
11278                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11279 3339           53                         push	bx
11280 333A           50                         push	ax
11281 333B           31C0                       xor	ax,ax
11282 333D           BB                   1000  mov	bx,#$1000
11283 3340           53                         push	bx
11284 3341           50                         push	ax
11285 3342           8B46         EE            mov	ax,-$12[bp]
11286 3345           8B5E         F0            mov	bx,-$10[bp]
11287 3348           8D7E         EA            lea	di,-$16[bp]
11288 334B           E8         CD7D            call	lcmpul
11289 334E           8D66         F2            lea	sp,-$E[bp]
11290 3351         0F82         00BC            blo 	.287
11291                       00003355            .288:
11292                                           ! 1898       outb(iobase1 + 1, 0x00);
11293                                           ! Debug: list int = const 0 (used reg = )
11294 3355           31C0                       xor	ax,ax
11295 3357           50                         push	ax
11296                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11297 3358           8B46         FC            mov	ax,-4[bp]
11298                                           ! Debug: list unsigned int = ax+1 (used reg = )
11299 335B           40                         inc	ax
11300 335C           50                         push	ax
11301                                           ! Debug: func () void = outb+0 (used reg = )
11302 335D           E8         D1F8            call	_outb
11303 3360           83C4                   04  add	sp,*4
11304                                           !BCC_EOS
11305                                           ! 1899       outb(iobase1 + 2, (count >> 8) & 0xff);
11306                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11307 3363           8B46         08            mov	ax,8[bp]
11308 3366           88E0                       mov	al,ah
11309 3368           30E4                       xor	ah,ah
11310                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11311                                           ! Debug: list unsigned char = al+0 (used reg = )
11312 336A           30E4                       xor	ah,ah
11313 336C           50                         push	ax
11314                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11315 336D           8B46         FC            mov	ax,-4[bp]
11316                                           ! Debug: list unsigned int = ax+2 (used reg = )
11317 3370           40                         inc	ax
11318 3371           40                         inc	ax
11319 3372           50                         push	ax
11320                                           ! Debug: func () void = outb+0 (used reg = )
11321 3373           E8         D1E2            call	_outb
11322 3376           83C4                   04  add	sp,*4
11323                                           !BCC_EOS
11324                                           ! 1900       outb(iobase1 + 3, lba_low >> 24);
11325                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11326 3379           8B46         10            mov	ax,$10[bp]
11327 337C           8B5E         12            mov	bx,$12[bp]
11328 337F           93                         xchg	bx,ax
11329 3380           88E0                       mov	al,ah
11330 3382           30E4                       xor	ah,ah
11331 3384           31DB                       xor	bx,bx
11332                                           ! Debug: list unsigned long = bx+0 (used reg = )
11333 3386           53                         push	bx
11334 3387           50                         push	ax
11335                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11336 3388           8B46         FC            mov	ax,-4[bp]
11337                                           ! Debug: list unsigned int = ax+3 (used reg = )
11338 338B           05                   0003  add	ax,*3
11339 338E           50                         push	ax
11340                                           ! Debug: func () void = outb+0 (used reg = )
11341 338F           E8         D1C6            call	_outb
11342 3392           83C4                   06  add	sp,*6
11343                                           !BCC_EOS
11344                                           ! 1901       outb(iobase1 + 4, lba_high & 0xff);
11345                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11346                                           ! Debug: expression subtree swapping
11347 3395           B8                   00FF  mov	ax,#$FF
11348 3398           31DB                       xor	bx,bx
11349 339A           8D7E         14            lea	di,$14[bp]
11350 339D           E8         CD1B            call	landul
11351                                           ! Debug: list unsigned long = bx+0 (used reg = )
11352 33A0           53                         push	bx
11353 33A1           50                         push	ax
11354                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11355 33A2           8B46         FC            mov	ax,-4[bp]
11356                                           ! Debug: list unsigned int = ax+4 (used reg = )
11357 33A5           05                   0004  add	ax,*4
11358 33A8           50                         push	ax
11359                                           ! Debug: func () void = outb+0 (used reg = )
11360 33A9           E8         D1AC            call	_outb
11361 33AC           83C4                   06  add	sp,*6
11362                                           !BCC_EOS
11363                                           ! 1902       outb(iobase1 + 5, l
11364                                           ! 1902 ba_high >> 8);
11365                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11366 33AF           8B46         14            mov	ax,$14[bp]
11367 33B2           8B5E         16            mov	bx,$16[bp]
11368 33B5           88E0                       mov	al,ah
11369 33B7           88DC                       mov	ah,bl
11370 33B9           88FB                       mov	bl,bh
11371 33BB           28FF                       sub	bh,bh
11372                                           ! Debug: list unsigned long = bx+0 (used reg = )
11373 33BD           53                         push	bx
11374 33BE           50                         push	ax
11375                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11376 33BF           8B46         FC            mov	ax,-4[bp]
11377                                           ! Debug: list unsigned int = ax+5 (used reg = )
11378 33C2           05                   0005  add	ax,*5
11379 33C5           50                         push	ax
11380                                           ! Debug: func () void = outb+0 (used reg = )
11381 33C6           E8         D18F            call	_outb
11382 33C9           83C4                   06  add	sp,*6
11383                                           !BCC_EOS
11384                                           ! 1903       command |= 0x04;
11385                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11386 33CC           8B46         06            mov	ax,6[bp]
11387 33CF           0C                     04  or	al,*4
11388 33D1           8946         06            mov	6[bp],ax
11389                                           !BCC_EOS
11390                                           ! 1904       count &= (1UL << 8) - 1;
11391                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11392 33D4           8B46         08            mov	ax,8[bp]
11393 33D7           31DB                       xor	bx,bx
11394 33D9           53                         push	bx
11395 33DA           50                         push	ax
11396 33DB           B8                   00FF  mov	ax,#$FF
11397 33DE           31DB                       xor	bx,bx
11398 33E0           53                         push	bx
11399 33E1           50                         push	ax
11400 33E2           8B46         EE            mov	ax,-$12[bp]
11401 33E5           8B5E         F0            mov	bx,-$10[bp]
11402 33E8           8D7E         EA            lea	di,-$16[bp]
11403 33EB           E8         CCCD            call	landul
11404 33EE           8946         08            mov	8[bp],ax
11405 33F1           83C4                   08  add	sp,*8
11406                                           !BCC_EOS
11407                                           ! 1905       lba_low &= (1UL << 24) - 1;
11408                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11409 33F4           B8                   FFFF  mov	ax,#$FFFF
11410 33F7           BB                   00FF  mov	bx,#$FF
11411 33FA           53                         push	bx
11412 33FB           50                         push	ax
11413 33FC           8B46         10            mov	ax,$10[bp]
11414 33FF           8B5E         12            mov	bx,$12[bp]
11415 3402           8D7E         EE            lea	di,-$12[bp]
11416 3405           E8         CCB3            call	landul
11417 3408           8946         10            mov	$10[bp],ax
11418 340B           895E         12            mov	$12[bp],bx
11419 340E           83C4                   04  add	sp,*4
11420                                           !BCC_EOS
11421                                           ! 1906     }
11422                                           ! 1907     sector = (Bit16u) (lba_low & 0x000000ffL);
11423                       00003411            .287:
11424                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11425                                           ! Debug: expression subtree swapping
11426 3411           B8                   00FF  mov	ax,#$FF
11427 3414           31DB                       xor	bx,bx
11428 3416           8D7E         10            lea	di,$10[bp]
11429 3419           E8         CC9F            call	landul
11430                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11431                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11432 341C           8946         0E            mov	$E[bp],ax
11433                                           !BCC_EOS
11434                                           ! 1908     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11435                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11436 341F           8B46         10            mov	ax,$10[bp]
11437 3422           8B5E         12            mov	bx,$12[bp]
11438 3425           88E0                       mov	al,ah
11439 3427           88DC                       mov	ah,bl
11440 3429           88FB                       mov	bl,bh
11441 342B           28FF                       sub	bh,bh
11442                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11443 342D           53                         push	bx
11444 342E           50                         push	ax
11445 342F           B8                   FFFF  mov	ax,#$FFFF
11446 3432           31DB                       xor	bx,bx
11447 3434           53                         push	bx
11448 3435           50                         push	ax
11449 3436           8B46         EE            mov	ax,-$12[bp]
11450 3439           8B5E         F0            mov	bx,-$10[bp]
11451 343C           8D7E         EA            lea	di,-$16[bp]
11452 343F           E8         CC79            call	landul
11453 3442           83C4                   08  add	sp,*8
11454                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11455                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11456 3445           8946         0A            mov	$A[bp],ax
11457                                           !BCC_EOS
11458                                           ! 1909     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11459                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11460 3448           8B46         10            mov	ax,$10[bp]
11461 344B           8B5E         12            mov	bx,$12[bp]
11462 344E           93                         xchg	bx,ax
11463 344F           88E0                       mov	al,ah
11464 3451           30E4                       xor	ah,ah
11465 3453           31DB                       xor	bx,bx
11466                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11467 3455           53                         push	bx
11468 3456           50                         push	ax
11469 3457           B8                   000F  mov	ax,*$F
11470 345A           31DB                       xor	bx,bx
11471 345C           53                         push	bx
11472 345D           50                         push	ax
11473 345E           8B46         EE            mov	ax,-$12[bp]
11474 3461           8B5E         F0            mov	bx,-$10[bp]
11475 3464           8D7E         EA            lea	di,-$16[bp]
11476 3467           E8         CC51            call	landul
11477 346A           83C4                   08  add	sp,*8
11478                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11479                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11480 346D           0C                     40  or	al,*$40
11481                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11482 346F           8946         0C            mov	$C[bp],ax
11483                                           !BCC_EOS
11484                                           ! 1910   }
11485                                           ! 1911   outb(iobase1 + 1, 0x00);
11486                       00003472            .285:
11487                                           ! Debug: list int = const 0 (used reg = )
11488 3472           31C0                       xor	ax,ax
11489 3474           50                         push	ax
11490                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11491 3475           8B46         FC            mov	ax,-4[bp]
11492                                           ! Debug: list unsigned int = ax+1 (used reg = )
11493 3478           40                         inc	ax
11494 3479           50                         push	ax
11495                                           ! Debug: func () void = outb+0 (used reg = )
11496 347A           E8         D0DB            call	_outb
11497 347D           83C4                   04  add	sp,*4
11498                                           !BCC_EOS
11499                                           ! 1912   outb(iobase1 + 2, count);
11500                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11501 3480           FF76         08            push	8[bp]
11502                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11503 3483           8B46         FC            mov	ax,-4[bp]
11504                                           ! Debug: list unsigned int = ax+2 (used reg = )
11505 3486           40                         inc	ax
11506 3487           40                         inc	ax
11507 3488           50                         push	ax
11508                                           ! Debug: func () void = outb+0 (used reg = )
11509 3489           E8         D0CC            call	_outb
11510 348C           83C4                   04  add	sp,*4
11511                                           !BCC_EOS
11512                                           ! 1913   outb(iobase1 + 3, sector);
11513                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11514 348F           FF76         0E            push	$E[bp]
11515                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11516 3492           8B46         FC            mov	ax,-4[bp]
11517                                           ! Debug: list unsigned int = ax+3 (used reg = )
11518 3495           05                   0003  add	ax,*3
11519 3498           50                         push	ax
11520                                           ! Debug: func () void = outb+0 (used reg = )
11521 3499           E8         D0BC            call	_outb
11522 349C           83C4                   04  add	sp,*4
11523                                           !BCC_EOS
11524                                           ! 1914   outb(iobase1 + 4, cylinder & 0x00ff);
11525                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11526 349F           8A46         0A            mov	al,$A[bp]
11527                                           ! Debug: list unsigned char = al+0 (used reg = )
11528 34A2           30E4                       xor	ah,ah
11529 34A4           50                         push	ax
11530                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11531 34A5           8B46         FC            mov	ax,-4[bp]
11532                                           ! Debug: list unsigned int = ax+4 (used reg = )
11533 34A8           05                   0004  add	ax,*4
11534 34AB           50                         push	ax
11535                                           ! Debug: func () void = outb+0 (used reg = )
11536 34AC           E8         D0A9            call	_outb
11537 34AF           83C4                   04  add	sp,*4
11538                                           !BCC_EOS
11539                                           ! 1915   outb(iobase1 + 5, cylinder >> 8);
11540                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11541 34B2           8B46         0A            mov	ax,$A[bp]
11542 34B5           88E0                       mov	al,ah
11543 34B7           30E4                       xor	ah,ah
11544                                           ! Debug: list unsigned int = ax+0 (used reg = )
11545 34B9           50                         push	ax
11546                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11547 34BA           8B46         FC            mov	ax,-4[bp]
11548                                           ! Debug: list unsigned int = ax+5 (used reg = )
11549 34BD           05                   0005  add	ax,*5
11550 34C0           50                         push	ax
11551                                           ! Debug: func () void = outb+0 (used reg = )
11552 34C1           E8         D094            call	_outb
11553 34C4           83C4                   04  add	sp,*4
11554                                           !BCC_EOS
11555                                           ! 1916   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11556 34C7           8A46         F6            mov	al,-$A[bp]
11557 34CA           84C0                       test	al,al
11558 34CC           74           04            je  	.28E
11559                       000034CE            .28F:
11560 34CE           B0                     B0  mov	al,#$B0
11561 34D0           EB           02            jmp .290
11562                       000034D2            .28E:
11563 34D2           B0                     A0  mov	al,#$A0
11564                       000034D4            .290:
11565                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11566 34D4           0A46         0C            or	al,$C[bp]
11567                                           ! Debug: list unsigned char = al+0 (used reg = )
11568 34D7           30E4                       xor	ah,ah
11569 34D9           50                         push	ax
11570                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11571 34DA           8B46         FC            mov	ax,-4[bp]
11572                                           ! Debug: list unsigned int = ax+6 (used reg = )
11573 34DD           05                   0006  add	ax,*6
11574 34E0           50                         push	ax
11575                                           ! Debug: func () void = outb+0 (used reg = )
11576 34E1           E8         D074            call	_outb
11577 34E4           83C4                   04  add	sp,*4
11578                                           !BCC_EOS
11579                                           ! 1917   outb(iobase1 + 7, command);
11580                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11581 34E7           FF76         06            push	6[bp]
11582                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11583 34EA           8B46         FC            mov	ax,-4[bp]
11584                                           ! Debug: list unsigned int = ax+7 (used reg = )
11585 34ED           05                   0007  add	ax,*7
11586 34F0           50                         push	ax
11587                                           ! Debug: func () void = outb+0 (used reg = )
11588 34F1           E8         D064            call	_outb
11589 34F4           83C4                   04  add	sp,*4
11590                                           !BCC_EOS
11591                                           ! 1918   await_ide(3, iobase1, 32000u);
11592                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11593 34F7           B8                   7D00  mov	ax,#$7D00
11594 34FA           50                         push	ax
11595                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11596 34FB           FF76         FC            push	-4[bp]
11597                                           ! Debug: list int = const 3 (used reg = )
11598 34FE           B8                   0003  mov	ax,*3
11599 3501           50                         push	ax
11600                                           ! Debug: func () int = await_ide+0 (used reg = )
11601 3502           E8         E71F            call	_await_ide
11602 3505           83C4                   06  add	sp,*6
11603                                           !BCC_EOS
11604                                           ! 1919   status = inb(iobase1 + 7);
11605                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11606 3508           8B46         FC            mov	ax,-4[bp]
11607                                           ! Debug: list unsigned int = ax+7 (used reg = )
11608 350B           05                   0007  add	ax,*7
11609 350E           50                         push	ax
11610                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11611 350F           E8         D030            call	_inb
11612 3512           44                         inc	sp
11613 3513           44                         inc	sp
11614                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11615 3514           8846         F5            mov	-$B[bp],al
11616                                           !BCC_EOS
11617                                           ! 1920   if (status & 0x01) {
11618                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11619 3517           8A46         F5            mov	al,-$B[bp]
11620 351A           24                     01  and	al,*1
11621 351C           84C0                       test	al,al
11622 351E           74           09            je  	.291
11623                       00003520            .292:
11624                                           ! 1921     ;
11625                                           !BCC_EOS
11626                                           ! 1922     return 2;
11627 3520           B8                   0002  mov	ax,*2
11628 3523           89EC                       mov	sp,bp
11629 3525           5D                         pop	bp
11630 3526           C3                         ret
11631                                           !BCC_EOS
11632                                           ! 1923   } else if ( !(status & 0x08) ) {
11633 3527           EB           10            jmp .293
11634                       00003529            .291:
11635                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11636 3529           8A46         F5            mov	al,-$B[bp]
11637 352C           24                     08  and	al,*8
11638 352E           84C0                       test	al,al
11639 3530           75           07            jne 	.294
11640                       00003532            .295:
11641                                           ! 1924     ;
11642                                           !BCC_EOS
11643                                           ! 1925     return 3;
11644 3532           B8                   0003  mov	ax,*3
11645 3535           89EC                       mov	sp,bp
11646 3537           5D                         pop	bp
11647 3538           C3                         ret
11648                                           !BCC_EOS
11649                                           ! 1926   }
11650                                           ! 1927 #asm
11651                       00003539            .294:
11652                       00003539            .293:
11653                                           !BCC_EOS
11654                                           !BCC_ASM
11655                       00000016            _ata_cmd_data_out.count	set	$16
11656                       00000008            .ata_cmd_data_out.count	set	8
11657                       00000026            _ata_cmd_data_out.segment	set	$26
11658                       00000018            .ata_cmd_data_out.segment	set	$18
11659                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11660                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11661                       00000005            _ata_cmd_data_out.channel	set	5
11662                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11663                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11664                       00000010            .ata_cmd_data_out.lba_low	set	$10
11665                       00000022            _ata_cmd_data_out.lba_high	set	$22
11666                       00000014            .ata_cmd_data_out.lba_high	set	$14
11667                       0000001C            _ata_cmd_data_out.sector	set	$1C
11668                       0000000E            .ata_cmd_data_out.sector	set	$E
11669                       00000006            _ata_cmd_data_out.blksize	set	6
11670                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11671                       0000001A            _ata_cmd_data_out.head	set	$1A
11672                       0000000C            .ata_cmd_data_out.head	set	$C
11673                       00000018            _ata_cmd_data_out.cylinder	set	$18
11674                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11675                       00000012            _ata_cmd_data_out.device	set	$12
11676                       00000004            .ata_cmd_data_out.device	set	4
11677                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11678                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11679                       00000003            _ata_cmd_data_out.status	set	3
11680                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11681                       00000002            _ata_cmd_data_out.current	set	2
11682                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11683                       00000014            _ata_cmd_data_out.command	set	$14
11684                       00000006            .ata_cmd_data_out.command	set	6
11685                       00000001            _ata_cmd_data_out.mode	set	1
11686                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11687                       00000008            _ata_cmd_data_out.iobase2	set	8
11688                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11689                       00000028            _ata_cmd_data_out.offset	set	$28
11690                       0000001A            .ata_cmd_data_out.offset	set	$1A
11691                       00000004            _ata_cmd_data_out.slave	set	4
11692                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11693 3539           FB                                 sti ;; enable higher priority interrupts
11694                                           ! 1929 endasm
11695                                           !BCC_ENDASM
11696                                           !BCC_EOS
11697                                           ! 1930   while (1) {
11698                       0000353A            .298:
11699                                           ! 1931 #asm
11700                                           !BCC_EOS
11701                                           !BCC_ASM
11702                       00000016            _ata_cmd_data_out.count	set	$16
11703                       00000008            .ata_cmd_data_out.count	set	8
11704                       00000026            _ata_cmd_data_out.segment	set	$26
11705                       00000018            .ata_cmd_data_out.segment	set	$18
11706                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11707                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11708                       00000005            _ata_cmd_data_out.channel	set	5
11709                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11710                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11711                       00000010            .ata_cmd_data_out.lba_low	set	$10
11712                       00000022            _ata_cmd_data_out.lba_high	set	$22
11713                       00000014            .ata_cmd_data_out.lba_high	set	$14
11714                       0000001C            _ata_cmd_data_out.sector	set	$1C
11715                       0000000E            .ata_cmd_data_out.sector	set	$E
11716                       00000006            _ata_cmd_data_out.blksize	set	6
11717                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11718                       0000001A            _ata_cmd_data_out.head	set	$1A
11719                       0000000C            .ata_cmd_data_out.head	set	$C
11720                       00000018            _ata_cmd_data_out.cylinder	set	$18
11721                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11722                       00000012            _ata_cmd_data_out.device	set	$12
11723                       00000004            .ata_cmd_data_out.device	set	4
11724                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11725                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11726                       00000003            _ata_cmd_data_out.status	set	3
11727                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11728                       00000002            _ata_cmd_data_out.current	set	2
11729                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11730                       00000014            _ata_cmd_data_out.command	set	$14
11731                       00000006            .ata_cmd_data_out.command	set	6
11732                       00000001            _ata_cmd_data_out.mode	set	1
11733                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11734                       00000008            _ata_cmd_data_out.iobase2	set	8
11735                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11736                       00000028            _ata_cmd_data_out.offset	set	$28
11737                       0000001A            .ata_cmd_data_out.offset	set	$1A
11738                       00000004            _ata_cmd_data_out.slave	set	4
11739                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11740 353A           55                                 push bp
11741 353B           89E5                               mov bp, sp
11742 353D           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
11743 3540           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
11744 3543           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
11745                                                   ;; adjust if there will be an overrun. 2K max sector size
11746 3546           81FE                 F800          cmp si, #0xf800 ;;
11747 354A           76           07                    jbe ata_out_no_adjust
11748                       0000354C            ata_out_adjust:
11749 354C           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
11750 3550           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11751                       00003553            ata_out_no_adjust:
11752 3553           8EC0                               mov es, ax ;; segment in es
11753 3555           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
11754 3558           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
11755 355B           80FC                   01          cmp ah, #0x01
11756 355E           74           05                    je ata_out_32
11757                       00003560            ata_out_16:
11758 3560           26                                 seg ES
11759 3561           F3                                 rep
11760 3562           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
11761 3563           EB           04                    jmp ata_out_done
11762                       00003565            ata_out_32:
11763 3565           26                                 seg ES
11764 3566           F3                                 rep
11765 3567     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
11766                       00003569            ata_out_done:
11767 3569           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
11768 356C           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
11769 356F           5D                                 pop bp
11770                                           ! 1962 endasm
11771                                           !BCC_ENDASM
11772                                           !BCC_EOS
11773                                           ! 1963     current++;
11774                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11775 3570           8A46         F4            mov	al,-$C[bp]
11776 3573           40                         inc	ax
11777 3574           8846         F4            mov	-$C[bp],al
11778                                           !BCC_EOS
11779                                           ! 1964     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11780                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11781 3577           8A46         F4            mov	al,-$C[bp]
11782 357A           30E4                       xor	ah,ah
11783 357C           50                         push	ax
11784                                           ! Debug: list * unsigned short = const $254 (used reg = )
11785 357D           B8                   0254  mov	ax,#$254
11786 3580           50                         push	ax
11787                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11788 3581           FF76         FE            push	-2[bp]
11789                                           ! Debug: func () void = write_word+0 (used reg = )
11790 3584           E8         D0AF            call	_write_word
11791 3587           83C4                   06  add	sp,*6
11792                                           !BCC_EOS
11793                                           ! 1965     count--;
11794                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11795 358A           8B46         08            mov	ax,8[bp]
11796 358D           48                         dec	ax
11797 358E           8946         08            mov	8[bp],ax
11798                                           !BCC_EOS
11799                                           ! 1966     status = inb(iobase1 + 7);
11800                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11801 3591           8B46         FC            mov	ax,-4[bp]
11802                                           ! Debug: list unsigned int = ax+7 (used reg = )
11803 3594           05                   0007  add	ax,*7
11804 3597           50                         push	ax
11805                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11806 3598           E8         CFA7            call	_inb
11807 359B           44                         inc	sp
11808 359C           44                         inc	sp
11809                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11810 359D           8846         F5            mov	-$B[bp],al
11811                                           !BCC_EOS
11812                                           ! 1967     if (count == 0) {
11813                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11814 35A0           8B46         08            mov	ax,8[bp]
11815 35A3           85C0                       test	ax,ax
11816 35A5           75           14            jne 	.299
11817                       000035A7            .29A:
11818                                           ! 1968       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11819                                           ! 1969           != 0x40 ) {
11820                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
11821 35A7           8A46         F5            mov	al,-$B[bp]
11822 35AA           24                     E9  and	al,#$E9
11823                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11824 35AC           3C                     40  cmp	al,*$40
11825 35AE           74           07            je  	.29B
11826                       000035B0            .29C:
11827                                           ! 1970         ;
11828                                           !BCC_EOS
11829                                           ! 1971         return 6;
11830 35B0           B8                   0006  mov	ax,*6
11831 35B3           89EC                       mov	sp,bp
11832 35B5           5D                         pop	bp
11833 35B6           C3                         ret
11834                                           !BCC_EOS
11835                                           ! 1972     
11836                                           ! 1972   }
11837                                           ! 1973       break;
11838                       000035B7            .29B:
11839 35B7           EB           17            jmp .296
11840                                           !BCC_EOS
11841                                           ! 1974     }
11842                                           ! 1975     else {
11843 35B9           EB           12            jmp .29D
11844                       000035BB            .299:
11845                                           ! 1976       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11846                                           ! 1977           != (0x40 | 0x08) ) {
11847                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11848 35BB           8A46         F5            mov	al,-$B[bp]
11849 35BE           24                     C9  and	al,#$C9
11850                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11851 35C0           3C                     48  cmp	al,*$48
11852 35C2           74           07            je  	.29E
11853                       000035C4            .29F:
11854                                           ! 1978         ;
11855                                           !BCC_EOS
11856                                           ! 1979         return 7;
11857 35C4           B8                   0007  mov	ax,*7
11858 35C7           89EC                       mov	sp,bp
11859 35C9           5D                         pop	bp
11860 35CA           C3                         ret
11861                                           !BCC_EOS
11862                                           ! 1980       }
11863                                           ! 1981       continue;
11864                       000035CB            .29E:
11865 35CB           EB           00            jmp .297
11866                                           !BCC_EOS
11867                                           ! 1982     }
11868                                           ! 1983   }
11869                       000035CD            .29D:
11870                                           ! 1984   outb(iobase2+6, 0x08);
11871                       000035CD            .297:
11872 35CD           E9         FF6A            jmp	.298
11873                       000035D0            .2A0:
11874                       000035D0            .296:
11875                                           ! Debug: list int = const 8 (used reg = )
11876 35D0           B8                   0008  mov	ax,*8
11877 35D3           50                         push	ax
11878                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11879 35D4           8B46         FA            mov	ax,-6[bp]
11880                                           ! Debug: list unsigned int = ax+6 (used reg = )
11881 35D7           05                   0006  add	ax,*6
11882 35DA           50                         push	ax
11883                                           ! Debug: func () void = outb+0 (used reg = )
11884 35DB           E8         CF7A            call	_outb
11885 35DE           83C4                   04  add	sp,*4
11886                                           !BCC_EOS
11887                                           ! 1985   return 0;
11888 35E1           31C0                       xor	ax,ax
11889 35E3           89EC                       mov	sp,bp
11890 35E5           5D                         pop	bp
11891 35E6           C3                         ret
11892                                           !BCC_EOS
11893                                           ! 1986 }
11894                                           ! 1987 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
11895                                           ! Register BX used in function ata_cmd_data_out
11896                                           ! 1988 Bit8u cmdlen,inout;
11897                                           export	_ata_cmd_packet
11898                       000035E7            _ata_cmd_packet:
11899                                           !BCC_EOS
11900                                           ! 1989 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
11901                                           !BCC_EOS
11902                                           ! 1990 Bit16u header;
11903                                           !BCC_EOS
11904                                           ! 1991 Bit32u length;
11905                                           !BCC_EOS
11906                                           ! 1992 {
11907                                           ! 1993   Bit16u ebda_seg=read_word(0x0040,0x000E);
11908 35E7           55                         push	bp
11909 35E8           89E5                       mov	bp,sp
11910 35EA           4C                         dec	sp
11911 35EB           4C                         dec	sp
11912                                           ! Debug: list int = const $E (used reg = )
11913 35EC           B8                   000E  mov	ax,*$E
11914 35EF           50                         push	ax
11915                                           ! Debug: list int = const $40 (used reg = )
11916 35F0           B8                   0040  mov	ax,*$40
11917 35F3           50                         push	ax
11918                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11919 35F4           E8         D014            call	_read_word
11920 35F7           83C4                   04  add	sp,*4
11921                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11922 35FA           8946         FE            mov	-2[bp],ax
11923                                           !BCC_EOS
11924                                           ! 1994   Bit16u iobase1, iobase2;
11925                                           !BCC_EOS
11926                                           ! 1995   Bit16u lcount, lbefore, lafter, count;
11927                                           !BCC_EOS
11928                                           ! 1996   Bit8u channel, slave;
11929                                           !BCC_EOS
11930                                           ! 1997   Bit8u status, mode, lmode;
11931                                           !BCC_EOS
11932                                           ! 1998   Bit32u total, transfer;
11933                                           !BCC_EOS
11934                                           ! 1999   channel = device / 2;
11935 35FD           83C4                   E6  add	sp,*-$1A
11936                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11937 3600           8B46         04            mov	ax,4[bp]
11938 3603           D1E8                       shr	ax,*1
11939                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
11940 3605           8846         F1            mov	-$F[bp],al
11941                                           !BCC_EOS
11942                                           ! 2000   slave = device % 2;
11943                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11944 3608           8B46         04            mov	ax,4[bp]
11945 360B           24                     01  and	al,*1
11946                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
11947 360D           8846         F0            mov	-$10[bp],al
11948                                           !BCC_EOS
11949                                           ! 2001   if (inout == 0x02) {
11950                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
11951 3610           8A46         12            mov	al,$12[bp]
11952 3613           3C                     02  cmp	al,*2
11953 3615           75           15            jne 	.2A1
11954                       00003617            .2A2:
11955                                           ! 2002     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
11956                                           ! Debug: list * char = .2A3+0 (used reg = )
11957 3617           BB                   D64F  mov	bx,#.2A3
11958 361A           53                         push	bx
11959                                           ! Debug: list int = const 4 (used reg = )
11960 361B           B8                   0004  mov	ax,*4
11961 361E           50                         push	ax
11962                                           ! Debug: func () void = bios_printf+0 (used reg = )
11963 361F           E8         D385            call	_bios_printf
11964 3622           83C4                   04  add	sp,*4
11965                                           !BCC_EOS
11966                                           ! 2003     return 1;
11967 3625           B8                   0001  mov	ax,*1
11968 3628           89EC                       mov	sp,bp
11969 362A           5D                         pop	bp
11970 362B           C3                         ret
11971                                           !BCC_EOS
11972                                           ! 2004   }
11973                                           ! 2005   if (header & 1) {
11974                       0000362C            .2A1:
11975                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
11976 362C           8A46         0C            mov	al,$C[bp]
11977 362F           24                     01  and	al,*1
11978 3631           84C0                       test	al,al
11979 3633           74           07            je  	.2A4
11980                       00003635            .2A5:
11981                                           ! 2006     ;
11982                                           !BCC_EOS
11983                                           ! 2007     return 1;
11984 3635           B8                   0001  mov	ax,*1
11985 3638           89EC                       mov	sp,bp
11986 363A           5D                         pop	bp
11987 363B           C3                         ret
11988                                           !BCC_EOS
11989                                           ! 2008   }
11990                                           ! 2009   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11991                       0000363C            .2A4:
11992                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11993 363C           8A46         F1            mov	al,-$F[bp]
11994 363F           30E4                       xor	ah,ah
11995 3641           B1                     03  mov	cl,*3
11996 3643           D3E0                       shl	ax,cl
11997 3645           89C3                       mov	bx,ax
11998                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11999                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
12000 3647           81C3                 0124  add	bx,#$124
12001 364B           53                         push	bx
12002                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12003 364C           FF76         FE            push	-2[bp]
12004                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12005 364F           E8         CFB9            call	_read_word
12006 3652           83C4                   04  add	sp,*4
12007                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12008 3655           8946         FC            mov	-4[bp],ax
12009                                           !BCC_EOS
12010                                           ! 2010   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
12011                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12012 3658           8A46         F1            mov	al,-$F[bp]
12013 365B           30E4                       xor	ah,ah
12014 365D           B1                     03  mov	cl,*3
12015 365F           D3E0                       shl	ax,cl
12016 3661           89C3                       mov	bx,ax
12017                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
12018                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
12019 3663           81C3                 0126  add	bx,#$126
12020 3667           53                         push	bx
12021                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12022 3668           FF76         FE            push	-2[bp]
12023                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12024 366B           E8         CF9D            call	_read_word
12025 366E           83C4                   04  add	sp,*4
12026                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
12027 3671           8946         FA            mov	-6[bp],ax
12028                                           !BCC_EOS
12029                                           ! 2011   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
12030                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
12031 3674           8B46         04            mov	ax,4[bp]
12032 3677           B9                   001E  mov	cx,*$1E
12033 367A           F7E9                       imul	cx
12034 367C           89C3                       mov	bx,ax
12035                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
12036                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
12037 367E           81C3                 0146  add	bx,#$146
12038 3682           53                         push	bx
12039                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12040 3683           FF76         FE            push	-2[bp]
12041                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12042 3686           E8         CF6F            call	_read_byte
12043 3689           83C4                   04  add	sp,*4
12044                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
12045 368C           8846         EE            mov	-$12[bp],al
12046                                           !BCC_EOS
12047                                           ! 2012   transfer= 0L;
12048                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
12049 368F           31C0                       xor	ax,ax
12050 3691           31DB                       xor	bx,bx
12051 3693           8946         E4            mov	-$1C[bp],ax
12052 3696           895E         E6            mov	-$1A[bp],bx
12053                                           !BCC_EOS
12054                                           ! 2013   if (cmdlen < 12) cmdlen=12;
12055                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12056 3699           8A46         06            mov	al,6[bp]
12057 369C           3C                     0C  cmp	al,*$C
12058 369E           73           05            jae 	.2A6
12059                       000036A0            .2A7:
12060                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12061 36A0           B0                     0C  mov	al,*$C
12062 36A2           8846         06            mov	6[bp],al
12063                                           !BCC_EOS
12064                                           ! 2014   if (cmdlen > 12) cmdlen=16;
12065                       000036A5            .2A6:
12066                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12067 36A5           8A46         06            mov	al,6[bp]
12068 36A8           3C                     0C  cmp	al,*$C
12069 36AA           76           05            jbe 	.2A8
12070                       000036AC            .2A9:
12071                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12072 36AC           B0                     10  mov	al,*$10
12073 36AE           8846         06            mov	6[bp],al
12074                                           !BCC_EOS
12075                                           ! 2015   cmdlen>>=1;
12076                       000036B1            .2A8:
12077                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12078 36B1           8A46         06            mov	al,6[bp]
12079 36B4           30E4                       xor	ah,ah
12080 36B6           D1E8                       shr	ax,*1
12081 36B8           8846         06            mov	6[bp],al
12082                                           !BCC_EOS
12083                                           ! 2016   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
12084                                           ! Debug: list int = const 0 (used reg = )
12085 36BB           31C0                       xor	ax,ax
12086 36BD           50                         push	ax
12087                                           ! Debug: list * unsigned short = const $254 (used reg = )
12088 36BE           B8                   0254  mov	ax,#$254
12089 36C1           50                         push	ax
12090                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
12091 36C2           FF76         FE            push	-2[bp]
12092                                           ! Debug: func () void = write_word+0 (used reg = )
12093 36C5           E8         CF6E            call	_write_word
12094 36C8           83C4                   06  add	sp,*6
12095                                           !BCC_EOS
12096                                           ! 2017   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
12097                                           ! Debug: list long = const 0 (used reg = )
12098 36CB           31C0                       xor	ax,ax
12099 36CD           31DB                       xor	bx,bx
12100 36CF           53                         push	bx
12101 36D0           50                         push	ax
12102                                           ! Debug: list * unsigned long = const $256 (used reg = )
12103 36D1           B8                   0256  mov	ax,#$256
12104 36D4           50                         push	ax
12105                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12106 36D5           FF76         FE            push	-2[bp]
12107                                           ! Debug: func () void = write_dword+0 (used reg = )
12108 36D8           E8         C9C0            call	_write_dword
12109 36DB           83C4                   08  add	sp,*8
12110                                           !BCC_EOS
12111                                           ! 2018   status = inb(iobase1 + 7);
12112                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12113 36DE           8B46         FC            mov	ax,-4[bp]
12114                                           ! Debug: list unsigned int = ax+7 (used reg = )
12115 36E1           05                   0007  add	ax,*7
12116 36E4           50                         push	ax
12117                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12118 36E5           E8         CE5A            call	_inb
12119 36E8           44                         inc	sp
12120 36E9           44                         inc	sp
12121                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12122 36EA           8846         EF            mov	-$11[bp],al
12123                                           !BCC_EOS
12124                                           ! 2019   if (status & 0x80) return 2;
12125                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12126 36ED           8A46         EF            mov	al,-$11[bp]
12127 36F0           24                     80  and	al,#$80
12128 36F2           84C0                       test	al,al
12129 36F4           74           07            je  	.2AA
12130                       000036F6            .2AB:
12131 36F6           B8                   0002  mov	ax,*2
12132 36F9           89EC                       mov	sp,bp
12133 36FB           5D                         pop	bp
12134 36FC           C3                         ret
12135                                           !BCC_EOS
12136                                           ! 2020   outb(iobase2 + 6, 0x08 | 0x02);
12137                       000036FD            .2AA:
12138                                           ! Debug: list int = const $A (used reg = )
12139 36FD           B8                   000A  mov	ax,*$A
12140 3700           50                         push	ax
12141                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12142 3701           8B46         FA            mov	ax,-6[bp]
12143                                           ! Debug: list unsigned int = ax+6 (used reg = )
12144 3704           05                   0006  add	ax,*6
12145 3707           50                         push	ax
12146                                           ! Debug: func () void = outb+0 (used reg = )
12147 3708           E8         CE4D            call	_outb
12148 370B           83C4                   04  add	sp,*4
12149                                           !BCC_EOS
12150                                           ! 2021   outb(iobase1 + 1, 0x00);
12151                                           ! Debug: list int = const 0 (used reg = )
12152 370E           31C0                       xor	ax,ax
12153 3710           50                         push	ax
12154                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12155 3711           8B46         FC            mov	ax,-4[bp]
12156                                           ! Debug: list unsigned int = ax+1 (used reg = )
12157 3714           40                         inc	ax
12158 3715           50                         push	ax
12159                                           ! Debug: func () void = outb+0 (used reg = )
12160 3716           E8         CE3F            call	_outb
12161 3719           83C4                   04  add	sp,*4
12162                                           !BCC_EOS
12163                                           ! 2022   outb(iobase1 + 2, 0x00);
12164                                           ! Debug: list int = const 0 (used reg = )
12165 371C           31C0                       xor	ax,ax
12166 371E           50                         push	ax
12167                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12168 371F           8B46         FC            mov	ax,-4[bp]
12169                                           ! Debug: list unsigned int = ax+2 (used reg = )
12170 3722           40                         inc	ax
12171 3723           40                         inc	ax
12172 3724           50                         push	ax
12173                                           ! Debug: func () void = outb+0 (used reg = )
12174 3725           E8         CE30            call	_outb
12175 3728           83C4                   04  add	sp,*4
12176                                           !BCC_EOS
12177                                           ! 2023   outb(iobase1 + 3, 0x00);
12178                                           ! Debug: list int = const 0 (used reg = )
12179 372B           31C0                       xor	ax,ax
12180 372D           50                         push	ax
12181                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12182 372E           8B46         FC            mov	ax,-4[bp]
12183                                           ! Debug: list unsigned int = ax+3 (used reg = )
12184 3731           05                   0003  add	ax,*3
12185 3734           50                         push	ax
12186                                           ! Debug: func () void = outb+0 (used reg = )
12187 3735           E8         CE20            call	_outb
12188 3738           83C4                   04  add	sp,*4
12189                                           !BCC_EOS
12190                                           ! 2024   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12191                                           ! Debug: list unsigned int = const $F0 (used reg = )
12192 373B           B8                   00F0  mov	ax,#$F0
12193 373E           50                         push	ax
12194                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12195 373F           8B46         FC            mov	ax,-4[bp]
12196                                           ! Debug: list unsigned int = ax+4 (used reg = )
12197 3742           05                   0004  add	ax,*4
12198 3745           50                         push	ax
12199                                           ! Debug: func () void = outb+0 (used reg = )
12200 3746           E8         CE0F            call	_outb
12201 3749           83C4                   04  add	sp,*4
12202                                           !BCC_EOS
12203                                           ! 2025   outb(iobase1 + 5, 0xfff0 >> 8);
12204                                           ! Debug: list unsigned int = const $FF (used reg = )
12205 374C           B8                   00FF  mov	ax,#$FF
12206 374F           50                         push	ax
12207                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12208 3750           8B46         FC            mov	ax,-4[bp]
12209                                           ! Debug: list unsigned int = ax+5 (used reg = )
12210 3753           05                   0005  add	ax,*5
12211 3756           50                         push	ax
12212                                           ! Debug: func () void = outb+0 (used reg = )
12213 3757           E8         CDFE            call	_outb
12214 375A           83C4                   04  add	sp,*4
12215                                           !BCC_EOS
12216                                           ! 2026   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12217 375D           8A46         F0            mov	al,-$10[bp]
12218 3760           84C0                       test	al,al
12219 3762           74           04            je  	.2AC
12220                       00003764            .2AD:
12221 3764           B0                     B0  mov	al,#$B0
12222 3766           EB           02            jmp .2AE
12223                       00003768            .2AC:
12224 3768           B0                     A0  mov	al,#$A0
12225                       0000376A            .2AE:
12226                                           ! Debug: list char = al+0 (used reg = )
12227 376A           30E4                       xor	ah,ah
12228 376C           50                         push	ax
12229                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12230 376D           8B46         FC            mov	ax,-4[bp]
12231                                           ! Debug: list unsigned int = ax+6 (used reg = )
12232 3770           05                   0006  add	ax,*6
12233 3773           50                         push	ax
12234                                           ! Debug: func () void = outb+0 (used reg = )
12235 3774           E8         CDE1            call	_outb
12236 3777           83C4                   04  add	sp,*4
12237                                           !BCC_EOS
12238                                           ! 2027   outb(iobase1 + 7, 0xA0);
12239                                           ! Debug: list int = const $A0 (used reg = )
12240 377A           B8                   00A0  mov	ax,#$A0
12241 377D           50                         push	ax
12242                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12243 377E           8B46         FC            mov	ax,-4[bp]
12244                                           ! Debug: list unsigned int = ax+7 (used reg = )
12245 3781           05                   0007  add	ax,*7
12246 3784           50                         push	ax
12247                                           ! Debug: func () void = outb+0 (used reg = )
12248 3785           E8         CDD0            call	_outb
12249 3788           83C4                   04  add	sp,*4
12250                                           !BCC_EOS
12251                                           ! 2028   await_ide(3, iobase1, 32000u);
12252                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12253 378B           B8                   7D00  mov	ax,#$7D00
12254 378E           50                         push	ax
12255                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12256 378F           FF76         FC            push	-4[bp]
12257                                           ! Debug: list int = const 3 (used reg = )
12258 3792           B8                   0003  mov	ax,*3
12259 3795           50                         push	ax
12260                                           ! Debug: func () int = await_ide+0 (used reg = )
12261 3796           E8         E48B            call	_await_ide
12262 3799           83C4                   06  add	sp,*6
12263                                           !BCC_EOS
12264                                           ! 2029   status = inb(iobase1 + 7);
12265                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12266 379C           8B46         FC            mov	ax,-4[bp]
12267                                           ! Debug: list unsigned int = ax+7 (used reg = )
12268 379F           05                   0007  add	ax,*7
12269 37A2           50                         push	ax
12270                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12271 37A3           E8         CD9C            call	_inb
12272 37A6           44                         inc	sp
12273 37A7           44                         inc	sp
12274                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12275 37A8           8846         EF            mov	-$11[bp],al
12276                                           !BCC_EOS
12277                                           ! 2030   if (status & 0x01) {
12278                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12279 37AB           8A46         EF            mov	al,-$11[bp]
12280 37AE           24                     01  and	al,*1
12281 37B0           84C0                       test	al,al
12282 37B2           74           09            je  	.2AF
12283                       000037B4            .2B0:
12284                                           ! 2031     ;
12285                                           !BCC_EOS
12286                                           ! 2032     return 3;
12287 37B4           B8                   0003  mov	ax,*3
12288 37B7           89EC                       mov	sp,bp
12289 37B9           5D                         pop	bp
12290 37BA           C3                         ret
12291                                           !BCC_EOS
12292                                           ! 2033   } else if ( !(status & 0x08) ) {
12293 37BB           EB           10            jmp .2B1
12294                       000037BD            .2AF:
12295                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12296 37BD           8A46         EF            mov	al,-$11[bp]
12297 37C0           24                     08  and	al,*8
12298 37C2           84C0                       test	al,al
12299 37C4           75           07            jne 	.2B2
12300                       000037C6            .2B3:
12301                                           ! 2034     ;
12302                                           !BCC_EOS
12303                                           ! 2035     return 4;
12304 37C6           B8                   0004  mov	ax,*4
12305 37C9           89EC                       mov	sp,bp
12306 37CB           5D                         pop	bp
12307 37CC           C3                         ret
12308                                           !BCC_EOS
12309                                           ! 2036   }
12310                                           ! 2037   cmdseg += (cmdoff / 16);
12311                       000037CD            .2B2:
12312                       000037CD            .2B1:
12313                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12314 37CD           8B46         0A            mov	ax,$A[bp]
12315 37D0           B1                     04  mov	cl,*4
12316 37D2           D3E8                       shr	ax,cl
12317                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12318 37D4           0346         08            add	ax,8[bp]
12319 37D7           8946         08            mov	8[bp],ax
12320                                           !BCC_EOS
12321                                           ! 2038   cmdoff %= 16;
12322                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12323 37DA           8B46         0A            mov	ax,$A[bp]
12324 37DD           24                     0F  and	al,*$F
12325 37DF           30E4                       xor	ah,ah
12326 37E1           8946         0A            mov	$A[bp],ax
12327                                           !BCC_EOS
12328                                           ! 2039 #asm
12329                                           !BCC_EOS
12330                                           !BCC_ASM
12331                       00000026            _ata_cmd_packet.cmdoff	set	$26
12332                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12333                       00000028            _ata_cmd_packet.header	set	$28
12334                       0000000C            .ata_cmd_packet.header	set	$C
12335                       0000000E            _ata_cmd_packet.count	set	$E
12336                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12337                       00000010            _ata_cmd_packet.lafter	set	$10
12338                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12339                       00000018            _ata_cmd_packet.iobase1	set	$18
12340                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12341                       0000000D            _ata_cmd_packet.channel	set	$D
12342                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12343                       00000024            _ata_cmd_packet.cmdseg	set	$24
12344                       00000008            .ata_cmd_packet.cmdseg	set	8
12345                       00000022            _ata_cmd_packet.cmdlen	set	$22
12346                       00000006            .ata_cmd_packet.cmdlen	set	6
12347                       00000009            _ata_cmd_packet.lmode	set	9
12348                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12349                       00000020            _ata_cmd_packet.device	set	$20
12350                       00000004            .ata_cmd_packet.device	set	4
12351                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12352                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12353                       00000014            _ata_cmd_packet.lcount	set	$14
12354                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12355                       00000004            _ata_cmd_packet.total	set	4
12356                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12357                       0000000B            _ata_cmd_packet.status	set	$B
12358                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12359                       0000000A            _ata_cmd_packet.mode	set	$A
12360                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12361                       00000032            _ata_cmd_packet.bufoff	set	$32
12362                       00000016            .ata_cmd_packet.bufoff	set	$16
12363                       00000000            _ata_cmd_packet.transfer	set	0
12364                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12365                       00000016            _ata_cmd_packet.iobase2	set	$16
12366                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12367                       00000012            _ata_cmd_packet.lbefore	set	$12
12368                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12369                       00000030            _ata_cmd_packet.bufseg	set	$30
12370                       00000014            .ata_cmd_packet.bufseg	set	$14
12371                       0000000C            _ata_cmd_packet.slave	set	$C
12372                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12373                       0000002E            _ata_cmd_packet.inout	set	$2E
12374                       00000012            .ata_cmd_packet.inout	set	$12
12375                       0000002A            _ata_cmd_packet.length	set	$2A
12376                       0000000E            .ata_cmd_packet.length	set	$E
12377 37E4           FB                               sti ;; enable higher priority interrupts
12378 37E5           55                               push bp
12379 37E6           89E5                             mov bp, sp
12380 37E8           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12381 37EB           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12382 37EE           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12383 37F1           8EC0                             mov es, ax ;; segment in es
12384 37F3           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12385 37F6           26                               seg ES
12386 37F7           F3                               rep
12387 37F8           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12388 37F9           5D                               pop bp
12389                                           ! 2052 endasm
12390                                           !BCC_ENDASM
12391                                           !BCC_EOS
12392                                           ! 2053   if (inout == 0x00) {
12393                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12394 37FA           8A46         12            mov	al,$12[bp]
12395 37FD           84C0                       test	al,al
12396 37FF           75           23            jne 	.2B4
12397                       00003801            .2B5:
12398                                           ! 2054     await_ide(2, iobase1, 32000u);
12399                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12400 3801           B8                   7D00  mov	ax,#$7D00
12401 3804           50                         push	ax
12402                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12403 3805           FF76         FC            push	-4[bp]
12404                                           ! Debug: list int = const 2 (used reg = )
12405 3808           B8                   0002  mov	ax,*2
12406 380B           50                         push	ax
12407                                           ! Debug: func () int = await_ide+0 (used reg = )
12408 380C           E8         E415            call	_await_ide
12409 380F           83C4                   06  add	sp,*6
12410                                           !BCC_EOS
12411                                           ! 2055     status = inb(iobase1 + 7);
12412                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12413 3812           8B46         FC            mov	ax,-4[bp]
12414                                           ! Debug: list unsigned int = ax+7 (used reg = )
12415 3815           05                   0007  add	ax,*7
12416 3818           50                         push	ax
12417                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12418 3819           E8         CD26            call	_inb
12419 381C           44                         inc	sp
12420 381D           44                         inc	sp
12421                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12422 381E           8846         EF            mov	-$11[bp],al
12423                                           !BCC_EOS
12424                                           ! 2056   }
12425                                           ! 2057   else {
12426 3821           E9         027B            br 	.2B6
12427                       00003824            .2B4:
12428                                           ! 2058     Bit16u loops = 0;
12429 3824           4C                         dec	sp
12430 3825           4C                         dec	sp
12431                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12432 3826           31C0                       xor	ax,ax
12433 3828           8946         E2            mov	-$1E[bp],ax
12434                                           !BCC_EOS
12435                                           ! 2059     Bit8u sc;
12436                                           !BCC_EOS
12437                                           ! 2060     while (1) {
12438 382B           4C                         dec	sp
12439 382C           4C                         dec	sp
12440                       0000382D            .2B9:
12441                                           ! 2061       if (loops == 0) {
12442                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12443 382D           8B46         E2            mov	ax,-$1E[bp]
12444 3830           85C0                       test	ax,ax
12445 3832           75           22            jne 	.2BA
12446                       00003834            .2BB:
12447                                           ! 2062         status = inb(iobase2 + 6);
12448                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12449 3834           8B46         FA            mov	ax,-6[bp]
12450                                           ! Debug: list unsigned int = ax+6 (used reg = )
12451 3837           05                   0006  add	ax,*6
12452 383A           50                         push	ax
12453                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12454 383B           E8         CD04            call	_inb
12455 383E           44                         inc	sp
12456 383F           44                         inc	sp
12457                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12458 3840           8846         EF            mov	-$11[bp],al
12459                                           !BCC_EOS
12460                                           ! 2063         await_ide(3, iobase1, 32000u);
12461                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12462 3843           B8                   7D00  mov	ax,#$7D00
12463 3846           50                         push	ax
12464                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12465 3847           FF76         FC            push	-4[bp]
12466                                           ! Debug: list int = const 3 (used reg = )
12467 384A           B8                   0003  mov	ax,*3
12468 384D           50                         push	ax
12469                                           ! Debug: func () int = await_ide+0 (used reg = )
12470 384E           E8         E3D3            call	_await_ide
12471 3851           83C4                   06  add	sp,*6
12472                                           !BCC_EOS
12473                                           ! 2064       }
12474                                           ! 2065       else
12475                                           ! 2066         await_ide(2, iobase1, 32000u);
12476 3854           EB           11            jmp .2BC
12477                       00003856            .2BA:
12478                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12479 3856           B8                   7D00  mov	ax,#$7D00
12480 3859           50                         push	ax
12481                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12482 385A           FF76         FC            push	-4[bp]
12483                                           ! Debug: list int = const 2 (used reg = )
12484 385D           B8                   0002  mov	ax,*2
12485 3860           50                         push	ax
12486                                           ! Debug: func () int = await_ide+0 (used reg = )
12487 3861           E8         E3C0            call	_await_ide
12488 3864           83C4                   06  add	sp,*6
12489                                           !BCC_EOS
12490                                           ! 2067       loops++;
12491                       00003867            .2BC:
12492                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12493 3867           8B46         E2            mov	ax,-$1E[bp]
12494 386A           40                         inc	ax
12495 386B           8946         E2            mov	-$1E[bp],ax
12496                                           !BCC_EOS
12497                                           ! 2068       status = inb(iobase1 + 7);
12498                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-6] (used reg = )
12499 386E           8B46         FC            mov	ax,-4[bp]
12500                                           ! Debug: list unsigned int = ax+7 (used reg = )
12501 3871           05                   0007  add	ax,*7
12502 3874           50                         push	ax
12503                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12504 3875           E8         CCCA            call	_inb
12505 3878           44                         inc	sp
12506 3879           44                         inc	sp
12507                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12508 387A           8846         EF            mov	-$11[bp],al
12509                                           !BCC_EOS
12510                                           ! 2069       sc = inb(iobase1 + 2);
12511                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12512 387D           8B46         FC            mov	ax,-4[bp]
12513                                           ! Debug: list unsigned int = ax+2 (used reg = )
12514 3880           40                         inc	ax
12515 3881           40                         inc	ax
12516 3882           50                         push	ax
12517                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12518 3883           E8         CCBC            call	_inb
12519 3886           44                         inc	sp
12520 3887           44                         inc	sp
12521                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12522 3888           8846         E1            mov	-$1F[bp],al
12523                                           !BCC_EOS
12524                                           ! 2070       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12525                                           ! 2071          ((status & (0x40 | 0x01)) == 0x40)) break;
12526                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12527 388B           8B46         FC            mov	ax,-4[bp]
12528                                           ! Debug: list unsigned int = ax+2 (used reg = )
12529 388E           40                         inc	ax
12530 388F           40                         inc	ax
12531 3890           50                         push	ax
12532                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12533 3891           E8         CCAE            call	_inb
12534 3894           44                         inc	sp
12535 3895           44                         inc	sp
12536                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12537 3896           24                     07  and	al,*7
12538                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12539 3898           3C                     03  cmp	al,*3
12540 389A           75           0C            jne 	.2BD
12541                       0000389C            .2BF:
12542                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12543 389C           8A46         EF            mov	al,-$11[bp]
12544 389F           24                     41  and	al,*$41
12545                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12546 38A1           3C                     40  cmp	al,*$40
12547 38A3           75           03            jne 	.2BD
12548                       000038A5            .2BE:
12549 38A5           E9         01F4            br 	.2B7
12550                                           !BCC_EOS
12551                                           ! 2072       if (status & 0x01) {
12552                       000038A8            .2BD:
12553                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12554 38A8           8A46         EF            mov	al,-$11[bp]
12555 38AB           24                     01  and	al,*1
12556 38AD           84C0                       test	al,al
12557 38AF           74           07            je  	.2C0
12558                       000038B1            .2C1:
12559                                           ! 2073         ;
12560                                           !BCC_EOS
12561                                           ! 2074         return 3;
12562 38B1           B8                   0003  mov	ax,*3
12563 38B4           89EC                       mov	sp,bp
12564 38B6           5D                         pop	bp
12565 38B7           C3                         ret
12566                                           !BCC_EOS
12567                                           ! 2075       }
12568                                           ! 2076       bufseg += (bufoff / 16);
12569                       000038B8            .2C0:
12570                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12571 38B8           8B46         16            mov	ax,$16[bp]
12572 38BB           B1                     04  mov	cl,*4
12573 38BD           D3E8                       shr	ax,cl
12574                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12575 38BF           0346         14            add	ax,$14[bp]
12576 38C2           8946         14            mov	$14[bp],ax
12577                                           !BCC_EOS
12578                                           ! 2077       bufoff %= 16;
12579                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12580 38C5           8B46         16            mov	ax,$16[bp]
12581 38C8           24                     0F  and	al,*$F
12582 38CA           30E4                       xor	ah,ah
12583 38CC           8946         16            mov	$16[bp],ax
12584                                           !BCC_EOS
12585                                           ! 2078       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12586                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12587 38CF           8B46         FC            mov	ax,-4[bp]
12588                                           ! Debug: list unsigned int = ax+4 (used reg = )
12589 38D2           05                   0004  add	ax,*4
12590 38D5           50                         push	ax
12591                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12592 38D6           E8         CC69            call	_inb
12593 38D9           44                         inc	sp
12594 38DA           44                         inc	sp
12595 38DB           50                         push	ax
12596                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12597 38DC           8B46         FC            mov	ax,-4[bp]
12598                                           ! Debug: list unsigned int = ax+5 (used reg = )
12599 38DF           05                   0005  add	ax,*5
12600 38E2           50                         push	ax
12601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12602 38E3           E8         CC5C            call	_inb
12603 38E6           44                         inc	sp
12604 38E7           44                         inc	sp
12605                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12606 38E8           30E4                       xor	ah,ah
12607                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12608 38EA           88C4                       mov	ah,al
12609 38EC           30C0                       xor	al,al
12610                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12611 38EE           0246         DE            add	al,-$22[bp]
12612 38F1           80D4                   00  adc	ah,*0
12613 38F4           44                         inc	sp
12614 38F5           44                         inc	sp
12615                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12616 38F6           8946         F8            mov	-8[bp],ax
12617                                           !BCC_EOS
12618                                           ! 2079       if(header>lcount) {
12619                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12620 38F9           8B46         0C            mov	ax,$C[bp]
12621 38FC           3B46         F8            cmp	ax,-8[bp]
12622 38FF           76           16            jbe 	.2C2
12623                       00003901            .2C3:
12624                                           ! 2080          lbefore=lcount;
12625                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12626 3901           8B46         F8            mov	ax,-8[bp]
12627 3904           8946         F6            mov	-$A[bp],ax
12628                                           !BCC_EOS
12629                                           ! 2081          header-=lcount;
12630                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12631 3907           8B46         0C            mov	ax,$C[bp]
12632 390A           2B46         F8            sub	ax,-8[bp]
12633 390D           8946         0C            mov	$C[bp],ax
12634                                           !BCC_EOS
12635                                           ! 2082          lcount=0;
12636                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12637 3910           31C0                       xor	ax,ax
12638 3912           8946         F8            mov	-8[bp],ax
12639                                           !BCC_EOS
12640                                           ! 2083       }
12641                                           ! 2084       else {
12642 3915           EB           14            jmp .2C4
12643                       00003917            .2C2:
12644                                           ! 2085         lbefore=header;
12645                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12646 3917           8B46         0C            mov	ax,$C[bp]
12647 391A           8946         F6            mov	-$A[bp],ax
12648                                           !BCC_EOS
12649                                           ! 2086         header=0;
12650                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12651 391D           31C0                       xor	ax,ax
12652 391F           8946         0C            mov	$C[bp],ax
12653                                           !BCC_EOS
12654                                           ! 2087         lcount-=lbefore;
12655                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12656 3922           8B46         F8            mov	ax,-8[bp]
12657 3925           2B46         F6            sub	ax,-$A[bp]
12658 3928           8946         F8            mov	-8[bp],ax
12659                                           !BCC_EOS
12660                                           ! 2088       }
12661                                           ! 2089       if(lcount>length) {
12662                       0000392B            .2C4:
12663                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12664 392B           8B46         F8            mov	ax,-8[bp]
12665 392E           31DB                       xor	bx,bx
12666                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12667 3930           8D7E         0E            lea	di,$E[bp]
12668 3933           E8         C795            call	lcmpul
12669 3936           76           20            jbe 	.2C5
12670                       00003938            .2C6:
12671                                           ! 2090         lafter=lcount-length;
12672                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12673 3938           8B46         F8            mov	ax,-8[bp]
12674 393B           31DB                       xor	bx,bx
12675                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12676 393D           8D7E         0E            lea	di,$E[bp]
12677 3940           E8         C79E            call	lsubul
12678                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12679 3943           8946         F4            mov	-$C[bp],ax
12680                                           !BCC_EOS
12681                                           ! 2091         lcount=length;
12682                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12683 3946           8B46         0E            mov	ax,$E[bp]
12684 3949           8946         F8            mov	-8[bp],ax
12685                                           !BCC_EOS
12686                                           ! 2092         length=0;
12687                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12688 394C           31C0                       xor	ax,ax
12689 394E           31DB                       xor	bx,bx
12690 3950           8946         0E            mov	$E[bp],ax
12691 3953           895E         10            mov	$10[bp],bx
12692                                           !BCC_EOS
12693                                           ! 2093       }
12694                                           ! 2094       else {
12695 3956           EB           21            jmp .2C7
12696                       00003958            .2C5:
12697                                           ! 2095         lafter=0;
12698                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12699 3958           31C0                       xor	ax,ax
12700 395A           8946         F4            mov	-$C[bp],ax
12701                                           !BCC_EOS
12702                                           ! 2096         length-=lcount;
12703                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12704 395D           8B46         F8            mov	ax,-8[bp]
12705 3960           31DB                       xor	bx,bx
12706                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12707 3962           53                         push	bx
12708 3963           50                         push	ax
12709 3964           8B46         0E            mov	ax,$E[bp]
12710 3967           8B5E         10            mov	bx,$10[bp]
12711 396A           8D7E         DC            lea	di,-$24[bp]
12712 396D           E8         C771            call	lsubul
12713 3970           8946         0E            mov	$E[bp],ax
12714 3973           895E         10            mov	$10[bp],bx
12715 3976           83C4                   04  add	sp,*4
12716                                           !BCC_EOS
12717                                           ! 2097       }
12718                                           ! 2098       count = lcount;
12719                       00003979            .2C7:
12720                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12721 3979           8B46         F8            mov	ax,-8[bp]
12722 397C           8946         F2            mov	-$E[bp],ax
12723                                           !BCC_EOS
12724                                           ! 2099       ;
12725                                           !BCC_EOS
12726                                           ! 2100       ;
12727                                           !BCC_EOS
12728                                           ! 2101       lmode = mode;
12729                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
12730 397F           8A46         EE            mov	al,-$12[bp]
12731 3982           8846         ED            mov	-$13[bp],al
12732                                           !BCC_EOS
12733                                           ! 2102       if (lbefore & 0x03) lmode=0x00;
12734                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
12735 3985           8A46         F6            mov	al,-$A[bp]
12736 3988           24                     03  and	al,*3
12737 398A           84C0                       test	al,al
12738 398C           74           05            je  	.2C8
12739                       0000398E            .2C9:
12740                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12741 398E           30C0                       xor	al,al
12742 3990           8846         ED            mov	-$13[bp],al
12743                                           !BCC_EOS
12744                                           ! 2103       if (lcount & 0x03) lmode=0x00;
12745                       00003993            .2C8:
12746                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
12747 3993           8A46         F8            mov	al,-8[bp]
12748 3996           24                     03  and	al,*3
12749 3998           84C0                       test	al,al
12750 399A           74           05            je  	.2CA
12751                       0000399C            .2CB:
12752                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12753 399C           30C0                       xor	al,al
12754 399E           8846         ED            mov	-$13[bp],al
12755                                           !BCC_EOS
12756                                           ! 2104       if (lafter & 0x03) lmode=0x00;
12757                       000039A1            .2CA:
12758                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
12759 39A1           8A46         F4            mov	al,-$C[bp]
12760 39A4           24                     03  and	al,*3
12761 39A6           84C0                       test	al,al
12762 39A8           74           05            je  	.2CC
12763                       000039AA            .2CD:
12764                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12765 39AA           30C0                       xor	al,al
12766 39AC           8846         ED            mov	-$13[bp],al
12767                                           !BCC_EOS
12768                                           ! 2105       if (lcount & 0x01) {
12769                       000039AF            .2CC:
12770                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12771 39AF           8A46         F8            mov	al,-8[bp]
12772 39B2           24                     01  and	al,*1
12773 39B4           84C0                       test	al,al
12774 39B6           74           1E            je  	.2CE
12775                       000039B8            .2CF:
12776                                           ! 2106         lcount+=1;
12777                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12778 39B8           8B46         F8            mov	ax,-8[bp]
12779 39BB           40                         inc	ax
12780 39BC           8946         F8            mov	-8[bp],ax
12781                                           !BCC_EOS
12782                                           ! 2107         if ((lafter > 0) && (lafter & 0x01)) {
12783                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12784 39BF           8B46         F4            mov	ax,-$C[bp]
12785 39C2           85C0                       test	ax,ax
12786 39C4           74           10            je  	.2D0
12787                       000039C6            .2D2:
12788                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12789 39C6           8A46         F4            mov	al,-$C[bp]
12790 39C9           24                     01  and	al,*1
12791 39CB           84C0                       test	al,al
12792 39CD           74           07            je  	.2D0
12793                       000039CF            .2D1:
12794                                           ! 2108           lafter-=1;
12795                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12796 39CF           8B46         F4            mov	ax,-$C[bp]
12797 39D2           48                         dec	ax
12798 39D3           8946         F4            mov	-$C[bp],ax
12799                                           !BCC_EOS
12800                                           ! 2109         }
12801                                           ! 2110       }
12802                       000039D6            .2D0:
12803                                           ! 2111       if (lmode == 0x01) {
12804                       000039D6            .2CE:
12805                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
12806 39D6           8A46         ED            mov	al,-$13[bp]
12807 39D9           3C                     01  cmp	al,*1
12808 39DB           75           20            jne 	.2D3
12809                       000039DD            .2D4:
12810                                           ! 2112         lcount>>=2; lbefore>>=2; lafter>>=2;
12811                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
12812 39DD           8B46         F8            mov	ax,-8[bp]
12813 39E0           D1E8                       shr	ax,*1
12814 39E2           D1E8                       shr	ax,*1
12815 39E4           8946         F8            mov	-8[bp],ax
12816                                           !BCC_EOS
12817                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
12818 39E7           8B46         F6            mov	ax,-$A[bp]
12819 39EA           D1E8                       shr	ax,*1
12820 39EC           D1E8                       shr	ax,*1
12821 39EE           8946         F6            mov	-$A[bp],ax
12822                                           !BCC_EOS
12823                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
12824 39F1           8B46         F4            mov	ax,-$C[bp]
12825 39F4           D1E8                       shr	ax,*1
12826 39F6           D1E8                       shr	ax,*1
12827 39F8           8946         F4            mov	-$C[bp],ax
12828                                           !BCC_EOS
12829                                           ! 2113       }
12830                                           ! 2114       else {
12831 39FB           EB           18            jmp .2D5
12832                       000039FD            .2D3:
12833                                           ! 2115         lcount>>=1; lbefore>>=1; lafter>>=1;
12834                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12835 39FD           8B46         F8            mov	ax,-8[bp]
12836 3A00           D1E8                       shr	ax,*1
12837 3A02           8946         F8            mov	-8[bp],ax
12838                                           !BCC_EOS
12839                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
12840 3A05           8B46         F6            mov	ax,-$A[bp]
12841 3A08           D1E8                       shr	ax,*1
12842 3A0A           8946         F6            mov	-$A[bp],ax
12843                                           !BCC_EOS
12844                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12845 3A0D           8B46         F4            mov	ax,-$C[bp]
12846 3A10           D1E8                       shr	ax,*1
12847 3A12           8946         F4            mov	-$C[bp],ax
12848                                           !BCC_EOS
12849                                           ! 2116       }
12850                                           ! 2117        ;
12851                       00003A15            .2D5:
12852                                           !BCC_EOS
12853                                           ! 2118 #asm
12854                                           !BCC_EOS
12855                                           !BCC_ASM
12856                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
12857                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12858                       0000002C            _ata_cmd_packet.header	set	$2C
12859                       0000000C            .ata_cmd_packet.header	set	$C
12860                       00000012            _ata_cmd_packet.count	set	$12
12861                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12862                       00000014            _ata_cmd_packet.lafter	set	$14
12863                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12864                       0000001C            _ata_cmd_packet.iobase1	set	$1C
12865                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12866                       00000011            _ata_cmd_packet.channel	set	$11
12867                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12868                       00000028            _ata_cmd_packet.cmdseg	set	$28
12869                       00000008            .ata_cmd_packet.cmdseg	set	8
12870                       00000026            _ata_cmd_packet.cmdlen	set	$26
12871                       00000006            .ata_cmd_packet.cmdlen	set	6
12872                       0000000D            _ata_cmd_packet.lmode	set	$D
12873                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12874                       00000024            _ata_cmd_packet.device	set	$24
12875                       00000004            .ata_cmd_packet.device	set	4
12876                       00000002            _ata_cmd_packet.loops	set	2
12877                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
12878                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
12879                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12880                       00000018            _ata_cmd_packet.lcount	set	$18
12881                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12882                       00000008            _ata_cmd_packet.total	set	8
12883                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12884                       0000000F            _ata_cmd_packet.status	set	$F
12885                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12886                       0000000E            _ata_cmd_packet.mode	set	$E
12887                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12888                       00000036            _ata_cmd_packet.bufoff	set	$36
12889                       00000016            .ata_cmd_packet.bufoff	set	$16
12890                       00000004            _ata_cmd_packet.transfer	set	4
12891                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12892                       00000001            _ata_cmd_packet.sc	set	1
12893                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
12894                       0000001A            _ata_cmd_packet.iobase2	set	$1A
12895                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12896                       00000016            _ata_cmd_packet.lbefore	set	$16
12897                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12898                       00000034            _ata_cmd_packet.bufseg	set	$34
12899                       00000014            .ata_cmd_packet.bufseg	set	$14
12900                       00000010            _ata_cmd_packet.slave	set	$10
12901                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12902                       00000032            _ata_cmd_packet.inout	set	$32
12903                       00000012            .ata_cmd_packet.inout	set	$12
12904                       0000002E            _ata_cmd_packet.length	set	$2E
12905                       0000000E            .ata_cmd_packet.length	set	$E
12906 3A15           55                                 push bp
12907 3A16           89E5                               mov bp, sp
12908 3A18           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
12909 3A1B           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
12910 3A1E           E3           15                    jcxz ata_packet_no_before
12911 3A20           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12912 3A23           80FC                   01          cmp ah, #0x01
12913 3A26           74           05                    je ata_packet_in_before_32
12914                       00003A28            ata_packet_in_before_16:
12915 3A28           ED                                 in ax, dx
12916 3A29           E2           FD                    loop ata_packet_in_before_16
12917 3A2B           EB           08                    jmp ata_packet_no_before
12918                       00003A2D            ata_packet_in_before_32:
12919 3A2D     66    50                                 push eax
12920                       00003A2F            ata_packet_in_before_32_loop:
12921 3A2F     66    ED                                 in eax, dx
12922 3A31           E2           FC                    loop ata_packet_in_before_32_loop
12923 3A33     66    58                                 pop eax
12924                       00003A35            ata_packet_no_before:
12925 3A35           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
12926 3A38           E3           17                    jcxz ata_packet_after
12927 3A3A           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
12928 3A3D           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
12929 3A40           8EC0                               mov es, ax
12930 3A42           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12931 3A45           80FC                   01          cmp ah, #0x01
12932 3A48           74           04                    je ata_packet_in_32
12933                       00003A4A            ata_packet_in_16:
12934 3A4A           F3                                 rep
12935 3A4B           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
12936 3A4C           EB           03                    jmp ata_packet_after
12937                       00003A4E            ata_packet_in_32:
12938 3A4E           F3                                 rep
12939 3A4F     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
12940                       00003A51            ata_packet_after:
12941 3A51           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
12942 3A54           E3           15                    jcxz ata_packet_done
12943 3A56           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12944 3A59           80FC                   01          cmp ah, #0x01
12945 3A5C           74           05                    je ata_packet_in_after_32
12946                       00003A5E            ata_packet_in_after_16:
12947 3A5E           ED                                 in ax, dx
12948 3A5F           E2           FD                    loop ata_packet_in_after_16
12949 3A61           EB           08                    jmp ata_packet_done
12950                       00003A63            ata_packet_in_after_32:
12951 3A63     66    50                                 push eax
12952                       00003A65            ata_packet_in_after_32_loop:
12953 3A65     66    ED                                 in eax, dx
12954 3A67           E2           FC                    loop ata_packet_in_after_32_loop
12955 3A69     66    58                                 pop eax
12956                       00003A6B            ata_packet_done:
12957 3A6B           5D                                 pop bp
12958                                           ! 2171 endasm
12959                                           !BCC_ENDASM
12960                                           !BCC_EOS
12961                                           ! 2172       bufoff += count;
12962                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
12963 3A6C           8B46         16            mov	ax,$16[bp]
12964 3A6F           0346         F2            add	ax,-$E[bp]
12965 3A72           8946         16            mov	$16[bp],ax
12966                                           !BCC_EOS
12967                                           ! 2173       transfer += count;
12968                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
12969 3A75           8B46         F2            mov	ax,-$E[bp]
12970 3A78           31DB                       xor	bx,bx
12971                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
12972 3A7A           8D7E         E4            lea	di,-$1C[bp]
12973 3A7D           E8         C643            call	laddul
12974 3A80           8946         E4            mov	-$1C[bp],ax
12975 3A83           895E         E6            mov	-$1A[bp],bx
12976                                           !BCC_EOS
12977                                           ! 2174       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
12978                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
12979 3A86           FF76         E6            push	-$1A[bp]
12980 3A89           FF76         E4            push	-$1C[bp]
12981                                           ! Debug: list * unsigned long = const $256 (used reg = )
12982 3A8C           B8                   0256  mov	ax,#$256
12983 3A8F           50                         push	ax
12984                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
12985 3A90           FF76         FE            push	-2[bp]
12986                                           ! Debug: func () void = write_dword+0 (used reg = )
12987 3A93           E8         C605            call	_write_dword
12988 3A96           83C4                   08  add	sp,*8
12989                                           !BCC_EOS
12990                                           ! 2175     }
12991                                           ! 2176   }
12992                       00003A99            .2B8:
12993 3A99           E9         FD91            br 	.2B9
12994                       00003A9C            .2D6:
12995                       00003A9C            .2B7:
12996 3A9C           83C4                   04  add	sp,*4
12997                                           ! 2177   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
12998                       00003A9F            .2B6:
12999                                           ! 2178          != 0x40 ) {
13000                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
13001 3A9F           8A46         EF            mov	al,-$11[bp]
13002 3AA2           24                     E9  and	al,#$E9
13003                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
13004 3AA4           3C                     40  cmp	al,*$40
13005 3AA6           74           07            je  	.2D7
13006                       00003AA8            .2D8:
13007                                           ! 2179     ;
13008                                           !BCC_EOS
13009                                           ! 2180     return 4;
13010 3AA8           B8                   0004  mov	ax,*4
13011 3AAB           89EC                       mov	sp,bp
13012 3AAD           5D                         pop	bp
13013 3AAE           C3                         ret
13014                                           !BCC_EOS
13015                                           ! 2181   }
13016                                           ! 2182   outb(iobase2+6, 0x08);
13017                       00003AAF            .2D7:
13018                                           ! Debug: list int = const 8 (used reg = )
13019 3AAF           B8                   0008  mov	ax,*8
13020 3AB2           50                         push	ax
13021                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
13022 3AB3           8B46         FA            mov	ax,-6[bp]
13023                                           ! Debug: list unsigned int = ax+6 (used reg = )
13024 3AB6           05                   0006  add	ax,*6
13025 3AB9           50                         push	ax
13026                                           ! Debug: func () void = outb+0 (used reg = )
13027 3ABA           E8         CA9B            call	_outb
13028 3ABD           83C4                   04  add	sp,*4
13029                                           !BCC_EOS
13030                                           ! 2183   return 0;
13031 3AC0           31C0                       xor	ax,ax
13032 3AC2           89EC                       mov	sp,bp
13033 3AC4           5D                         pop	bp
13034 3AC5           C3                         ret
13035                                           !BCC_EOS
13036                                           ! 2184 }
13037                                           ! 2185   Bit16u
13038                                           ! Register BX used in function ata_cmd_packet
13039                                           ! 2186 atapi_get_sense(device, seg, asc, ascq)
13040                                           ! 2187   Bit16u device;
13041                                           export	_atapi_get_sense
13042                       00003AC6            _atapi_get_sense:
13043                                           !BCC_EOS
13044                                           ! 2188 {
13045                                           ! 2189   Bit8u atacmd[12];
13046                                           !BCC_EOS
13047                                           ! 2190   Bit8u buffer[18];
13048                                           !BCC_EOS
13049                                           ! 2191   Bit8u i;
13050                                           !BCC_EOS
13051                                           ! 2192   memsetb(get_SS(),atacmd,0,12);
13052 3AC6           55                         push	bp
13053 3AC7           89E5                       mov	bp,sp
13054 3AC9           83C4                   E0  add	sp,*-$20
13055                                           ! Debug: list int = const $C (used reg = )
13056 3ACC           B8                   000C  mov	ax,*$C
13057 3ACF           50                         push	ax
13058                                           ! Debug: list int = const 0 (used reg = )
13059 3AD0           31C0                       xor	ax,ax
13060 3AD2           50                         push	ax
13061                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
13062 3AD3           8D5E         F4            lea	bx,-$C[bp]
13063 3AD6           53                         push	bx
13064                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13065 3AD7           E8         CB77            call	_get_SS
13066                                           ! Debug: list unsigned short = ax+0 (used reg = )
13067 3ADA           50                         push	ax
13068                                           ! Debug: func () void = memsetb+0 (used reg = )
13069 3ADB           E8         C522            call	_memsetb
13070 3ADE           83C4                   08  add	sp,*8
13071                                           !BCC_EOS
13072                                           ! 2193   atacmd[0]=0x03;
13073                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
13074 3AE1           B0                     03  mov	al,*3
13075 3AE3           8846         F4            mov	-$C[bp],al
13076                                           !BCC_EOS
13077                                           ! 2194   atacmd[4]=sizeof(buffer);
13078                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
13079 3AE6           B0                     12  mov	al,*$12
13080 3AE8           8846         F8            mov	-8[bp],al
13081                                           !BCC_EOS
13082                                           ! 2195   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
13083                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
13084 3AEB           8D5E         E2            lea	bx,-$1E[bp]
13085 3AEE           53                         push	bx
13086                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13087 3AEF           E8         CB5F            call	_get_SS
13088                                           ! Debug: list unsigned short = ax+0 (used reg = )
13089 3AF2           50                         push	ax
13090                                           ! Debug: list int = const 1 (used reg = )
13091 3AF3           B8                   0001  mov	ax,*1
13092 3AF6           50                         push	ax
13093                                           ! Debug: list long = const $12 (used reg = )
13094 3AF7           B8                   0012  mov	ax,*$12
13095 3AFA           31DB                       xor	bx,bx
13096 3AFC           53                         push	bx
13097 3AFD           50                         push	ax
13098                                           ! Debug: list int = const 0 (used reg = )
13099 3AFE           31C0                       xor	ax,ax
13100 3B00           50                         push	ax
13101                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
13102 3B01           8D5E         F4            lea	bx,-$C[bp]
13103 3B04           53                         push	bx
13104                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13105 3B05           E8         CB49            call	_get_SS
13106                                           ! Debug: list unsigned short = ax+0 (used reg = )
13107 3B08           50                         push	ax
13108                                           ! Debug: list int = const $C (used reg = )
13109 3B09           B8                   000C  mov	ax,*$C
13110 3B0C           50                         push	ax
13111                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
13112 3B0D           FF76         04            push	4[bp]
13113                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13114 3B10           E8         FAD4            call	_ata_cmd_packet
13115 3B13           83C4                   14  add	sp,*$14
13116                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13117 3B16           85C0                       test	ax,ax
13118 3B18           74           07            je  	.2D9
13119                       00003B1A            .2DA:
13120                                           ! 2196     return 0x0002;
13121 3B1A           B8                   0002  mov	ax,*2
13122 3B1D           89EC                       mov	sp,bp
13123 3B1F           5D                         pop	bp
13124 3B20           C3                         ret
13125                                           !BCC_EOS
13126                                           ! 2197   write_byte(seg,asc,buffer[12]);
13127                       00003B21            .2D9:
13128                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
13129 3B21           8A46         EE            mov	al,-$12[bp]
13130 3B24           30E4                       xor	ah,ah
13131 3B26           50                         push	ax
13132                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13133 3B27           FF76         08            push	8[bp]
13134                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13135 3B2A           FF76         06            push	6[bp]
13136                                           ! Debug: func () void = write_byte+0 (used reg = )
13137 3B2D           E8         CAEE            call	_write_byte
13138 3B30           83C4                   06  add	sp,*6
13139                                           !BCC_EOS
13140                                           ! 2198   write_byte(seg,ascq,buffer[13]);
13141                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13142 3B33           8A46         EF            mov	al,-$11[bp]
13143 3B36           30E4                       xor	ah,ah
13144 3B38           50                         push	ax
13145                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13146 3B39           FF76         0A            push	$A[bp]
13147                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13148 3B3C           FF76         06            push	6[bp]
13149                                           ! Debug: func () void = write_byte+0 (used reg = )
13150 3B3F           E8         CADC            call	_write_byte
13151 3B42           83C4                   06  add	sp,*6
13152                                           !BCC_EOS
13153                                           ! 2199   return 0;
13154 3B45           31C0                       xor	ax,ax
13155 3B47           89EC                       mov	sp,bp
13156 3B49           5D                         pop	bp
13157 3B4A           C3                         ret
13158                                           !BCC_EOS
13159                                           ! 2200 }
13160                                           ! 2201   Bit16u
13161                                           ! Register BX used in function atapi_get_sense
13162                                           ! 2202 atapi_is_ready(device)
13163                                           ! 2203   Bit16u device;
13164                                           export	_atapi_is_ready
13165                       00003B4B            _atapi_is_ready:
13166                                           !BCC_EOS
13167                                           ! 2204 {
13168                                           ! 2205   Bit8u packet[12];
13169                                           !BCC_EOS
13170                                           ! 2206   Bit8u buf[8];
13171                                           !BCC_EOS
13172                                           ! 2207   Bit32u block_len;
13173                                           !BCC_EOS
13174                                           ! 2208   Bit32u sectors;
13175                                           !BCC_EOS
13176                                           ! 2209   Bit32u timeout;
13177                                           !BCC_EOS
13178                                           ! 2210   Bit32u time;
13179                                           !BCC_EOS
13180                                           ! 2211   Bit8u asc, ascq;
13181                                           !BCC_EOS
13182                                           ! 2212   Bit8u in_progress;
13183                                           !BCC_EOS
13184                                           ! 2213   Bit16u ebda_seg = read_wo
13185                                           ! 2213 rd(0x0040,0x000E);
13186 3B4B           55                         push	bp
13187 3B4C           89E5                       mov	bp,sp
13188 3B4E           83C4                   D6  add	sp,*-$2A
13189                                           ! Debug: list int = const $E (used reg = )
13190 3B51           B8                   000E  mov	ax,*$E
13191 3B54           50                         push	ax
13192                                           ! Debug: list int = const $40 (used reg = )
13193 3B55           B8                   0040  mov	ax,*$40
13194 3B58           50                         push	ax
13195                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13196 3B59           E8         CAAF            call	_read_word
13197 3B5C           83C4                   04  add	sp,*4
13198                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13199 3B5F           8946         D6            mov	-$2A[bp],ax
13200                                           !BCC_EOS
13201                                           ! 2214   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13202                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13203 3B62           8B46         04            mov	ax,4[bp]
13204 3B65           B9                   001E  mov	cx,*$1E
13205 3B68           F7E9                       imul	cx
13206 3B6A           89C3                       mov	bx,ax
13207                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13208                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13209 3B6C           81C3                 0142  add	bx,#$142
13210 3B70           53                         push	bx
13211                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13212 3B71           FF76         D6            push	-$2A[bp]
13213                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13214 3B74           E8         CA81            call	_read_byte
13215 3B77           83C4                   04  add	sp,*4
13216                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13217 3B7A           3C                     03  cmp	al,*3
13218 3B7C           74           15            je  	.2DB
13219                       00003B7E            .2DC:
13220                                           ! 2215     bios_printf(2, "not implemented for non-ATAPI device\n");
13221                                           ! Debug: list * char = .2DD+0 (used reg = )
13222 3B7E           BB                   D629  mov	bx,#.2DD
13223 3B81           53                         push	bx
13224                                           ! Debug: list int = const 2 (used reg = )
13225 3B82           B8                   0002  mov	ax,*2
13226 3B85           50                         push	ax
13227                                           ! Debug: func () void = bios_printf+0 (used reg = )
13228 3B86           E8         CE1E            call	_bios_printf
13229 3B89           83C4                   04  add	sp,*4
13230                                           !BCC_EOS
13231                                           ! 2216     return -1;
13232 3B8C           B8                   FFFF  mov	ax,#$FFFF
13233 3B8F           89EC                       mov	sp,bp
13234 3B91           5D                         pop	bp
13235 3B92           C3                         ret
13236                                           !BCC_EOS
13237                                           ! 2217   }
13238                                           ! 2218   ;
13239                       00003B93            .2DB:
13240                                           !BCC_EOS
13241                                           ! 2219   memsetb(get_SS(),packet, 0, sizeof packet);
13242                                           ! Debug: list int = const $C (used reg = )
13243 3B93           B8                   000C  mov	ax,*$C
13244 3B96           50                         push	ax
13245                                           ! Debug: list int = const 0 (used reg = )
13246 3B97           31C0                       xor	ax,ax
13247 3B99           50                         push	ax
13248                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13249 3B9A           8D5E         F4            lea	bx,-$C[bp]
13250 3B9D           53                         push	bx
13251                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13252 3B9E           E8         CAB0            call	_get_SS
13253                                           ! Debug: list unsigned short = ax+0 (used reg = )
13254 3BA1           50                         push	ax
13255                                           ! Debug: func () void = memsetb+0 (used reg = )
13256 3BA2           E8         C45B            call	_memsetb
13257 3BA5           83C4                   08  add	sp,*8
13258                                           !BCC_EOS
13259                                           ! 2220   packet[0] = 0x25;
13260                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13261 3BA8           B0                     25  mov	al,*$25
13262 3BAA           8846         F4            mov	-$C[bp],al
13263                                           !BCC_EOS
13264                                           ! 2221   timeout = 5000;
13265                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13266 3BAD           B8                   1388  mov	ax,#$1388
13267 3BB0           31DB                       xor	bx,bx
13268 3BB2           8946         E0            mov	-$20[bp],ax
13269 3BB5           895E         E2            mov	-$1E[bp],bx
13270                                           !BCC_EOS
13271                                           ! 2222   time = 0;
13272                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13273 3BB8           31C0                       xor	ax,ax
13274 3BBA           31DB                       xor	bx,bx
13275 3BBC           8946         DC            mov	-$24[bp],ax
13276 3BBF           895E         DE            mov	-$22[bp],bx
13277                                           !BCC_EOS
13278                                           ! 2223   in_progress = 0;
13279                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13280 3BC2           30C0                       xor	al,al
13281 3BC4           8846         D9            mov	-$27[bp],al
13282                                           !BCC_EOS
13283                                           ! 2224   while (time < timeout) {
13284 3BC7           E9         00AB            br 	.2DF
13285                       00003BCA            .2E0:
13286                                           ! 2225     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13287                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13288 3BCA           8D5E         EC            lea	bx,-$14[bp]
13289 3BCD           53                         push	bx
13290                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13291 3BCE           E8         CA80            call	_get_SS
13292                                           ! Debug: list unsigned short = ax+0 (used reg = )
13293 3BD1           50                         push	ax
13294                                           ! Debug: list int = const 1 (used reg = )
13295 3BD2           B8                   0001  mov	ax,*1
13296 3BD5           50                         push	ax
13297                                           ! Debug: list long = const 8 (used reg = )
13298 3BD6           B8                   0008  mov	ax,*8
13299 3BD9           31DB                       xor	bx,bx
13300 3BDB           53                         push	bx
13301 3BDC           50                         push	ax
13302                                           ! Debug: list int = const 0 (used reg = )
13303 3BDD           31C0                       xor	ax,ax
13304 3BDF           50                         push	ax
13305                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13306 3BE0           8D5E         F4            lea	bx,-$C[bp]
13307 3BE3           53                         push	bx
13308                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13309 3BE4           E8         CA6A            call	_get_SS
13310                                           ! Debug: list unsigned short = ax+0 (used reg = )
13311 3BE7           50                         push	ax
13312                                           ! Debug: list int = const $C (used reg = )
13313 3BE8           B8                   000C  mov	ax,*$C
13314 3BEB           50                         push	ax
13315                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13316 3BEC           FF76         04            push	4[bp]
13317                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13318 3BEF           E8         F9F5            call	_ata_cmd_packet
13319 3BF2           83C4                   14  add	sp,*$14
13320                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13321 3BF5           85C0                       test	ax,ax
13322 3BF7           75           06            jne 	.2E1
13323                       00003BF9            .2E2:
13324                                           ! 2226       goto ok;
13325 3BF9           83C4                   00  add	sp,#..FFFA+$2C
13326 3BFC           E9         008D            br 	.FFFA
13327                                           !BCC_EOS
13328                                           ! 2227     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13329                       00003BFF            .2E1:
13330                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13331 3BFF           8D5E         DA            lea	bx,-$26[bp]
13332 3C02           53                         push	bx
13333                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13334 3C03           8D5E         DB            lea	bx,-$25[bp]
13335 3C06           53                         push	bx
13336                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13337 3C07           E8         CA47            call	_get_SS
13338                                           ! Debug: list unsigned short = ax+0 (used reg = )
13339 3C0A           50                         push	ax
13340                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13341 3C0B           FF76         04            push	4[bp]
13342                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13343 3C0E           E8         FEB5            call	_atapi_get_sense
13344 3C11           83C4                   08  add	sp,*8
13345                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13346 3C14           85C0                       test	ax,ax
13347 3C16           75           41            jne 	.2E3
13348                       00003C18            .2E4:
13349                                           ! 2228       if (asc == 0x3a) {
13350                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13351 3C18           8A46         DB            mov	al,-$25[bp]
13352 3C1B           3C                     3A  cmp	al,*$3A
13353 3C1D           75           07            jne 	.2E5
13354                       00003C1F            .2E6:
13355                                           ! 2229         ;
13356                                           !BCC_EOS
13357                                           ! 2230         return -1;
13358 3C1F           B8                   FFFF  mov	ax,#$FFFF
13359 3C22           89EC                       mov	sp,bp
13360 3C24           5D                         pop	bp
13361 3C25           C3                         ret
13362                                           !BCC_EOS
13363                                           ! 2231       }
13364                                           ! 2232       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13365                       00003C26            .2E5:
13366                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13367 3C26           8A46         DB            mov	al,-$25[bp]
13368 3C29           3C                     04  cmp	al,*4
13369 3C2B           75           2C            jne 	.2E7
13370                       00003C2D            .2EA:
13371                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13372 3C2D           8A46         DA            mov	al,-$26[bp]
13373 3C30           3C                     01  cmp	al,*1
13374 3C32           75           25            jne 	.2E7
13375                       00003C34            .2E9:
13376 3C34           8A46         D9            mov	al,-$27[bp]
13377 3C37           84C0                       test	al,al
13378 3C39           75           1E            jne 	.2E7
13379                       00003C3B            .2E8:
13380                                           ! 2233         bios_printf(2, "Waiting for device to detect medium... ");
13381                                           ! Debug: list * char = .2EB+0 (used reg = )
13382 3C3B           BB                   D601  mov	bx,#.2EB
13383 3C3E           53                         push	bx
13384                                           ! Debug: list int = const 2 (used reg = )
13385 3C3F           B8                   0002  mov	ax,*2
13386 3C42           50                         push	ax
13387                                           ! Debug: func () void = bios_printf+0 (used reg = )
13388 3C43           E8         CD61            call	_bios_printf
13389 3C46           83C4                   04  add	sp,*4
13390                                           !BCC_EOS
13391                                           ! 2234         timeout = 30000;
13392                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13393 3C49           B8                   7530  mov	ax,#$7530
13394 3C4C           31DB                       xor	bx,bx
13395 3C4E           8946         E0            mov	-$20[bp],ax
13396 3C51           895E         E2            mov	-$1E[bp],bx
13397                                           !BCC_EOS
13398                                           ! 2235         in_progress = 1;
13399                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13400 3C54           B0                     01  mov	al,*1
13401 3C56           8846         D9            mov	-$27[bp],al
13402                                           !BCC_EOS
13403                                           ! 2236       }
13404                                           ! 2237     }
13405                       00003C59            .2E7:
13406                                           ! 2238     time += 100;
13407                       00003C59            .2E3:
13408                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13409 3C59           B8                   0064  mov	ax,*$64
13410 3C5C           31DB                       xor	bx,bx
13411 3C5E           53                         push	bx
13412 3C5F           50                         push	ax
13413 3C60           8B46         DC            mov	ax,-$24[bp]
13414 3C63           8B5E         DE            mov	bx,-$22[bp]
13415 3C66           8D7E         D2            lea	di,-$2E[bp]
13416 3C69           E8         C457            call	laddul
13417 3C6C           8946         DC            mov	-$24[bp],ax
13418 3C6F           895E         DE            mov	-$22[bp],bx
13419 3C72           83C4                   04  add	sp,*4
13420                                           !BCC_EOS
13421                                           ! 2239   }
13422                                           ! 2240   ;
13423                       00003C75            .2DF:
13424                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13425 3C75           8B46         E0            mov	ax,-$20[bp]
13426 3C78           8B5E         E2            mov	bx,-$1E[bp]
13427 3C7B           8D7E         DC            lea	di,-$24[bp]
13428 3C7E           E8         C44A            call	lcmpul
13429 3C81         0F87         FF45            bhi 	.2E0
13430                       00003C85            .2EC:
13431                       00003C85            .2DE:
13432                                           !BCC_EOS
13433                                           ! 2241   return -1;
13434 3C85           B8                   FFFF  mov	ax,#$FFFF
13435 3C88           89EC                       mov	sp,bp
13436 3C8A           5D                         pop	bp
13437 3C8B           C3                         ret
13438                                           !BCC_EOS
13439                                           ! 2242 ok:
13440                       00003C8C            .FFFA:
13441                       FFFFFFD4            ..FFFA	=	-$2C
13442                                           ! 2243   block_len = (Bit32u) buf[4] << 24
13443                                           ! 2244     | (Bit32u) buf[5] << 16
13444                                           ! 2245     | (Bit32u) buf[6] << 8
13445                                           ! 2246     | (Bit32u) buf[7] << 0;
13446                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13447 3C8C           8A46         F3            mov	al,-$D[bp]
13448 3C8F           30E4                       xor	ah,ah
13449 3C91           31DB                       xor	bx,bx
13450                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13451 3C93           53                         push	bx
13452 3C94           50                         push	ax
13453                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13454 3C95           8A46         F2            mov	al,-$E[bp]
13455 3C98           30E4                       xor	ah,ah
13456 3C9A           31DB                       xor	bx,bx
13457                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13458 3C9C           88DF                       mov	bh,bl
13459 3C9E           88E3                       mov	bl,ah
13460 3CA0           88C4                       mov	ah,al
13461 3CA2           30C0                       xor	al,al
13462 3CA4           53                         push	bx
13463 3CA5           50                         push	ax
13464                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13465 3CA6           8A46         F1            mov	al,-$F[bp]
13466 3CA9           30E4                       xor	ah,ah
13467 3CAB           31DB                       xor	bx,bx
13468                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13469 3CAD           93                         xchg	bx,ax
13470 3CAE           31C0                       xor	ax,ax
13471 3CB0           53                         push	bx
13472 3CB1           50                         push	ax
13473                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13474 3CB2           8A46         F0            mov	al,-$10[bp]
13475 3CB5           30E4                       xor	ah,ah
13476 3CB7           31DB                       xor	bx,bx
13477                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13478 3CB9           88C4                       mov	ah,al
13479 3CBB           30C0                       xor	al,al
13480 3CBD           93                         xchg	bx,ax
13481 3CBE           31C0                       xor	ax,ax
13482                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13483 3CC0           8D7E         CA            lea	di,-$36[bp]
13484 3CC3           E8         C441            call	lorul
13485 3CC6           83C4                   04  add	sp,*4
13486                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13487 3CC9           8D7E         CE            lea	di,-$32[bp]
13488 3CCC           E8         C438            call	lorul
13489 3CCF           83C4                   04  add	sp,*4
13490                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13491 3CD2           8D7E         D2            lea	di,-$2E[bp]
13492 3CD5           E8         C42F            call	lorul
13493 3CD8           83C4                   04  add	sp,*4
13494                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13495 3CDB           8946         E8            mov	-$18[bp],ax
13496 3CDE           895E         EA            mov	-$16[bp],bx
13497                                           !BCC_EOS
13498                                           ! 2247   ;
13499                                           !BCC_EOS
13500                                           ! 2248   if (block_len!= 2048 && block_len!= 512)
13501                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13502                                           ! Debug: expression subtree swapping
13503 3CE1           B8                   0800  mov	ax,#$800
13504 3CE4           31DB                       xor	bx,bx
13505 3CE6           53                         push	bx
13506 3CE7           50                         push	ax
13507 3CE8           8B46         E8            mov	ax,-$18[bp]
13508 3CEB           8B5E         EA            mov	bx,-$16[bp]
13509 3CEE           8D7E         D2            lea	di,-$2E[bp]
13510 3CF1           E8         C3D7            call	lcmpul
13511 3CF4           8D66         D6            lea	sp,-$2A[bp]
13512 3CF7           74           33            je  	.2ED
13513                       00003CF9            .2EF:
13514                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13515                                           ! Debug: expression subtree swapping
13516 3CF9           B8                   0200  mov	ax,#$200
13517 3CFC           31DB                       xor	bx,bx
13518 3CFE           53                         push	bx
13519 3CFF           50                         push	ax
13520 3D00           8B46         E8            mov	ax,-$18[bp]
13521 3D03           8B5E         EA            mov	bx,-$16[bp]
13522 3D06           8D7E         D2            lea	di,-$2E[bp]
13523 3D09           E8         C3BF            call	lcmpul
13524 3D0C           8D66         D6            lea	sp,-$2A[bp]
13525 3D0F           74           1B            je  	.2ED
13526                       00003D11            .2EE:
13527                                           ! 2249   {
13528                                           ! 2250     bios_printf(2, "Unsupported sector size %u\n", block_len);
13529                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13530 3D11           FF76         EA            push	-$16[bp]
13531 3D14           FF76         E8            push	-$18[bp]
13532                                           ! Debug: list * char = .2F0+0 (used reg = )
13533 3D17           BB                   D5E5  mov	bx,#.2F0
13534 3D1A           53                         push	bx
13535                                           ! Debug: list int = const 2 (used reg = )
13536 3D1B           B8                   0002  mov	ax,*2
13537 3D1E           50                         push	ax
13538                                           ! Debug: func () void = bios_printf+0 (used reg = )
13539 3D1F           E8         CC85            call	_bios_printf
13540 3D22           83C4                   08  add	sp,*8
13541                                           !BCC_EOS
13542                                           ! 2251     return -1;
13543 3D25           B8                   FFFF  mov	ax,#$FFFF
13544 3D28           89EC                       mov	sp,bp
13545 3D2A           5D                         pop	bp
13546 3D2B           C3                         ret
13547                                           !BCC_EOS
13548                                           ! 2252   }
13549                                           ! 2253   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13550                       00003D2C            .2ED:
13551                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13552 3D2C           FF76         EA            push	-$16[bp]
13553 3D2F           FF76         E8            push	-$18[bp]
13554                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13555 3D32           8B46         04            mov	ax,4[bp]
13556 3D35           B9                   001E  mov	cx,*$1E
13557 3D38           F7E9                       imul	cx
13558 3D3A           89C3                       mov	bx,ax
13559                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13560                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13561 3D3C           81C3                 0148  add	bx,#$148
13562 3D40           53                         push	bx
13563                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13564 3D41           FF76         D6            push	-$2A[bp]
13565                                           ! Debug: func () void = write_dword+0 (used reg = )
13566 3D44           E8         C354            call	_write_dword
13567 3D47           83C4                   08  add	sp,*8
13568                                           !BCC_EOS
13569                                           ! 2254   sectors = (Bit32u) buf[0] << 24
13570                                           ! 2255     | (Bit32u) buf[1] << 16
13571                                           ! 2256     | (Bit32u) buf[2] << 8
13572                                           ! 2257     | (Bit32u) buf[3] << 0;
13573                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13574 3D4A           8A46         EF            mov	al,-$11[bp]
13575 3D4D           30E4                       xor	ah,ah
13576 3D4F           31DB                       xor	bx,bx
13577                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13578 3D51           53                         push	bx
13579 3D52           50                         push	ax
13580                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13581 3D53           8A46         EE            mov	al,-$12[bp]
13582 3D56           30E4                       xor	ah,ah
13583 3D58           31DB                       xor	bx,bx
13584                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13585 3D5A           88DF                       mov	bh,bl
13586 3D5C           88E3                       mov	bl,ah
13587 3D5E           88C4                       mov	ah,al
13588 3D60           30C0                       xor	al,al
13589 3D62           53                         push	bx
13590 3D63           50                         push	ax
13591                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13592 3D64           8A46         ED            mov	al,-$13[bp]
13593 3D67           30E4                       xor	ah,ah
13594 3D69           31DB                       xor	bx,bx
13595                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13596 3D6B           93                         xchg	bx,ax
13597 3D6C           31C0                       xor	ax,ax
13598 3D6E           53                         push	bx
13599 3D6F           50                         push	ax
13600                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13601 3D70           8A46         EC            mov	al,-$14[bp]
13602 3D73           30E4                       xor	ah,ah
13603 3D75           31DB                       xor	bx,bx
13604                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13605 3D77           88C4                       mov	ah,al
13606 3D79           30C0                       xor	al,al
13607 3D7B           93                         xchg	bx,ax
13608 3D7C           31C0                       xor	ax,ax
13609                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13610 3D7E           8D7E         CA            lea	di,-$36[bp]
13611 3D81           E8         C383            call	lorul
13612 3D84           83C4                   04  add	sp,*4
13613                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13614 3D87           8D7E         CE            lea	di,-$32[bp]
13615 3D8A           E8         C37A            call	lorul
13616 3D8D           83C4                   04  add	sp,*4
13617                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13618 3D90           8D7E         D2            lea	di,-$2E[bp]
13619 3D93           E8         C371            call	lorul
13620 3D96           83C4                   04  add	sp,*4
13621                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13622 3D99           8946         E4            mov	-$1C[bp],ax
13623 3D9C           895E         E6            mov	-$1A[bp],bx
13624                                           !BCC_EOS
13625                                           ! 2258   ;
13626                                           !BCC_EOS
13627                                           ! 2259   if (block_len == 2048)
13628                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13629                                           ! Debug: expression subtree swapping
13630 3D9F           B8                   0800  mov	ax,#$800
13631 3DA2           31DB                       xor	bx,bx
13632 3DA4           53                         push	bx
13633 3DA5           50                         push	ax
13634 3DA6           8B46         E8            mov	ax,-$18[bp]
13635 3DA9           8B5E         EA            mov	bx,-$16[bp]
13636 3DAC           8D7E         D2            lea	di,-$2E[bp]
13637 3DAF           E8         C319            call	lcmpul
13638 3DB2           8D66         D6            lea	sp,-$2A[bp]
13639 3DB5           75           12            jne 	.2F1
13640                       00003DB7            .2F2:
13641                                           ! 2260     sectors <<= 2;
13642                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13643 3DB7           8B46         E4            mov	ax,-$1C[bp]
13644 3DBA           8B5E         E6            mov	bx,-$1A[bp]
13645 3DBD           BF                   0002  mov	di,*2
13646 3DC0           E8         C384            call	lslul
13647 3DC3           8946         E4            mov	-$1C[bp],ax
13648 3DC6           895E         E6            mov	-$1A[bp],bx
13649                                           !BCC_EOS
13650                                           ! 2261   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13651                       00003DC9            .2F1:
13652                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13653 3DC9           8B46         04            mov	ax,4[bp]
13654 3DCC           B9                   001E  mov	cx,*$1E
13655 3DCF           F7E9                       imul	cx
13656 3DD1           89C3                       mov	bx,ax
13657                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13658                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13659 3DD3           81C3                 0158  add	bx,#$158
13660 3DD7           53                         push	bx
13661                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13662 3DD8           FF76         D6            push	-$2A[bp]
13663                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13664 3DDB           E8         C2A5            call	_read_dword
13665 3DDE           89D3                       mov	bx,dx
13666 3DE0           83C4                   04  add	sp,*4
13667                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13668                                           ! Debug: expression subtree swapping
13669 3DE3           8D7E         E4            lea	di,-$1C[bp]
13670 3DE6           E8         C2E2            call	lcmpul
13671 3DE9           74           24            je  	.2F3
13672                       00003DEB            .2F4:
13673                                           ! 2262     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13674                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13675 3DEB           8B46         E4            mov	ax,-$1C[bp]
13676 3DEE           8B5E         E6            mov	bx,-$1A[bp]
13677 3DF1           88E0                       mov	al,ah
13678 3DF3           88DC                       mov	ah,bl
13679 3DF5           88FB                       mov	bl,bh
13680 3DF7           28FF                       sub	bh,bh
13681 3DF9           BF                   0003  mov	di,*3
13682 3DFC           E8         C32A            call	lsrul
13683                                           ! Debug: list unsigned long = bx+0 (used reg = )
13684 3DFF           53                         push	bx
13685 3E00           50                         push	ax
13686                                           ! Debug: list * char = .2F5+0 (used reg = )
13687 3E01           BB                   D5CF  mov	bx,#.2F5
13688 3E04           53                         push	bx
13689                                           ! Debug: list int = const 2 (used reg = )
13690 3E05           B8                   0002  mov	ax,*2
13691 3E08           50                         push	ax
13692                                           ! Debug: func () void = bios_printf+0 (used reg = )
13693 3E09           E8         CB9B            call	_bios_printf
13694 3E0C           83C4                   08  add	sp,*8
13695                                           !BCC_EOS
13696                                           ! 2263   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13697                       00003E0F            .2F3:
13698                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13699 3E0F           FF76         E6            push	-$1A[bp]
13700 3E12           FF76         E4            push	-$1C[bp]
13701                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13702 3E15           8B46         04            mov	ax,4[bp]
13703 3E18           B9                   001E  mov	cx,*$1E
13704 3E1B           F7E9                       imul	cx
13705 3E1D           89C3                       mov	bx,ax
13706                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13707                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13708 3E1F           81C3                 0158  add	bx,#$158
13709 3E23           53                         push	bx
13710                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13711 3E24           FF76         D6            push	-$2A[bp]
13712                                           ! Debug: func () void = write_dword+0 (used reg = )
13713 3E27           E8         C271            call	_write_dword
13714 3E2A           83C4                   08  add	sp,*8
13715                                           !BCC_EOS
13716                                           ! 2264   return 0;
13717 3E2D           31C0                       xor	ax,ax
13718 3E2F           89EC                       mov	sp,bp
13719 3E31           5D                         pop	bp
13720 3E32           C3                         ret
13721                                           !BCC_EOS
13722                                           ! 2265 }
13723                                           ! 2266   Bit16u
13724                                           ! Register BX used in function atapi_is_ready
13725                                           ! 2267 atapi_is_cdrom(device)
13726                                           ! 2268   Bit8u device;
13727                                           export	_atapi_is_cdrom
13728                       00003E33            _atapi_is_cdrom:
13729                                           !BCC_EOS
13730                                           ! 2269 {
13731                                           ! 2270   Bit16u ebda_seg=read_word(0x0040,0x000E);
13732 3E33           55                         push	bp
13733 3E34           89E5                       mov	bp,sp
13734 3E36           4C                         dec	sp
13735 3E37           4C                         dec	sp
13736                                           ! Debug: list int = const $E (used reg = )
13737 3E38           B8                   000E  mov	ax,*$E
13738 3E3B           50                         push	ax
13739                                           ! Debug: list int = const $40 (used reg = )
13740 3E3C           B8                   0040  mov	ax,*$40
13741 3E3F           50                         push	ax
13742                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13743 3E40           E8         C7C8            call	_read_word
13744 3E43           83C4                   04  add	sp,*4
13745                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13746 3E46           8946         FE            mov	-2[bp],ax
13747                                           !BCC_EOS
13748                                           ! 2271   if (device >= (4*2))
13749                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
13750 3E49           8A46         04            mov	al,4[bp]
13751 3E4C           3C                     08  cmp	al,*8
13752 3E4E           72           06            jb  	.2F6
13753                       00003E50            .2F7:
13754                                           ! 2272     return 0;
13755 3E50           31C0                       xor	ax,ax
13756 3E52           89EC                       mov	sp,bp
13757 3E54           5D                         pop	bp
13758 3E55           C3                         ret
13759                                           !BCC_EOS
13760                                           ! 2273   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
13761                       00003E56            .2F6:
13762                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13763 3E56           8A46         04            mov	al,4[bp]
13764 3E59           30E4                       xor	ah,ah
13765 3E5B           B9                   001E  mov	cx,*$1E
13766 3E5E           F7E9                       imul	cx
13767 3E60           89C3                       mov	bx,ax
13768                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13769                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13770 3E62           81C3                 0142  add	bx,#$142
13771 3E66           53                         push	bx
13772                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13773 3E67           FF76         FE            push	-2[bp]
13774                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13775 3E6A           E8         C78B            call	_read_byte
13776 3E6D           83C4                   04  add	sp,*4
13777                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13778 3E70           3C                     03  cmp	al,*3
13779 3E72           74           06            je  	.2F8
13780                       00003E74            .2F9:
13781                                           ! 2274     return 0;
13782 3E74           31C0                       xor	ax,ax
13783 3E76           89EC                       mov	sp,bp
13784 3E78           5D                         pop	bp
13785 3E79           C3                         ret
13786                                           !BCC_EOS
13787                                           ! 2275   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
13788                       00003E7A            .2F8:
13789                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13790 3E7A           8A46         04            mov	al,4[bp]
13791 3E7D           30E4                       xor	ah,ah
13792 3E7F           B9                   001E  mov	cx,*$1E
13793 3E82           F7E9                       imul	cx
13794 3E84           89C3                       mov	bx,ax
13795                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
13796                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
13797 3E86           81C3                 0143  add	bx,#$143
13798 3E8A           53                         push	bx
13799                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13800 3E8B           FF76         FE            push	-2[bp]
13801                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13802 3E8E           E8         C767            call	_read_byte
13803 3E91           83C4                   04  add	sp,*4
13804                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
13805 3E94           3C                     05  cmp	al,*5
13806 3E96           74           06            je  	.2FA
13807                       00003E98            .2FB:
13808                                           ! 2276     return 0;
13809 3E98           31C0                       xor	ax,ax
13810 3E9A           89EC                       mov	sp,bp
13811 3E9C           5D                         pop	bp
13812 3E9D           C3                         ret
13813                                           !BCC_EOS
13814                                           ! 2277   return 1;
13815                       00003E9E            .2FA:
13816 3E9E           B8                   0001  mov	ax,*1
13817 3EA1           89EC                       mov	sp,bp
13818 3EA3           5D                         pop	bp
13819 3EA4           C3                         ret
13820                                           !BCC_EOS
13821                                           ! 2278 }
13822                                           ! 2279   void
13823                                           ! Register BX used in function atapi_is_cdrom
13824                                           ! 2280 cdemu_init()
13825                                           ! 2281 {
13826                                           export	_cdemu_init
13827                       00003EA5            _cdemu_init:
13828                                           ! 2282   Bit16u ebda_seg=read_word(0x0040,0x000E);
13829 3EA5           55                         push	bp
13830 3EA6           89E5                       mov	bp,sp
13831 3EA8           4C                         dec	sp
13832 3EA9           4C                         dec	sp
13833                                           ! Debug: list int = const $E (used reg = )
13834 3EAA           B8                   000E  mov	ax,*$E
13835 3EAD           50                         push	ax
13836                                           ! Debug: list int = const $40 (used reg = )
13837 3EAE           B8                   0040  mov	ax,*$40
13838 3EB1           50                         push	ax
13839                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13840 3EB2           E8         C756            call	_read_word
13841 3EB5           83C4                   04  add	sp,*4
13842                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13843 3EB8           8946         FE            mov	-2[bp],ax
13844                                           !BCC_EOS
13845                                           ! 2283   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
13846                                           ! Debug: list int = const 0 (used reg = )
13847 3EBB           31C0                       xor	ax,ax
13848 3EBD           50                         push	ax
13849                                           ! Debug: list * unsigned char = const $25A (used reg = )
13850 3EBE           B8                   025A  mov	ax,#$25A
13851 3EC1           50                         push	ax
13852                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
13853 3EC2           FF76         FE            push	-2[bp]
13854                                           ! Debug: func () void = write_byte+0 (used reg = )
13855 3EC5           E8         C756            call	_write_byte
13856 3EC8           83C4                   06  add	sp,*6
13857                                           !BCC_EOS
13858                                           ! 2284 }
13859 3ECB           89EC                       mov	sp,bp
13860 3ECD           5D                         pop	bp
13861 3ECE           C3                         ret
13862                                           ! 2285   Bit8u
13863                                           ! 2286 cdemu_isa
13864                                           ! 2286 ctive()
13865                                           ! 2287 {
13866                                           export	_cdemu_isactive
13867                       00003ECF            _cdemu_isactive:
13868                                           ! 2288   Bit16u ebda_seg=read_word(0x0040,0x000E);
13869 3ECF           55                         push	bp
13870 3ED0           89E5                       mov	bp,sp
13871 3ED2           4C                         dec	sp
13872 3ED3           4C                         dec	sp
13873                                           ! Debug: list int = const $E (used reg = )
13874 3ED4           B8                   000E  mov	ax,*$E
13875 3ED7           50                         push	ax
13876                                           ! Debug: list int = const $40 (used reg = )
13877 3ED8           B8                   0040  mov	ax,*$40
13878 3EDB           50                         push	ax
13879                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13880 3EDC           E8         C72C            call	_read_word
13881 3EDF           83C4                   04  add	sp,*4
13882                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13883 3EE2           8946         FE            mov	-2[bp],ax
13884                                           !BCC_EOS
13885                                           ! 2289   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
13886                                           ! Debug: list * unsigned char = const $25A (used reg = )
13887 3EE5           B8                   025A  mov	ax,#$25A
13888 3EE8           50                         push	ax
13889                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13890 3EE9           FF76         FE            push	-2[bp]
13891                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13892 3EEC           E8         C709            call	_read_byte
13893 3EEF           83C4                   04  add	sp,*4
13894                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13895 3EF2           89EC                       mov	sp,bp
13896 3EF4           5D                         pop	bp
13897 3EF5           C3                         ret
13898                                           !BCC_EOS
13899                                           ! 2290 }
13900                                           ! 2291   Bit8u
13901                                           ! 2292 cdemu_emulated_drive()
13902                                           ! 2293 {
13903                                           export	_cdemu_emulated_drive
13904                       00003EF6            _cdemu_emulated_drive:
13905                                           ! 2294   Bit16u ebda_seg=read_word(0x0040,0x000E);
13906 3EF6           55                         push	bp
13907 3EF7           89E5                       mov	bp,sp
13908 3EF9           4C                         dec	sp
13909 3EFA           4C                         dec	sp
13910                                           ! Debug: list int = const $E (used reg = )
13911 3EFB           B8                   000E  mov	ax,*$E
13912 3EFE           50                         push	ax
13913                                           ! Debug: list int = const $40 (used reg = )
13914 3EFF           B8                   0040  mov	ax,*$40
13915 3F02           50                         push	ax
13916                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13917 3F03           E8         C705            call	_read_word
13918 3F06           83C4                   04  add	sp,*4
13919                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13920 3F09           8946         FE            mov	-2[bp],ax
13921                                           !BCC_EOS
13922                                           ! 2295   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
13923                                           ! Debug: list * unsigned char = const $25C (used reg = )
13924 3F0C           B8                   025C  mov	ax,#$25C
13925 3F0F           50                         push	ax
13926                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13927 3F10           FF76         FE            push	-2[bp]
13928                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13929 3F13           E8         C6E2            call	_read_byte
13930 3F16           83C4                   04  add	sp,*4
13931                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13932 3F19           89EC                       mov	sp,bp
13933 3F1B           5D                         pop	bp
13934 3F1C           C3                         ret
13935                                           !BCC_EOS
13936                                           ! 2296 }
13937                                           ! 2297 static char isotag[6]="CD001";
13938                                           
13939                       00003F1D            _isotag:
13940                       00003F1D            .2FC:
13941 3F1D                        43            .ascii	"CD001"
13942 3F22                        00            .byte	0
13943                                           !BCC_EOS
13944                                           ! 2298 static char eltorito[24]="EL TORITO SPECIFICATION";
13945                       00003F23            _eltorito:
13946                       00003F23            .2FD:
13947 3F23                        45            .ascii	"EL TORITO SPECIFICATION"
13948 3F3A                        00            .byte	0
13949                                           !BCC_EOS
13950                                           ! 2299   Bit16u
13951                                           ! 2300 cdrom_boot()
13952                                           ! 2301 {
13953                                           
13954                                           export	_cdrom_boot
13955                       00003F3B            _cdrom_boot:
13956                                           ! 2302   Bit16u ebda_seg=read_word(0x0040,0x000E);
13957 3F3B           55                         push	bp
13958 3F3C           89E5                       mov	bp,sp
13959 3F3E           4C                         dec	sp
13960 3F3F           4C                         dec	sp
13961                                           ! Debug: list int = const $E (used reg = )
13962 3F40           B8                   000E  mov	ax,*$E
13963 3F43           50                         push	ax
13964                                           ! Debug: list int = const $40 (used reg = )
13965 3F44           B8                   0040  mov	ax,*$40
13966 3F47           50                         push	ax
13967                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13968 3F48           E8         C6C0            call	_read_word
13969 3F4B           83C4                   04  add	sp,*4
13970                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13971 3F4E           8946         FE            mov	-2[bp],ax
13972                                           !BCC_EOS
13973                                           ! 2303   Bit8u atacmd[12], buffer[2048];
13974                                           !BCC_EOS
13975                                           ! 2304   Bit32u lba;
13976                                           !BCC_EOS
13977                                           ! 2305   Bit16u boot_segment, nbsectors, i, error;
13978                                           !BCC_EOS
13979                                           ! 2306   Bit8u device;
13980                                           !BCC_EOS
13981                                           ! 2307   for (device=0; device<(4*2);device++) {
13982 3F51           81C4                 F7E6  add	sp,#-$81A
13983                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
13984 3F55           30C0                       xor	al,al
13985 3F57           8886       F7E5            mov	-$81B[bp],al
13986                                           !BCC_EOS
13987                                           !BCC_EOS
13988 3F5B           EB           1B            jmp .300
13989                       00003F5D            .301:
13990                                           ! 2308     if (atapi_is_cdrom(device)) break;
13991                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
13992 3F5D           8A86       F7E5            mov	al,-$81B[bp]
13993 3F61           30E4                       xor	ah,ah
13994 3F63           50                         push	ax
13995                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
13996 3F64           E8         FECC            call	_atapi_is_cdrom
13997 3F67           44                         inc	sp
13998 3F68           44                         inc	sp
13999 3F69           85C0                       test	ax,ax
14000 3F6B           74           02            je  	.302
14001                       00003F6D            .303:
14002 3F6D           EB           11            jmp .2FE
14003                                           !BCC_EOS
14004                                           ! 2309   }
14005                       00003F6F            .302:
14006                                           ! 2310   if(device >= (4*2)) return 2;
14007                       00003F6F            .2FF:
14008                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
14009 3F6F           8A86       F7E5            mov	al,-$81B[bp]
14010 3F73           40                         inc	ax
14011 3F74           8886       F7E5            mov	-$81B[bp],al
14012                       00003F78            .300:
14013                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14014 3F78           8A86       F7E5            mov	al,-$81B[bp]
14015 3F7C           3C                     08  cmp	al,*8
14016 3F7E           72           DD            jb 	.301
14017                       00003F80            .304:
14018                       00003F80            .2FE:
14019                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14020 3F80           8A86       F7E5            mov	al,-$81B[bp]
14021 3F84           3C                     08  cmp	al,*8
14022 3F86           72           07            jb  	.305
14023                       00003F88            .306:
14024 3F88           B8                   0002  mov	ax,*2
14025 3F8B           89EC                       mov	sp,bp
14026 3F8D           5D                         pop	bp
14027 3F8E           C3                         ret
14028                                           !BCC_EOS
14029                                           ! 2311   if(error = atapi_is_ready(device) != 0)
14030                       00003F8F            .305:
14031                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14032 3F8F           8A86       F7E5            mov	al,-$81B[bp]
14033 3F93           30E4                       xor	ah,ah
14034 3F95           50                         push	ax
14035                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
14036 3F96           E8         FBB2            call	_atapi_is_ready
14037 3F99           44                         inc	sp
14038 3F9A           44                         inc	sp
14039                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14040 3F9B           85C0                       test	ax,ax
14041 3F9D           74           04            je 	.309
14042 3F9F           B0                     01  mov	al,*1
14043 3FA1           EB           02            jmp	.30A
14044                       00003FA3            .309:
14045 3FA3           30C0                       xor	al,al
14046                       00003FA5            .30A:
14047                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14048 3FA5           30E4                       xor	ah,ah
14049 3FA7           8986       F7E6            mov	-$81A[bp],ax
14050 3FAB           85C0                       test	ax,ax
14051 3FAD           74           12            je  	.307
14052                       00003FAF            .308:
14053                                           ! 2312     bios_printf(4, "ata_is_ready returned %d\n",error);
14054                                           ! Debug: list unsigned short error = [S+$81E-$81C] (used reg = )
14055 3FAF           FFB6       F7E6            push	-$81A[bp]
14056                                           ! Debug: list * char = .30B+0 (used reg = )
14057 3FB3           BB                   D5B5  mov	bx,#.30B
14058 3FB6           53                         push	bx
14059                                           ! Debug: list int = const 4 (used reg = )
14060 3FB7           B8                   0004  mov	ax,*4
14061 3FBA           50                         push	ax
14062                                           ! Debug: func () void = bios_printf+0 (used reg = )
14063 3FBB           E8         C9E9            call	_bios_printf
14064 3FBE           83C4                   06  add	sp,*6
14065                                           !BCC_EOS
14066                                           ! 2313   memsetb(get_SS(),atacmd,0,12);
14067                       00003FC1            .307:
14068                                           ! Debug: list int = const $C (used reg = )
14069 3FC1           B8                   000C  mov	ax,*$C
14070 3FC4           50                         push	ax
14071                                           ! Debug: list int = const 0 (used reg = )
14072 3FC5           31C0                       xor	ax,ax
14073 3FC7           50                         push	ax
14074                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14075 3FC8           8D5E         F2            lea	bx,-$E[bp]
14076 3FCB           53                         push	bx
14077                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14078 3FCC           E8         C682            call	_get_SS
14079                                           ! Debug: list unsigned short = ax+0 (used reg = )
14080 3FCF           50                         push	ax
14081                                           ! Debug: func () void = memsetb+0 (used reg = )
14082 3FD0           E8         C02D            call	_memsetb
14083 3FD3           83C4                   08  add	sp,*8
14084                                           !BCC_EOS
14085                                           ! 2314   atacmd[0]=0x28;
14086                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14087 3FD6           B0                     28  mov	al,*$28
14088 3FD8           8846         F2            mov	-$E[bp],al
14089                                           !BCC_EOS
14090                                           ! 2315   atacmd[7]=(0x01 & 0xff00) >> 8;
14091                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14092 3FDB           30C0                       xor	al,al
14093 3FDD           8846         F9            mov	-7[bp],al
14094                                           !BCC_EOS
14095                                           ! 2316   atacmd[8]=(0x01 & 0x00ff);
14096                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14097 3FE0           B0                     01  mov	al,*1
14098 3FE2           8846         FA            mov	-6[bp],al
14099                                           !BCC_EOS
14100                                           ! 2317   atacmd[2]=(0x11 & 0xff000000) >> 24;
14101                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14102 3FE5           30C0                       xor	al,al
14103 3FE7           8846         F4            mov	-$C[bp],al
14104                                           !BCC_EOS
14105                                           ! 2318   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
14106                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14107 3FEA           30C0                       xor	al,al
14108 3FEC           8846         F5            mov	-$B[bp],al
14109                                           !BCC_EOS
14110                                           ! 2319   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
14111                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14112 3FEF           30C0                       xor	al,al
14113 3FF1           8846         F6            mov	-$A[bp],al
14114                                           !BCC_EOS
14115                                           ! 2320   atacmd[5]=(0x11 & 0x000000ff);
14116                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14117 3FF4           B0                     11  mov	al,*$11
14118 3FF6           8846         F7            mov	-9[bp],al
14119                                           !BCC_EOS
14120                                           ! 2321   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14121                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14122 3FF9           8D9E       F7F2            lea	bx,-$80E[bp]
14123 3FFD           53                         push	bx
14124                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14125 3FFE           E8         C650            call	_get_SS
14126                                           ! Debug: list unsigned short = ax+0 (used reg = )
14127 4001           50                         push	ax
14128                                           ! Debug: list int = const 1 (used reg = )
14129 4002           B8                   0001  mov	ax,*1
14130 4005           50                         push	ax
14131                                           ! Debug: list long = const $800 (used reg = )
14132 4006           B8                   0800  mov	ax,#$800
14133 4009           31DB                       xor	bx,bx
14134 400B           53                         push	bx
14135 400C           50                         push	ax
14136                                           ! Debug: list int = const 0 (used reg = )
14137 400D           31C0                       xor	ax,ax
14138 400F           50                         push	ax
14139                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14140 4010           8D5E         F2            lea	bx,-$E[bp]
14141 4013           53                         push	bx
14142                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14143 4014           E8         C63A            call	_get_SS
14144                                           ! Debug: list unsigned short = ax+0 (used reg = )
14145 4017           50                         push	ax
14146                                           ! Debug: list int = const $C (used reg = )
14147 4018           B8                   000C  mov	ax,*$C
14148 401B           50                         push	ax
14149                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14150 401C           8A86       F7E5            mov	al,-$81B[bp]
14151 4020           30E4                       xor	ah,ah
14152 4022           50                         push	ax
14153                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14154 4023           E8         F5C1            call	_ata_cmd_packet
14155 4026           83C4                   14  add	sp,*$14
14156                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14157 4029           8986       F7E6            mov	-$81A[bp],ax
14158                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14159 402D           85C0                       test	ax,ax
14160 402F           74           07            je  	.30C
14161                       00004031            .30D:
14162                                           ! 2322     return 3;
14163 4031           B8                   0003  mov	ax,*3
14164 4034           89EC                       mov	sp,bp
14165 4036           5D                         pop	bp
14166 4037           C3                         ret
14167                                           !BCC_EOS
14168                                           ! 2323   if(buffer[0]!=0) return 4;
14169                       00004038            .30C:
14170                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14171 4038           8A86       F7F2            mov	al,-$80E[bp]
14172 403C           84C0                       test	al,al
14173 403E           74           07            je  	.30E
14174                       00004040            .30F:
14175 4040           B8                   0004  mov	ax,*4
14176 4043           89EC                       mov	sp,bp
14177 4045           5D                         pop	bp
14178 4046           C3                         ret
14179                                           !BCC_EOS
14180                                           ! 2324   for(i=0;i<5;i++){
14181                       00004047            .30E:
14182                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14183 4047           31C0                       xor	ax,ax
14184 4049           8986       F7E8            mov	-$818[bp],ax
14185                                           !BCC_EOS
14186                                           !BCC_EOS
14187 404D           EB           3B            jmp .312
14188                       0000404F            .313:
14189                                           ! 2325     if(buffer[1+i]!=read_byte(0xf000,&isotag[i])) return 5;
14190                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14191 404F           8B9E       F7E8            mov	bx,-$818[bp]
14192                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14193                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14194 4053           81C3                 3F1D  add	bx,#_isotag
14195 4057           53                         push	bx
14196                                           ! Debug: list unsigned int = const $F000 (used reg = )
14197 4058           B8                   F000  mov	ax,#$F000
14198 405B           50                         push	ax
14199                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14200 405C           E8         C599            call	_read_byte
14201 405F           83C4                   04  add	sp,*4
14202 4062           50                         push	ax
14203                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14204                                           ! Debug: expression subtree swapping
14205 4063           8B86       F7E8            mov	ax,-$818[bp]
14206                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14207 4067           40                         inc	ax
14208 4068           89EB                       mov	bx,bp
14209 406A           01C3                       add	bx,ax
14210                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
14211 406C           8A87       F7F2            mov	al,-$80E[bx]
14212 4070           3A86       F7E2            cmp	al,-$81E[bp]
14213 4074           8DA6       F7E4            lea	sp,-$81C[bp]
14214 4078           74           07            je  	.314
14215                       0000407A            .315:
14216 407A           B8                   0005  mov	ax,*5
14217 407D           89EC                       mov	sp,bp
14218 407F           5D                         pop	bp
14219 4080           C3                         ret
14220                                           !BCC_EOS
14221                                           ! 2326   }
14222                       00004081            .314:
14223                                           ! 2327   for(i=0;i<23;i++)
14224                       00004081            .311:
14225                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14226 4081           8B86       F7E8            mov	ax,-$818[bp]
14227 4085           40                         inc	ax
14228 4086           8986       F7E8            mov	-$818[bp],ax
14229                       0000408A            .312:
14230                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14231 408A           8B86       F7E8            mov	ax,-$818[bp]
14232 408E           3D                   0005  cmp	ax,*5
14233 4091           72           BC            jb 	.313
14234                       00004093            .316:
14235                       00004093            .310:
14236                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14237 4093           31C0                       xor	ax,ax
14238 4095           8986       F7E8            mov	-$818[bp],ax
14239                                           !BCC_EOS
14240                                           !BCC_EOS
14241                                           ! 2328     if(buffer[7+i]!=read_byte(0xf000,&eltorito[i])) return 6;
14242 4099           EB           3D            jmp .319
14243                       0000409B            .31A:
14244                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14245 409B           8B9E       F7E8            mov	bx,-$818[bp]
14246                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14247                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14248 409F           81C3                 3F23  add	bx,#_eltorito
14249 40A3           53                         push	bx
14250                                           ! Debug: list unsigned int = const $F000 (used reg = )
14251 40A4           B8                   F000  mov	ax,#$F000
14252 40A7           50                         push	ax
14253                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14254 40A8           E8         C54D            call	_read_byte
14255 40AB           83C4                   04  add	sp,*4
14256 40AE           50                         push	ax
14257                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14258                                           ! Debug: expression subtree swapping
14259 40AF           8B86       F7E8            mov	ax,-$818[bp]
14260                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14261 40B3           05                   0007  add	ax,*7
14262 40B6           89EB                       mov	bx,bp
14263 40B8           01C3                       add	bx,ax
14264                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
14265 40BA           8A87       F7F2            mov	al,-$80E[bx]
14266 40BE           3A86       F7E2            cmp	al,-$81E[bp]
14267 40C2           8DA6       F7E4            lea	sp,-$81C[bp]
14268 40C6           74           07            je  	.31B
14269                       000040C8            .31C:
14270 40C8           B8                   0006  mov	ax,*6
14271 40CB           89EC                       mov	sp,bp
14272 40CD           5D                         pop	bp
14273 40CE           C3                         ret
14274                                           !BCC_EOS
14275                                           ! 2329   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14276                       000040CF            .31B:
14277                       000040CF            .318:
14278                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14279 40CF           8B86       F7E8            mov	ax,-$818[bp]
14280 40D3           40                         inc	ax
14281 40D4           8986       F7E8            mov	-$818[bp],ax
14282                       000040D8            .319:
14283                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14284 40D8           8B86       F7E8            mov	ax,-$818[bp]
14285 40DC           3D                   0017  cmp	ax,*$17
14286 40DF           72           BA            jb 	.31A
14287                       000040E1            .31D:
14288                       000040E1            .317:
14289                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14290 40E1           8A86       F839            mov	al,-$7C7[bp]
14291 40E5           30E4                       xor	ah,ah
14292 40E7           31DB                       xor	bx,bx
14293 40E9           53                         push	bx
14294 40EA           50                         push	ax
14295                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14296 40EB           8A86       F83A            mov	al,-$7C6[bp]
14297 40EF           30E4                       xor	ah,ah
14298 40F1           B9                   0100  mov	cx,#$100
14299 40F4           F7E9                       imul	cx
14300                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14301 40F6           31DB                       xor	bx,bx
14302 40F8           53                         push	bx
14303 40F9           50                         push	ax
14304                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14305 40FA           8A86       F83B            mov	al,-$7C5[bp]
14306 40FE           30E4                       xor	ah,ah
14307 4100           31DB                       xor	bx,bx
14308                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14309 4102           53                         push	bx
14310 4103           50                         push	ax
14311 4104           31C0                       xor	ax,ax
14312 4106           BB                   0001  mov	bx,*1
14313 4109           53                         push	bx
14314 410A           50                         push	ax
14315 410B           8B86       F7D8            mov	ax,-$828[bp]
14316 410F           8B9E       F7DA            mov	bx,-$826[bp]
14317 4113           8DBE       F7D4            lea	di,-$82C[bp]
14318 4117           E8         BFCF            call	lmulul
14319 411A           83C4                   08  add	sp,*8
14320 411D           53                         push	bx
14321 411E           50                         push	ax
14322                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14323 411F           8A86       F83C            mov	al,-$7C4[bp]
14324 4123           30E4                       xor	ah,ah
14325 4125           31DB                       xor	bx,bx
14326                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14327 4127           53                         push	bx
14328 4128           50                         push	ax
14329 4129           31C0                       xor	ax,ax
14330 412B           BB                   0100  mov	bx,#$100
14331 412E           53                         push	bx
14332 412F           50                         push	ax
14333 4130           8B86       F7D4            mov	ax,-$82C[bp]
14334 4134           8B9E       F7D6            mov	bx,-$82A[bp]
14335 4138           8DBE       F7D0            lea	di,-$830[bp]
14336 413C           E8         BFAA            call	lmulul
14337 413F           83C4                   08  add	sp,*8
14338                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14339 4142           8DBE       F7D8            lea	di,-$828[bp]
14340 4146           E8         BF7A            call	laddul
14341 4149           83C4                   04  add	sp,*4
14342                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14343 414C           8DBE       F7DC            lea	di,-$824[bp]
14344 4150           E8         BF70            call	laddul
14345 4153           83C4                   04  add	sp,*4
14346                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14347 4156           8DBE       F7E0            lea	di,-$820[bp]
14348 415A           E8         BF66            call	laddul
14349 415D           83C4                   04  add	sp,*4
14350                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14351 4160           8986       F7EE            mov	-$812[bp],ax
14352 4164           899E       F7F0            mov	-$810[bp],bx
14353                                           !BCC_EOS
14354                                           ! 2330   memsetb(get_SS(),atacmd,0,12);
14355                                           ! Debug: list int = const $C (used reg = )
14356 4168           B8                   000C  mov	ax,*$C
14357 416B           50                         push	ax
14358                                           ! Debug: list int = const 0 (used reg = )
14359 416C           31C0                       xor	ax,ax
14360 416E           50                         push	ax
14361                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14362 416F           8D5E         F2            lea	bx,-$E[bp]
14363 4172           53                         push	bx
14364                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14365 4173           E8         C4DB            call	_get_SS
14366                                           ! Debug: list unsigned short = ax+0 (used reg = )
14367 4176           50                         push	ax
14368                                           ! Debug: func () void = memsetb+0 (used reg = )
14369 4177           E8         BE86            call	_memsetb
14370 417A           83C4                   08  add	sp,*8
14371                                           !BCC_EOS
14372                                           ! 2331   atacmd[0]=0x28;
14373                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14374 417D           B0                     28  mov	al,*$28
14375 417F           8846         F2            mov	-$E[bp],al
14376                                           !BCC_EOS
14377                                           ! 2332   atacmd[7]=(0x01 & 0xff00) >> 8;
14378                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14379 4182           30C0                       xor	al,al
14380 4184           8846         F9            mov	-7[bp],al
14381                                           !BCC_EOS
14382                                           ! 2333   atacmd[8]=(0x01 & 0x00ff);
14383                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14384 4187           B0                     01  mov	al,*1
14385 4189           8846         FA            mov	-6[bp],al
14386                                           !BCC_EOS
14387                                           ! 2334   atacmd[2]=(lba & 0xff000000) >> 24;
14388                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14389                                           ! Debug: expression subtree swapping
14390 418C           31C0                       xor	ax,ax
14391 418E           BB                   FF00  mov	bx,#$FF00
14392 4191           8DBE       F7EE            lea	di,-$812[bp]
14393 4195           E8         BF23            call	landul
14394                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14395 4198           93                         xchg	bx,ax
14396 4199           88E0                       mov	al,ah
14397 419B           30E4                       xor	ah,ah
14398 419D           31DB                       xor	bx,bx
14399                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14400 419F           8846         F4            mov	-$C[bp],al
14401                                           !BCC_EOS
14402                                           ! 2335   atacmd[3]=(lba & 0x00ff0000) >> 16;
14403                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14404                                           ! Debug: expression subtree swapping
14405 41A2           31C0                       xor	ax,ax
14406 41A4           BB                   00FF  mov	bx,#$FF
14407 41A7           8DBE       F7EE            lea	di,-$812[bp]
14408 41AB           E8         BF0D            call	landul
14409                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14410 41AE           93                         xchg	bx,ax
14411 41AF           31DB                       xor	bx,bx
14412                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14413 41B1           8846         F5            mov	-$B[bp],al
14414                                           !BCC_EOS
14415                                           ! 2336   atacmd[4]=(lba & 0x0000ff00) >> 8;
14416                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14417                                           ! Debug: expression subtree swapping
14418 41B4           B8                   FF00  mov	ax,#$FF00
14419 41B7           31DB                       xor	bx,bx
14420 41B9           8DBE       F7EE            lea	di,-$812[bp]
14421 41BD           E8         BEFB            call	landul
14422                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14423 41C0           88E0                       mov	al,ah
14424 41C2           88DC                       mov	ah,bl
14425 41C4           88FB                       mov	bl,bh
14426 41C6           28FF                       sub	bh,bh
14427                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14428 41C8           8846         F6            mov	-$A[bp],al
14429                                           !BCC_EOS
14430                                           ! 2337   atacmd[5]=(lba & 0x000000ff);
14431                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14432                                           ! Debug: expression subtree swapping
14433 41CB           B8                   00FF  mov	ax,#$FF
14434 41CE           31DB                       xor	bx,bx
14435 41D0           8DBE       F7EE            lea	di,-$812[bp]
14436 41D4           E8         BEE4            call	landul
14437                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14438 41D7           8846         F7            mov	-9[bp],al
14439                                           !BCC_EOS
14440                                           ! 2338   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14441                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14442 41DA           8D9E       F7F2            lea	bx,-$80E[bp]
14443 41DE           53                         push	bx
14444                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14445 41DF           E8         C46F            call	_get_SS
14446                                           ! Debug: list unsigned short = ax+0 (used reg = )
14447 41E2           50                         push	ax
14448                                           ! Debug: list int = const 1 (used reg = )
14449 41E3           B8                   0001  mov	ax,*1
14450 41E6           50                         push	ax
14451                                           ! Debug: list long = const $800 (used reg = )
14452 41E7           B8                   0800  mov	ax,#$800
14453 41EA           31DB                       xor	bx,bx
14454 41EC           53                         push	bx
14455 41ED           50                         push	ax
14456                                           ! Debug: list int = const 0 (used reg = )
14457 41EE           31C0                       xor	ax,ax
14458 41F0           50                         push	ax
14459                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14460 41F1           8D5E         F2            lea	bx,-$E[bp]
14461 41F4           53                         push	bx
14462                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14463 41F5           E8         C459            call	_get_SS
14464                                           ! Debug: list unsigned short = ax+0 (used reg = )
14465 41F8           50                         push	ax
14466                                           ! Debug: list int = const $C (used reg = )
14467 41F9           B8                   000C  mov	ax,*$C
14468 41FC           50                         push	ax
14469                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14470 41FD           8A86       F7E5            mov	al,-$81B[bp]
14471 4201           30E4                       xor	ah,ah
14472 4203           50                         push	ax
14473                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14474 4204           E8         F3E0            call	_ata_cmd_packet
14475 4207           83C4                   14  add	sp,*$14
14476                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14477 420A           8986       F7E6            mov	-$81A[bp],ax
14478                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14479 420E           85C0                       test	ax,ax
14480 4210           74           07            je  	.31E
14481                       00004212            .31F:
14482                                           ! 2339     return 7;
14483 4212           B8                   0007  mov	ax,*7
14484 4215           89EC                       mov	sp,bp
14485 4217           5D                         pop	bp
14486 4218           C3                         ret
14487                                           !BCC_EOS
14488                                           ! 2340   if(buffer[0x00]!=0x01)return 8;
14489                       00004219            .31E:
14490                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14491 4219           8A86       F7F2            mov	al,-$80E[bp]
14492 421D           3C                     01  cmp	al,*1
14493 421F           74           07            je  	.320
14494                       00004221            .321:
14495 4221           B8                   0008  mov	ax,*8
14496 4224           89EC                       mov	sp,bp
14497 4226           5D                         pop	bp
14498 4227           C3                         ret
14499                                           !BCC_EOS
14500                                           ! 2341   if(buffer[0x01]!=0x00)return 9;
14501                       00004228            .320:
14502                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14503 4228           8A86       F7F3            mov	al,-$80D[bp]
14504 422C           84C0                       test	al,al
14505 422E           74           07            je  	.322
14506                       00004230            .323:
14507 4230           B8                   0009  mov	ax,*9
14508 4233           89EC                       mov	sp,bp
14509 4235           5D                         pop	bp
14510 4236           C3                         ret
14511                                           !BCC_EOS
14512                                           ! 2342   if(buffer[0x1E]!=0x55)return 10;
14513                       00004237            .322:
14514                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14515 4237           8A86       F810            mov	al,-$7F0[bp]
14516 423B           3C                     55  cmp	al,*$55
14517 423D           74           07            je  	.324
14518                       0000423F            .325:
14519 423F           B8                   000A  mov	ax,*$A
14520 4242           89EC                       mov	sp,bp
14521 4244           5D                         pop	bp
14522 4245           C3                         ret
14523                                           !BCC_EOS
14524                                           ! 2343   if(buffer[0x1F]!=0xAA)return 10;
14525                       00004246            .324:
14526                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14527 4246           8A86       F811            mov	al,-$7EF[bp]
14528 424A           3C                     AA  cmp	al,#$AA
14529 424C           74           07            je  	.326
14530                       0000424E            .327:
14531 424E           B8                   000A  mov	ax,*$A
14532 4251           89EC                       mov	sp,bp
14533 4253           5D                         pop	bp
14534 4254           C3                         ret
14535                                           !BCC_EOS
14536                                           ! 2344   if(buffer[0x20]!=0x88)return 11;
14537                       00004255            .326:
14538                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14539 4255           8A86       F812            mov	al,-$7EE[bp]
14540 4259           3C                     88  cmp	al,#$88
14541 425B           74           07            je  	.328
14542                       0000425D            .329:
14543 425D           B8                   000B  mov	ax,*$B
14544 4260           89EC                       mov	sp,bp
14545 4262           5D                         pop	bp
14546 4263           C3                         ret
14547                                           !BCC_EOS
14548                                           ! 2345   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14549                       00004264            .328:
14550                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14551 4264           8A86       F813            mov	al,-$7ED[bp]
14552 4268           30E4                       xor	ah,ah
14553 426A           50                         push	ax
14554                                           ! Debug: list * unsigned char = const $25B (used reg = )
14555 426B           B8                   025B  mov	ax,#$25B
14556 426E           50                         push	ax
14557                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14558 426F           FF76         FE            push	-2[bp]
14559                                           ! Debug: func () void = write_byte+0 (used reg = )
14560 4272           E8         C3A9            call	_write_byte
14561 4275           83C4                   06  add	sp,*6
14562                                           !BCC_EOS
14563                                           ! 2346   if(buffer[0x21]==0){
14564                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14565 4278           8A86       F813            mov	al,-$7ED[bp]
14566 427C           84C0                       test	al,al
14567 427E           75           13            jne 	.32A
14568                       00004280            .32B:
14569                                           ! 2347     
14570                                           ! 2347 write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14571                                           ! Debug: list int = const $E0 (used reg = )
14572 4280           B8                   00E0  mov	ax,#$E0
14573 4283           50                         push	ax
14574                                           ! Debug: list * unsigned char = const $25C (used reg = )
14575 4284           B8                   025C  mov	ax,#$25C
14576 4287           50                         push	ax
14577                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14578 4288           FF76         FE            push	-2[bp]
14579                                           ! Debug: func () void = write_byte+0 (used reg = )
14580 428B           E8         C390            call	_write_byte
14581 428E           83C4                   06  add	sp,*6
14582                                           !BCC_EOS
14583                                           ! 2348   }
14584                                           ! 2349   else if(buffer[0x21]<4)
14585 4291           EB           2B            jmp .32C
14586                       00004293            .32A:
14587                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14588 4293           8A86       F813            mov	al,-$7ED[bp]
14589 4297           3C                     04  cmp	al,*4
14590 4299           73           12            jae 	.32D
14591                       0000429B            .32E:
14592                                           ! 2350     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14593                                           ! Debug: list int = const 0 (used reg = )
14594 429B           31C0                       xor	ax,ax
14595 429D           50                         push	ax
14596                                           ! Debug: list * unsigned char = const $25C (used reg = )
14597 429E           B8                   025C  mov	ax,#$25C
14598 42A1           50                         push	ax
14599                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14600 42A2           FF76         FE            push	-2[bp]
14601                                           ! Debug: func () void = write_byte+0 (used reg = )
14602 42A5           E8         C376            call	_write_byte
14603 42A8           83C4                   06  add	sp,*6
14604                                           !BCC_EOS
14605                                           ! 2351   else
14606                                           ! 2352     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14607 42AB           EB           11            jmp .32F
14608                       000042AD            .32D:
14609                                           ! Debug: list int = const $80 (used reg = )
14610 42AD           B8                   0080  mov	ax,#$80
14611 42B0           50                         push	ax
14612                                           ! Debug: list * unsigned char = const $25C (used reg = )
14613 42B1           B8                   025C  mov	ax,#$25C
14614 42B4           50                         push	ax
14615                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14616 42B5           FF76         FE            push	-2[bp]
14617                                           ! Debug: func () void = write_byte+0 (used reg = )
14618 42B8           E8         C363            call	_write_byte
14619 42BB           83C4                   06  add	sp,*6
14620                                           !BCC_EOS
14621                                           ! 2353   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
14622                       000042BE            .32F:
14623                       000042BE            .32C:
14624                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14625 42BE           8A86       F7E5            mov	al,-$81B[bp]
14626 42C2           30E4                       xor	ah,ah
14627 42C4           D1E8                       shr	ax,*1
14628                                           ! Debug: list unsigned int = ax+0 (used reg = )
14629 42C6           50                         push	ax
14630                                           ! Debug: list * unsigned char = const $25D (used reg = )
14631 42C7           B8                   025D  mov	ax,#$25D
14632 42CA           50                         push	ax
14633                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14634 42CB           FF76         FE            push	-2[bp]
14635                                           ! Debug: func () void = write_byte+0 (used reg = )
14636 42CE           E8         C34D            call	_write_byte
14637 42D1           83C4                   06  add	sp,*6
14638                                           !BCC_EOS
14639                                           ! 2354   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14640                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14641 42D4           8A86       F7E5            mov	al,-$81B[bp]
14642 42D8           30E4                       xor	ah,ah
14643 42DA           24                     01  and	al,*1
14644                                           ! Debug: list unsigned char = al+0 (used reg = )
14645 42DC           30E4                       xor	ah,ah
14646 42DE           50                         push	ax
14647                                           ! Debug: list * unsigned short = const $25E (used reg = )
14648 42DF           B8                   025E  mov	ax,#$25E
14649 42E2           50                         push	ax
14650                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14651 42E3           FF76         FE            push	-2[bp]
14652                                           ! Debug: func () void = write_byte+0 (used reg = )
14653 42E6           E8         C335            call	_write_byte
14654 42E9           83C4                   06  add	sp,*6
14655                                           !BCC_EOS
14656                                           ! 2355   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14657                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14658 42EC           8A86       F815            mov	al,-$7EB[bp]
14659 42F0           30E4                       xor	ah,ah
14660 42F2           B9                   0100  mov	cx,#$100
14661 42F5           F7E9                       imul	cx
14662                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14663 42F7           0286       F814            add	al,-$7EC[bp]
14664 42FB           80D4                   00  adc	ah,*0
14665                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14666 42FE           8986       F7EC            mov	-$814[bp],ax
14667                                           !BCC_EOS
14668                                           ! 2356   if(boot_segment==0x0000)boot_segment=0x07C0;
14669                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14670 4302           8B86       F7EC            mov	ax,-$814[bp]
14671 4306           85C0                       test	ax,ax
14672 4308           75           07            jne 	.330
14673                       0000430A            .331:
14674                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14675 430A           B8                   07C0  mov	ax,#$7C0
14676 430D           8986       F7EC            mov	-$814[bp],ax
14677                                           !BCC_EOS
14678                                           ! 2357   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14679                       00004311            .330:
14680                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14681 4311           FFB6       F7EC            push	-$814[bp]
14682                                           ! Debug: list * unsigned short = const $266 (used reg = )
14683 4315           B8                   0266  mov	ax,#$266
14684 4318           50                         push	ax
14685                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14686 4319           FF76         FE            push	-2[bp]
14687                                           ! Debug: func () void = write_word+0 (used reg = )
14688 431C           E8         C317            call	_write_word
14689 431F           83C4                   06  add	sp,*6
14690                                           !BCC_EOS
14691                                           ! 2358   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14692                                           ! Debug: list int = const 0 (used reg = )
14693 4322           31C0                       xor	ax,ax
14694 4324           50                         push	ax
14695                                           ! Debug: list * unsigned short = const $264 (used reg = )
14696 4325           B8                   0264  mov	ax,#$264
14697 4328           50                         push	ax
14698                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14699 4329           FF76         FE            push	-2[bp]
14700                                           ! Debug: func () void = write_word+0 (used reg = )
14701 432C           E8         C307            call	_write_word
14702 432F           83C4                   06  add	sp,*6
14703                                           !BCC_EOS
14704                                           ! 2359   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14705                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14706 4332           8A86       F819            mov	al,-$7E7[bp]
14707 4336           30E4                       xor	ah,ah
14708 4338           B9                   0100  mov	cx,#$100
14709 433B           F7E9                       imul	cx
14710                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
14711 433D           0286       F818            add	al,-$7E8[bp]
14712 4341           80D4                   00  adc	ah,*0
14713                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14714 4344           8986       F7EA            mov	-$816[bp],ax
14715                                           !BCC_EOS
14716                                           ! 2360   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
14717                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
14718 4348           FFB6       F7EA            push	-$816[bp]
14719                                           ! Debug: list * unsigned short = const $268 (used reg = )
14720 434C           B8                   0268  mov	ax,#$268
14721 434F           50                         push	ax
14722                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14723 4350           FF76         FE            push	-2[bp]
14724                                           ! Debug: func () void = write_word+0 (used reg = )
14725 4353           E8         C2E0            call	_write_word
14726 4356           83C4                   06  add	sp,*6
14727                                           !BCC_EOS
14728                                           ! 2361   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
14729                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
14730 4359           8A86       F81A            mov	al,-$7E6[bp]
14731 435D           30E4                       xor	ah,ah
14732 435F           31DB                       xor	bx,bx
14733 4361           53                         push	bx
14734 4362           50                         push	ax
14735                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
14736 4363           8A86       F81B            mov	al,-$7E5[bp]
14737 4367           30E4                       xor	ah,ah
14738 4369           B9                   0100  mov	cx,#$100
14739 436C           F7E9                       imul	cx
14740                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14741 436E           31DB                       xor	bx,bx
14742 4370           53                         push	bx
14743 4371           50                         push	ax
14744                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
14745 4372           8A86       F81C            mov	al,-$7E4[bp]
14746 4376           30E4                       xor	ah,ah
14747 4378           31DB                       xor	bx,bx
14748                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14749 437A           53                         push	bx
14750 437B           50                         push	ax
14751 437C           31C0                       xor	ax,ax
14752 437E           BB                   0001  mov	bx,*1
14753 4381           53                         push	bx
14754 4382           50                         push	ax
14755 4383           8B86       F7D8            mov	ax,-$828[bp]
14756 4387           8B9E       F7DA            mov	bx,-$826[bp]
14757 438B           8DBE       F7D4            lea	di,-$82C[bp]
14758 438F           E8         BD57            call	lmulul
14759 4392           83C4                   08  add	sp,*8
14760 4395           53                         push	bx
14761 4396           50                         push	ax
14762                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
14763 4397           8A86       F81D            mov	al,-$7E3[bp]
14764 439B           30E4                       xor	ah,ah
14765 439D           31DB                       xor	bx,bx
14766                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14767 439F           53                         push	bx
14768 43A0           50                         push	ax
14769 43A1           31C0                       xor	ax,ax
14770 43A3           BB                   0100  mov	bx,#$100
14771 43A6           53                         push	bx
14772 43A7           50                         push	ax
14773 43A8           8B86       F7D4            mov	ax,-$82C[bp]
14774 43AC           8B9E       F7D6            mov	bx,-$82A[bp]
14775 43B0           8DBE       F7D0            lea	di,-$830[bp]
14776 43B4           E8         BD32            call	lmulul
14777 43B7           83C4                   08  add	sp,*8
14778                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14779 43BA           8DBE       F7D8            lea	di,-$828[bp]
14780 43BE           E8         BD02            call	laddul
14781 43C1           83C4                   04  add	sp,*4
14782                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14783 43C4           8DBE       F7DC            lea	di,-$824[bp]
14784 43C8           E8         BCF8            call	laddul
14785 43CB           83C4                   04  add	sp,*4
14786                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14787 43CE           8DBE       F7E0            lea	di,-$820[bp]
14788 43D2           E8         BCEE            call	laddul
14789 43D5           83C4                   04  add	sp,*4
14790                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14791 43D8           8986       F7EE            mov	-$812[bp],ax
14792 43DC           899E       F7F0            mov	-$810[bp],bx
14793                                           !BCC_EOS
14794                                           ! 2362   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
14795                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
14796 43E0           FFB6       F7F0            push	-$810[bp]
14797 43E4           FFB6       F7EE            push	-$812[bp]
14798                                           ! Debug: list * unsigned long = const $260 (used reg = )
14799 43E8           B8                   0260  mov	ax,#$260
14800 43EB           50                         push	ax
14801                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
14802 43EC           FF76         FE            push	-2[bp]
14803                                           ! Debug: func () void = write_dword+0 (used reg = )
14804 43EF           E8         BCA9            call	_write_dword
14805 43F2           83C4                   08  add	sp,*8
14806                                           !BCC_EOS
14807                                           ! 2363   memsetb(get_SS(),atacmd,0,12);
14808                                           ! Debug: list int = const $C (used reg = )
14809 43F5           B8                   000C  mov	ax,*$C
14810 43F8           50                         push	ax
14811                                           ! Debug: list int = const 0 (used reg = )
14812 43F9           31C0                       xor	ax,ax
14813 43FB           50                         push	ax
14814                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14815 43FC           8D5E         F2            lea	bx,-$E[bp]
14816 43FF           53                         push	bx
14817                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14818 4400           E8         C24E            call	_get_SS
14819                                           ! Debug: list unsigned short = ax+0 (used reg = )
14820 4403           50                         push	ax
14821                                           ! Debug: func () void = memsetb+0 (used reg = )
14822 4404           E8         BBF9            call	_memsetb
14823 4407           83C4                   08  add	sp,*8
14824                                           !BCC_EOS
14825                                           ! 2364   atacmd[0]=0x28;
14826                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14827 440A           B0                     28  mov	al,*$28
14828 440C           8846         F2            mov	-$E[bp],al
14829                                           !BCC_EOS
14830                                           ! 2365   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
14831                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14832 440F           8B86       F7EA            mov	ax,-$816[bp]
14833                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14834 4413           48                         dec	ax
14835 4414           D1E8                       shr	ax,*1
14836 4416           D1E8                       shr	ax,*1
14837                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14838                                           ! Debug: expression subtree swapping
14839                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
14840 4418           40                         inc	ax
14841 4419           30C0                       xor	al,al
14842                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
14843 441B           88E0                       mov	al,ah
14844 441D           30E4                       xor	ah,ah
14845                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14846 441F           8846         F9            mov	-7[bp],al
14847                                           !BCC_EOS
14848                                           ! 2366   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
14849                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14850 4422           8B86       F7EA            mov	ax,-$816[bp]
14851                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14852 4426           48                         dec	ax
14853 4427           D1E8                       shr	ax,*1
14854 4429           D1E8                       shr	ax,*1
14855                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14856                                           ! Debug: expression subtree swapping
14857                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
14858 442B           40                         inc	ax
14859                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
14860 442C           8846         FA            mov	-6[bp],al
14861                                           !BCC_EOS
14862                                           ! 2367   atacmd[2]=(lba & 0xff000000) >> 24;
14863                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14864                                           ! Debug: expression subtree swapping
14865 442F           31C0                       xor	ax,ax
14866 4431           BB                   FF00  mov	bx,#$FF00
14867 4434           8DBE       F7EE            lea	di,-$812[bp]
14868 4438           E8         BC80            call	landul
14869                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14870 443B           93                         xchg	bx,ax
14871 443C           88E0                       mov	al,ah
14872 443E           30E4                       xor	ah,ah
14873 4440           31DB                       xor	bx,bx
14874                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14875 4442           8846         F4            mov	-$C[bp],al
14876                                           !BCC_EOS
14877                                           ! 2368   atacmd[3]=(lba & 0x00ff0000) >> 16;
14878                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14879                                           ! Debug: expression subtree swapping
14880 4445           31C0                       xor	ax,ax
14881 4447           BB                   00FF  mov	bx,#$FF
14882 444A           8DBE       F7EE            lea	di,-$812[bp]
14883 444E           E8         BC6A            call	landul
14884                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14885 4451           93                         xchg	bx,ax
14886 4452           31DB                       xor	bx,bx
14887                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14888 4454           8846         F5            mov	-$B[bp],al
14889                                           !BCC_EOS
14890                                           ! 2369   atacmd[4]=(lba & 0x0000ff00) >> 8;
14891                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14892                                           ! Debug: expression subtree swapping
14893 4457           B8                   FF00  mov	ax,#$FF00
14894 445A           31DB                       xor	bx,bx
14895 445C           8DBE       F7EE            lea	di,-$812[bp]
14896 4460           E8         BC58            call	landul
14897                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14898 4463           88E0                       mov	al,ah
14899 4465           88DC                       mov	ah,bl
14900 4467           88FB                       mov	bl,bh
14901 4469           28FF                       sub	bh,bh
14902                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14903 446B           8846         F6            mov	-$A[bp],al
14904                                           !BCC_EOS
14905                                           ! 2370   atacmd[5]=(lba & 0x000000ff);
14906                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14907                                           ! Debug: expression subtree swapping
14908 446E           B8                   00FF  mov	ax,#$FF
14909 4471           31DB                       xor	bx,bx
14910 4473           8DBE       F7EE            lea	di,-$812[bp]
14911 4477           E8         BC41            call	landul
14912                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14913 447A           8846         F7            mov	-9[bp],al
14914                                           !BCC_EOS
14915                                           ! 2371   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
14916                                           ! Debug: list int = const 0 (used reg = )
14917 447D           31C0                       xor	ax,ax
14918 447F           50                         push	ax
14919                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
14920 4480           FFB6       F7EC            push	-$814[bp]
14921                                           ! Debug: list int = const 1 (used reg = )
14922 4484           B8                   0001  mov	ax,*1
14923 4487           50                         push	ax
14924                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
14925 4488           8B86       F7EA            mov	ax,-$816[bp]
14926 448C           31DB                       xor	bx,bx
14927                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
14928 448E           53                         push	bx
14929 448F           50                         push	ax
14930 4490           B8                   0200  mov	ax,#$200
14931 4493           31DB                       xor	bx,bx
14932 4495           53                         push	bx
14933 4496           50                         push	ax
14934 4497           8B86       F7DA            mov	ax,-$826[bp]
14935 449B           8B9E       F7DC            mov	bx,-$824[bp]
14936 449F           8DBE       F7D6            lea	di,-$82A[bp]
14937 44A3           E8         BC43            call	lmulul
14938 44A6           83C4                   08  add	sp,*8
14939                                           ! Debug: list unsigned long = bx+0 (used reg = )
14940 44A9           53                         push	bx
14941 44AA           50                         push	ax
14942                                           ! Debug: list int = const 0 (used reg = )
14943 44AB           31C0                       xor	ax,ax
14944 44AD           50                         push	ax
14945                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14946 44AE           8D5E         F2            lea	bx,-$E[bp]
14947 44B1           53                         push	bx
14948                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14949 44B2           E8         C19C            call	_get_SS
14950                                           ! Debug: list unsigned short = ax+0 (used reg = )
14951 44B5           50                         push	ax
14952                                           ! Debug: list int = const $C (used reg = )
14953 44B6           B8                   000C  mov	ax,*$C
14954 44B9           50                         push	ax
14955                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14956 44BA           8A86       F7E5            mov	al,-$81B[bp]
14957 44BE           30E4                       xor	ah,ah
14958 44C0           50                         push	ax
14959                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14960 44C1           E8         F123            call	_ata_cmd_packet
14961 44C4           83C4                   14  add	sp,*$14
14962                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14963 44C7           8986       F7E6            mov	-$81A[bp],ax
14964                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14965 44CB           85C0                       test	ax,ax
14966 44CD           74           07            je  	.332
14967                       000044CF            .333:
14968                                           ! 2372     return 12;
14969 44CF           B8                   000C  mov	ax,*$C
14970 44D2           89EC                       mov	sp,bp
14971 44D4           5D                         pop	bp
14972 44D5           C3                         ret
14973                                           !BCC_EOS
14974                                           ! 2373   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
14975                       000044D6            .332:
14976                                           ! Debug: list * unsigned char = const $25B (used reg = )
14977 44D6           B8                   025B  mov	ax,#$25B
14978 44D9           50                         push	ax
14979                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
14980 44DA           FF76         FE            push	-2[bp]
14981                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14982 44DD           E8         C118            call	_read_byte
14983 44E0           83C4                   04  add	sp,*4
14984 44E3           E9         0120            br 	.336
14985                                           ! 2374     case 0x01:
14986                                           ! 2375       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
14987                       000044E6            .337:
14988                                           ! Debug: list int = const $F (used reg = )
14989 44E6           B8                   000F  mov	ax,*$F
14990 44E9           50                         push	ax
14991                                           ! Debug: list * unsigned short = const $26E (used reg = )
14992 44EA           B8                   026E  mov	ax,#$26E
14993 44ED           50                         push	ax
14994                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14995 44EE           FF76         FE            push	-2[bp]
14996                                           ! Debug: func () void = write_word+0 (used reg = )
14997 44F1           E8         C142            call	_write_word
14998 44F4           83C4                   06  add	sp,*6
14999                                           !BCC_EOS
15000                                           ! 2376       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15001                                           ! Debug: list int = const $50 (used reg = )
15002 44F7           B8                   0050  mov	ax,*$50
15003 44FA           50                         push	ax
15004                                           ! Debug: list * unsigned short = const $26C (used reg = )
15005 44FB           B8                   026C  mov	ax,#$26C
15006 44FE           50                         push	ax
15007                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15008 44FF           FF76         FE            push	-2[bp]
15009                                           ! Debug: func () void = write_word+0 (used reg = )
15010 4502           E8         C131            call	_write_word
15011 4505           83C4                   06  add	sp,*6
15012                                           !BCC_EOS
15013                                           ! 2377       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15014                                           ! Debug: list int = const 2 (used reg = )
15015 4508           B8                   0002  mov	ax,*2
15016 450B           50                         push	ax
15017                                           ! Debug: list * unsigned short = const $26A (used reg = )
15018 450C           B8                   026A  mov	ax,#$26A
15019 450F           50                         push	ax
15020                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15021 4510           FF76         FE            push	-2[bp]
15022                                           ! Debug: func () void = write_word+0 (used reg = )
15023 4513           E8         C120            call	_write_word
15024 4516           83C4                   06  add	sp,*6
15025                                           !BCC_EOS
15026                                           ! 2378       break;
15027 4519           E9         0102            br 	.334
15028                                           !BCC_EOS
15029                                           ! 2379     case 0x02:
15030                                           ! 2380       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
15031                       0000451C            .338:
15032                                           ! Debug: list int = const $12 (used reg = )
15033 451C           B8                   0012  mov	ax,*$12
15034 451F           50                         push	ax
15035                                           ! Debug: list * unsigned short = const $26E (used reg = )
15036 4520           B8                   026E  mov	ax,#$26E
15037 4523           50                         push	ax
15038                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15039 4524           FF76         FE            push	-2[bp]
15040                                           ! Debug: func () void = write_word+0 (used reg = )
15041 4527           E8         C10C            call	_write_word
15042 452A           83C4                   06  add	sp,*6
15043                                           !BCC_EOS
15044                                           ! 2381       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15045                                           ! Debug: list int = const $50 (used reg = )
15046 452D           B8                   0050  mov	ax,*$50
15047 4530           50                         push	ax
15048                                           ! Debug: list * unsigned short = const $26C (used reg = )
15049 4531           B8                   026C  mov	ax,#$26C
15050 4534           50                         push	ax
15051                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15052 4535           FF76         FE            push	-2[bp]
15053                                           ! Debug: func () void = write_word+0 (used reg = )
15054 4538           E8         C0FB            call	_write_word
15055 453B           83C4                   06  add	sp,*6
15056                                           !BCC_EOS
15057                                           ! 2382       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15058                                           ! Debug: list int = const 2 (used reg = )
15059 453E           B8                   0002  mov	ax,*2
15060 4541           50                         push	ax
15061                                           ! Debug: list * unsigned short = const $26A (used reg = )
15062 4542           B8                   026A  mov	ax,#$26A
15063 4545           50                         push	ax
15064                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15065 4546           FF76         FE            push	-2[bp]
15066                                           ! Debug: func () void = write_word+0 (used reg = )
15067 4549           E8         C0EA            call	_write_word
15068 454C           83C4                   06  add	sp,*6
15069                                           !BCC_EOS
15070                                           ! 2383       break;
15071 454F           E9         00CC            br 	.334
15072                                           !BCC_EOS
15073                                           ! 2384     case 0x03:
15074                                           ! 2385       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
15075                       00004552            .339:
15076                                           ! Debug: list int = const $24 (used reg = )
15077 4552           B8                   0024  mov	ax,*$24
15078 4555           50                         push	ax
15079                                           ! Debug: list * unsigned short = const $26E (used reg = )
15080 4556           B8                   026E  mov	ax,#$26E
15081 4559           50                         push	ax
15082                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15083 455A           FF76         FE            push	-2[bp]
15084                                           ! Debug: func () void = write_word+0 (used reg = )
15085 455D           E8         C0D6            call	_write_word
15086 4560           83C4                   06  add	sp,*6
15087                                           !BCC_EOS
15088                                           ! 2386       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders
15089                                           ! 2386 ,80);
15090                                           ! Debug: list int = const $50 (used reg = )
15091 4563           B8                   0050  mov	ax,*$50
15092 4566           50                         push	ax
15093                                           ! Debug: list * unsigned short = const $26C (used reg = )
15094 4567           B8                   026C  mov	ax,#$26C
15095 456A           50                         push	ax
15096                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15097 456B           FF76         FE            push	-2[bp]
15098                                           ! Debug: func () void = write_word+0 (used reg = )
15099 456E           E8         C0C5            call	_write_word
15100 4571           83C4                   06  add	sp,*6
15101                                           !BCC_EOS
15102                                           ! 2387       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15103                                           ! Debug: list int = const 2 (used reg = )
15104 4574           B8                   0002  mov	ax,*2
15105 4577           50                         push	ax
15106                                           ! Debug: list * unsigned short = const $26A (used reg = )
15107 4578           B8                   026A  mov	ax,#$26A
15108 457B           50                         push	ax
15109                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15110 457C           FF76         FE            push	-2[bp]
15111                                           ! Debug: func () void = write_word+0 (used reg = )
15112 457F           E8         C0B4            call	_write_word
15113 4582           83C4                   06  add	sp,*6
15114                                           !BCC_EOS
15115                                           ! 2388       break;
15116 4585           E9         0096            br 	.334
15117                                           !BCC_EOS
15118                                           ! 2389     case 0x04:
15119                                           ! 2390       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
15120                       00004588            .33A:
15121                                           ! Debug: list int = const $1C4 (used reg = )
15122 4588           B8                   01C4  mov	ax,#$1C4
15123 458B           50                         push	ax
15124                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15125 458C           FFB6       F7EC            push	-$814[bp]
15126                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15127 4590           E8         C065            call	_read_byte
15128 4593           83C4                   04  add	sp,*4
15129                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15130 4596           24                     3F  and	al,*$3F
15131                                           ! Debug: list unsigned char = al+0 (used reg = )
15132 4598           30E4                       xor	ah,ah
15133 459A           50                         push	ax
15134                                           ! Debug: list * unsigned short = const $26E (used reg = )
15135 459B           B8                   026E  mov	ax,#$26E
15136 459E           50                         push	ax
15137                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15138 459F           FF76         FE            push	-2[bp]
15139                                           ! Debug: func () void = write_word+0 (used reg = )
15140 45A2           E8         C091            call	_write_word
15141 45A5           83C4                   06  add	sp,*6
15142                                           !BCC_EOS
15143                                           ! 2391       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15144                                           ! 2392               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15145                                           ! Debug: list int = const $1C5 (used reg = )
15146 45A8           B8                   01C5  mov	ax,#$1C5
15147 45AB           50                         push	ax
15148                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15149 45AC           FFB6       F7EC            push	-$814[bp]
15150                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15151 45B0           E8         C045            call	_read_byte
15152 45B3           83C4                   04  add	sp,*4
15153 45B6           50                         push	ax
15154                                           ! Debug: list int = const $1C4 (used reg = )
15155 45B7           B8                   01C4  mov	ax,#$1C4
15156 45BA           50                         push	ax
15157                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15158 45BB           FFB6       F7EC            push	-$814[bp]
15159                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15160 45BF           E8         C036            call	_read_byte
15161 45C2           83C4                   04  add	sp,*4
15162                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15163 45C5           30E4                       xor	ah,ah
15164 45C7           D1E0                       shl	ax,*1
15165 45C9           D1E0                       shl	ax,*1
15166                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15167 45CB           0286       F7E2            add	al,0+..FFF9[bp]
15168 45CF           80D4                   00  adc	ah,*0
15169 45D2           44                         inc	sp
15170 45D3           44                         inc	sp
15171                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15172                                           ! Debug: list unsigned int = ax+1 (used reg = )
15173 45D4           40                         inc	ax
15174 45D5           50                         push	ax
15175                                           ! Debug: list * unsigned short = const $26C (used reg = )
15176 45D6           B8                   026C  mov	ax,#$26C
15177 45D9           50                         push	ax
15178                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15179 45DA           FF76         FE            push	-2[bp]
15180                                           ! Debug: func () void = write_word+0 (used reg = )
15181 45DD           E8         C056            call	_write_word
15182 45E0           83C4                   06  add	sp,*6
15183                                           !BCC_EOS
15184                                           ! 2393       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15185                                           ! Debug: list int = const $1C3 (used reg = )
15186 45E3           B8                   01C3  mov	ax,#$1C3
15187 45E6           50                         push	ax
15188                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15189 45E7           FFB6       F7EC            push	-$814[bp]
15190                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15191 45EB           E8         C00A            call	_read_byte
15192 45EE           83C4                   04  add	sp,*4
15193                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15194 45F1           30E4                       xor	ah,ah
15195                                           ! Debug: list unsigned int = ax+1 (used reg = )
15196 45F3           40                         inc	ax
15197 45F4           50                         push	ax
15198                                           ! Debug: list * unsigned short = const $26A (used reg = )
15199 45F5           B8                   026A  mov	ax,#$26A
15200 45F8           50                         push	ax
15201                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15202 45F9           FF76         FE            push	-2[bp]
15203                                           ! Debug: func () void = write_word+0 (used reg = )
15204 45FC           E8         C037            call	_write_word
15205 45FF           83C4                   06  add	sp,*6
15206                                           !BCC_EOS
15207                                           ! 2394       break;
15208 4602           EB           1A            jmp .334
15209                                           !BCC_EOS
15210                                           ! 2395    }
15211                                           ! 2396   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15212 4604           EB           18            jmp .334
15213                       00004606            .336:
15214 4606           2C                     01  sub	al,*1
15215 4608         0F84         FEDA            beq 	.337
15216 460C           2C                     01  sub	al,*1
15217 460E         0F84         FF0A            beq 	.338
15218 4612           2C                     01  sub	al,*1
15219 4614         0F84         FF3A            beq 	.339
15220 4618           2C                     01  sub	al,*1
15221 461A         0F84         FF6A            beq 	.33A
15222                       0000461E            .334:
15223                       FFFFF7E2            ..FFF9	=	-$81E
15224                                           ! Debug: list * unsigned char = const $25B (used reg = )
15225 461E           B8                   025B  mov	ax,#$25B
15226 4621           50                         push	ax
15227                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15228 4622           FF76         FE            push	-2[bp]
15229                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15230 4625           E8         BFD0            call	_read_byte
15231 4628           83C4                   04  add	sp,*4
15232                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15233 462B           84C0                       test	al,al
15234 462D           74           52            je  	.33B
15235                       0000462F            .33C:
15236                                           ! 2397     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15237                                           ! Debug: list * unsigned char = const $25C (used reg = )
15238 462F           B8                   025C  mov	ax,#$25C
15239 4632           50                         push	ax
15240                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15241 4633           FF76         FE            push	-2[bp]
15242                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15243 4636           E8         BFBF            call	_read_byte
15244 4639           83C4                   04  add	sp,*4
15245                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15246 463C           84C0                       test	al,al
15247 463E           75           23            jne 	.33D
15248                       00004640            .33E:
15249                                           ! 2398       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15250                                           ! Debug: list int = const $10 (used reg = )
15251 4640           B8                   0010  mov	ax,*$10
15252 4643           50                         push	ax
15253                                           ! Debug: list int = const $40 (used reg = )
15254 4644           B8                   0040  mov	ax,*$40
15255 4647           50                         push	ax
15256                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15257 4648           E8         BFAD            call	_read_byte
15258 464B           83C4                   04  add	sp,*4
15259                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15260 464E           0C                     41  or	al,*$41
15261                                           ! Debug: list unsigned char = al+0 (used reg = )
15262 4650           30E4                       xor	ah,ah
15263 4652           50                         push	ax
15264                                           ! Debug: list int = const $10 (used reg = )
15265 4653           B8                   0010  mov	ax,*$10
15266 4656           50                         push	ax
15267                                           ! Debug: list int = const $40 (used reg = )
15268 4657           B8                   0040  mov	ax,*$40
15269 465A           50                         push	ax
15270                                           ! Debug: func () void = write_byte+0 (used reg = )
15271 465B           E8         BFC0            call	_write_byte
15272 465E           83C4                   06  add	sp,*6
15273                                           !BCC_EOS
15274                                           ! 2399     else
15275                                           ! 2400       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15276 4661           EB           1E            jmp .33F
15277                       00004663            .33D:
15278                                           ! Debug: list * unsigned char = const $232 (used reg = )
15279 4663           B8                   0232  mov	ax,#$232
15280 4666           50                         push	ax
15281                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15282 4667           FF76         FE            push	-2[bp]
15283                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15284 466A           E8         BF8B            call	_read_byte
15285 466D           83C4                   04  add	sp,*4
15286                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15287 4670           30E4                       xor	ah,ah
15288                                           ! Debug: list unsigned int = ax+1 (used reg = )
15289 4672           40                         inc	ax
15290 4673           50                         push	ax
15291                                           ! Debug: list * unsigned char = const $232 (used reg = )
15292 4674           B8                   0232  mov	ax,#$232
15293 4677           50                         push	ax
15294                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15295 4678           FF76         FE            push	-2[bp]
15296                                           ! Debug: func () void = write_byte+0 (used reg = )
15297 467B           E8         BFA0            call	_write_byte
15298 467E           83C4                   06  add	sp,*6
15299                                           !BCC_EOS
15300                                           ! 2401   }
15301                       00004681            .33F:
15302                                           ! 2402   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15303                       00004681            .33B:
15304                                           ! Debug: list * unsigned char = const $25B (used reg = )
15305 4681           B8                   025B  mov	ax,#$25B
15306 4684           50                         push	ax
15307                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15308 4685           FF76         FE            push	-2[bp]
15309                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15310 4688           E8         BF6D            call	_read_byte
15311 468B           83C4                   04  add	sp,*4
15312                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15313 468E           84C0                       test	al,al
15314 4690           74           11            je  	.340
15315                       00004692            .341:
15316                                           ! 2403     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15317                                           ! Debug: list int = const 1 (used reg = )
15318 4692           B8                   0001  mov	ax,*1
15319 4695           50                         push	ax
15320                                           ! Debug: list * unsigned char = const $25A (used reg = )
15321 4696           B8                   025A  mov	ax,#$25A
15322 4699           50                         push	ax
15323                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15324 469A           FF76         FE            push	-2[bp]
15325                                           ! Debug: func () void = write_byte+0 (used reg = )
15326 469D           E8         BF7E            call	_write_byte
15327 46A0           83C4                   06  add	sp,*6
15328                                           !BCC_EOS
15329                                           ! 2404   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15330                       000046A3            .340:
15331                                           ! Debug: list * unsigned char = const $25C (used reg = )
15332 46A3           B8                   025C  mov	ax,#$25C
15333 46A6           50                         push	ax
15334                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15335 46A7           FF76         FE            push	-2[bp]
15336                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15337 46AA           E8         BF4B            call	_read_byte
15338 46AD           83C4                   04  add	sp,*4
15339                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15340 46B0           30E4                       xor	ah,ah
15341 46B2           B9                   0100  mov	cx,#$100
15342 46B5           F7E9                       imul	cx
15343                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15344                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15345 46B7           89EC                       mov	sp,bp
15346 46B9           5D                         pop	bp
15347 46BA           C3                         ret
15348                                           !BCC_EOS
15349                                           ! 2405 }
15350                                           ! 2406 void int14_function(regs, ds, iret_addr)
15351                                           ! Register BX used in function cdrom_boot
15352                                           ! 2407   pusha_regs_t regs;
15353                                           export	_int14_function
15354                       000046BB            _int14_function:
15355                                           !BCC_EOS
15356                                           ! 2408   Bit16u ds;
15357                                           !BCC_EOS
15358                                           ! 2409   iret_addr_t iret_addr;
15359                                           !BCC_EOS
15360                                           ! 2410 {
15361                                           ! 2411   Bit16u addr,timer,val16;
15362                                           !BCC_EOS
15363                                           ! 2412   Bit8u counter;
15364                                           !BCC_EOS
15365                                           ! 2413 #asm
15366 46BB           55                         push	bp
15367 46BC           89E5                       mov	bp,sp
15368 46BE           83C4                   F8  add	sp,*-8
15369                                           !BCC_EOS
15370                                           !BCC_ASM
15371                       0000001C            _int14_function.ds	set	$1C
15372                       00000014            .int14_function.ds	set	$14
15373                       00000001            _int14_function.counter	set	1
15374                       FFFFFFF9            .int14_function.counter	set	-7
15375                       00000004            _int14_function.timer	set	4
15376                       FFFFFFFC            .int14_function.timer	set	-4
15377                       0000001E            _int14_function.iret_addr	set	$1E
15378                       00000016            .int14_function.iret_addr	set	$16
15379                       00000006            _int14_function.addr	set	6
15380                       FFFFFFFE            .int14_function.addr	set	-2
15381                       00000002            _int14_function.val16	set	2
15382                       FFFFFFFA            .int14_function.val16	set	-6
15383                       0000000C            _int14_function.regs	set	$C
15384                       00000004            .int14_function.regs	set	4
15385 46C1           FB                           sti
15386                                           ! 2415 endasm
15387                                           !BCC_ENDASM
15388                                           !BCC_EOS
15389                                           ! 2416   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15390                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15391 46C2           8B46         0E            mov	ax,$E[bp]
15392 46C5           D1E0                       shl	ax,*1
15393                                           ! Debug: list unsigned int = ax+0 (used reg = )
15394 46C7           50                         push	ax
15395                                           ! Debug: list int = const $40 (used reg = )
15396 46C8           B8                   0040  mov	ax,*$40
15397 46CB           50                         push	ax
15398                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15399 46CC           E8         BF3C            call	_read_word
15400 46CF           83C4                   04  add	sp,*4
15401                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15402 46D2           8946         FE            mov	-2[bp],ax
15403                                           !BCC_EOS
15404                                           ! 2417   counter = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15405                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15406                                           ! Debug: expression subtree swapping
15407 46D5           8B46         0E            mov	ax,$E[bp]
15408                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15409 46D8           05                   007C  add	ax,*$7C
15410 46DB           50                         push	ax
15411                                           ! Debug: list int = const $40 (used reg = )
15412 46DC           B8                   0040  mov	ax,*$40
15413 46DF           50                         push	ax
15414                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15415 46E0           E8         BF15            call	_read_byte
15416 46E3           83C4                   04  add	sp,*4
15417                                           ! Debug: eq unsigned char = al+0 to unsigned char counter = [S+$A-9] (used reg = )
15418 46E6           8846         F9            mov	-7[bp],al
15419                                           !BCC_EOS
15420                                           ! 2418   if ((regs.u.r16.dx < 4) && (addr > 0)) {
15421                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15422 46E9           8B46         0E            mov	ax,$E[bp]
15423 46EC           3D                   0004  cmp	ax,*4
15424 46EF         0F83         0224            bhis	.342
15425                       000046F3            .344:
15426                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15427 46F3           8B46         FE            mov	ax,-2[bp]
15428 46F6           85C0                       test	ax,ax
15429 46F8         0F84         021B            beq 	.342
15430                       000046FC            .343:
15431                                           ! 2419     switch (regs.u.r8.ah) {
15432 46FC           8A46         13            mov	al,$13[bp]
15433 46FF           E9         01FB            br 	.347
15434                                           ! 2420       case 0:
15435                                           ! 2421         outb(addr+3, inb(addr+3) | 0x80);
15436                       00004702            .348:
15437                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15438 4702           8B46         FE            mov	ax,-2[bp]
15439                                           ! Debug: list unsigned int = ax+3 (used reg = )
15440 4705           05                   0003  add	ax,*3
15441 4708           50                         push	ax
15442                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15443 4709           E8         BE36            call	_inb
15444 470C           44                         inc	sp
15445 470D           44                         inc	sp
15446                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15447 470E           0C                     80  or	al,#$80
15448                                           ! Debug: list unsigned char = al+0 (used reg = )
15449 4710           30E4                       xor	ah,ah
15450 4712           50                         push	ax
15451                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15452 4713           8B46         FE            mov	ax,-2[bp]
15453                                           ! Debug: list unsigned int = ax+3 (used reg = )
15454 4716           05                   0003  add	ax,*3
15455 4719           50                         push	ax
15456                                           ! Debug: func () void = outb+0 (used reg = )
15457 471A           E8         BE3B            call	_outb
15458 471D           83C4                   04  add	sp,*4
15459                                           !BCC_EOS
15460                                           ! 2422         if (regs.u.r8.al & 0xE0 == 0) {
15461                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15462 4720           8A46         12            mov	al,$12[bp]
15463 4723           30C0                       xor	al,al
15464 4725           84C0                       test	al,al
15465 4727           74           1E            je  	.349
15466                       00004729            .34A:
15467                                           ! 2423           outb(addr, 0x17);
15468                                           ! Debug: list int = const $17 (used reg = )
15469 4729           B8                   0017  mov	ax,*$17
15470 472C           50                         push	ax
15471                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15472 472D           FF76         FE            push	-2[bp]
15473                                           ! Debug: func () void = outb+0 (used reg = )
15474 4730           E8         BE25            call	_outb
15475 4733           83C4                   04  add	sp,*4
15476                                           !BCC_EOS
15477                                           ! 2424           outb(addr+1, 0x04);
15478                                           ! Debug: list int = const 4 (used reg = )
15479 4736           B8                   0004  mov	ax,*4
15480 4739           50                         push	ax
15481                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15482 473A           8B46         FE            mov	ax,-2[bp]
15483                                           ! Debug: list unsigned int = ax+1 (used reg = )
15484 473D           40                         inc	ax
15485 473E           50                         push	ax
15486                                           ! Debug: func () void = outb+0 (used reg = )
15487 473F           E8         BE16            call	_outb
15488 4742           83C4                   04  add	sp,*4
15489                                           !BCC_EOS
15490                                           ! 2425         } else {
15491 4745           EB           39            jmp .34B
15492                       00004747            .349:
15493                                           ! 2426           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15494                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15495 4747           8A46         12            mov	al,$12[bp]
15496 474A           24                     E0  and	al,#$E0
15497                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15498 474C           30E4                       xor	ah,ah
15499 474E           B1                     05  mov	cl,*5
15500 4750           D3E8                       shr	ax,cl
15501                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15502 4752           89C3                       mov	bx,ax
15503 4754           B8                   0600  mov	ax,#$600
15504 4757           89D9                       mov	cx,bx
15505 4759           D3F8                       sar	ax,cl
15506                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15507 475B           8946         FA            mov	-6[bp],ax
15508                                           !BCC_EOS
15509                                           ! 2427           outb(addr, val16 & 0xFF);
15510                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15511 475E           8A46         FA            mov	al,-6[bp]
15512                                           ! Debug: list unsigned char = al+0 (used reg = )
15513 4761           30E4                       xor	ah,ah
15514 4763           50                         push	ax
15515                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15516 4764           FF76         FE            push	-2[bp]
15517                                           ! Debug: func () void = outb+0 (used reg = )
15518 4767           E8         BDEE            call	_outb
15519 476A           83C4                   04  add	sp,*4
15520                                           !BCC_EOS
15521                                           ! 2428           outb(addr+1, val16 >> 8);
15522                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15523 476D           8B46         FA            mov	ax,-6[bp]
15524 4770           88E0                       mov	al,ah
15525 4772           30E4                       xor	ah,ah
15526                                           ! Debug: list unsigned int = ax+0 (used reg = )
15527 4774           50                         push	ax
15528                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15529 4775           8B46         FE            mov	ax,-2[bp]
15530                                           ! Debug: list unsigned int = ax+1 (used reg = )
15531 4778           40                         inc	ax
15532 4779           50                         push	ax
15533                                           ! Debug: func () void = outb+0 (used reg = )
15534 477A           E8         BDDB            call	_outb
15535 477D           83C4                   04  add	sp,*4
15536                                           !BCC_EOS
15537                                           ! 2429         }
15538                                           ! 2430         outb(addr+3, regs.u.r8.al & 0x1F);
15539                       00004780            .34B:
15540                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15541 4780           8A46         12            mov	al,$12[bp]
15542 4783           24                     1F  and	al,*$1F
15543                                           ! Debug: list unsigned char = al+0 (used reg = )
15544 4785           30E4                       xor	ah,ah
15545 4787           50                         push	ax
15546                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15547 4788           8B46         FE            mov	ax,-2[bp]
15548                                           ! Debug: list unsigned int = ax+3 (used reg = )
15549 478B           05                   0003  add	ax,*3
15550 478E           50                         push	ax
15551                                           ! Debug: func () void = outb+0 (used reg = )
15552 478F           E8         BDC6            call	_outb
15553 4792           83C4                   04  add	sp,*4
15554                                           !BCC_EOS
15555                                           ! 2431         regs.u.r8.ah = inb(addr+5);
15556                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15557 4795           8B46         FE            mov	ax,-2[bp]
15558                                           ! Debug: list unsigned int = ax+5 (used reg = )
15559 4798           05                   0005  add	ax,*5
15560 479B           50                         push	ax
15561                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15562 479C           E8         BDA3            call	_inb
15563 479F           44                         inc	sp
15564 47A0           44                         inc	sp
15565                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15566 47A1           8846         13            mov	$13[bp],al
15567                                           !BCC_EOS
15568                                           ! 2432         regs.u.r8.al = inb(addr+6);
15569                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15570 47A4           8B46         FE            mov	ax,-2[bp]
15571                                           ! Debug: list unsigned int = ax+6 (used reg = )
15572 47A7           05                   0006  add	ax,*6
15573 47AA           50                         push	ax
15574                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15575 47AB           E8         BD94            call	_inb
15576 47AE           44                         inc	sp
15577 47AF           44                         inc	sp
15578                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15579 47B0           8846         12            mov	$12[bp],al
15580                                           !BCC_EOS
15581                                           ! 2433         iret_addr.flags.u.r8.flagsl &= 0xfe;
15582                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15583 47B3           8A46         1A            mov	al,$1A[bp]
15584 47B6           24                     FE  and	al,#$FE
15585 47B8           8846         1A            mov	$1A[bp],al
15586                                           !BCC_EOS
15587                                           ! 2434         break;
15588 47BB           E9         0157            br 	.345
15589                                           !BCC_EOS
15590                                           ! 2435       case 1:
15591                                           ! 2436         timer = read_word(0x0040, 0x006C);
15592                       000047BE            .34C:
15593                                           ! Debug: list int = const $6C (used reg = )
15594 47BE           B8                   006C  mov	ax,*$6C
15595 47C1           50                         push	ax
15596                                           ! Debug: list int = const $40 (used reg = )
15597 47C2           B8                   0040  mov	ax,*$40
15598 47C5           50                         push	ax
15599                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15600 47C6           E8         BE42            call	_read_word
15601 47C9           83C4                   04  add	sp,*4
15602                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15603 47CC           8946         FC            mov	-4[bp],ax
15604                                           !BCC_EOS
15605                                           ! 2437         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
15606 47CF           EB           26            jmp .34E
15607                       000047D1            .34F:
15608                                           ! 2438           val16 = read_word(0x0040, 0x006C);
15609                                           ! Debug: list int = const $6C (used reg = )
15610 47D1           B8                   006C  mov	ax,*$6C
15611 47D4           50                         push	ax
15612                                           ! Debug: list int = const $40 (used reg = )
15613 47D5           B8                   0040  mov	ax,*$40
15614 47D8           50                         push	ax
15615                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15616 47D9           E8         BE2F            call	_read_word
15617 47DC           83C4                   04  add	sp,*4
15618                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15619 47DF           8946         FA            mov	-6[bp],ax
15620                                           !BCC_EOS
15621                                           ! 2439           if (val16 
15622                                           ! 2439 != timer) {
15623                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15624 47E2           8B46         FA            mov	ax,-6[bp]
15625 47E5           3B46         FC            cmp	ax,-4[bp]
15626 47E8           74           0D            je  	.350
15627                       000047EA            .351:
15628                                           ! 2440             timer = val16;
15629                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15630 47EA           8B46         FA            mov	ax,-6[bp]
15631 47ED           8946         FC            mov	-4[bp],ax
15632                                           !BCC_EOS
15633                                           ! 2441             counter--;
15634                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
15635 47F0           8A46         F9            mov	al,-7[bp]
15636 47F3           48                         dec	ax
15637 47F4           8846         F9            mov	-7[bp],al
15638                                           !BCC_EOS
15639                                           ! 2442           }
15640                                           ! 2443         }
15641                       000047F7            .350:
15642                                           ! 2444         if (counter > 0) {
15643                       000047F7            .34E:
15644                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15645 47F7           8B46         FE            mov	ax,-2[bp]
15646                                           ! Debug: list unsigned int = ax+5 (used reg = )
15647 47FA           05                   0005  add	ax,*5
15648 47FD           50                         push	ax
15649                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15650 47FE           E8         BD41            call	_inb
15651 4801           44                         inc	sp
15652 4802           44                         inc	sp
15653                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15654 4803           24                     60  and	al,*$60
15655                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15656 4805           3C                     60  cmp	al,*$60
15657 4807           74           07            je  	.352
15658                       00004809            .353:
15659 4809           8A46         F9            mov	al,-7[bp]
15660 480C           84C0                       test	al,al
15661 480E           75           C1            jne	.34F
15662                       00004810            .352:
15663                       00004810            .34D:
15664                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
15665 4810           8A46         F9            mov	al,-7[bp]
15666 4813           84C0                       test	al,al
15667 4815           74           20            je  	.354
15668                       00004817            .355:
15669                                           ! 2445           outb(addr, regs.u.r8.al);
15670                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15671 4817           8A46         12            mov	al,$12[bp]
15672 481A           30E4                       xor	ah,ah
15673 481C           50                         push	ax
15674                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15675 481D           FF76         FE            push	-2[bp]
15676                                           ! Debug: func () void = outb+0 (used reg = )
15677 4820           E8         BD35            call	_outb
15678 4823           83C4                   04  add	sp,*4
15679                                           !BCC_EOS
15680                                           ! 2446           regs.u.r8.ah = inb(addr+5);
15681                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15682 4826           8B46         FE            mov	ax,-2[bp]
15683                                           ! Debug: list unsigned int = ax+5 (used reg = )
15684 4829           05                   0005  add	ax,*5
15685 482C           50                         push	ax
15686                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15687 482D           E8         BD12            call	_inb
15688 4830           44                         inc	sp
15689 4831           44                         inc	sp
15690                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15691 4832           8846         13            mov	$13[bp],al
15692                                           !BCC_EOS
15693                                           ! 2447         } else {
15694 4835           EB           05            jmp .356
15695                       00004837            .354:
15696                                           ! 2448           regs.u.r8.ah = 0x80;
15697                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15698 4837           B0                     80  mov	al,#$80
15699 4839           8846         13            mov	$13[bp],al
15700                                           !BCC_EOS
15701                                           ! 2449         }
15702                                           ! 2450         iret_addr.flags.u.r8.flagsl &= 0xfe;
15703                       0000483C            .356:
15704                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15705 483C           8A46         1A            mov	al,$1A[bp]
15706 483F           24                     FE  and	al,#$FE
15707 4841           8846         1A            mov	$1A[bp],al
15708                                           !BCC_EOS
15709                                           ! 2451         break;
15710 4844           E9         00CE            br 	.345
15711                                           !BCC_EOS
15712                                           ! 2452       case 2:
15713                                           ! 2453         timer = read_word(0x0040, 0x006C);
15714                       00004847            .357:
15715                                           ! Debug: list int = const $6C (used reg = )
15716 4847           B8                   006C  mov	ax,*$6C
15717 484A           50                         push	ax
15718                                           ! Debug: list int = const $40 (used reg = )
15719 484B           B8                   0040  mov	ax,*$40
15720 484E           50                         push	ax
15721                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15722 484F           E8         BDB9            call	_read_word
15723 4852           83C4                   04  add	sp,*4
15724                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15725 4855           8946         FC            mov	-4[bp],ax
15726                                           !BCC_EOS
15727                                           ! 2454         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
15728 4858           EB           26            jmp .359
15729                       0000485A            .35A:
15730                                           ! 2455           val16 = read_word(0x0040, 0x006C);
15731                                           ! Debug: list int = const $6C (used reg = )
15732 485A           B8                   006C  mov	ax,*$6C
15733 485D           50                         push	ax
15734                                           ! Debug: list int = const $40 (used reg = )
15735 485E           B8                   0040  mov	ax,*$40
15736 4861           50                         push	ax
15737                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15738 4862           E8         BDA6            call	_read_word
15739 4865           83C4                   04  add	sp,*4
15740                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15741 4868           8946         FA            mov	-6[bp],ax
15742                                           !BCC_EOS
15743                                           ! 2456           if (val16 != timer) {
15744                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15745 486B           8B46         FA            mov	ax,-6[bp]
15746 486E           3B46         FC            cmp	ax,-4[bp]
15747 4871           74           0D            je  	.35B
15748                       00004873            .35C:
15749                                           ! 2457             timer = val16;
15750                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15751 4873           8B46         FA            mov	ax,-6[bp]
15752 4876           8946         FC            mov	-4[bp],ax
15753                                           !BCC_EOS
15754                                           ! 2458             counter--;
15755                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
15756 4879           8A46         F9            mov	al,-7[bp]
15757 487C           48                         dec	ax
15758 487D           8846         F9            mov	-7[bp],al
15759                                           !BCC_EOS
15760                                           ! 2459           }
15761                                           ! 2460         }
15762                       00004880            .35B:
15763                                           ! 2461         if (counter > 0) {
15764                       00004880            .359:
15765                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15766 4880           8B46         FE            mov	ax,-2[bp]
15767                                           ! Debug: list unsigned int = ax+5 (used reg = )
15768 4883           05                   0005  add	ax,*5
15769 4886           50                         push	ax
15770                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15771 4887           E8         BCB8            call	_inb
15772 488A           44                         inc	sp
15773 488B           44                         inc	sp
15774                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
15775 488C           24                     01  and	al,*1
15776                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15777 488E           84C0                       test	al,al
15778 4890           75           07            jne 	.35D
15779                       00004892            .35E:
15780 4892           8A46         F9            mov	al,-7[bp]
15781 4895           84C0                       test	al,al
15782 4897           75           C1            jne	.35A
15783                       00004899            .35D:
15784                       00004899            .358:
15785                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
15786 4899           8A46         F9            mov	al,-7[bp]
15787 489C           84C0                       test	al,al
15788 489E           74           1C            je  	.35F
15789                       000048A0            .360:
15790                                           ! 2462           regs.u.r8.ah = inb(addr+5);
15791                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15792 48A0           8B46         FE            mov	ax,-2[bp]
15793                                           ! Debug: list unsigned int = ax+5 (used reg = )
15794 48A3           05                   0005  add	ax,*5
15795 48A6           50                         push	ax
15796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15797 48A7           E8         BC98            call	_inb
15798 48AA           44                         inc	sp
15799 48AB           44                         inc	sp
15800                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15801 48AC           8846         13            mov	$13[bp],al
15802                                           !BCC_EOS
15803                                           ! 2463           regs.u.r8.al = inb(addr);
15804                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
15805 48AF           FF76         FE            push	-2[bp]
15806                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15807 48B2           E8         BC8D            call	_inb
15808 48B5           44                         inc	sp
15809 48B6           44                         inc	sp
15810                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15811 48B7           8846         12            mov	$12[bp],al
15812                                           !BCC_EOS
15813                                           ! 2464         } else {
15814 48BA           EB           05            jmp .361
15815                       000048BC            .35F:
15816                                           ! 2465           regs.u.r8.ah = 0x80;
15817                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15818 48BC           B0                     80  mov	al,#$80
15819 48BE           8846         13            mov	$13[bp],al
15820                                           !BCC_EOS
15821                                           ! 2466         }
15822                                           ! 2467         iret_addr.flags.u.r8.flagsl &= 0xfe;
15823                       000048C1            .361:
15824                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15825 48C1           8A46         1A            mov	al,$1A[bp]
15826 48C4           24                     FE  and	al,#$FE
15827 48C6           8846         1A            mov	$1A[bp],al
15828                                           !BCC_EOS
15829                                           ! 2468         break;
15830 48C9           EB           4A            jmp .345
15831                                           !BCC_EOS
15832                                           ! 2469       case 3:
15833                                           ! 2470         regs.u.r8.ah = inb(addr+5);
15834                       000048CB            .362:
15835                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15836 48CB           8B46         FE            mov	ax,-2[bp]
15837                                           ! Debug: list unsigned int = ax+5 (used reg = )
15838 48CE           05                   0005  add	ax,*5
15839 48D1           50                         push	ax
15840                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15841 48D2           E8         BC6D            call	_inb
15842 48D5           44                         inc	sp
15843 48D6           44                         inc	sp
15844                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15845 48D7           8846         13            mov	$13[bp],al
15846                                           !BCC_EOS
15847                                           ! 2471         regs.u.r8.al = inb(addr+6);
15848                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15849 48DA           8B46         FE            mov	ax,-2[bp]
15850                                           ! Debug: list unsigned int = ax+6 (used reg = )
15851 48DD           05                   0006  add	ax,*6
15852 48E0           50                         push	ax
15853                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15854 48E1           E8         BC5E            call	_inb
15855 48E4           44                         inc	sp
15856 48E5           44                         inc	sp
15857                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15858 48E6           8846         12            mov	$12[bp],al
15859                                           !BCC_EOS
15860                                           ! 2472         iret_addr.flags.u.r8.flagsl &= 0xfe;
15861                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15862 48E9           8A46         1A            mov	al,$1A[bp]
15863 48EC           24                     FE  and	al,#$FE
15864 48EE           8846         1A            mov	$1A[bp],al
15865                                           !BCC_EOS
15866                                           ! 2473         break;
15867 48F1           EB           22            jmp .345
15868                                           !BCC_EOS
15869                                           ! 2474       default:
15870                                           ! 2475         iret_addr.flags.u.r8.flagsl |= 0x01;
15871                       000048F3            .363:
15872                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15873 48F3           8A46         1A            mov	al,$1A[bp]
15874 48F6           0C                     01  or	al,*1
15875 48F8           8846         1A            mov	$1A[bp],al
15876                                           !BCC_EOS
15877                                           ! 2476       }
15878                                           ! 2477   } else {
15879 48FB           EB           18            jmp .345
15880                       000048FD            .347:
15881 48FD           2C                     00  sub	al,*0
15882 48FF         0F84         FDFF            beq 	.348
15883 4903           2C                     01  sub	al,*1
15884 4905         0F84         FEB5            beq 	.34C
15885 4909           2C                     01  sub	al,*1
15886 490B         0F84         FF38            beq 	.357
15887 490F           2C                     01  sub	al,*1
15888 4911           74           B8            je 	.362
15889 4913           EB           DE            jmp	.363
15890                       00004915            .345:
15891                       FFFFFFF6            ..FFF8	=	-$A
15892 4915           EB           08            jmp .364
15893                       00004917            .342:
15894                                           ! 2478     iret_addr.flags.u.r8.flagsl |= 0x01;
15895                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15896 4917           8A46         1A            mov	al,$1A[bp]
15897 491A           0C                     01  or	al,*1
15898 491C           8846         1A            mov	$1A[bp],al
15899                                           !BCC_EOS
15900                                           ! 2479   }
15901                                           ! 2480 }
15902                       0000491F            .364:
15903 491F           89EC                       mov	sp,bp
15904 4921           5D                         pop	bp
15905 4922           C3                         ret
15906                                           ! 2481   void
15907                                           ! Register BX used in function int14_function
15908                                           ! 2482 int15_function(regs, ES, DS, FLAGS)
15909                                           ! 2483   pusha_regs_t regs;
15910                                           export	_int15_function
15911                       00004923            _int15_function:
15912                                           !BCC_EOS
15913                                           ! 2484   Bit16u ES, DS, FLAGS;
15914                                           !BCC_EOS
15915                                           ! 2485 {
15916                                           ! 2486   Bit16u ebda_seg=read_word(0x0040,0x000E);
15917 4923           55                         push	bp
15918 4924           89E5                       mov	bp,sp
15919 4926           4C                         dec	sp
15920 4927           4C                         dec	sp
15921                                           ! Debug: list int = const $E (used reg = )
15922 4928           B8                   000E  mov	ax,*$E
15923 492B           50                         push	ax
15924                                           ! Debug: list int = const $40 (used reg = )
15925 492C           B8                   0040  mov	ax,*$40
15926 492F           50                         push	ax
15927                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15928 4930           E8         BCD8            call	_read_word
15929 4933           83C4                   04  add	sp,*4
15930                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15931 4936           8946         FE            mov	-2[bp],ax
15932                                           !BCC_EOS
15933                                           ! 2487   bx_bool prev_a20_enable;
15934                                           !BCC_EOS
15935                                           ! 2488   Bit16u base15_00;
15936                                           !BCC_EOS
15937                                           ! 2489   Bit8u base23_16;
15938                                           !BCC_EOS
15939                                           ! 2490   Bit16u ss;
15940                                           !BCC_EOS
15941                                           ! 2491   Bit16u BX,CX,DX;
15942                                           !BCC_EOS
15943                                           ! 2492   Bit16u bRegister;
15944                                           !BCC_EOS
15945                                           ! 2493   Bit8u irqDisable;
15946                                           !BCC_EOS
15947                                           ! 2494 ;
15948 4939           83C4                   EE  add	sp,*-$12
15949                                           !BCC_EOS
15950                                           ! 2495   switch (regs.u.r8.ah) {
15951 493C           8A46         13            mov	al,$13[bp]
15952 493F           E9         059B            br 	.367
15953                                           ! 2496     case 0x24:
15954                                           ! 2497       switch (regs.u.r8.al) {
15955                       00004942            .368:
15956 4942           8A46         12            mov	al,$12[bp]
15957 4945           E9         0089            br 	.36B
15958                                           ! 2498         case 0x00:
15959                                           ! 2499           set_enable_a20(0);
15960                       00004948            .36C:
15961                                           ! Debug: list int = const 0 (used reg = )
15962 4948           31C0                       xor	ax,ax
15963 494A           50                         push	ax
15964                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15965 494B           E8         CEAB            call	_set_enable_a20
15966 494E           44                         inc	sp
15967 494F           44                         inc	sp
15968                                           !BCC_EOS
15969                                           ! 2500           FLAGS &= 0xfffe;
15970                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15971 4950           8B46         18            mov	ax,$18[bp]
15972 4953           24                     FE  and	al,#$FE
15973 4955           8946         18            mov	$18[bp],ax
15974                                           !BCC_EOS
15975                                           ! 2501           regs.u.r8.ah = 0;
15976                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15977 4958           30C0                       xor	al,al
15978 495A           8846         13            mov	$13[bp],al
15979                                           !BCC_EOS
15980                                           ! 2502           break;
15981 495D           E9         0087            br 	.369
15982                                           !BCC_EOS
15983                                           ! 2503         case 0x01:
15984                                           ! 2504           set_enable_a20(1);
15985                       00004960            .36D:
15986                                           ! Debug: list int = const 1 (used reg = )
15987 4960           B8                   0001  mov	ax,*1
15988 4963           50                         push	ax
15989                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15990 4964           E8         CE92            call	_set_enable_a20
15991 4967           44                         inc	sp
15992 4968           44                         inc	sp
15993                                           !BCC_EOS
15994                                           ! 2505           FLAGS &= 0xfffe;
15995                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15996 4969           8B46         18            mov	ax,$18[bp]
15997 496C           24                     FE  and	al,#$FE
15998 496E           8946         18            mov	$18[bp],ax
15999                                           !BCC_EOS
16000                                           ! 2506           regs.u.r8.ah = 0;
16001                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16002 4971           30C0                       xor	al,al
16003 4973           8846         13            mov	$13[bp],al
16004                                           !BCC_EOS
16005                                           ! 2507           break;
16006 4976           EB           6F            jmp .369
16007                                           !BCC_EOS
16008                                           ! 2508         case 0x02:
16009                                           ! 2509           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
16010                       00004978            .36E:
16011                                           ! Debug: list int = const $92 (used reg = )
16012 4978           B8                   0092  mov	ax,#$92
16013 497B           50                         push	ax
16014                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16015 497C           E8         BBC3            call	_inb
16016 497F           44                         inc	sp
16017 4980           44                         inc	sp
16018                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
16019 4981           30E4                       xor	ah,ah
16020 4983           D1E8                       shr	ax,*1
16021                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
16022 4985           24                     01  and	al,*1
16023                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
16024 4987           8846         12            mov	$12[bp],al
16025                                           !BCC_EOS
16026                                           ! 2510           FLAGS &= 0xfffe;
16027                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16028 498A           8B46         18            mov	ax,$18[bp]
16029 498D           24                     FE  and	al,#$FE
16030 498F           8946         18            mov	$18[bp],ax
16031                                           !BCC_EOS
16032                                           ! 2511           regs.u.r8.ah = 0;
16033                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16034 4992           30C0                       xor	al,al
16035 4994           8846         13            mov	$13[bp],al
16036                                           !BCC_EOS
16037                                           ! 2512           break;
16038 4997           EB           4E            jmp .369
16039                                           !BCC_EOS
16040                                           ! 2513         case 0x03:
16041                                           ! 2514           FLAGS &= 0xfffe;
16042                       00004999            .36F:
16043                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16044 4999           8B46         18            mov	ax,$18[bp]
16045 499C           24                     FE  and	al,#$FE
16046 499E           8946         18            mov	$18[bp],ax
16047                                           !BCC_EOS
16048                                           ! 2515           regs.u.r8.ah = 0;
16049                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16050 49A1           30C0                       xor	al,al
16051 49A3           8846         13            mov	$13[bp],al
16052                                           !BCC_EOS
16053                                           ! 2516           regs.u.r16.bx = 3;
16054                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
16055 49A6           B8                   0003  mov	ax,*3
16056 49A9           8946         0C            mov	$C[bp],ax
16057                                           !BCC_EOS
16058                                           ! 2517           break;
16059 49AC           EB           39            jmp .369
16060                                           !BCC_EOS
16061                                           ! 2518         default:
16062                                           ! 2519           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
16063                       000049AE            .370:
16064                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
16065 49AE           8A46         12            mov	al,$12[bp]
16066 49B1           30E4                       xor	ah,ah
16067 49B3           50                         push	ax
16068                                           ! Debug: list * char = .371+0 (used reg = )
16069 49B4           BB                   D575  mov	bx,#.371
16070 49B7           53                         push	bx
16071                                           ! Debug: list int = const 4 (used reg = )
16072 49B8           B8                   0004  mov	ax,*4
16073 49BB           50                         push	ax
16074                                           ! Debug: func () void = bios_printf+0 (used reg = )
16075 49BC           E8         BFE8            call	_bios_printf
16076 49BF           83C4                   06  add	sp,*6
16077                                           !BCC_EOS
16078                                           ! 2520        
16079                                           ! 2520    FLAGS |= 0x0001;
16080                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16081 49C2           8B46         18            mov	ax,$18[bp]
16082 49C5           0C                     01  or	al,*1
16083 49C7           8946         18            mov	$18[bp],ax
16084                                           !BCC_EOS
16085                                           ! 2521           regs.u.r8.ah = 0x86;
16086                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16087 49CA           B0                     86  mov	al,#$86
16088 49CC           8846         13            mov	$13[bp],al
16089                                           !BCC_EOS
16090                                           ! 2522       }
16091                                           ! 2523       break;
16092 49CF           EB           16            jmp .369
16093                       000049D1            .36B:
16094 49D1           2C                     00  sub	al,*0
16095 49D3         0F84         FF71            beq 	.36C
16096 49D7           2C                     01  sub	al,*1
16097 49D9         0F84         FF83            beq 	.36D
16098 49DD           2C                     01  sub	al,*1
16099 49DF           74           97            je 	.36E
16100 49E1           2C                     01  sub	al,*1
16101 49E3           74           B4            je 	.36F
16102 49E5           EB           C7            jmp	.370
16103                       000049E7            .369:
16104 49E7           E9         0557            br 	.365
16105                                           !BCC_EOS
16106                                           ! 2524     case 0x41:
16107                                           ! 2525       FLAGS |= 0x0001;
16108                       000049EA            .372:
16109                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16110 49EA           8B46         18            mov	ax,$18[bp]
16111 49ED           0C                     01  or	al,*1
16112 49EF           8946         18            mov	$18[bp],ax
16113                                           !BCC_EOS
16114                                           ! 2526       regs.u.r8.ah = 0x86;
16115                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16116 49F2           B0                     86  mov	al,#$86
16117 49F4           8846         13            mov	$13[bp],al
16118                                           !BCC_EOS
16119                                           ! 2527       break;
16120 49F7           E9         0547            br 	.365
16121                                           !BCC_EOS
16122                                           ! 2528     case 0x4f:
16123                                           ! 2529       FLAGS |= 0x0001;
16124                       000049FA            .373:
16125                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16126 49FA           8B46         18            mov	ax,$18[bp]
16127 49FD           0C                     01  or	al,*1
16128 49FF           8946         18            mov	$18[bp],ax
16129                                           !BCC_EOS
16130                                           ! 2530       break;
16131 4A02           E9         053C            br 	.365
16132                                           !BCC_EOS
16133                                           ! 2531     case 0x52:
16134                                           ! 2532       FLAGS &= 0xfffe;
16135                       00004A05            .374:
16136                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16137 4A05           8B46         18            mov	ax,$18[bp]
16138 4A08           24                     FE  and	al,#$FE
16139 4A0A           8946         18            mov	$18[bp],ax
16140                                           !BCC_EOS
16141                                           ! 2533       regs.u.r8.ah = 0;
16142                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16143 4A0D           30C0                       xor	al,al
16144 4A0F           8846         13            mov	$13[bp],al
16145                                           !BCC_EOS
16146                                           ! 2534       break;
16147 4A12           E9         052C            br 	.365
16148                                           !BCC_EOS
16149                                           ! 2535     case 0x83: {
16150                       00004A15            .375:
16151                                           ! 2536       if( regs.u.r8.al == 0 ) {
16152                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
16153 4A15           8A46         12            mov	al,$12[bp]
16154 4A18           84C0                       test	al,al
16155 4A1A         0F85         00C1            bne 	.376
16156                       00004A1E            .377:
16157                                           ! 2537         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16158                                           ! Debug: list int = const $A0 (used reg = )
16159 4A1E           B8                   00A0  mov	ax,#$A0
16160 4A21           50                         push	ax
16161                                           ! Debug: list int = const $40 (used reg = )
16162 4A22           B8                   0040  mov	ax,*$40
16163 4A25           50                         push	ax
16164                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16165 4A26           E8         BBCF            call	_read_byte
16166 4A29           83C4                   04  add	sp,*4
16167                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16168 4A2C           24                     01  and	al,*1
16169                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16170 4A2E           84C0                       test	al,al
16171 4A30         0F85         009C            bne 	.378
16172                       00004A34            .379:
16173                                           ! 2538           write_byte( 0x40, 0xA0, 1 );
16174                                           ! Debug: list int = const 1 (used reg = )
16175 4A34           B8                   0001  mov	ax,*1
16176 4A37           50                         push	ax
16177                                           ! Debug: list int = const $A0 (used reg = )
16178 4A38           B8                   00A0  mov	ax,#$A0
16179 4A3B           50                         push	ax
16180                                           ! Debug: list int = const $40 (used reg = )
16181 4A3C           B8                   0040  mov	ax,*$40
16182 4A3F           50                         push	ax
16183                                           ! Debug: func () void = write_byte+0 (used reg = )
16184 4A40           E8         BBDB            call	_write_byte
16185 4A43           83C4                   06  add	sp,*6
16186                                           !BCC_EOS
16187                                           ! 2539           write_word( 0x40, 0x98, ES );
16188                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
16189 4A46           FF76         14            push	$14[bp]
16190                                           ! Debug: list int = const $98 (used reg = )
16191 4A49           B8                   0098  mov	ax,#$98
16192 4A4C           50                         push	ax
16193                                           ! Debug: list int = const $40 (used reg = )
16194 4A4D           B8                   0040  mov	ax,*$40
16195 4A50           50                         push	ax
16196                                           ! Debug: func () void = write_word+0 (used reg = )
16197 4A51           E8         BBE2            call	_write_word
16198 4A54           83C4                   06  add	sp,*6
16199                                           !BCC_EOS
16200                                           ! 2540           write_word( 0x40, 0x9A, regs.u.r16.bx );
16201                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
16202 4A57           FF76         0C            push	$C[bp]
16203                                           ! Debug: list int = const $9A (used reg = )
16204 4A5A           B8                   009A  mov	ax,#$9A
16205 4A5D           50                         push	ax
16206                                           ! Debug: list int = const $40 (used reg = )
16207 4A5E           B8                   0040  mov	ax,*$40
16208 4A61           50                         push	ax
16209                                           ! Debug: func () void = write_word+0 (used reg = )
16210 4A62           E8         BBD1            call	_write_word
16211 4A65           83C4                   06  add	sp,*6
16212                                           !BCC_EOS
16213                                           ! 2541           write_word( 0x40, 0x9C, regs.u.r16.dx );
16214                                           ! Debug: list unsigned short regs = [S+$16+$C] (used reg = )
16215 4A68           FF76         0E            push	$E[bp]
16216                                           ! Debug: list int = const $9C (used reg = )
16217 4A6B           B8                   009C  mov	ax,#$9C
16218 4A6E           50                         push	ax
16219                                           ! Debug: list int = const $40 (used reg = )
16220 4A6F           B8                   0040  mov	ax,*$40
16221 4A72           50                         push	ax
16222                                           ! Debug: func () void = write_word+0 (used reg = )
16223 4A73           E8         BBC0            call	_write_word
16224 4A76           83C4                   06  add	sp,*6
16225                                           !BCC_EOS
16226                                           ! 2542           write_word( 0x40, 0x9E, regs.u.r16.cx );
16227                                           ! Debug: list unsigned short regs = [S+$16+$E] (used reg = )
16228 4A79           FF76         10            push	$10[bp]
16229                                           ! Debug: list int = const $9E (used reg = )
16230 4A7C           B8                   009E  mov	ax,#$9E
16231 4A7F           50                         push	ax
16232                                           ! Debug: list int = const $40 (used reg = )
16233 4A80           B8                   0040  mov	ax,*$40
16234 4A83           50                         push	ax
16235                                           ! Debug: func () void = write_word+0 (used reg = )
16236 4A84           E8         BBAF            call	_write_word
16237 4A87           83C4                   06  add	sp,*6
16238                                           !BCC_EOS
16239                                           ! 2543           FLAGS &= 0xfffe;
16240                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16241 4A8A           8B46         18            mov	ax,$18[bp]
16242 4A8D           24                     FE  and	al,#$FE
16243 4A8F           8946         18            mov	$18[bp],ax
16244                                           !BCC_EOS
16245                                           ! 2544           irqDisable = inb( 0xA1 );
16246                                           ! Debug: list int = const $A1 (used reg = )
16247 4A92           B8                   00A1  mov	ax,#$A1
16248 4A95           50                         push	ax
16249                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16250 4A96           E8         BAA9            call	_inb
16251 4A99           44                         inc	sp
16252 4A9A           44                         inc	sp
16253                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
16254 4A9B           8846         ED            mov	-$13[bp],al
16255                                           !BCC_EOS
16256                                           ! 2545           outb( 0xA1, irqDisable & 0xFE );
16257                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
16258 4A9E           8A46         ED            mov	al,-$13[bp]
16259 4AA1           24                     FE  and	al,#$FE
16260                                           ! Debug: list unsigned char = al+0 (used reg = )
16261 4AA3           30E4                       xor	ah,ah
16262 4AA5           50                         push	ax
16263                                           ! Debug: list int = const $A1 (used reg = )
16264 4AA6           B8                   00A1  mov	ax,#$A1
16265 4AA9           50                         push	ax
16266                                           ! Debug: func () void = outb+0 (used reg = )
16267 4AAA           E8         BAAB            call	_outb
16268 4AAD           83C4                   04  add	sp,*4
16269                                           !BCC_EOS
16270                                           ! 2546           bRegister = inb_cmos( 0xB );
16271                                           ! Debug: list int = const $B (used reg = )
16272 4AB0           B8                   000B  mov	ax,*$B
16273 4AB3           50                         push	ax
16274                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16275 4AB4           E8         BAD0            call	_inb_cmos
16276 4AB7           44                         inc	sp
16277 4AB8           44                         inc	sp
16278                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
16279 4AB9           30E4                       xor	ah,ah
16280 4ABB           8946         EE            mov	-$12[bp],ax
16281                                           !BCC_EOS
16282                                           ! 2547           outb_cmos( 0xB, bRegister | 0x40 );
16283                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
16284 4ABE           8B46         EE            mov	ax,-$12[bp]
16285 4AC1           0C                     40  or	al,*$40
16286                                           ! Debug: list unsigned int = ax+0 (used reg = )
16287 4AC3           50                         push	ax
16288                                           ! Debug: list int = const $B (used reg = )
16289 4AC4           B8                   000B  mov	ax,*$B
16290 4AC7           50                         push	ax
16291                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16292 4AC8           E8         BAAD            call	_outb_cmos
16293 4ACB           83C4                   04  add	sp,*4
16294                                           !BCC_EOS
16295                                           ! 2548         } else {
16296 4ACE           EB           0D            jmp .37A
16297                       00004AD0            .378:
16298                                           ! 2549           ;
16299                                           !BCC_EOS
16300                                           ! 2550           FLAGS |= 0x0001;
16301                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16302 4AD0           8B46         18            mov	ax,$18[bp]
16303 4AD3           0C                     01  or	al,*1
16304 4AD5           8946         18            mov	$18[bp],ax
16305                                           !BCC_EOS
16306                                           ! 2551           regs.u.r8.ah = 0x86;
16307                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16308 4AD8           B0                     86  mov	al,#$86
16309 4ADA           8846         13            mov	$13[bp],al
16310                                           !BCC_EOS
16311                                           ! 2552         }
16312                                           ! 2553       } else if( regs.u.r8.al == 1 ) {
16313                       00004ADD            .37A:
16314 4ADD           EB           54            jmp .37B
16315                       00004ADF            .376:
16316                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
16317 4ADF           8A46         12            mov	al,$12[bp]
16318 4AE2           3C                     01  cmp	al,*1
16319 4AE4           75           39            jne 	.37C
16320                       00004AE6            .37D:
16321                                           ! 2554         write_byte( 0x40, 0xA0, 0 );
16322                                           ! Debug: list int = const 0 (used reg = )
16323 4AE6           31C0                       xor	ax,ax
16324 4AE8           50                         push	ax
16325                                           ! Debug: list int = const $A0 (used reg = )
16326 4AE9           B8                   00A0  mov	ax,#$A0
16327 4AEC           50                         push	ax
16328                                           ! Debug: list int = const $40 (used reg = )
16329 4AED           B8                   0040  mov	ax,*$40
16330 4AF0           50                         push	ax
16331                                           ! Debug: func () void = write_byte+0 (used reg = )
16332 4AF1           E8         BB2A            call	_write_byte
16333 4AF4           83C4                   06  add	sp,*6
16334                                           !BCC_EOS
16335                                           ! 2555         FLAGS &= 0xfffe;
16336                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16337 4AF7           8B46         18            mov	ax,$18[bp]
16338 4AFA           24                     FE  and	al,#$FE
16339 4AFC           8946         18            mov	$18[bp],ax
16340                                           !BCC_EOS
16341                                           ! 2556         bRegister = inb_cmos( 0xB );
16342                                           ! Debug: list int = const $B (used reg = )
16343 4AFF           B8                   000B  mov	ax,*$B
16344 4B02           50                         push	ax
16345                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16346 4B03           E8         BA81            call	_inb_cmos
16347 4B06           44                         inc	sp
16348 4B07           44                         inc	sp
16349                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
16350 4B08           30E4                       xor	ah,ah
16351 4B0A           8946         EE            mov	-$12[bp],ax
16352                                           !BCC_EOS
16353                                           ! 2557         outb_cmos( 0xB, bRegister & ~0x40 );
16354                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
16355 4B0D           8B46         EE            mov	ax,-$12[bp]
16356 4B10           24                     BF  and	al,#$BF
16357                                           ! Debug: list unsigned int = ax+0 (used reg = )
16358 4B12           50                         push	ax
16359                                           ! Debug: list int = const $B (used reg = )
16360 4B13           B8                   000B  mov	ax,*$B
16361 4B16           50                         push	ax
16362                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16363 4B17           E8         BA5E            call	_outb_cmos
16364 4B1A           83C4                   04  add	sp,*4
16365                                           !BCC_EOS
16366                                           ! 2558       } else {
16367 4B1D           EB           14            jmp .37E
16368                       00004B1F            .37C:
16369                                           ! 2559         ;
16370                                           !BCC_EOS
16371                                           ! 2560         FLAGS |= 0x0001;
16372                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
16373 4B1F           8B46         18            mov	ax,$18[bp]
16374 4B22           0C                     01  or	al,*1
16375 4B24           8946         18            mov	$18[bp],ax
16376                                           !BCC_EOS
16377                                           ! 2561         regs.u.r8.ah = 0x86;
16378                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
16379 4B27           B0                     86  mov	al,#$86
16380 4B29           8846         13            mov	$13[bp],al
16381                                           !BCC_EOS
16382                                           ! 2562         regs.u.r8.al--;
16383                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
16384 4B2C           8A46         12            mov	al,$12[bp]
16385 4B2F           48                         dec	ax
16386 4B30           8846         12            mov	$12[bp],al
16387                                           !BCC_EOS
16388                                           ! 2563       }
16389                                           ! 2564       break;
16390                       00004B33            .37E:
16391                       00004B33            .37B:
16392 4B33           E9         040B            br 	.365
16393                                           !BCC_EOS
16394                                           ! 2565     }
16395                                           ! 2566     case 0x87:
16396                                           ! 2567 #asm
16397                       00004B36            .37F:
16398                                           !BCC_EOS
16399                                           !BCC_ASM
16400                       00000006            _int15_function.CX	set	6
16401                       FFFFFFF2            .int15_function.CX	set	-$E
16402                       0000002C            _int15_function.FLAGS	set	$2C
16403                       00000018            .int15_function.FLAGS	set	$18
16404                       00000001            _int15_function.irqDisable	set	1
16405                       FFFFFFED            .int15_function.irqDisable	set	-$13
16406                       0000002A            _int15_function.DS	set	$2A
16407                       00000016            .int15_function.DS	set	$16
16408                       00000004            _int15_function.DX	set	4
16409                       FFFFFFF0            .int15_function.DX	set	-$10
16410                       0000000D            _int15_function.base23_16	set	$D
16411                       FFFFFFF9            .int15_function.base23_16	set	-7
16412                       00000002            _int15_function.bRegister	set	2
16413                       FFFFFFEE            .int15_function.bRegister	set	-$12
16414                       00000028            _int15_function.ES	set	$28
16415                       00000014            .int15_function.ES	set	$14
16416                       00000012            _int15_function.ebda_seg	set	$12
16417                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16418                       0000000E            _int15_function.base15_00	set	$E
16419                       FFFFFFFA            .int15_function.base15_00	set	-6
16420                       0000000A            _int15_function.ss	set	$A
16421                       FFFFFFF6            .int15_function.ss	set	-$A
16422                       00000008            _int15_function.BX	set	8
16423                       FFFFFFF4            .int15_function.BX	set	-$C
16424                       00000018            _int15_function.regs	set	$18
16425                       00000004            .int15_function.regs	set	4
16426                       00000010            _int15_function.prev_a20_enable	set	$10
16427                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16428 4B36           FA                           cli
16429                                           ! 2569 endasm
16430                                           !BCC_ENDASM
16431                                           !BCC_EOS
16432                                           ! 2570       prev_a20_enable = set_enable_a20(1);
16433                                           ! Debug: list int = const 1 (used reg = )
16434 4B37           B8                   0001  mov	ax,*1
16435 4B3A           50                         push	ax
16436                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16437 4B3B           E8         CCBB            call	_set_enable_a20
16438 4B3E           44                         inc	sp
16439 4B3F           44                         inc	sp
16440                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
16441 4B40           8946         FC            mov	-4[bp],ax
16442                                           !BCC_EOS
16443                                           ! 2571       base15_00 = (ES << 4) + regs.u.r16.si;
16444                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
16445 4B43           8B46         14            mov	ax,$14[bp]
16446 4B46           B1                     04  mov	cl,*4
16447 4B48           D3E0                       shl	ax,cl
16448                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
16449 4B4A           0346         06            add	ax,6[bp]
16450                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16451 4B4D           8946         FA            mov	-6[bp],ax
16452                                           !BCC_EOS
16453                                           ! 2572       base23_16 = ES >> 12;
16454                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
16455 4B50           8B46         14            mov	ax,$14[bp]
16456 4B53           88E0                       mov	al,ah
16457 4B55           30E4                       xor	ah,ah
16458 4B57           B1                     04  mov	cl,*4
16459 4B59           D3E8                       shr	ax,cl
16460                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
16461 4B5B           8846         F9            mov	-7[bp],al
16462                                           !BCC_EOS
16463                                           ! 2573       if (base15_00 < (ES<<4))
16464                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
16465 4B5E           8B46         14            mov	ax,$14[bp]
16466 4B61           B1                     04  mov	cl,*4
16467 4B63           D3E0                       shl	ax,cl
16468                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16469 4B65           3B46         FA            cmp	ax,-6[bp]
16470 4B68           76           07            jbe 	.380
16471                       00004B6A            .381:
16472                                           ! 2574         base23_16++;
16473                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
16474 4B6A           8A46         F9            mov	al,-7[bp]
16475 4B6D           40                         inc	ax
16476 4B6E           8846         F9            mov	-7[bp],al
16477                                           !BCC_EOS
16478                                           ! 2575       write_word(ES, regs.u.r16.si+0x08+0, 47);
16479                       00004B71            .380:
16480                                           ! Debug: list int = const $2F (used reg = )
16481 4B71           B8                   002F  mov	ax,*$2F
16482 4B74           50                         push	ax
16483                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16484 4B75           8B46         06            mov	ax,6[bp]
16485                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16486                                           ! Debug: list unsigned int = ax+8 (used reg = )
16487 4B78           05                   0008  add	ax,*8
16488 4B7B           50                         push	ax
16489                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16490 4B7C           FF76         14            push	$14[bp]
16491                                           ! Debug: func () void = write_word+0 (used reg = )
16492 4B7F           E8         BAB4            call	_write_word
16493 4B82           83C4                   06  add	sp,*6
16494                                           !BCC_EOS
16495                                           ! 2576       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16496                                           ! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
16497 4B85           FF76         FA            push	-6[bp]
16498                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16499 4B88           8B46         06            mov	ax,6[bp]
16500                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16501                                           ! Debug: list unsigned int = ax+$A (used reg = )
16502 4B8B           05                   000A  add	ax,*$A
16503 4B8E           50                         push	ax
16504                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16505 4B8F           FF76         14            push	$14[bp]
16506                                           ! Debug: func () void = write_word+0 (used reg = )
16507 4B92           E8         BAA1            call	_write_word
16508 4B95           83C4                   06  add	sp,*6
16509                                           !BCC_EOS
16510                                           ! 2577       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16511                                           ! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
16512 4B98           8A46         F9            mov	al,-7[bp]
16513 4B9B           30E4                       xor	ah,ah
16514 4B9D           50                         push	ax
16515                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16516 4B9E           8B46         06            mov	ax,6[bp]
16517                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16518                                           ! Debug: list unsigned int = ax+$C (used reg = )
16519 4BA1           05                   000C  add	ax,*$C
16520 4BA4           50                         push	ax
16521                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16522 4BA5           FF76         14            push	$14[bp]
16523                                           ! Debug: func () void = write_byte+0 (used reg = )
16524 4BA8           E8         BA73            call	_write_byte
16525 4BAB           83C4                   06  add	sp,*6
16526                                           !BCC_EOS
16527                                           ! 2578       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16528                                           ! Debug: list int = const $93 (used reg = )
16529 4BAE           B8                   0093  mov	ax,#$93
16530 4BB1           50                         push	ax
16531                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16532 4BB2           8B46         06            mov	ax,6[bp]
16533                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16534                                           ! Debug: list unsigned int = ax+$D (used reg = )
16535 4BB5           05                   000D  add	ax,*$D
16536 4BB8           50                         push	ax
16537                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16538 4BB9           FF76         14            push	$14[bp]
16539                                           ! Debug: func () void = write_byte+0 (used reg = )
16540 4BBC           E8         BA5F            call	_write_byte
16541 4BBF           83C4                   06  add	sp,*6
16542                                           !BCC_EOS
16543                                           ! 2579       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16544                                           ! Debug: list int = const 0 (used reg = )
16545 4BC2           31C0                       xor	ax,ax
16546 4BC4           50                         push	ax
16547                                           ! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
16548 4BC5           8B46         06            mov	ax,6[bp]
16549                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16550                                           ! Debug: list unsigned int = ax+$E (used reg = )
16551 4BC8           05                   000E  add	ax,*$E
16552 4BCB           50                         push	ax
16553                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16554 4BCC           FF76         14            push	$14[bp]
16555                                           ! Debug: func () void = write_word+0 (used reg = )
16556 4BCF           E8         BA64            call	_write_word
16557 4BD2           83C4                   06  add	sp,*6
16558                                           !BCC_EOS
16559                                           ! 2580       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16560                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16561 4BD5           B8                   FFFF  mov	ax,#$FFFF
16562 4BD8           50                         push	ax
16563                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16564 4BD9           8B46         06            mov	ax,6[bp]
16565                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16566                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16567 4BDC           05                   0020  add	ax,*$20
16568 4BDF           50                         push	ax
16569                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16570 4BE0           FF76         14            push	$14[bp]
16571                                           ! Debug: func () void = write_word+0 (used reg = )
16572 4BE3           E8         BA50            call	_write_word
16573 4BE6           83C4                   06  add	sp,*6
16574                                           !BCC_EOS
16575                                           ! 2581       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16576                                           ! Debug: list int = const 0 (used reg = )
16577 4BE9           31C0                       xor	ax,ax
16578 4BEB           50                         push	ax
16579                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16580 4BEC           8B46         06            mov	ax,6[bp]
16581                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16582                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16583 4BEF           05                   0022  add	ax,*$22
16584 4BF2           50                         push	ax
16585                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16586 4BF3           FF76         14            push	$14[bp]
16587                                           ! Debug: func () void = write_word+0 (used reg = )
16588 4BF6           E8         BA3D            call	_write_word
16589 4BF9           83C4                   06  add	sp,*6
16590                                           !BCC_EOS
16591                                           ! 2582       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16592                                           ! Debug: list int = const $F (used reg = )
16593 4BFC           B8                   000F  mov	ax,*$F
16594 4BFF           50                         push	ax
16595                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16596 4C00           8B46         06            mov	ax,6[bp]
16597                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16598                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16599 4C03           05                   0024  add	ax,*$24
16600 4C06           50                         push	ax
16601                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16602 4C07           FF76         14            push	$14[bp]
16603                                           ! Debug: func () void = write_byte+0 (used reg = )
16604 4C0A           E8         BA11            call	_write_byte
16605 4C0D           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 2583       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16608                                           ! Debug: list int = const $9B (used reg = )
16609 4C10           B8                   009B  mov	ax,#$9B
16610 4C13           50                         push	ax
16611                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16612 4C14           8B46         06            mov	ax,6[bp]
16613                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16614                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16615 4C17           05                   0025  add	ax,*$25
16616 4C1A           50                         push	ax
16617                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16618 4C1B           FF76         14            push	$14[bp]
16619                                           ! Debug: func () void = write_byte+0 (used reg = )
16620 4C1E           E8         B9FD            call	_write_byte
16621 4C21           83C4                   06  add	sp,*6
16622                                           !BCC_EOS
16623                                           ! 2584       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
16624                                           ! Debug: list int = const 0 (used reg = )
16625 4C24           31C0                       xor	ax,ax
16626 4C26           50                         push	ax
16627                                           ! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
16628 4C27           8B46         06            mov	ax,6[bp]
16629                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16630                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16631 4C2A           05                   0026  add	ax,*$26
16632 4C2D           50                         push	ax
16633                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16634 4C2E           FF76         14            push	$14[bp]
16635                                           ! Debug: func () void = write_word+0 (used reg = )
16636 4C31           E8         BA02            call	_write_word
16637 4C34           83C4                   06  add	sp,*6
16638                                           !BCC_EOS
16639                                           ! 2585       ss = get_SS();
16640                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16641 4C37           E8         BA17            call	_get_SS
16642                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
16643 4C3A           8946         F6            mov	-$A[bp],ax
16644                                           !BCC_EOS
16645                                           ! 2586       base15_00 = ss << 4;
16646                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
16647 4C3D           8B46         F6            mov	ax,-$A[bp]
16648 4C40           B1                     04  mov	cl,*4
16649 4C42           D3E0                       shl	ax,cl
16650                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
16651 4C44           8946         FA            mov	-6[bp],ax
16652                                           !BCC_EOS
16653                                           ! 2587       base23_16 = ss >> 12;
16654                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
16655 4C47           8B46         F6            mov	ax,-$A[bp]
16656 4C4A           88E0                       mov	al,ah
16657 4C4C           30E4                       xor	ah,ah
16658 4C4E           B1                     04  mov	cl,*4
16659 4C50           D3E8                       shr	ax,cl
16660                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
16661 4C52           8846         F9            mov	-7[bp],al
16662                                           !BCC_EOS
16663                                           ! 2588       write_word(ES, regs.u.r16.si+0x28+0
16664                                           ! 2588 , 0xffff);
16665                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16666 4C55           B8                   FFFF  mov	ax,#$FFFF
16667 4C58           50                         push	ax
16668                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16669 4C59           8B46         06            mov	ax,6[bp]
16670                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16671                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16672 4C5C           05                   0028  add	ax,*$28
16673 4C5F           50                         push	ax
16674                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16675 4C60           FF76         14            push	$14[bp]
16676                                           ! Debug: func () void = write_word+0 (used reg = )
16677 4C63           E8         B9D0            call	_write_word
16678 4C66           83C4                   06  add	sp,*6
16679                                           !BCC_EOS
16680                                           ! 2589       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16681                                           ! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
16682 4C69           FF76         FA            push	-6[bp]
16683                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16684 4C6C           8B46         06            mov	ax,6[bp]
16685                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16686                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16687 4C6F           05                   002A  add	ax,*$2A
16688 4C72           50                         push	ax
16689                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16690 4C73           FF76         14            push	$14[bp]
16691                                           ! Debug: func () void = write_word+0 (used reg = )
16692 4C76           E8         B9BD            call	_write_word
16693 4C79           83C4                   06  add	sp,*6
16694                                           !BCC_EOS
16695                                           ! 2590       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16696                                           ! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
16697 4C7C           8A46         F9            mov	al,-7[bp]
16698 4C7F           30E4                       xor	ah,ah
16699 4C81           50                         push	ax
16700                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16701 4C82           8B46         06            mov	ax,6[bp]
16702                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16703                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16704 4C85           05                   002C  add	ax,*$2C
16705 4C88           50                         push	ax
16706                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16707 4C89           FF76         14            push	$14[bp]
16708                                           ! Debug: func () void = write_byte+0 (used reg = )
16709 4C8C           E8         B98F            call	_write_byte
16710 4C8F           83C4                   06  add	sp,*6
16711                                           !BCC_EOS
16712                                           ! 2591       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
16713                                           ! Debug: list int = const $93 (used reg = )
16714 4C92           B8                   0093  mov	ax,#$93
16715 4C95           50                         push	ax
16716                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16717 4C96           8B46         06            mov	ax,6[bp]
16718                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
16719                                           ! Debug: list unsigned int = ax+$2D (used reg = )
16720 4C99           05                   002D  add	ax,*$2D
16721 4C9C           50                         push	ax
16722                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16723 4C9D           FF76         14            push	$14[bp]
16724                                           ! Debug: func () void = write_byte+0 (used reg = )
16725 4CA0           E8         B97B            call	_write_byte
16726 4CA3           83C4                   06  add	sp,*6
16727                                           !BCC_EOS
16728                                           ! 2592       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
16729                                           ! Debug: list int = const 0 (used reg = )
16730 4CA6           31C0                       xor	ax,ax
16731 4CA8           50                         push	ax
16732                                           ! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
16733 4CA9           8B46         06            mov	ax,6[bp]
16734                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
16735                                           ! Debug: list unsigned int = ax+$2E (used reg = )
16736 4CAC           05                   002E  add	ax,*$2E
16737 4CAF           50                         push	ax
16738                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16739 4CB0           FF76         14            push	$14[bp]
16740                                           ! Debug: func () void = write_word+0 (used reg = )
16741 4CB3           E8         B980            call	_write_word
16742 4CB6           83C4                   06  add	sp,*6
16743                                           !BCC_EOS
16744                                           ! 2593       CX = regs.u.r16.cx;
16745                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
16746 4CB9           8B46         10            mov	ax,$10[bp]
16747 4CBC           8946         F2            mov	-$E[bp],ax
16748                                           !BCC_EOS
16749                                           ! 2594 #asm
16750                                           !BCC_EOS
16751                                           !BCC_ASM
16752                       00000006            _int15_function.CX	set	6
16753                       FFFFFFF2            .int15_function.CX	set	-$E
16754                       0000002C            _int15_function.FLAGS	set	$2C
16755                       00000018            .int15_function.FLAGS	set	$18
16756                       00000001            _int15_function.irqDisable	set	1
16757                       FFFFFFED            .int15_function.irqDisable	set	-$13
16758                       0000002A            _int15_function.DS	set	$2A
16759                       00000016            .int15_function.DS	set	$16
16760                       00000004            _int15_function.DX	set	4
16761                       FFFFFFF0            .int15_function.DX	set	-$10
16762                       0000000D            _int15_function.base23_16	set	$D
16763                       FFFFFFF9            .int15_function.base23_16	set	-7
16764                       00000002            _int15_function.bRegister	set	2
16765                       FFFFFFEE            .int15_function.bRegister	set	-$12
16766                       00000028            _int15_function.ES	set	$28
16767                       00000014            .int15_function.ES	set	$14
16768                       00000012            _int15_function.ebda_seg	set	$12
16769                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16770                       0000000E            _int15_function.base15_00	set	$E
16771                       FFFFFFFA            .int15_function.base15_00	set	-6
16772                       0000000A            _int15_function.ss	set	$A
16773                       FFFFFFF6            .int15_function.ss	set	-$A
16774                       00000008            _int15_function.BX	set	8
16775                       FFFFFFF4            .int15_function.BX	set	-$C
16776                       00000018            _int15_function.regs	set	$18
16777                       00000004            .int15_function.regs	set	4
16778                       00000010            _int15_function.prev_a20_enable	set	$10
16779                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16780 4CBF           89E3                             mov bx, sp
16781 4CC1           36                               SEG SS
16782 4CC2           8B4F         06                    mov cx, _int15_function.CX [bx]
16783 4CC5     66    50                               push eax
16784 4CC7     66    31C0                             xor eax, eax
16785 4CCA           8ED8                             mov ds, ax
16786 4CCC           8C16       0469                  mov 0x0469, ss
16787 4CD0           8926       0467                  mov 0x0467, sp
16788 4CD4           26                               SEG ES
16789 4CD5         0F0154         08                    lgdt [si + 0x08]
16790 4CD9           2E                               SEG CS
16791 4CDA         0F011E       F88C                    lidt [pmode_IDT_info]
16792                                                 ;; perhaps do something with IDT here
16793                                                 ;; set PE bit in CR0
16794 4CDF         0F20C0                             mov eax, cr0
16795 4CE2           0C                     01        or al, #0x01
16796 4CE4         0F22C0                             mov cr0, eax
16797                                                 ;; far jump to flush CPU queue after transition to protected mode
16798                                                 JMP_AP(0x0020, protected_mode)
 +a   4CE7                        EA              db 0xea
 +a   4CE8                      4CEC              dw  protected_mode
 +a   4CEA                      0020              dw 0x0020
16799                       00004CEC            protected_mode:
16800                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
16801 4CEC           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
16802 4CEF           8ED0                             mov ss, ax
16803 4CF1           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
16804 4CF4           8ED8                             mov ds, ax
16805 4CF6           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
16806 4CF9           8EC0                             mov es, ax
16807 4CFB           31F6                             xor si, si
16808 4CFD           31FF                             xor di, di
16809 4CFF           FC                               cld
16810 4D00           F3                               rep
16811 4D01           A5                                 movsw ;; move CX words from DS:SI to ES:DI
16812                                                 ;; make sure DS and ES limits are 64KB
16813 4D02           B8                   0028        mov ax, #0x28
16814 4D05           8ED8                             mov ds, ax
16815 4D07           8EC0                             mov es, ax
16816                                                 ;; reset PG bit in CR0 ???
16817 4D09         0F20C0                             mov eax, cr0
16818 4D0C           24                     FE        and al, #0xFE
16819 4D0E         0F22C0                             mov cr0, eax
16820                                                 ;; far jump to flush CPU queue after transition to real mode
16821                                                 JMP_AP(0xf000, real_mode)
 +a   4D11                        EA              db 0xea
 +a   4D12                      4D16              dw  real_mode
 +a   4D14                      F000              dw 0xf000
16822                       00004D16            real_mode:
16823                                                 ;; restore IDT to normal real-mode defaults
16824 4D16           2E                               SEG CS
16825 4D17         0F011E       F891                    lidt [rmode_IDT_info]
16826 4D1C           31C0                             xor ax, ax
16827 4D1E           8ED8                             mov ds, ax
16828 4D20           8E16       0469                  mov ss, 0x0469
16829 4D24           8B26       0467                  mov sp, 0x0467
16830 4D28     66    58                               pop eax
16831                                           ! 2646 endasm
16832                                           !BCC_ENDASM
16833                                           !BCC_EOS
16834                                           ! 2647       set_enable_a20(prev_a20_enable);
16835                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
16836 4D2A           FF76         FC            push	-4[bp]
16837                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16838 4D2D           E8         CAC9            call	_set_enable_a20
16839 4D30           44                         inc	sp
16840 4D31           44                         inc	sp
16841                                           !BCC_EOS
16842                                           ! 2648 #asm
16843                                           !BCC_EOS
16844                                           !BCC_ASM
16845                       00000006            _int15_function.CX	set	6
16846                       FFFFFFF2            .int15_function.CX	set	-$E
16847                       0000002C            _int15_function.FLAGS	set	$2C
16848                       00000018            .int15_function.FLAGS	set	$18
16849                       00000001            _int15_function.irqDisable	set	1
16850                       FFFFFFED            .int15_function.irqDisable	set	-$13
16851                       0000002A            _int15_function.DS	set	$2A
16852                       00000016            .int15_function.DS	set	$16
16853                       00000004            _int15_function.DX	set	4
16854                       FFFFFFF0            .int15_function.DX	set	-$10
16855                       0000000D            _int15_function.base23_16	set	$D
16856                       FFFFFFF9            .int15_function.base23_16	set	-7
16857                       00000002            _int15_function.bRegister	set	2
16858                       FFFFFFEE            .int15_function.bRegister	set	-$12
16859                       00000028            _int15_function.ES	set	$28
16860                       00000014            .int15_function.ES	set	$14
16861                       00000012            _int15_function.ebda_seg	set	$12
16862                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16863                       0000000E            _int15_function.base15_00	set	$E
16864                       FFFFFFFA            .int15_function.base15_00	set	-6
16865                       0000000A            _int15_function.ss	set	$A
16866                       FFFFFFF6            .int15_function.ss	set	-$A
16867                       00000008            _int15_function.BX	set	8
16868                       FFFFFFF4            .int15_function.BX	set	-$C
16869                       00000018            _int15_function.regs	set	$18
16870                       00000004            .int15_function.regs	set	4
16871                       00000010            _int15_function.prev_a20_enable	set	$10
16872                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16873 4D32           FB                           sti
16874                                           ! 2650 endasm
16875                                           !BCC_ENDASM
16876                                           !BCC_EOS
16877                                           ! 2651       regs.u.r8.ah = 0;
16878                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
16879 4D33           30C0                       xor	al,al
16880 4D35           8846         13            mov	$13[bp],al
16881                                           !BCC_EOS
16882                                           ! 2652       FLAGS &= 0xfffe;
16883                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16884 4D38           8B46         18            mov	ax,$18[bp]
16885 4D3B           24                     FE  and	al,#$FE
16886 4D3D           8946         18            mov	$18[bp],ax
16887                                           !BCC_EOS
16888                                           ! 2653       break;
16889 4D40           E9         01FE            br 	.365
16890                                           !BCC_EOS
16891                                           ! 2654     case 0x88:
16892                                           ! 2655       regs.u.r8.al = inb_cmos(0x30);
16893                       00004D43            .382:
16894                                           ! Debug: list int = const $30 (used reg = )
16895 4D43           B8                   0030  mov	ax,*$30
16896 4D46           50                         push	ax
16897                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16898 4D47           E8         B83D            call	_inb_cmos
16899 4D4A           44                         inc	sp
16900 4D4B           44                         inc	sp
16901                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
16902 4D4C           8846         12            mov	$12[bp],al
16903                                           !BCC_EOS
16904                                           ! 2656       regs.u.r8.ah = inb_cmos(0x31);
16905                                           ! Debug: list int = const $31 (used reg = )
16906 4D4F           B8                   0031  mov	ax,*$31
16907 4D52           50                         push	ax
16908                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16909 4D53           E8         B831            call	_inb_cmos
16910 4D56           44                         inc	sp
16911 4D57           44                         inc	sp
16912                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
16913 4D58           8846         13            mov	$13[bp],al
16914                                           !BCC_EOS
16915                                           ! 2657       if(regs.u.r16.ax > 0xffc0)
16916                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
16917 4D5B           8B46         12            mov	ax,$12[bp]
16918 4D5E           3D                   FFC0  cmp	ax,#$FFC0
16919 4D61           76           06            jbe 	.383
16920                       00004D63            .384:
16921                                           ! 2658         regs.u.r16.ax = 0xffc0;
16922                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
16923 4D63           B8                   FFC0  mov	ax,#$FFC0
16924 4D66           8946         12            mov	$12[bp],ax
16925                                           !BCC_EOS
16926                                           ! 2659       FLAGS &= 0xfffe;
16927                       00004D69            .383:
16928                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
16929 4D69           8B46         18            mov	ax,$18[bp]
16930 4D6C           24                     FE  and	al,#$FE
16931 4D6E           8946         18            mov	$18[bp],ax
16932                                           !BCC_EOS
16933                                           ! 2660       break;
16934 4D71           E9         01CD            br 	.365
16935                                           !BCC_EOS
16936                                           ! 2661   case 0x89:
16937                                           ! 2662 #asm
16938                       00004D74            .385:
16939                                           !BCC_EOS
16940                                           !BCC_ASM
16941                       00000006            _int15_function.CX	set	6
16942                       FFFFFFF2            .int15_function.CX	set	-$E
16943                       0000002C            _int15_function.FLAGS	set	$2C
16944                       00000018            .int15_function.FLAGS	set	$18
16945                       00000001            _int15_function.irqDisable	set	1
16946                       FFFFFFED            .int15_function.irqDisable	set	-$13
16947                       0000002A            _int15_function.DS	set	$2A
16948                       00000016            .int15_function.DS	set	$16
16949                       00000004            _int15_function.DX	set	4
16950                       FFFFFFF0            .int15_function.DX	set	-$10
16951                       0000000D            _int15_function.base23_16	set	$D
16952                       FFFFFFF9            .int15_function.base23_16	set	-7
16953                       00000002            _int15_function.bRegister	set	2
16954                       FFFFFFEE            .int15_function.bRegister	set	-$12
16955                       00000028            _int15_function.ES	set	$28
16956                       00000014            .int15_function.ES	set	$14
16957                       00000012            _int15_function.ebda_seg	set	$12
16958                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16959                       0000000E            _int15_function.base15_00	set	$E
16960                       FFFFFFFA            .int15_function.base15_00	set	-6
16961                       0000000A            _int15_function.ss	set	$A
16962                       FFFFFFF6            .int15_function.ss	set	-$A
16963                       00000008            _int15_function.BX	set	8
16964                       FFFFFFF4            .int15_function.BX	set	-$C
16965                       00000018            _int15_function.regs	set	$18
16966                       00000004            .int15_function.regs	set	4
16967                       00000010            _int15_function.prev_a20_enable	set	$10
16968                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16969 4D74           FA                           cli
16970                                           ! 2664 endasm
16971                                           !BCC_ENDASM
16972                                           !BCC_EOS
16973                                           ! 2665       set_enable_a20(1);
16974                                           ! 2665 
16975                                           ! Debug: list int = const 1 (used reg = )
16976 4D75           B8                   0001  mov	ax,*1
16977 4D78           50                         push	ax
16978                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16979 4D79           E8         CA7D            call	_set_enable_a20
16980 4D7C           44                         inc	sp
16981 4D7D           44                         inc	sp
16982                                           !BCC_EOS
16983                                           ! 2666       write_word(ES, regs.u.r16.si+0x38+0, 0xffff);
16984                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16985 4D7E           B8                   FFFF  mov	ax,#$FFFF
16986 4D81           50                         push	ax
16987                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
16988 4D82           8B46         06            mov	ax,6[bp]
16989                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
16990                                           ! Debug: list unsigned int = ax+$38 (used reg = )
16991 4D85           05                   0038  add	ax,*$38
16992 4D88           50                         push	ax
16993                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
16994 4D89           FF76         14            push	$14[bp]
16995                                           ! Debug: func () void = write_word+0 (used reg = )
16996 4D8C           E8         B8A7            call	_write_word
16997 4D8F           83C4                   06  add	sp,*6
16998                                           !BCC_EOS
16999                                           ! 2667       write_word(ES, regs.u.r16.si+0x38+2, 0x0000);
17000                                           ! Debug: list int = const 0 (used reg = )
17001 4D92           31C0                       xor	ax,ax
17002 4D94           50                         push	ax
17003                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17004 4D95           8B46         06            mov	ax,6[bp]
17005                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
17006                                           ! Debug: list unsigned int = ax+$3A (used reg = )
17007 4D98           05                   003A  add	ax,*$3A
17008 4D9B           50                         push	ax
17009                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17010 4D9C           FF76         14            push	$14[bp]
17011                                           ! Debug: func () void = write_word+0 (used reg = )
17012 4D9F           E8         B894            call	_write_word
17013 4DA2           83C4                   06  add	sp,*6
17014                                           !BCC_EOS
17015                                           ! 2668       write_byte(ES, regs.u.r16.si+0x38+4, 0x000f);
17016                                           ! Debug: list int = const $F (used reg = )
17017 4DA5           B8                   000F  mov	ax,*$F
17018 4DA8           50                         push	ax
17019                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17020 4DA9           8B46         06            mov	ax,6[bp]
17021                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
17022                                           ! Debug: list unsigned int = ax+$3C (used reg = )
17023 4DAC           05                   003C  add	ax,*$3C
17024 4DAF           50                         push	ax
17025                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17026 4DB0           FF76         14            push	$14[bp]
17027                                           ! Debug: func () void = write_byte+0 (used reg = )
17028 4DB3           E8         B868            call	_write_byte
17029 4DB6           83C4                   06  add	sp,*6
17030                                           !BCC_EOS
17031                                           ! 2669       write_byte(ES, regs.u.r16.si+0x38+5, 0x9b);
17032                                           ! Debug: list int = const $9B (used reg = )
17033 4DB9           B8                   009B  mov	ax,#$9B
17034 4DBC           50                         push	ax
17035                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17036 4DBD           8B46         06            mov	ax,6[bp]
17037                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
17038                                           ! Debug: list unsigned int = ax+$3D (used reg = )
17039 4DC0           05                   003D  add	ax,*$3D
17040 4DC3           50                         push	ax
17041                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17042 4DC4           FF76         14            push	$14[bp]
17043                                           ! Debug: func () void = write_byte+0 (used reg = )
17044 4DC7           E8         B854            call	_write_byte
17045 4DCA           83C4                   06  add	sp,*6
17046                                           !BCC_EOS
17047                                           ! 2670       write_word(ES, regs.u.r16.si+0x38+6, 0x0000);
17048                                           ! Debug: list int = const 0 (used reg = )
17049 4DCD           31C0                       xor	ax,ax
17050 4DCF           50                         push	ax
17051                                           ! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
17052 4DD0           8B46         06            mov	ax,6[bp]
17053                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
17054                                           ! Debug: list unsigned int = ax+$3E (used reg = )
17055 4DD3           05                   003E  add	ax,*$3E
17056 4DD6           50                         push	ax
17057                                           ! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
17058 4DD7           FF76         14            push	$14[bp]
17059                                           ! Debug: func () void = write_word+0 (used reg = )
17060 4DDA           E8         B859            call	_write_word
17061 4DDD           83C4                   06  add	sp,*6
17062                                           !BCC_EOS
17063                                           ! 2671       BX = regs.u.r16.bx;
17064                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
17065 4DE0           8B46         0C            mov	ax,$C[bp]
17066 4DE3           8946         F4            mov	-$C[bp],ax
17067                                           !BCC_EOS
17068                                           ! 2672 #asm
17069                                           !BCC_EOS
17070                                           !BCC_ASM
17071                       00000006            _int15_function.CX	set	6
17072                       FFFFFFF2            .int15_function.CX	set	-$E
17073                       0000002C            _int15_function.FLAGS	set	$2C
17074                       00000018            .int15_function.FLAGS	set	$18
17075                       00000001            _int15_function.irqDisable	set	1
17076                       FFFFFFED            .int15_function.irqDisable	set	-$13
17077                       0000002A            _int15_function.DS	set	$2A
17078                       00000016            .int15_function.DS	set	$16
17079                       00000004            _int15_function.DX	set	4
17080                       FFFFFFF0            .int15_function.DX	set	-$10
17081                       0000000D            _int15_function.base23_16	set	$D
17082                       FFFFFFF9            .int15_function.base23_16	set	-7
17083                       00000002            _int15_function.bRegister	set	2
17084                       FFFFFFEE            .int15_function.bRegister	set	-$12
17085                       00000028            _int15_function.ES	set	$28
17086                       00000014            .int15_function.ES	set	$14
17087                       00000012            _int15_function.ebda_seg	set	$12
17088                       FFFFFFFE            .int15_function.ebda_seg	set	-2
17089                       0000000E            _int15_function.base15_00	set	$E
17090                       FFFFFFFA            .int15_function.base15_00	set	-6
17091                       0000000A            _int15_function.ss	set	$A
17092                       FFFFFFF6            .int15_function.ss	set	-$A
17093                       00000008            _int15_function.BX	set	8
17094                       FFFFFFF4            .int15_function.BX	set	-$C
17095                       00000018            _int15_function.regs	set	$18
17096                       00000004            .int15_function.regs	set	4
17097                       00000010            _int15_function.prev_a20_enable	set	$10
17098                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
17099 4DE6           89E3                             mov bx, sp
17100 4DE8           36                               SEG SS
17101 4DE9           8B5F         08                    mov bx, _int15_function.BX [bx]
17102 4DEC           B0                     11        mov al, #0x11 ; send initialisation commands
17103 4DEE           E6                     20        out 0x20, al
17104 4DF0           E6                     A0        out 0xa0, al
17105 4DF2           88F8                             mov al, bh
17106 4DF4           E6                     21        out 0x21, al
17107 4DF6           88D8                             mov al, bl
17108 4DF8           E6                     A1        out 0xa1, al
17109 4DFA           B0                     04        mov al, #0x04
17110 4DFC           E6                     21        out 0x21, al
17111 4DFE           B0                     02        mov al, #0x02
17112 4E00           E6                     A1        out 0xa1, al
17113 4E02           B0                     01        mov al, #0x01
17114 4E04           E6                     21        out 0x21, al
17115 4E06           E6                     A1        out 0xa1, al
17116 4E08           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
17117 4E0A           E6                     21        out 0x21, al
17118 4E0C           E6                     A1        out 0xa1, al
17119 4E0E           26                               SEG ES
17120 4E0F         0F0154         08                    lgdt [si + 0x08]
17121 4E13           26                               SEG ES
17122 4E14         0F015C         10                    lidt [si + 0x10]
17123 4E18         0F20C0                             mov eax, cr0
17124 4E1B           0C                     01        or al, #0x01
17125 4E1D         0F22C0                             mov cr0, eax
17126                                                 JMP_AP(0x0038, protmode_switch)
 +a   4E20                        EA              db 0xea
 +a   4E21                      4E25              dw  protmode_switch
 +a   4E23                      0038              dw 0x0038
17127                       00004E25            protmode_switch:
17128                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
17129 4E25           B8                   0028        mov ax, #0x28
17130 4E28           8ED0                             mov ss, ax
17131 4E2A           B8                   0018        mov ax, #0x18
17132 4E2D           8ED8                             mov ds, ax
17133 4E2F           B8                   0020        mov ax, #0x20
17134 4E32           8EC0                             mov es, ax
17135 4E34           89EC                             mov sp,bp
17136 4E36           83C4                   04        add sp,#4 ; skip return address
17137 4E39           61                               popa ; restore regs
17138 4E3A           58                               pop ax ; skip saved es
17139 4E3B           58                               pop ax ; skip saved ds
17140 4E3C           58                               pop ax ; skip saved flags
17141 4E3D           59                               pop cx ; get return offset
17142 4E3E           58                               pop ax ; skip return segment
17143 4E3F           58                               pop ax ; skip flags
17144 4E40           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
17145 4E43           50                               push ax
17146 4E44           51                               push cx ; re-create modified ret address on stack
17147 4E45           CB                               retf
17148                                           ! 2722 endasm
17149                                           !BCC_ENDASM
17150                                           !BCC_EOS
17151                                           ! 2723       break;
17152 4E46           E9         00F8            br 	.365
17153                                           !BCC_EOS
17154                                           ! 2724     case 0x90:
17155                                           ! 2725       break;
17156                       00004E49            .386:
17157 4E49           E9         00F5            br 	.365
17158                                           !BCC_EOS
17159                                           ! 2726     case 0x91:
17160                                           ! 2727       break;
17161                       00004E4C            .387:
17162 4E4C           E9         00F2            br 	.365
17163                                           !BCC_EOS
17164                                           ! 2728     case 0xbf:
17165                                           ! 2729       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
17166                       00004E4F            .388:
17167                                           ! Debug: list * char = .389+0 (used reg = )
17168 4E4F           BB                   D546  mov	bx,#.389
17169 4E52           53                         push	bx
17170                                           ! Debug: list int = const 4 (used reg = )
17171 4E53           B8                   0004  mov	ax,*4
17172 4E56           50                         push	ax
17173                                           ! Debug: func () void = bios_printf+0 (used reg = )
17174 4E57           E8         BB4D            call	_bios_printf
17175 4E5A           83C4                   04  add	sp,*4
17176                                           !BCC_EOS
17177                                           ! 2730       FLAGS |= 0x0001;
17178                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17179 4E5D           8B46         18            mov	ax,$18[bp]
17180 4E60           0C                     01  or	al,*1
17181 4E62           8946         18            mov	$18[bp],ax
17182                                           !BCC_EOS
17183                                           ! 2731       regs.u.r8.ah = 0x86;
17184                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17185 4E65           B0                     86  mov	al,#$86
17186 4E67           8846         13            mov	$13[bp],al
17187                                           !BCC_EOS
17188                                           ! 2732       break;
17189 4E6A           E9         00D4            br 	.365
17190                                           !BCC_EOS
17191                                           ! 2733     case 0xC0:
17192                                           ! 2734       FLAGS &= 0xfffe;
17193                       00004E6D            .38A:
17194                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
17195 4E6D           8B46         18            mov	ax,$18[bp]
17196 4E70           24                     FE  and	al,#$FE
17197 4E72           8946         18            mov	$18[bp],ax
17198                                           !BCC_EOS
17199                                           ! 2735       regs.u.r8.ah = 0;
17200                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
17201 4E75           30C0                       xor	al,al
17202 4E77           8846         13            mov	$13[bp],al
17203                                           !BCC_EOS
17204                                           ! 2736       regs.u.r16.bx = 0xe6f5;
17205                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
17206 4E7A           B8                   E6F5  mov	ax,#$E6F5
17207 4E7D           8946         0C            mov	$C[bp],ax
17208                                           !BCC_EOS
17209                                           ! 2737       ES = 0xF000;
17210                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
17211 4E80           B8                   F000  mov	ax,#$F000
17212 4E83           8946         14            mov	$14[bp],ax
17213                                           !BCC_EOS
17214                                           ! 2738       break;
17215 4E86           E9         00B8            br 	.365
17216                                           !BCC_EOS
17217                                           ! 2739     case 0xc1:
17218                                           ! 2740       ES = ebda_seg;
17219                       00004E89            .38B:
17220                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
17221 4E89           8B46         FE            mov	ax,-2[bp]
17222 4E8C           8946         14            mov	$14[bp],ax
17223                                           !BCC_EOS
17224                                           ! 2741       FLAGS &= 0xfffe;
17225                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
17226 4E8F           8B46         18            mov	ax,$18[bp]
17227 4E92           24                     FE  and	al,#$FE
17228 4E94           8946         18            mov	$18[bp],ax
17229                                           !BCC_EOS
17230                                           ! 2742       break;
17231 4E97           E9         00A7            br 	.365
17232                                           !BCC_EOS
17233                                           ! 2743     case 0xd8:
17234                                           ! 2744       bios_printf(8, "EISA BIOS not present\n");
17235                       00004E9A            .38C:
17236                                           ! Debug: list * char = .38D+0 (used reg = )
17237 4E9A           BB                   D52F  mov	bx,#.38D
17238 4E9D           53                         push	bx
17239                                           ! Debug: list int = const 8 (used reg = )
17240 4E9E           B8                   0008  mov	ax,*8
17241 4EA1           50                         push	ax
17242                                           ! Debug: func () void = bios_printf+0 (used reg = )
17243 4EA2           E8         BB02            call	_bios_printf
17244 4EA5           83C4                   04  add	sp,*4
17245                                           !BCC_EOS
17246                                           ! 2745       FLAGS |= 0x0001;
17247                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17248 4EA8           8B46         18            mov	ax,$18[bp]
17249 4EAB           0C                     01  or	al,*1
17250 4EAD           8946         18            mov	$18[bp],ax
17251                                           !BCC_EOS
17252                                           ! 2746       regs.u.r8.ah =
17253                                           ! 2746  0x86;
17254                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17255 4EB0           B0                     86  mov	al,#$86
17256 4EB2           8846         13            mov	$13[bp],al
17257                                           !BCC_EOS
17258                                           ! 2747       break;
17259 4EB5           E9         0089            br 	.365
17260                                           !BCC_EOS
17261                                           ! 2748     default:
17262                                           ! 2749       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17263                       00004EB8            .38E:
17264                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
17265 4EB8           FF76         0C            push	$C[bp]
17266                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
17267 4EBB           FF76         12            push	$12[bp]
17268                                           ! Debug: list * char = .38F+0 (used reg = )
17269 4EBE           BB                   D4F5  mov	bx,#.38F
17270 4EC1           53                         push	bx
17271                                           ! Debug: list int = const 4 (used reg = )
17272 4EC2           B8                   0004  mov	ax,*4
17273 4EC5           50                         push	ax
17274                                           ! Debug: func () void = bios_printf+0 (used reg = )
17275 4EC6           E8         BADE            call	_bios_printf
17276 4EC9           83C4                   08  add	sp,*8
17277                                           !BCC_EOS
17278                                           ! 2750       FLAGS |= 0x0001;
17279                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
17280 4ECC           8B46         18            mov	ax,$18[bp]
17281 4ECF           0C                     01  or	al,*1
17282 4ED1           8946         18            mov	$18[bp],ax
17283                                           !BCC_EOS
17284                                           ! 2751       regs.u.r8.ah = 0x86;
17285                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
17286 4ED4           B0                     86  mov	al,#$86
17287 4ED6           8846         13            mov	$13[bp],al
17288                                           !BCC_EOS
17289                                           ! 2752       break;
17290 4ED9           EB           66            jmp .365
17291                                           !BCC_EOS
17292                                           ! 2753     }
17293                                           ! 2754 }
17294 4EDB           EB           64            jmp .365
17295                       00004EDD            .367:
17296 4EDD           2C                     24  sub	al,*$24
17297 4EDF         0F84         FA5F            beq 	.368
17298 4EE3           2C                     1D  sub	al,*$1D
17299 4EE5         0F84         FB01            beq 	.372
17300 4EE9           2C                     0E  sub	al,*$E
17301 4EEB         0F84         FB0B            beq 	.373
17302 4EEF           2C                     03  sub	al,*3
17303 4EF1         0F84         FB10            beq 	.374
17304 4EF5           2C                     31  sub	al,*$31
17305 4EF7           72           BF            jb 	.38E
17306 4EF9           3C                     0E  cmp	al,*$E
17307 4EFB           77           29            ja  	.390
17308 4EFD           30E4                       xor	ah,ah
17309 4EFF           D1E0                       shl	ax,*1
17310 4F01           89C3                       mov	bx,ax
17311 4F03           2E                         seg	cs
17312 4F04           FFA7       4F08            br	.391[bx]
17313                       00004F08            .391:
17314 4F08                      4A15            .word	.375
17315 4F0A                      4EB8            .word	.38E
17316 4F0C                      4EB8            .word	.38E
17317 4F0E                      4EB8            .word	.38E
17318 4F10                      4B36            .word	.37F
17319 4F12                      4D43            .word	.382
17320 4F14                      4D74            .word	.385
17321 4F16                      4EB8            .word	.38E
17322 4F18                      4EB8            .word	.38E
17323 4F1A                      4EB8            .word	.38E
17324 4F1C                      4EB8            .word	.38E
17325 4F1E                      4EB8            .word	.38E
17326 4F20                      4EB8            .word	.38E
17327 4F22                      4E49            .word	.386
17328 4F24                      4E4C            .word	.387
17329                       00004F26            .390:
17330 4F26           2C                     3C  sub	al,*$3C
17331 4F28         0F84         FF23            beq 	.388
17332 4F2C           2C                     01  sub	al,*1
17333 4F2E         0F84         FF3B            beq 	.38A
17334 4F32           2C                     01  sub	al,*1
17335 4F34         0F84         FF51            beq 	.38B
17336 4F38           2C                     17  sub	al,*$17
17337 4F3A         0F84         FF5C            beq 	.38C
17338 4F3E           E9         FF77            br 	.38E
17339                       00004F41            .365:
17340                       FFFFFFEA            ..FFF7	=	-$16
17341 4F41           89EC                       mov	sp,bp
17342 4F43           5D                         pop	bp
17343 4F44           C3                         ret
17344                                           ! 2755   void
17345                                           ! Register BX used in function int15_function
17346                                           ! 2756 int15_function_mouse(regs, ES, DS, FLAGS)
17347                                           ! 2757   pusha_regs_t regs;
17348                                           export	_int15_function_mouse
17349                       00004F45            _int15_function_mouse:
17350                                           !BCC_EOS
17351                                           ! 2758   Bit16u ES, DS, FLAGS;
17352                                           !BCC_EOS
17353                                           ! 2759 {
17354                                           ! 2760   Bit16u ebda_seg=read_word(0x0040,0x000E);
17355 4F45           55                         push	bp
17356 4F46           89E5                       mov	bp,sp
17357 4F48           4C                         dec	sp
17358 4F49           4C                         dec	sp
17359                                           ! Debug: list int = const $E (used reg = )
17360 4F4A           B8                   000E  mov	ax,*$E
17361 4F4D           50                         push	ax
17362                                           ! Debug: list int = const $40 (used reg = )
17363 4F4E           B8                   0040  mov	ax,*$40
17364 4F51           50                         push	ax
17365                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17366 4F52           E8         B6B6            call	_read_word
17367 4F55           83C4                   04  add	sp,*4
17368                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
17369 4F58           8946         FE            mov	-2[bp],ax
17370                                           !BCC_EOS
17371                                           ! 2761   Bit8u mouse_flags_1, mouse_flags_2;
17372                                           !BCC_EOS
17373                                           ! 2762   Bit16u mouse_driver_seg;
17374                                           !BCC_EOS
17375                                           ! 2763   Bit16u mouse_driver_offset;
17376                                           !BCC_EOS
17377                                           ! 2764   Bit8u comm_byte, prev_command_byte;
17378                                           !BCC_EOS
17379                                           ! 2765   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
17380                                           !BCC_EOS
17381                                           ! 2766 ;
17382 4F5B           83C4                   F4  add	sp,*-$C
17383                                           !BCC_EOS
17384                                           ! 2767   switch (regs.u.r8.ah) {
17385 4F5E           8A46         13            mov	al,$13[bp]
17386 4F61           E9         0652            br 	.394
17387                                           ! 2768     case 0xC2:
17388                                           ! 2769       switch (regs.u.r8.al) {
17389                       00004F64            .395:
17390 4F64           8A46         12            mov	al,$12[bp]
17391 4F67           E9         0600            br 	.398
17392                                           ! 2770         case 0:
17393                                           ! 2771 ;
17394                       00004F6A            .399:
17395                                           !BCC_EOS
17396                                           ! 2772           switch (regs.u.r8.bh) {
17397 4F6A           8A46         0D            mov	al,$D[bp]
17398 4F6D           E9         00E9            br 	.39C
17399                                           ! 2773             case 0:
17400                                           ! 2774 ;
17401                       00004F70            .39D:
17402                                           !BCC_EOS
17403                                           ! 2775               inhibit_mouse_int_and_events();
17404                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17405 4F70           E8         117B            call	_inhibit_mouse_int_and_events
17406                                           !BCC_EOS
17407                                           ! 2776               ret = send_to_mouse_ctrl(0xF5);
17408                                           ! Debug: list int = const $F5 (used reg = )
17409 4F73           B8                   00F5  mov	ax,#$F5
17410 4F76           50                         push	ax
17411                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17412 4F77           E8         12C5            call	_send_to_mouse_ctrl
17413 4F7A           44                         inc	sp
17414 4F7B           44                         inc	sp
17415                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17416 4F7C           8846         F5            mov	-$B[bp],al
17417                                           !BCC_EOS
17418                                           ! 2777               if (ret == 0) {
17419                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17420 4F7F           8A46         F5            mov	al,-$B[bp]
17421 4F82           84C0                       test	al,al
17422 4F84           75           2B            jne 	.39E
17423                       00004F86            .39F:
17424                                           ! 2778                 ret = get_mouse_data(&mouse_data1);
17425                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17426 4F86           8D5E         F4            lea	bx,-$C[bp]
17427 4F89           53                         push	bx
17428                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17429 4F8A           E8         12FC            call	_get_mouse_data
17430 4F8D           44                         inc	sp
17431 4F8E           44                         inc	sp
17432                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17433 4F8F           8846         F5            mov	-$B[bp],al
17434                                           !BCC_EOS
17435                                           ! 2779                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17436                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17437 4F92           8A46         F5            mov	al,-$B[bp]
17438 4F95           84C0                       test	al,al
17439 4F97           74           07            je  	.3A1
17440                       00004F99            .3A2:
17441                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17442 4F99           8A46         F4            mov	al,-$C[bp]
17443 4F9C           3C                     FA  cmp	al,#$FA
17444 4F9E           75           11            jne 	.3A0
17445                       00004FA0            .3A1:
17446                                           ! 2780                   FLAGS &= 0xfffe;
17447                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17448 4FA0           8B46         18            mov	ax,$18[bp]
17449 4FA3           24                     FE  and	al,#$FE
17450 4FA5           8946         18            mov	$18[bp],ax
17451                                           !BCC_EOS
17452                                           ! 2781                   regs.u.r8.ah = 0;
17453                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17454 4FA8           30C0                       xor	al,al
17455 4FAA           8846         13            mov	$13[bp],al
17456                                           !BCC_EOS
17457                                           ! 2782                   return;
17458 4FAD           89EC                       mov	sp,bp
17459 4FAF           5D                         pop	bp
17460 4FB0           C3                         ret
17461                                           !BCC_EOS
17462                                           ! 2783                 }
17463                                           ! 2784               }
17464                       00004FB1            .3A0:
17465                                           ! 2785               FLAGS |= 0x0001;
17466                       00004FB1            .39E:
17467                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17468 4FB1           8B46         18            mov	ax,$18[bp]
17469 4FB4           0C                     01  or	al,*1
17470 4FB6           8946         18            mov	$18[bp],ax
17471                                           !BCC_EOS
17472                                           ! 2786               regs.u.r8.ah = ret;
17473                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17474 4FB9           8A46         F5            mov	al,-$B[bp]
17475 4FBC           8846         13            mov	$13[bp],al
17476                                           !BCC_EOS
17477                                           ! 2787               return;
17478 4FBF           89EC                       mov	sp,bp
17479 4FC1           5D                         pop	bp
17480 4FC2           C3                         ret
17481                                           !BCC_EOS
17482                                           ! 2788               break;
17483 4FC3           E9         00A1            br 	.39A
17484                                           !BCC_EOS
17485                                           ! 2789             case 1:
17486                                           ! 2790 ;
17487                       00004FC6            .3A3:
17488                                           !BCC_EOS
17489                                           ! 2791               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17490                                           ! Debug: list int = const $27 (used reg = )
17491 4FC6           B8                   0027  mov	ax,*$27
17492 4FC9           50                         push	ax
17493                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17494 4FCA           FF76         FE            push	-2[bp]
17495                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17496 4FCD           E8         B628            call	_read_byte
17497 4FD0           83C4                   04  add	sp,*4
17498                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17499 4FD3           8846         FC            mov	-4[bp],al
17500                                           !BCC_EOS
17501                                           ! 2792               if ( (mouse_flags_2 & 0x80) == 0 ) {
17502                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17503 4FD6           8A46         FC            mov	al,-4[bp]
17504 4FD9           24                     80  and	al,#$80
17505                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17506 4FDB           84C0                       test	al,al
17507 4FDD           75           11            jne 	.3A4
17508                       00004FDF            .3A5:
17509                                           ! 2793                 ;
17510                                           !BCC_EOS
17511                                           ! 2794                 FLAGS |= 0x0001;
17512                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17513 4FDF           8B46         18            mov	ax,$18[bp]
17514 4FE2           0C                     01  or	al,*1
17515 4FE4           8946         18            mov	$18[bp],ax
17516                                           !BCC_EOS
17517                                           ! 2795                 regs.u.r8.ah = 5;
17518                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17519 4FE7           B0                     05  mov	al,*5
17520 4FE9           8846         13            mov	$13[bp],al
17521                                           !BCC_EOS
17522                                           ! 2796                 return;
17523 4FEC           89EC                       mov	sp,bp
17524 4FEE           5D                         pop	bp
17525 4FEF           C3                         ret
17526                                           !BCC_EOS
17527                                           ! 2797               }
17528                                           ! 2798               inhibit_mouse_int_and_events();
17529                       00004FF0            .3A4:
17530                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17531 4FF0           E8         10FB            call	_inhibit_mouse_int_and_events
17532                                           !BCC_EOS
17533                                           ! 2799               ret = send_to_mouse_ctrl(0xF4);
17534                                           ! Debug: list int = const $F4 (used reg = )
17535 4FF3           B8                   00F4  mov	ax,#$F4
17536 4FF6           50                         push	ax
17537                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17538 4FF7           E8         1245            call	_send_to_mouse_ctrl
17539 4FFA           44                         inc	sp
17540 4FFB           44                         inc	sp
17541                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17542 4FFC           8846         F5            mov	-$B[bp],al
17543                                           !BCC_EOS
17544                                           ! 2800               if (ret == 0) {
17545                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17546 4FFF           8A46         F5            mov	al,-$B[bp]
17547 5002           84C0                       test	al,al
17548 5004           75           2E            jne 	.3A6
17549                       00005006            .3A7:
17550                                           ! 2801                 ret = get_mouse_data(&mouse_data1);
17551                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17552 5006           8D5E         F4            lea	bx,-$C[bp]
17553 5009           53                         push	bx
17554                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17555 500A           E8         127C            call	_get_mouse_data
17556 500D           44                         inc	sp
17557 500E           44                         inc	sp
17558                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17559 500F           8846         F5            mov	-$B[bp],al
17560                                           !BCC_EOS
17561                                           ! 2802                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
17562                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17563 5012           8A46         F5            mov	al,-$B[bp]
17564 5015           84C0                       test	al,al
17565 5017           75           1B            jne 	.3A8
17566                       00005019            .3AA:
17567                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17568 5019           8A46         F4            mov	al,-$C[bp]
17569 501C           3C                     FA  cmp	al,#$FA
17570 501E           75           14            jne 	.3A8
17571                       00005020            .3A9:
17572                                           ! 2803                   enable_mouse_int_and_events();
17573                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17574 5020           E8         1178            call	_enable_mouse_int_and_events
17575                                           !BCC_EOS
17576                                           ! 2804                   FLAGS &= 0xfffe;
17577                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17578 5023           8B46         18            mov	ax,$18[bp]
17579 5026           24                     FE  and	al,#$FE
17580 5028           8946         18            mov	$18[bp],ax
17581                                           !BCC_EOS
17582                                           ! 2805                   regs.u.r8.ah = 0;
17583                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17584 502B           30C0                       xor	al,al
17585 502D           8846         13            mov	$13[bp],al
17586                                           !BCC_EOS
17587                                           ! 2806                   return;
17588 5030           89EC                       mov	sp,bp
17589 5032           5D                         pop	bp
17590 5033           C3                         ret
17591                                           !BCC_EOS
17592                                           ! 2807                 }
17593                                           ! 2808               }
17594                       00005034            .3A8:
17595                                           ! 2809               FLAGS |= 0x0001;
17596                       00005034            .3A6:
17597                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17598 5034           8B46         18            mov	ax,$18[bp]
17599 5037           0C                     01  or	al,*1
17600 5039           8946         18            mov	$18[bp],ax
17601                                           !BCC_EOS
17602                                           ! 2810               regs.u.r8.ah = ret;
17603                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17604 503C           8A46         F5            mov	al,-$B[bp]
17605 503F           8846         13            mov	$13[bp],al
17606                                           !BCC_EOS
17607                                           ! 2811               return;
17608 5042           89EC                       mov	sp,bp
17609 5044           5D                         pop	bp
17610 5045           C3                         ret
17611                                           !BCC_EOS
17612                                           ! 2812             default:
17613                                           ! 2813               ;
17614                       00005046            .3AB:
17615                                           !BCC_EOS
17616                                           ! 2814               FLAGS |= 0x0001;
17617                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17618 5046           8B46         18            mov	ax,$18[bp]
17619 5049           0C                     01  or	al,*1
17620 504B           8946         18            mov	$18[bp],ax
17621                                           !BCC_EOS
17622                                           ! 2815               regs.u.r8.ah = 1;
17623                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17624 504E           B0                     01  mov	al,*1
17625 5050           8846         13            mov	$13[bp],al
17626                                           !BCC_EOS
17627                                           ! 2816    
17628                                           ! 2816            return;
17629 5053           89EC                       mov	sp,bp
17630 5055           5D                         pop	bp
17631 5056           C3                         ret
17632                                           !BCC_EOS
17633                                           ! 2817           }
17634                                           ! 2818           break;
17635 5057           EB           0E            jmp .39A
17636                       00005059            .39C:
17637 5059           2C                     00  sub	al,*0
17638 505B         0F84         FF11            beq 	.39D
17639 505F           2C                     01  sub	al,*1
17640 5061         0F84         FF61            beq 	.3A3
17641 5065           EB           DF            jmp	.3AB
17642                       00005067            .39A:
17643 5067           E9         0525            br 	.396
17644                                           !BCC_EOS
17645                                           ! 2819         case 1:
17646                                           ! 2820         case 5:
17647                       0000506A            .3AC:
17648                                           ! 2821 ;
17649                       0000506A            .3AD:
17650                                           !BCC_EOS
17651                                           ! 2822           if (regs.u.r8.al == 5) {
17652                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17653 506A           8A46         12            mov	al,$12[bp]
17654 506D           3C                     05  cmp	al,*5
17655 506F         0F85         005E            bne 	.3AE
17656                       00005073            .3AF:
17657                                           ! 2823             if (regs.u.r8.bh != 3) {
17658                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17659 5073           8A46         0D            mov	al,$D[bp]
17660 5076           3C                     03  cmp	al,*3
17661 5078           74           11            je  	.3B0
17662                       0000507A            .3B1:
17663                                           ! 2824               FLAGS |= 0x0001;
17664                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17665 507A           8B46         18            mov	ax,$18[bp]
17666 507D           0C                     01  or	al,*1
17667 507F           8946         18            mov	$18[bp],ax
17668                                           !BCC_EOS
17669                                           ! 2825               regs.u.r8.ah = 0x02;
17670                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17671 5082           B0                     02  mov	al,*2
17672 5084           8846         13            mov	$13[bp],al
17673                                           !BCC_EOS
17674                                           ! 2826               return;
17675 5087           89EC                       mov	sp,bp
17676 5089           5D                         pop	bp
17677 508A           C3                         ret
17678                                           !BCC_EOS
17679                                           ! 2827             }
17680                                           ! 2828             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17681                       0000508B            .3B0:
17682                                           ! Debug: list int = const $27 (used reg = )
17683 508B           B8                   0027  mov	ax,*$27
17684 508E           50                         push	ax
17685                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17686 508F           FF76         FE            push	-2[bp]
17687                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17688 5092           E8         B563            call	_read_byte
17689 5095           83C4                   04  add	sp,*4
17690                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17691 5098           8846         FC            mov	-4[bp],al
17692                                           !BCC_EOS
17693                                           ! 2829             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17694                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17695 509B           8A46         FC            mov	al,-4[bp]
17696 509E           30C0                       xor	al,al
17697                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17698 50A0           0A46         0D            or	al,$D[bp]
17699                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17700 50A3           8846         FC            mov	-4[bp],al
17701                                           !BCC_EOS
17702                                           ! 2830             mouse_flags_1 = 0x00;
17703                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17704 50A6           30C0                       xor	al,al
17705 50A8           8846         FD            mov	-3[bp],al
17706                                           !BCC_EOS
17707                                           ! 2831             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17708                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17709 50AB           8A46         FD            mov	al,-3[bp]
17710 50AE           30E4                       xor	ah,ah
17711 50B0           50                         push	ax
17712                                           ! Debug: list int = const $26 (used reg = )
17713 50B1           B8                   0026  mov	ax,*$26
17714 50B4           50                         push	ax
17715                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17716 50B5           FF76         FE            push	-2[bp]
17717                                           ! Debug: func () void = write_byte+0 (used reg = )
17718 50B8           E8         B563            call	_write_byte
17719 50BB           83C4                   06  add	sp,*6
17720                                           !BCC_EOS
17721                                           ! 2832             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17722                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17723 50BE           8A46         FC            mov	al,-4[bp]
17724 50C1           30E4                       xor	ah,ah
17725 50C3           50                         push	ax
17726                                           ! Debug: list int = const $27 (used reg = )
17727 50C4           B8                   0027  mov	ax,*$27
17728 50C7           50                         push	ax
17729                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17730 50C8           FF76         FE            push	-2[bp]
17731                                           ! Debug: func () void = write_byte+0 (used reg = )
17732 50CB           E8         B550            call	_write_byte
17733 50CE           83C4                   06  add	sp,*6
17734                                           !BCC_EOS
17735                                           ! 2833           }
17736                                           ! 2834           inhibit_mouse_int_and_events();
17737                       000050D1            .3AE:
17738                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17739 50D1           E8         101A            call	_inhibit_mouse_int_and_events
17740                                           !BCC_EOS
17741                                           ! 2835           ret = send_to_mouse_ctrl(0xFF);
17742                                           ! Debug: list int = const $FF (used reg = )
17743 50D4           B8                   00FF  mov	ax,#$FF
17744 50D7           50                         push	ax
17745                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17746 50D8           E8         1164            call	_send_to_mouse_ctrl
17747 50DB           44                         inc	sp
17748 50DC           44                         inc	sp
17749                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17750 50DD           8846         F5            mov	-$B[bp],al
17751                                           !BCC_EOS
17752                                           ! 2836           if (ret == 0) {
17753                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17754 50E0           8A46         F5            mov	al,-$B[bp]
17755 50E3           84C0                       test	al,al
17756 50E5         0F85         0087            bne 	.3B2
17757                       000050E9            .3B3:
17758                                           ! 2837             ret = get_mouse_data(&mouse_data3);
17759                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17760 50E9           8D5E         F2            lea	bx,-$E[bp]
17761 50EC           53                         push	bx
17762                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17763 50ED           E8         1199            call	_get_mouse_data
17764 50F0           44                         inc	sp
17765 50F1           44                         inc	sp
17766                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17767 50F2           8846         F5            mov	-$B[bp],al
17768                                           !BCC_EOS
17769                                           ! 2838             if (mouse_data3 == 0xfe) {
17770                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17771 50F5           8A46         F2            mov	al,-$E[bp]
17772 50F8           3C                     FE  cmp	al,#$FE
17773 50FA           75           0C            jne 	.3B4
17774                       000050FC            .3B5:
17775                                           ! 2839               FLAGS |= 0x0001;
17776                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17777 50FC           8B46         18            mov	ax,$18[bp]
17778 50FF           0C                     01  or	al,*1
17779 5101           8946         18            mov	$18[bp],ax
17780                                           !BCC_EOS
17781                                           ! 2840               return;
17782 5104           89EC                       mov	sp,bp
17783 5106           5D                         pop	bp
17784 5107           C3                         ret
17785                                           !BCC_EOS
17786                                           ! 2841             }
17787                                           ! 2842             if (mouse_data3 != 0xfa)
17788                       00005108            .3B4:
17789                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17790 5108           8A46         F2            mov	al,-$E[bp]
17791 510B           3C                     FA  cmp	al,#$FA
17792 510D           74           14            je  	.3B6
17793                       0000510F            .3B7:
17794                                           ! 2843               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17795                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17796 510F           8A46         F2            mov	al,-$E[bp]
17797 5112           30E4                       xor	ah,ah
17798 5114           50                         push	ax
17799                                           ! Debug: list * char = .3B8+0 (used reg = )
17800 5115           BB                   D4CA  mov	bx,#.3B8
17801 5118           53                         push	bx
17802                                           ! Debug: list int = const 7 (used reg = )
17803 5119           B8                   0007  mov	ax,*7
17804 511C           50                         push	ax
17805                                           ! Debug: func () void = bios_printf+0 (used reg = )
17806 511D           E8         B887            call	_bios_printf
17807 5120           83C4                   06  add	sp,*6
17808                                           !BCC_EOS
17809                                           ! 2844             if ( ret == 0 ) {
17810                       00005123            .3B6:
17811                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17812 5123           8A46         F5            mov	al,-$B[bp]
17813 5126           84C0                       test	al,al
17814 5128           75           46            jne 	.3B9
17815                       0000512A            .3BA:
17816                                           ! 2845               ret = get_mouse_data(&mouse_data1);
17817                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17818 512A           8D5E         F4            lea	bx,-$C[bp]
17819 512D           53                         push	bx
17820                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17821 512E           E8         1158            call	_get_mouse_data
17822 5131           44                         inc	sp
17823 5132           44                         inc	sp
17824                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17825 5133           8846         F5            mov	-$B[bp],al
17826                                           !BCC_EOS
17827                                           ! 2846               if ( ret == 0 ) {
17828                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17829 5136           8A46         F5            mov	al,-$B[bp]
17830 5139           84C0                       test	al,al
17831 513B           75           33            jne 	.3BB
17832                       0000513D            .3BC:
17833                                           ! 2847                 ret = get_mouse_data(&mouse_data2);
17834                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17835 513D           8D5E         F3            lea	bx,-$D[bp]
17836 5140           53                         push	bx
17837                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17838 5141           E8         1145            call	_get_mouse_data
17839 5144           44                         inc	sp
17840 5145           44                         inc	sp
17841                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17842 5146           8846         F5            mov	-$B[bp],al
17843                                           !BCC_EOS
17844                                           ! 2848                 if ( ret == 0 ) {
17845                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17846 5149           8A46         F5            mov	al,-$B[bp]
17847 514C           84C0                       test	al,al
17848 514E           75           20            jne 	.3BD
17849                       00005150            .3BE:
17850                                           ! 2849                   enable_mouse_int_and_events();
17851                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17852 5150           E8         1048            call	_enable_mouse_int_and_events
17853                                           !BCC_EOS
17854                                           ! 2850                   FLAGS &= 0xfffe;
17855                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17856 5153           8B46         18            mov	ax,$18[bp]
17857 5156           24                     FE  and	al,#$FE
17858 5158           8946         18            mov	$18[bp],ax
17859                                           !BCC_EOS
17860                                           ! 2851                   regs.u.r8.ah = 0;
17861                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17862 515B           30C0                       xor	al,al
17863 515D           8846         13            mov	$13[bp],al
17864                                           !BCC_EOS
17865                                           ! 2852                   regs.u.r8.bl = mouse_data1;
17866                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17867 5160           8A46         F4            mov	al,-$C[bp]
17868 5163           8846         0C            mov	$C[bp],al
17869                                           !BCC_EOS
17870                                           ! 2853                   regs.u.r8.bh = mouse_data2;
17871                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17872 5166           8A46         F3            mov	al,-$D[bp]
17873 5169           8846         0D            mov	$D[bp],al
17874                                           !BCC_EOS
17875                                           ! 2854                   return;
17876 516C           89EC                       mov	sp,bp
17877 516E           5D                         pop	bp
17878 516F           C3                         ret
17879                                           !BCC_EOS
17880                                           ! 2855                 }
17881                                           ! 2856               }
17882                       00005170            .3BD:
17883                                           ! 2857             }
17884                       00005170            .3BB:
17885                                           ! 2858           }
17886                       00005170            .3B9:
17887                                           ! 2859           FLAGS |= 0x0001;
17888                       00005170            .3B2:
17889                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17890 5170           8B46         18            mov	ax,$18[bp]
17891 5173           0C                     01  or	al,*1
17892 5175           8946         18            mov	$18[bp],ax
17893                                           !BCC_EOS
17894                                           ! 2860           regs.u.r8.ah = ret;
17895                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17896 5178           8A46         F5            mov	al,-$B[bp]
17897 517B           8846         13            mov	$13[bp],al
17898                                           !BCC_EOS
17899                                           ! 2861           return;
17900 517E           89EC                       mov	sp,bp
17901 5180           5D                         pop	bp
17902 5181           C3                         ret
17903                                           !BCC_EOS
17904                                           ! 2862         case 2:
17905                                           ! 2863 ;
17906                       00005182            .3BF:
17907                                           !BCC_EOS
17908                                           ! 2864           switch (regs.u.r8.bh) {
17909 5182           8A46         0D            mov	al,$D[bp]
17910 5185           EB           38            jmp .3C2
17911                                           ! 2865             case 0: mouse_data1 = 10; break;
17912                       00005187            .3C3:
17913                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17914 5187           B0                     0A  mov	al,*$A
17915 5189           8846         F4            mov	-$C[bp],al
17916                                           !BCC_EOS
17917 518C           EB           54            jmp .3C0
17918                                           !BCC_EOS
17919                                           ! 2866             case 1: mouse_data1 = 20; break;
17920                       0000518E            .3C4:
17921                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17922 518E           B0                     14  mov	al,*$14
17923 5190           8846         F4            mov	-$C[bp],al
17924                                           !BCC_EOS
17925 5193           EB           4D            jmp .3C0
17926                                           !BCC_EOS
17927                                           ! 2867             case 2: mouse_data1 = 40; break;
17928                       00005195            .3C5:
17929                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17930 5195           B0                     28  mov	al,*$28
17931 5197           8846         F4            mov	-$C[bp],al
17932                                           !BCC_EOS
17933 519A           EB           46            jmp .3C0
17934                                           !BCC_EOS
17935                                           ! 2868             case 3: mouse_data1 = 60; break;
17936                       0000519C            .3C6:
17937                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17938 519C           B0                     3C  mov	al,*$3C
17939 519E           8846         F4            mov	-$C[bp],al
17940                                           !BCC_EOS
17941 51A1           EB           3F            jmp .3C0
17942                                           !BCC_EOS
17943                                           ! 2869             case 4: mouse_data1 = 80; break;
17944                       000051A3            .3C7:
17945                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17946 51A3           B0                     50  mov	al,*$50
17947 51A5           8846         F4            mov	-$C[bp],al
17948                                           !BCC_EOS
17949 51A8           EB           38            jmp .3C0
17950                                           !BCC_EOS
17951                                           ! 2870             case 5: mouse_data1 = 100; break;
17952                       000051AA            .3C8:
17953                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17954 51AA           B0                     64  mov	al,*$64
17955 51AC           8846         F4            mov	-$C[bp],al
17956                                           !BCC_EOS
17957 51AF           EB           31            jmp .3C0
17958                                           !BCC_EOS
17959                                           ! 2871             case 6: mouse_data1 = 200; break;
17960                       000051B1            .3C9:
17961                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17962 51B1           B0                     C8  mov	al,#$C8
17963 51B3           8846         F4            mov	-$C[bp],al
17964                                           !BCC_EOS
17965 51B6           EB           2A            jmp .3C0
17966                                           !BCC_EOS
17967                                           ! 2872             default: mouse_data1 = 0;
17968                       000051B8            .3CA:
17969                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17970 51B8           30C0                       xor	al,al
17971 51BA           8846         F4            mov	-$C[bp],al
17972                                           !BCC_EOS
17973                                           ! 2873           }
17974                                           ! 2874           if (mouse_data1 > 0) {
17975 51BD           EB           23            jmp .3C0
17976                       000051BF            .3C2:
17977 51BF           2C                     00  sub	al,*0
17978 51C1           72           F5            jb 	.3CA
17979 51C3           3C                     06  cmp	al,*6
17980 51C5           77           19            ja  	.3CB
17981 51C7           30E4                       xor	ah,ah
17982 51C9           D1E0                       shl	ax,*1
17983 51CB           89C3                       mov	bx,ax
17984 51CD           2E                         seg	cs
17985 51CE           FFA7       51D2            br	.3CC[bx]
17986                       000051D2            .3CC:
17987 51D2                      5187            .word	.3C3
17988 51D4                      518E            .word	.3C4
17989 51D6                      5195            .word	.3C5
17990 51D8                      519C            .word	.3C6
17991 51DA                      51A3            .word	.3C7
17992 51DC                      51AA            .word	.3C8
17993 51DE                      51B1            .word	.3C9
17994                       000051E0            .3CB:
17995 51E0           EB           D6            jmp	.3CA
17996                       000051E2            .3C0:
17997                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17998 51E2           8A46         F4            mov	al,-$C[bp]
17999 51E5           84C0                       test	al,al
18000 51E7           74           57            je  	.3CD
18001                       000051E9            .3CE:
18002                                           ! 2875             ret = send_to_mouse_ctrl(0xF3);
18003                                           ! Debug: list int = const $F3 (used reg = )
18004 51E9           B8                   00F3  mov	ax,#$F3
18005 51EC           50                         push	ax
18006                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18007 51ED           E8         104F            call	_send_to_mouse_ctrl
18008 51F0           44                         inc	sp
18009 51F1           44                         inc	sp
18010                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18011 51F2           8846         F5            mov	-$B[bp],al
18012                                           !BCC_EOS
18013                                           ! 2876             if (ret == 0) {
18014                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18015 51F5           8A46         F5            mov	al,-$B[bp]
18016 51F8           84C0                       test	al,al
18017 51FA           75           35            jne 	.3CF
18018                       000051FC            .3D0:
18019                                           ! 2877   
18020                                           ! 2877             ret = get_mouse_data(&mouse_data2);
18021                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18022 51FC           8D5E         F3            lea	bx,-$D[bp]
18023 51FF           53                         push	bx
18024                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18025 5200           E8         1086            call	_get_mouse_data
18026 5203           44                         inc	sp
18027 5204           44                         inc	sp
18028                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18029 5205           8846         F5            mov	-$B[bp],al
18030                                           !BCC_EOS
18031                                           ! 2878               ret = send_to_mouse_ctrl(mouse_data1);
18032                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18033 5208           8A46         F4            mov	al,-$C[bp]
18034 520B           30E4                       xor	ah,ah
18035 520D           50                         push	ax
18036                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18037 520E           E8         102E            call	_send_to_mouse_ctrl
18038 5211           44                         inc	sp
18039 5212           44                         inc	sp
18040                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18041 5213           8846         F5            mov	-$B[bp],al
18042                                           !BCC_EOS
18043                                           ! 2879               ret = get_mouse_data(&mouse_data2);
18044                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18045 5216           8D5E         F3            lea	bx,-$D[bp]
18046 5219           53                         push	bx
18047                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18048 521A           E8         106C            call	_get_mouse_data
18049 521D           44                         inc	sp
18050 521E           44                         inc	sp
18051                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18052 521F           8846         F5            mov	-$B[bp],al
18053                                           !BCC_EOS
18054                                           ! 2880               FLAGS &= 0xfffe;
18055                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18056 5222           8B46         18            mov	ax,$18[bp]
18057 5225           24                     FE  and	al,#$FE
18058 5227           8946         18            mov	$18[bp],ax
18059                                           !BCC_EOS
18060                                           ! 2881               regs.u.r8.ah = 0;
18061                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18062 522A           30C0                       xor	al,al
18063 522C           8846         13            mov	$13[bp],al
18064                                           !BCC_EOS
18065                                           ! 2882             } else {
18066 522F           EB           0D            jmp .3D1
18067                       00005231            .3CF:
18068                                           ! 2883               FLAGS |= 0x0001;
18069                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18070 5231           8B46         18            mov	ax,$18[bp]
18071 5234           0C                     01  or	al,*1
18072 5236           8946         18            mov	$18[bp],ax
18073                                           !BCC_EOS
18074                                           ! 2884               regs.u.r8.ah = 0x86;
18075                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18076 5239           B0                     86  mov	al,#$86
18077 523B           8846         13            mov	$13[bp],al
18078                                           !BCC_EOS
18079                                           ! 2885             }
18080                                           ! 2886           } else {
18081                       0000523E            .3D1:
18082 523E           EB           0D            jmp .3D2
18083                       00005240            .3CD:
18084                                           ! 2887             FLAGS |= 0x0001;
18085                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18086 5240           8B46         18            mov	ax,$18[bp]
18087 5243           0C                     01  or	al,*1
18088 5245           8946         18            mov	$18[bp],ax
18089                                           !BCC_EOS
18090                                           ! 2888             regs.u.r8.ah = 0x86;
18091                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18092 5248           B0                     86  mov	al,#$86
18093 524A           8846         13            mov	$13[bp],al
18094                                           !BCC_EOS
18095                                           ! 2889           }
18096                                           ! 2890           break;
18097                       0000524D            .3D2:
18098 524D           E9         033F            br 	.396
18099                                           !BCC_EOS
18100                                           ! 2891         case 3:
18101                                           ! 2892 ;
18102                       00005250            .3D3:
18103                                           !BCC_EOS
18104                                           ! 2893           comm_byte = inhibit_mouse_int_and_events();
18105                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18106 5250           E8         0E9B            call	_inhibit_mouse_int_and_events
18107                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18108 5253           8846         F7            mov	-9[bp],al
18109                                           !BCC_EOS
18110                                           ! 2894           if (regs.u.r8.bh < 4) {
18111                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
18112 5256           8A46         0D            mov	al,$D[bp]
18113 5259           3C                     04  cmp	al,*4
18114 525B         0F83         008D            bhis	.3D4
18115                       0000525F            .3D5:
18116                                           ! 2895             ret = send_to_mouse_ctrl(0xE8);
18117                                           ! Debug: list int = const $E8 (used reg = )
18118 525F           B8                   00E8  mov	ax,#$E8
18119 5262           50                         push	ax
18120                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18121 5263           E8         0FD9            call	_send_to_mouse_ctrl
18122 5266           44                         inc	sp
18123 5267           44                         inc	sp
18124                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18125 5268           8846         F5            mov	-$B[bp],al
18126                                           !BCC_EOS
18127                                           ! 2896             if (ret == 0) {
18128                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18129 526B           8A46         F5            mov	al,-$B[bp]
18130 526E           84C0                       test	al,al
18131 5270           75           6B            jne 	.3D6
18132                       00005272            .3D7:
18133                                           ! 2897               ret = get_mouse_data(&mouse_data1);
18134                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18135 5272           8D5E         F4            lea	bx,-$C[bp]
18136 5275           53                         push	bx
18137                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18138 5276           E8         1010            call	_get_mouse_data
18139 5279           44                         inc	sp
18140 527A           44                         inc	sp
18141                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18142 527B           8846         F5            mov	-$B[bp],al
18143                                           !BCC_EOS
18144                                           ! 2898               if (mouse_data1 != 0xfa)
18145                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18146 527E           8A46         F4            mov	al,-$C[bp]
18147 5281           3C                     FA  cmp	al,#$FA
18148 5283           74           14            je  	.3D8
18149                       00005285            .3D9:
18150                                           ! 2899                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18151                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18152 5285           8A46         F4            mov	al,-$C[bp]
18153 5288           30E4                       xor	ah,ah
18154 528A           50                         push	ax
18155                                           ! Debug: list * char = .3DA+0 (used reg = )
18156 528B           BB                   D49E  mov	bx,#.3DA
18157 528E           53                         push	bx
18158                                           ! Debug: list int = const 7 (used reg = )
18159 528F           B8                   0007  mov	ax,*7
18160 5292           50                         push	ax
18161                                           ! Debug: func () void = bios_printf+0 (used reg = )
18162 5293           E8         B711            call	_bios_printf
18163 5296           83C4                   06  add	sp,*6
18164                                           !BCC_EOS
18165                                           ! 2900               ret = send_to_mouse_ctrl(regs.u.r8.bh);
18166                       00005299            .3D8:
18167                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18168 5299           8A46         0D            mov	al,$D[bp]
18169 529C           30E4                       xor	ah,ah
18170 529E           50                         push	ax
18171                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18172 529F           E8         0F9D            call	_send_to_mouse_ctrl
18173 52A2           44                         inc	sp
18174 52A3           44                         inc	sp
18175                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18176 52A4           8846         F5            mov	-$B[bp],al
18177                                           !BCC_EOS
18178                                           ! 2901               ret = get_mouse_data(&mouse_data1);
18179                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18180 52A7           8D5E         F4            lea	bx,-$C[bp]
18181 52AA           53                         push	bx
18182                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18183 52AB           E8         0FDB            call	_get_mouse_data
18184 52AE           44                         inc	sp
18185 52AF           44                         inc	sp
18186                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18187 52B0           8846         F5            mov	-$B[bp],al
18188                                           !BCC_EOS
18189                                           ! 2902               if (mouse_data1 != 0xfa)
18190                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18191 52B3           8A46         F4            mov	al,-$C[bp]
18192 52B6           3C                     FA  cmp	al,#$FA
18193 52B8           74           14            je  	.3DB
18194                       000052BA            .3DC:
18195                                           ! 2903                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18196                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18197 52BA           8A46         F4            mov	al,-$C[bp]
18198 52BD           30E4                       xor	ah,ah
18199 52BF           50                         push	ax
18200                                           ! Debug: list * char = .3DD+0 (used reg = )
18201 52C0           BB                   D472  mov	bx,#.3DD
18202 52C3           53                         push	bx
18203                                           ! Debug: list int = const 7 (used reg = )
18204 52C4           B8                   0007  mov	ax,*7
18205 52C7           50                         push	ax
18206                                           ! Debug: func () void = bios_printf+0 (used reg = )
18207 52C8           E8         B6DC            call	_bios_printf
18208 52CB           83C4                   06  add	sp,*6
18209                                           !BCC_EOS
18210                                           ! 2904               FLAGS &= 0xfffe;
18211                       000052CE            .3DB:
18212                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18213 52CE           8B46         18            mov	ax,$18[bp]
18214 52D1           24                     FE  and	al,#$FE
18215 52D3           8946         18            mov	$18[bp],ax
18216                                           !BCC_EOS
18217                                           ! 2905               regs.u.r8.ah = 0;
18218                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18219 52D6           30C0                       xor	al,al
18220 52D8           8846         13            mov	$13[bp],al
18221                                           !BCC_EOS
18222                                           ! 2906             } else {
18223 52DB           EB           0D            jmp .3DE
18224                       000052DD            .3D6:
18225                                           ! 2907               FLAGS |= 0x0001;
18226                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18227 52DD           8B46         18            mov	ax,$18[bp]
18228 52E0           0C                     01  or	al,*1
18229 52E2           8946         18            mov	$18[bp],ax
18230                                           !BCC_EOS
18231                                           ! 2908               regs.u.r8.ah = 0x86;
18232                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18233 52E5           B0                     86  mov	al,#$86
18234 52E7           8846         13            mov	$13[bp],al
18235                                           !BCC_EOS
18236                                           ! 2909             }
18237                                           ! 2910           } else {
18238                       000052EA            .3DE:
18239 52EA           EB           0D            jmp .3DF
18240                       000052EC            .3D4:
18241                                           ! 2911             FLAGS |= 0x0001;
18242                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18243 52EC           8B46         18            mov	ax,$18[bp]
18244 52EF           0C                     01  or	al,*1
18245 52F1           8946         18            mov	$18[bp],ax
18246                                           !BCC_EOS
18247                                           ! 2912             regs.u.r8.ah = 0x86;
18248                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18249 52F4           B0                     86  mov	al,#$86
18250 52F6           8846         13            mov	$13[bp],al
18251                                           !BCC_EOS
18252                                           ! 2913           }
18253                                           ! 2914           set_kbd_command_byte(comm_byte);
18254                       000052F9            .3DF:
18255                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18256 52F9           8A46         F7            mov	al,-9[bp]
18257 52FC           30E4                       xor	ah,ah
18258 52FE           50                         push	ax
18259                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18260 52FF           E8         0FC8            call	_set_kbd_command_byte
18261 5302           44                         inc	sp
18262 5303           44                         inc	sp
18263                                           !BCC_EOS
18264                                           ! 2915           break;
18265 5304           E9         0288            br 	.396
18266                                           !BCC_EOS
18267                                           ! 2916         case 4:
18268                                           ! 2917 ;
18269                       00005307            .3E0:
18270                                           !BCC_EOS
18271                                           ! 2918           inhibit_mouse_int_and_events();
18272                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18273 5307           E8         0DE4            call	_inhibit_mouse_int_and_events
18274                                           !BCC_EOS
18275                                           ! 2919           ret = send_to_mouse_ctrl(0xF2);
18276                                           ! Debug: list int = const $F2 (used reg = )
18277 530A           B8                   00F2  mov	ax,#$F2
18278 530D           50                         push	ax
18279                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18280 530E           E8         0F2E            call	_send_to_mouse_ctrl
18281 5311           44                         inc	sp
18282 5312           44                         inc	sp
18283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18284 5313           8846         F5            mov	-$B[bp],al
18285                                           !BCC_EOS
18286                                           ! 2920           if (ret == 0) {
18287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18288 5316           8A46         F5            mov	al,-$B[bp]
18289 5319           84C0                       test	al,al
18290 531B           75           2D            jne 	.3E1
18291                       0000531D            .3E2:
18292                                           ! 2921             ret = get_mouse_data(&mouse_data1);
18293                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18294 531D           8D5E         F4            lea	bx,-$C[bp]
18295 5320           53                         push	bx
18296                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18297 5321           E8         0F65            call	_get_mouse_data
18298 5324           44                         inc	sp
18299 5325           44                         inc	sp
18300                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18301 5326           8846         F5            mov	-$B[bp],al
18302                                           !BCC_EOS
18303                                           ! 2922             ret = get_mouse_data(&mouse_data2);
18304                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18305 5329           8D5E         F3            lea	bx,-$D[bp]
18306 532C           53                         push	bx
18307                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18308 532D           E8         0F59            call	_get_mouse_data
18309 5330           44                         inc	sp
18310 5331           44                         inc	sp
18311                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18312 5332           8846         F5            mov	-$B[bp],al
18313                                           !BCC_EOS
18314                                           ! 2923             FLAGS &= 0xfffe;
18315                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18316 5335           8B46         18            mov	ax,$18[bp]
18317 5338           24                     FE  and	al,#$FE
18318 533A           8946         18            mov	$18[bp],ax
18319                                           !BCC_EOS
18320                                           ! 2924             regs.u.r8.ah = 0;
18321                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18322 533D           30C0                       xor	al,al
18323 533F           8846         13            mov	$13[bp],al
18324                                           !BCC_EOS
18325                                           ! 2925             regs.u.r8.bh = mouse_data2;
18326                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
18327 5342           8A46         F3            mov	al,-$D[bp]
18328 5345           8846         0D            mov	$D[bp],al
18329                                           !BCC_EOS
18330                                           ! 2926           } else {
18331 5348           EB           0D            jmp .3E3
18332                       0000534A            .3E1:
18333                                           ! 2927             FLAGS |= 0x0001;
18334                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18335 534A           8B46         18            mov	ax,$18[bp]
18336 534D           0C                     01  or	al,*1
18337 534F           8946         18            mov	$18[bp],ax
18338                                           !BCC_EOS
18339                                           ! 2928             regs.u.r8.ah = 0x86;
18340                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18341 5352           B0                     86  mov	al,#$86
18342 5354           8846         13            mov	$13[bp],al
18343                                           !BCC_EOS
18344                                           ! 2929           }
18345                                           ! 2930           break;
18346                       00005357            .3E3:
18347 5357           E9         0235            br 	.396
18348                                           !BCC_EOS
18349                                           ! 2931         case 6:
18350                                           ! 2932 ;
18351                       0000535A            .3E4:
18352                                           !BCC_EOS
18353                                           ! 2933           switch (regs.u.r8.bh) {
18354 535A           8A46         0D            mov	al,$D[bp]
18355 535D           E9         015A            br 	.3E7
18356                                           ! 2934             case 0:
18357                                           ! 2935               comm_byte = inhibit_mouse_int_and_events();
18358                       00005360            .3E8:
18359                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18360 5360           E8         0D8B            call	_inhibit_mouse_int_and_events
18361                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18362 5363           8846         F7            mov	-9[bp],al
18363                                           !BCC_EOS
18364                                           ! 2936               ret = send_to_mouse_ctrl(0xE9);
18365                                           ! Debug: list int = const $E9 (used reg = )
18366 5366           B8                   00E9  mov	ax,#$E9
18367 5369           50                         push	ax
18368                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18369 536A           E8         0ED2            call	_send_to_mouse_ctrl
18370 536D           44                         inc	sp
18371 536E           44                         inc	sp
18372                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18373 536F           8846         F5            mov	-$B[bp],al
18374                                           !BCC_EOS
18375                                           ! 2937               if (ret == 0) {
18376                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18377 5372           8A46         F5            mov	al,-$B[bp]
18378 5375           84C0                       test	al,al
18379 5377         0F85         0095            bne 	.3E9
18380                       0000537B            .3EA:
18381                                           ! 2938                 ret = get_mouse
18382                                           ! 2938 _data(&mouse_data1);
18383                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18384 537B           8D5E         F4            lea	bx,-$C[bp]
18385 537E           53                         push	bx
18386                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18387 537F           E8         0F07            call	_get_mouse_data
18388 5382           44                         inc	sp
18389 5383           44                         inc	sp
18390                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18391 5384           8846         F5            mov	-$B[bp],al
18392                                           !BCC_EOS
18393                                           ! 2939                 if (mouse_data1 != 0xfa)
18394                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18395 5387           8A46         F4            mov	al,-$C[bp]
18396 538A           3C                     FA  cmp	al,#$FA
18397 538C           74           14            je  	.3EB
18398                       0000538E            .3EC:
18399                                           ! 2940                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18400                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18401 538E           8A46         F4            mov	al,-$C[bp]
18402 5391           30E4                       xor	ah,ah
18403 5393           50                         push	ax
18404                                           ! Debug: list * char = .3ED+0 (used reg = )
18405 5394           BB                   D446  mov	bx,#.3ED
18406 5397           53                         push	bx
18407                                           ! Debug: list int = const 7 (used reg = )
18408 5398           B8                   0007  mov	ax,*7
18409 539B           50                         push	ax
18410                                           ! Debug: func () void = bios_printf+0 (used reg = )
18411 539C           E8         B608            call	_bios_printf
18412 539F           83C4                   06  add	sp,*6
18413                                           !BCC_EOS
18414                                           ! 2941                 if (ret == 0) {
18415                       000053A2            .3EB:
18416                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18417 53A2           8A46         F5            mov	al,-$B[bp]
18418 53A5           84C0                       test	al,al
18419 53A7           75           67            jne 	.3EE
18420                       000053A9            .3EF:
18421                                           ! 2942                   ret = get_mouse_data(&mouse_data1);
18422                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18423 53A9           8D5E         F4            lea	bx,-$C[bp]
18424 53AC           53                         push	bx
18425                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18426 53AD           E8         0ED9            call	_get_mouse_data
18427 53B0           44                         inc	sp
18428 53B1           44                         inc	sp
18429                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18430 53B2           8846         F5            mov	-$B[bp],al
18431                                           !BCC_EOS
18432                                           ! 2943                   if (ret == 0) {
18433                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18434 53B5           8A46         F5            mov	al,-$B[bp]
18435 53B8           84C0                       test	al,al
18436 53BA           75           54            jne 	.3F0
18437                       000053BC            .3F1:
18438                                           ! 2944                     ret = get_mouse_data(&mouse_data2);
18439                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18440 53BC           8D5E         F3            lea	bx,-$D[bp]
18441 53BF           53                         push	bx
18442                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18443 53C0           E8         0EC6            call	_get_mouse_data
18444 53C3           44                         inc	sp
18445 53C4           44                         inc	sp
18446                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18447 53C5           8846         F5            mov	-$B[bp],al
18448                                           !BCC_EOS
18449                                           ! 2945                     if (ret == 0) {
18450                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18451 53C8           8A46         F5            mov	al,-$B[bp]
18452 53CB           84C0                       test	al,al
18453 53CD           75           41            jne 	.3F2
18454                       000053CF            .3F3:
18455                                           ! 2946                       ret = get_mouse_data(&mouse_data3);
18456                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18457 53CF           8D5E         F2            lea	bx,-$E[bp]
18458 53D2           53                         push	bx
18459                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18460 53D3           E8         0EB3            call	_get_mouse_data
18461 53D6           44                         inc	sp
18462 53D7           44                         inc	sp
18463                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18464 53D8           8846         F5            mov	-$B[bp],al
18465                                           !BCC_EOS
18466                                           ! 2947                       if (ret == 0) {
18467                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18468 53DB           8A46         F5            mov	al,-$B[bp]
18469 53DE           84C0                       test	al,al
18470 53E0           75           2E            jne 	.3F4
18471                       000053E2            .3F5:
18472                                           ! 2948                         FLAGS &= 0xfffe;
18473                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18474 53E2           8B46         18            mov	ax,$18[bp]
18475 53E5           24                     FE  and	al,#$FE
18476 53E7           8946         18            mov	$18[bp],ax
18477                                           !BCC_EOS
18478                                           ! 2949                         regs.u.r8.ah = 0;
18479                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18480 53EA           30C0                       xor	al,al
18481 53EC           8846         13            mov	$13[bp],al
18482                                           !BCC_EOS
18483                                           ! 2950                         regs.u.r8.bl = mouse_data1;
18484                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18485 53EF           8A46         F4            mov	al,-$C[bp]
18486 53F2           8846         0C            mov	$C[bp],al
18487                                           !BCC_EOS
18488                                           ! 2951                         regs.u.r8.cl = mouse_data2;
18489                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18490 53F5           8A46         F3            mov	al,-$D[bp]
18491 53F8           8846         10            mov	$10[bp],al
18492                                           !BCC_EOS
18493                                           ! 2952                         regs.u.r8.dl = mouse_data3;
18494                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18495 53FB           8A46         F2            mov	al,-$E[bp]
18496 53FE           8846         0E            mov	$E[bp],al
18497                                           !BCC_EOS
18498                                           ! 2953                         set_kbd_command_byte(comm_byte);
18499                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18500 5401           8A46         F7            mov	al,-9[bp]
18501 5404           30E4                       xor	ah,ah
18502 5406           50                         push	ax
18503                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18504 5407           E8         0EC0            call	_set_kbd_command_byte
18505 540A           44                         inc	sp
18506 540B           44                         inc	sp
18507                                           !BCC_EOS
18508                                           ! 2954                         return;
18509 540C           89EC                       mov	sp,bp
18510 540E           5D                         pop	bp
18511 540F           C3                         ret
18512                                           !BCC_EOS
18513                                           ! 2955                       }
18514                                           ! 2956                     }
18515                       00005410            .3F4:
18516                                           ! 2957                   }
18517                       00005410            .3F2:
18518                                           ! 2958                 }
18519                       00005410            .3F0:
18520                                           ! 2959               }
18521                       00005410            .3EE:
18522                                           ! 2960               FLAGS |= 0x0001;
18523                       00005410            .3E9:
18524                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18525 5410           8B46         18            mov	ax,$18[bp]
18526 5413           0C                     01  or	al,*1
18527 5415           8946         18            mov	$18[bp],ax
18528                                           !BCC_EOS
18529                                           ! 2961               regs.u.r8.ah = ret;
18530                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18531 5418           8A46         F5            mov	al,-$B[bp]
18532 541B           8846         13            mov	$13[bp],al
18533                                           !BCC_EOS
18534                                           ! 2962               set_kbd_command_byte(comm_byte);
18535                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18536 541E           8A46         F7            mov	al,-9[bp]
18537 5421           30E4                       xor	ah,ah
18538 5423           50                         push	ax
18539                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18540 5424           E8         0EA3            call	_set_kbd_command_byte
18541 5427           44                         inc	sp
18542 5428           44                         inc	sp
18543                                           !BCC_EOS
18544                                           ! 2963               return;
18545 5429           89EC                       mov	sp,bp
18546 542B           5D                         pop	bp
18547 542C           C3                         ret
18548                                           !BCC_EOS
18549                                           ! 2964             case 1:
18550                                           ! 2965             case 2:
18551                       0000542D            .3F6:
18552                                           ! 2966               comm_byte = inhibit_mouse_int_and_events();
18553                       0000542D            .3F7:
18554                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18555 542D           E8         0CBE            call	_inhibit_mouse_int_and_events
18556                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18557 5430           8846         F7            mov	-9[bp],al
18558                                           !BCC_EOS
18559                                           ! 2967               if (regs.u.r8.bh == 1) {
18560                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18561 5433           8A46         0D            mov	al,$D[bp]
18562 5436           3C                     01  cmp	al,*1
18563 5438           75           0E            jne 	.3F8
18564                       0000543A            .3F9:
18565                                           ! 2968                 ret = send_to_mouse_ctrl(0xE6);
18566                                           ! Debug: list int = const $E6 (used reg = )
18567 543A           B8                   00E6  mov	ax,#$E6
18568 543D           50                         push	ax
18569                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18570 543E           E8         0DFE            call	_send_to_mouse_ctrl
18571 5441           44                         inc	sp
18572 5442           44                         inc	sp
18573                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18574 5443           8846         F5            mov	-$B[bp],al
18575                                           !BCC_EOS
18576                                           ! 2969               } else {
18577 5446           EB           0C            jmp .3FA
18578                       00005448            .3F8:
18579                                           ! 2970                 ret = send_to_mouse_ctrl(0xE7);
18580                                           ! Debug: list int = const $E7 (used reg = )
18581 5448           B8                   00E7  mov	ax,#$E7
18582 544B           50                         push	ax
18583                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18584 544C           E8         0DF0            call	_send_to_mouse_ctrl
18585 544F           44                         inc	sp
18586 5450           44                         inc	sp
18587                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18588 5451           8846         F5            mov	-$B[bp],al
18589                                           !BCC_EOS
18590                                           ! 2971               }
18591                                           ! 2972               if (ret == 0) {
18592                       00005454            .3FA:
18593                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18594 5454           8A46         F5            mov	al,-$B[bp]
18595 5457           84C0                       test	al,al
18596 5459           75           19            jne 	.3FB
18597                       0000545B            .3FC:
18598                                           ! 2973                 get_mouse_data(&mouse_data1);
18599                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18600 545B           8D5E         F4            lea	bx,-$C[bp]
18601 545E           53                         push	bx
18602                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18603 545F           E8         0E27            call	_get_mouse_data
18604 5462           44                         inc	sp
18605 5463           44                         inc	sp
18606                                           !BCC_EOS
18607                                           ! 2974                 ret = (mouse_data1 != 0xFA);
18608                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18609 5464           8A46         F4            mov	al,-$C[bp]
18610 5467           3C                     FA  cmp	al,#$FA
18611 5469           74           04            je 	.3FD
18612 546B           B0                     01  mov	al,*1
18613 546D           EB           02            jmp	.3FE
18614                       0000546F            .3FD:
18615 546F           30C0                       xor	al,al
18616                       00005471            .3FE:
18617                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18618 5471           8846         F5            mov	-$B[bp],al
18619                                           !BCC_EOS
18620                                           ! 2975               }
18621                                           ! 2976               if (ret == 0) {
18622                       00005474            .3FB:
18623                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18624 5474           8A46         F5            mov	al,-$B[bp]
18625 5477           84C0                       test	al,al
18626 5479           75           0F            jne 	.3FF
18627                       0000547B            .400:
18628                                           ! 2977                 FLAGS &= 0xfffe;
18629                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18630 547B           8B46         18            mov	ax,$18[bp]
18631 547E           24                     FE  and	al,#$FE
18632 5480           8946         18            mov	$18[bp],ax
18633                                           !BCC_EOS
18634                                           ! 2978                 regs.u.r8.ah = 0;
18635                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18636 5483           30C0                       xor	al,al
18637 5485           8846         13            mov	$13[bp],al
18638                                           !BCC_EOS
18639                                           ! 2979               } else {
18640 5488           EB           0D            jmp .401
18641                       0000548A            .3FF:
18642                                           ! 2980                 FLAGS |= 0x0001;
18643                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18644 548A           8B46         18            mov	ax,$18[bp]
18645 548D           0C                     01  or	al,*1
18646 548F           8946         18            mov	$18[bp],ax
18647                                           !BCC_EOS
18648                                           ! 2981                 regs.u.r8.ah = 0x86;
18649                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18650 5492           B0                     86  mov	al,#$86
18651 5494           8846         13            mov	$13[bp],al
18652                                           !BCC_EOS
18653                                           ! 2982               }
18654                                           ! 2983               set_kbd_command_byte(comm_byte);
18655                       00005497            .401:
18656                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18657 5497           8A46         F7            mov	al,-9[bp]
18658 549A           30E4                       xor	ah,ah
18659 549C           50                         push	ax
18660                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18661 549D           E8         0E2A            call	_set_kbd_command_byte
18662 54A0           44                         inc	sp
18663 54A1           44                         inc	sp
18664                                           !BCC_EOS
18665                                           ! 2984               break;
18666 54A2           EB           2A            jmp .3E5
18667                                           !BCC_EOS
18668                                           ! 2985             default:
18669                                           ! 2986               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18670                       000054A4            .402:
18671                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18672 54A4           8A46         0D            mov	al,$D[bp]
18673 54A7           30E4                       xor	ah,ah
18674 54A9           50                         push	ax
18675                                           ! Debug: list * char = .403+0 (used reg = )
18676 54AA           BB                   D42C  mov	bx,#.403
18677 54AD           53                         push	bx
18678                                           ! Debug: list int = const 7 (used reg = )
18679 54AE           B8                   0007  mov	ax,*7
18680 54B1           50                         push	ax
18681                                           ! Debug: func () void = bios_printf+0 (used reg = )
18682 54B2           E8         B4F2            call	_bios_printf
18683 54B5           83C4                   06  add	sp,*6
18684                                           !BCC_EOS
18685                                           ! 2987           }
18686                                           ! 2988           break;
18687 54B8           EB           14            jmp .3E5
18688                       000054BA            .3E7:
18689 54BA           2C                     00  sub	al,*0
18690 54BC         0F84         FEA0            beq 	.3E8
18691 54C0           2C                     01  sub	al,*1
18692 54C2         0F84         FF67            beq 	.3F6
18693 54C6           2C                     01  sub	al,*1
18694 54C8         0F84         FF61            beq 	.3F7
18695 54CC           EB           D6            jmp	.402
18696                       000054CE            .3E5:
18697 54CE           E9         00BE            br 	.396
18698                                           !BCC_EOS
18699                                           ! 2989         case 7:
18700                                           ! 2990 ;
18701                       000054D1            .404:
18702                                           !BCC_EOS
18703                                           ! 2991           mouse_driver_seg = ES;
18704                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18705 54D1           8B46         14            mov	ax,$14[bp]
18706 54D4           8946         FA            mov	-6[bp],ax
18707                                           !BCC_EOS
18708                                           ! 2992           mouse_driver_offset = regs.u.r16.bx;
18709                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18710 54D7           8B46         0C            mov	ax,$C[bp]
18711 54DA           8946         F8            mov	-8[bp],ax
18712                                           !BCC_EOS
18713                                           ! 2993           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18714                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18715 54DD           FF76         F8            push	-8[bp]
18716                                           ! Debug: list int = const $22 (used reg = )
18717 54E0           B8                   0022  mov	ax,*$22
18718 54E3           50                         push	ax
18719                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18720 54E4           FF76         FE            push	-2[bp]
18721                                           ! Debug: func () void = write_word+0 (used reg = )
18722 54E7           E8         B14C            call	_write_word
18723 54EA           83C4                   06  add	sp,*6
18724                                           !BCC_EOS
18725                                           ! 2994           writ
18726                                           ! 2994 e_word(ebda_seg, 0x0024, mouse_driver_seg);
18727                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18728 54ED           FF76         FA            push	-6[bp]
18729                                           ! Debug: list int = const $24 (used reg = )
18730 54F0           B8                   0024  mov	ax,*$24
18731 54F3           50                         push	ax
18732                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18733 54F4           FF76         FE            push	-2[bp]
18734                                           ! Debug: func () void = write_word+0 (used reg = )
18735 54F7           E8         B13C            call	_write_word
18736 54FA           83C4                   06  add	sp,*6
18737                                           !BCC_EOS
18738                                           ! 2995           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18739                                           ! Debug: list int = const $27 (used reg = )
18740 54FD           B8                   0027  mov	ax,*$27
18741 5500           50                         push	ax
18742                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18743 5501           FF76         FE            push	-2[bp]
18744                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18745 5504           E8         B0F1            call	_read_byte
18746 5507           83C4                   04  add	sp,*4
18747                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18748 550A           8846         FC            mov	-4[bp],al
18749                                           !BCC_EOS
18750                                           ! 2996           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18751                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18752 550D           8B46         F8            mov	ax,-8[bp]
18753 5510           85C0                       test	ax,ax
18754 5512           75           1D            jne 	.405
18755                       00005514            .407:
18756                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18757 5514           8B46         FA            mov	ax,-6[bp]
18758 5517           85C0                       test	ax,ax
18759 5519           75           16            jne 	.405
18760                       0000551B            .406:
18761                                           ! 2997             if ( (mouse_flags_2 & 0x80) != 0 ) {
18762                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18763 551B           8A46         FC            mov	al,-4[bp]
18764 551E           24                     80  and	al,#$80
18765                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18766 5520           84C0                       test	al,al
18767 5522           74           0B            je  	.408
18768                       00005524            .409:
18769                                           ! 2998               mouse_flags_2 &= ~0x80;
18770                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18771 5524           8A46         FC            mov	al,-4[bp]
18772 5527           24                     7F  and	al,*$7F
18773 5529           8846         FC            mov	-4[bp],al
18774                                           !BCC_EOS
18775                                           ! 2999               inhibit_mouse_int_and_events();
18776                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18777 552C           E8         0BBF            call	_inhibit_mouse_int_and_events
18778                                           !BCC_EOS
18779                                           ! 3000             }
18780                                           ! 3001           }
18781                       0000552F            .408:
18782                                           ! 3002           else {
18783 552F           EB           08            jmp .40A
18784                       00005531            .405:
18785                                           ! 3003             mouse_flags_2 |= 0x80;
18786                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18787 5531           8A46         FC            mov	al,-4[bp]
18788 5534           0C                     80  or	al,#$80
18789 5536           8846         FC            mov	-4[bp],al
18790                                           !BCC_EOS
18791                                           ! 3004           }
18792                                           ! 3005           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18793                       00005539            .40A:
18794                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18795 5539           8A46         FC            mov	al,-4[bp]
18796 553C           30E4                       xor	ah,ah
18797 553E           50                         push	ax
18798                                           ! Debug: list int = const $27 (used reg = )
18799 553F           B8                   0027  mov	ax,*$27
18800 5542           50                         push	ax
18801                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18802 5543           FF76         FE            push	-2[bp]
18803                                           ! Debug: func () void = write_byte+0 (used reg = )
18804 5546           E8         B0D5            call	_write_byte
18805 5549           83C4                   06  add	sp,*6
18806                                           !BCC_EOS
18807                                           ! 3006           FLAGS &= 0xfffe;
18808                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18809 554C           8B46         18            mov	ax,$18[bp]
18810 554F           24                     FE  and	al,#$FE
18811 5551           8946         18            mov	$18[bp],ax
18812                                           !BCC_EOS
18813                                           ! 3007           regs.u.r8.ah = 0;
18814                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18815 5554           30C0                       xor	al,al
18816 5556           8846         13            mov	$13[bp],al
18817                                           !BCC_EOS
18818                                           ! 3008           break;
18819 5559           EB           34            jmp .396
18820                                           !BCC_EOS
18821                                           ! 3009         default:
18822                                           ! 3010 ;
18823                       0000555B            .40B:
18824                                           !BCC_EOS
18825                                           ! 3011           regs.u.r8.ah = 1;
18826                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18827 555B           B0                     01  mov	al,*1
18828 555D           8846         13            mov	$13[bp],al
18829                                           !BCC_EOS
18830                                           ! 3012           FLAGS |= 0x0001;
18831                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18832 5560           8B46         18            mov	ax,$18[bp]
18833 5563           0C                     01  or	al,*1
18834 5565           8946         18            mov	$18[bp],ax
18835                                           !BCC_EOS
18836                                           ! 3013       }
18837                                           ! 3014       break;
18838 5568           EB           25            jmp .396
18839                       0000556A            .398:
18840 556A           2C                     00  sub	al,*0
18841 556C           72           ED            jb 	.40B
18842 556E           3C                     07  cmp	al,*7
18843 5570           77           1B            ja  	.40C
18844 5572           30E4                       xor	ah,ah
18845 5574           D1E0                       shl	ax,*1
18846 5576           89C3                       mov	bx,ax
18847 5578           2E                         seg	cs
18848 5579           FFA7       557D            br	.40D[bx]
18849                       0000557D            .40D:
18850 557D                      4F6A            .word	.399
18851 557F                      506A            .word	.3AC
18852 5581                      5182            .word	.3BF
18853 5583                      5250            .word	.3D3
18854 5585                      5307            .word	.3E0
18855 5587                      506A            .word	.3AD
18856 5589                      535A            .word	.3E4
18857 558B                      54D1            .word	.404
18858                       0000558D            .40C:
18859 558D           EB           CC            jmp	.40B
18860                       0000558F            .396:
18861 558F           EB           2D            jmp .392
18862                                           !BCC_EOS
18863                                           ! 3015     default:
18864                                           ! 3016       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
18865                       00005591            .40E:
18866                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
18867 5591           FF76         0C            push	$C[bp]
18868                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
18869 5594           FF76         12            push	$12[bp]
18870                                           ! Debug: list * char = .40F+0 (used reg = )
18871 5597           BB                   D3F2  mov	bx,#.40F
18872 559A           53                         push	bx
18873                                           ! Debug: list int = const 4 (used reg = )
18874 559B           B8                   0004  mov	ax,*4
18875 559E           50                         push	ax
18876                                           ! Debug: func () void = bios_printf+0 (used reg = )
18877 559F           E8         B405            call	_bios_printf
18878 55A2           83C4                   08  add	sp,*8
18879                                           !BCC_EOS
18880                                           ! 3017       FLAGS |= 0x0001;
18881                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18882 55A5           8B46         18            mov	ax,$18[bp]
18883 55A8           0C                     01  or	al,*1
18884 55AA           8946         18            mov	$18[bp],ax
18885                                           !BCC_EOS
18886                                           ! 3018       regs.u.r8.ah = 0x86;
18887                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18888 55AD           B0                     86  mov	al,#$86
18889 55AF           8846         13            mov	$13[bp],al
18890                                           !BCC_EOS
18891                                           ! 3019       break;
18892 55B2           EB           0A            jmp .392
18893                                           !BCC_EOS
18894                                           ! 3020   }
18895                                           ! 3021 }
18896 55B4           EB           08            jmp .392
18897                       000055B6            .394:
18898 55B6           2C                     C2  sub	al,#$C2
18899 55B8         0F84         F9A8            beq 	.395
18900 55BC           EB           D3            jmp	.40E
18901                       000055BE            .392:
18902                       FFFFFFF0            ..FFF6	=	-$10
18903 55BE           89EC                       mov	sp,bp
18904 55C0           5D                         pop	bp
18905 55C1           C3                         ret
18906                                           ! 3022 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
18907                                           ! Register BX used in function int15_function_mouse
18908                                           ! 3023      Bit16u ES;
18909                                           export	_set_e820_range
18910                       000055C2            _set_e820_range:
18911                                           !BCC_EOS
18912                                           ! 3024      Bit16u DI;
18913                                           !BCC_EOS
18914                                           ! 3025      Bit32u start;
18915                                           !BCC_EOS
18916                                           ! 3026      Bit32u end;
18917                                           !BCC_EOS
18918                                           ! 3027      Bit8u extra_start;
18919                                           !BCC_EOS
18920                                           ! 3028      Bit8u extra_end;
18921                                           !BCC_EOS
18922                                           ! 3029      Bit16u type;
18923                                           !BCC_EOS
18924                                           ! 3030 {
18925                                           ! 3031     write_word(ES, DI, start);
18926 55C2           55                         push	bp
18927 55C3           89E5                       mov	bp,sp
18928                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18929 55C5           FF76         0A            push	$A[bp]
18930 55C8           FF76         08            push	8[bp]
18931                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18932 55CB           FF76         06            push	6[bp]
18933                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18934 55CE           FF76         04            push	4[bp]
18935                                           ! Debug: func () void = write_word+0 (used reg = )
18936 55D1           E8         B062            call	_write_word
18937 55D4           89EC                       mov	sp,bp
18938                                           !BCC_EOS
18939                                           ! 3032     write_word(ES, DI+2, start >> 16);
18940                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18941 55D6           8B46         08            mov	ax,8[bp]
18942 55D9           8B5E         0A            mov	bx,$A[bp]
18943 55DC           93                         xchg	bx,ax
18944 55DD           31DB                       xor	bx,bx
18945                                           ! Debug: list unsigned long = bx+0 (used reg = )
18946 55DF           53                         push	bx
18947 55E0           50                         push	ax
18948                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18949 55E1           8B46         06            mov	ax,6[bp]
18950                                           ! Debug: list unsigned int = ax+2 (used reg = )
18951 55E4           40                         inc	ax
18952 55E5           40                         inc	ax
18953 55E6           50                         push	ax
18954                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18955 55E7           FF76         04            push	4[bp]
18956                                           ! Debug: func () void = write_word+0 (used reg = )
18957 55EA           E8         B049            call	_write_word
18958 55ED           89EC                       mov	sp,bp
18959                                           !BCC_EOS
18960                                           ! 3033     write_word(ES, DI+4, extra_start);
18961                                           ! Debug: list unsigned char extra_start = [S+2+$E] (used reg = )
18962 55EF           8A46         10            mov	al,$10[bp]
18963 55F2           30E4                       xor	ah,ah
18964 55F4           50                         push	ax
18965                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
18966 55F5           8B46         06            mov	ax,6[bp]
18967                                           ! Debug: list unsigned int = ax+4 (used reg = )
18968 55F8           05                   0004  add	ax,*4
18969 55FB           50                         push	ax
18970                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18971 55FC           FF76         04            push	4[bp]
18972                                           ! Debug: func () void = write_word+0 (used reg = )
18973 55FF           E8         B034            call	_write_word
18974 5602           89EC                       mov	sp,bp
18975                                           !BCC_EOS
18976                                           ! 3034     write_word(ES, DI+6, 0x00);
18977                                           ! Debug: list int = const 0 (used reg = )
18978 5604           31C0                       xor	ax,ax
18979 5606           50                         push	ax
18980                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
18981 5607           8B46         06            mov	ax,6[bp]
18982                                           ! Debug: list unsigned int = ax+6 (used reg = )
18983 560A           05                   0006  add	ax,*6
18984 560D           50                         push	ax
18985                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18986 560E           FF76         04            push	4[bp]
18987                                           ! Debug: func () void = write_word+0 (used reg = )
18988 5611           E8         B022            call	_write_word
18989 5614           89EC                       mov	sp,bp
18990                                           !BCC_EOS
18991                                           ! 3035     end -= start;
18992                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
18993 5616           8B46         0C            mov	ax,$C[bp]
18994 5619           8B5E         0E            mov	bx,$E[bp]
18995 561C           8D7E         08            lea	di,8[bp]
18996 561F           E8         AABF            call	lsubul
18997 5622           8946         0C            mov	$C[bp],ax
18998 5625           895E         0E            mov	$E[bp],bx
18999                                           !BCC_EOS
19000                                           ! 3036     extra_end -= extra_start;
19001                                           ! Debug: subab unsigned char extra_start = [S+2+$E] to unsigned char extra_end = [S+2+$10] (used reg = )
19002 5628           8A46         12            mov	al,$12[bp]
19003 562B           30E4                       xor	ah,ah
19004 562D           2A46         10            sub	al,$10[bp]
19005 5630           80DC                   00  sbb	ah,*0
19006 5633           8846         12            mov	$12[bp],al
19007                                           !BCC_EOS
19008                                           ! 3037     write_word(ES, DI+8, end);
19009                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
19010 5636           FF76         0E            push	$E[bp]
19011 5639           FF76         0C            push	$C[bp]
19012                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
19013 563C           8B46         06            mov	ax,6[bp]
19014                                           ! Debug: list unsigned int = ax+8 (used reg = )
19015 563F           05                   0008  add	ax,*8
19016 5642           50                         push	ax
19017                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19018 5643           FF76         04            push	4[bp]
19019                                           ! Debug: func () void = write_word+0 (used reg = )
19020 5646           E8         AFED            call	_write_word
19021 5649           89EC                       mov	sp,bp
19022                                           !BCC_EOS
19023                                           ! 3038     write_word(ES, DI+10, end >> 16);
19024                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
19025 564B           8B46         0C            mov	ax,$C[bp]
19026 564E           8B5E         0E            mov	bx,$E[bp]
19027 5651           93                         xchg	bx,ax
19028 5652           31DB                       xor	bx,bx
19029                                           ! Debug: list unsigned long = bx+0 (used reg = )
19030 5654           53                         push	bx
19031 5655           50                         push	ax
19032                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
19033 5656           8B46         06            mov	ax,6[bp]
19034                                           ! Debug: list unsigned int = ax+$A (used reg = )
19035 5659           05                   000A  add	ax,*$A
19036 565C           50                         push	ax
19037                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19038 565D           FF76         04            push	4[bp]
19039                                           ! Debug: func () void = write_word+0 (used reg = )
19040 5660           E8         AFD3            call	_write_word
19041 5663           89EC                       mov	sp,bp
19042                                           !BCC_EOS
19043                                           ! 3039     write_word(ES, DI+12, extra_end);
19044                                           ! Debug: list unsigned char extra_end = [S+2+$10] (used reg = )
19045 5665           8A46         12            mov	al,$12[bp]
19046 5668           30E4                       xor	ah,ah
19047 566A           50                         push	ax
19048                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
19049 566B           8B46         06            mov	ax,6[bp]
19050                                           ! Debug: list unsigned int = ax+$C (used reg = )
19051 566E           05                   000C  add	ax,*$C
19052 5671           50                         push	ax
19053                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19054 5672           FF76         04            push	4[bp]
19055                                           ! Debug: func () void = write_word+0 (used reg = )
19056 5675           E8         AFBE            call	_write_word
19057 5678           89EC                       mov	sp,bp
19058                                           !BCC_EOS
19059                                           ! 3040     write_word(ES, DI+14, 0x0000);
19060                                           ! Debug: list int = const 0 (used reg = )
19061 567A           31C0                       xor	ax,ax
19062 567C           50                         push	ax
19063                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
19064 567D           8B46         06            mov	ax,6[bp]
19065                                           ! Debug: list unsigned int = ax+$E (used reg = )
19066 5680           05                   000E  add	ax,*$E
19067 5683           50                         push	ax
19068                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19069 5684           FF76         04            push	4[bp]
19070                                           ! Debug: func () void = write_word+0 (used reg = )
19071 5687           E8         AFAC            call	_write_word
19072 568A           89EC                       mov	sp,bp
19073                                           !BCC_EOS
19074                                           ! 3041     write_word(ES, DI+16, type);
19075                                           ! Debug: list unsigned short type = [S+2+$12] (used reg = )
19076 568C           FF76         14            push	$14[bp]
19077                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
19078 568F           8B46         06            mov	ax,6[bp]
19079                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19080 5692           05                   0010  add	ax,*$10
19081 5695           50                         push	ax
19082                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19083 5696           FF76         04            push	4[bp]
19084                                           ! Debug: func () void = write_word+0 (used reg = )
19085 5699           E8         AF9A            call	_write_word
19086 569C           89EC                       mov	sp,bp
19087                                           !BCC_EOS
19088                                           ! 3042     write_word(ES, DI+18, 0x0);
19089                                           ! Debug: list int = const 0 (used reg = )
19090 569E           31C0                       xor	ax,ax
19091 56A0           50                         push	ax
19092                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
19093 56A1           8B46         06            mov	ax,6[bp]
19094                                           ! Debug: list unsigned int = ax+$12 (used reg = )
19095 56A4           05                   0012  add	ax,*$12
19096 56A7           50                         push	ax
19097                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19098 56A8           FF76         04            push	4[bp]
19099                                           ! Debug: func () void = write_word+0 (used reg = )
19100 56AB           E8         AF88            call	_write_word
19101 56AE           89EC                       mov	sp,bp
19102                                           !BCC_EOS
19103                                           ! 3043 }
19104 56B0           5D                         pop	bp
19105 56B1           C3                         ret
19106                                           ! 3044   void
19107                                           ! Register BX used in function set_e820_range
19108                                           ! 3045 int15_function32(regs, ES, DS, FLAGS)
19109                                           ! 3046   pushad_regs_t regs;
19110                                           export	_int15_function32
19111                       000056B2            _int15_function32:
19112                                           !BCC_EOS
19113                                           ! 3047   Bit16u ES, DS, FLAGS;
19114                                           !BCC_EOS
19115                                           ! 3048 {
19116                                           ! 3049   Bit32u extended_memory_size=0;
19117 56B2           55                         push	bp
19118 56B3           89E5                       mov	bp,sp
19119 56B5           83C4                   FC  add	sp,*-4
19120                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
19121 56B8           31C0                       xor	ax,ax
19122 56BA           31DB                       xor	bx,bx
19123 56BC           8946         FC            mov	-4[bp],ax
19124 56BF           895E         FE            mov	-2[bp],bx
19125                                           !BCC_EOS
19126                                           ! 3050   Bit32u extra_lowbits_memory_size=0;
19127 56C2           83C4                   FC  add	sp,*-4
19128                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
19129 56C5           31C0                       xor	ax,ax
19130 56C7           31DB                       xor	bx,bx
19131 56C9           8946         F8            mov	-8[bp],ax
19132 56CC           895E         FA            mov	-6[bp],bx
19133                                           !BCC_EOS
19134                                           ! 3051   Bit16u CX,DX;
19135                                           !BCC_EOS
19136                                           ! 3052   Bit8u extra_highbits_memory_size=0;
19137 56CF           83C4                   FB  add	sp,*-5
19138                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
19139 56D2           30C0                       xor	al,al
19140 56D4           8846         F3            mov	-$D[bp],al
19141                                           !BCC_EOS
19142                                           ! 3053 ;
19143 56D7           4C                         dec	sp
19144                                           !BCC_EOS
19145                                           ! 3054   switch (regs.u.r8.ah) {
19146 56D8           8A46         21            mov	al,$21[bp]
19147 56DB           E9         04BB            br 	.412
19148                                           ! 3055     case 0x86:
19149                                           ! 3056       CX = regs.u.r16.cx;
19150                       000056DE            .413:
19151                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
19152 56DE           8B46         1C            mov	ax,$1C[bp]
19153 56E1           8946         F6            mov	-$A[bp],ax
19154                                           !BCC_EOS
19155                                           ! 3057       DX = regs.u.r16.dx;
19156                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
19157 56E4           8B46         18            mov	ax,$18[bp]
19158 56E7           8946         F4            mov	-$C[bp],ax
19159                                           !BCC_EOS
19160                                           ! 3058 #asm
19161                                           !BCC_EOS
19162                                           !BCC_ASM
19163                       00000004            _int15_function32.CX	set	4
19164                       FFFFFFF6            .int15_function32.CX	set	-$A
19165                       00000001            _int15_function32.extra_highbits_memory_size	set	1
19166                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
19167                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
19168                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
19169                       0000000A            _int15_function32.extended_memory_size	set	$A
19170                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
19171                       00000036            _int15_function32.FLAGS	set	$36
19172                       00000028            .int15_function32.FLAGS	set	$28
19173                       00000034            _int15_function32.DS	set	$34
19174                       00000026            .int15_function32.DS	set	$26
19175                       00000002            _int15_function32.DX	set	2
19176                       FFFFFFF4            .int15_function32.DX	set	-$C
19177                       00000032            _int15_function32.ES	set	$32
19178                       00000024            .int15_function32.ES	set	$24
19179                       00000012            _int15_function32.regs	set	$12
19180                       00000004            .int15_function32.regs	set	4
19181 56EA           FB                               sti
19182                                                 ;; Get the count in eax
19183 56EB           89E3                             mov bx, sp
19184 56ED           36                               SEG SS
19185 56EE           8B47         04                    mov ax, _int15_function32.CX [bx]
19186 56F1     66    C1E0                   10        shl eax, #16
19187 56F5           36                               SEG SS
19188 56F6           8B47         02                    mov ax, _int15_function32.DX [bx]
19189                                                 ;; convert to numbers of 15usec ticks
19190 56F9     66    BB               0000000F        mov ebx, #15
19191 56FF     66    31D2                             xor edx, edx
19192 5702     66    F7F3                             div eax, ebx
19193 5705     66    89C1                             mov ecx, eax
19194                                                 ;; wait for ecx number of refresh requests
19195 5708           E4                     61        in al, #0x61
19196 570A           24                     10        and al,#0x10
19197 570C           88C4                             mov ah, al
19198 570E     66    09C9                             or ecx, ecx
19199 5711           74           0E                  je int1586_tick_end
19200                       00005713            int1586_tick:
19201 5713           E4                     61        in al, #0x61
19202 5715           24                     10        and al,#0x10
19203 5717           38E0                             cmp al, ah
19204 5719           74           F8                  je int1586_tick
19205 571B           88C4                             mov ah, al
19206 571D     66    49                               dec ecx
19207 571F           75           F2                  jnz int1586_tick
19208                       00005721            int1586_tick_end:
19209                                           ! 3087 endasm
19210                                           !BCC_ENDASM
19211                                           !BCC_EOS
19212                                           ! 3088       break;
19213 5721           E9         0483            br 	.410
19214                                           !BCC_EOS
19215                                           ! 3089     case 0xe8:
19216                                           ! 3090         switch(regs.u.r8.al) {
19217                       00005724            .414:
19218 5724           8A46         20            mov	al,$20[bp]
19219 5727           E9         043C            br 	.417
19220                                           ! 3091          case 0x20:
19221                                           ! 3092             if(regs.u.r32.edx == 0x534D4150)
19222                       0000572A            .418:
19223                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
19224                                           ! Debug: expression subtree swapping
19225 572A           B8                   4150  mov	ax,#$4150
19226 572D           BB                   534D  mov	bx,#$534D
19227 5730           53                         push	bx
19228 5731           50                         push	ax
19229 5732           8B46         18            mov	ax,$18[bp]
19230 5735           8B5E         1A            mov	bx,$1A[bp]
19231 5738           8D7E         EE            lea	di,-2+..FFF5[bp]
19232 573B           E8         A98D            call	lcmpul
19233 573E           8D66         F2            lea	sp,2+..FFF5[bp]
19234 5741         0F85         03BF            bne 	.419
19235                       00005745            .41A:
19236                                           ! 3093             {
19237                                           ! 3094                 extended_memory_size = inb_cmos(0x35);
19238                                           ! Debug: list int = const $35 (used reg = )
19239 5745           B8                   0035  mov	ax,*$35
19240 5748           50                         push	ax
19241                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19242 5749           E8         AE3B            call	_inb_cmos
19243 574C           44                         inc	sp
19244 574D           44                         inc	sp
19245                                           ! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19246 574E           30E4                       xor	ah,ah
19247 5750           31DB                       xor	bx,bx
19248 5752           8946         FC            mov	-4[bp],ax
19249 5755           895E         FE            mov	-2[bp],bx
19250                                           !BCC_EOS
19251                                           ! 3095                 extended_memory_size <<= 8;
19252                                           ! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19253 5758           8B46         FC            mov	ax,-4[bp]
19254 575B           8B5E         FE            mov	bx,-2[bp]
19255 575E           88DF                       mov	bh,bl
19256 5760           88E3                       mov	bl,ah
19257 5762           88C4                       mov	ah,al
19258 5764           30C0                       xor	al,al
19259 5766           8946         FC            mov	-4[bp],ax
19260 5769           895E         FE            mov	-2[bp],bx
19261                                           !BCC_EOS
19262                                           ! 3096                 extended_memory_size |= inb_cmos(0x34);
19263                                           ! Debug: list int = const $34 (used reg = )
19264 576C           B8                   0034  mov	ax,*$34
19265 576F           50                         push	ax
19266                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19267 5770           E8         AE14            call	_inb_cmos
19268 5773           44                         inc	sp
19269 5774           44                         inc	sp
19270                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19271 5775           30E4                       xor	ah,ah
19272 5777           31DB                       xor	bx,bx
19273                                           ! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19274 5779           53                         push	bx
19275 577A           50                         push	ax
19276 577B           8B46         FC            mov	ax,-4[bp]
19277 577E           8B5E         FE            mov	bx,-2[bp]
19278 5781           8D7E         EE            lea	di,-2+..FFF5[bp]
19279 5784           E8         A980            call	lorul
19280 5787           8946         FC            mov	-4[bp],ax
19281 578A           895E         FE            mov	-2[bp],bx
19282 578D           83C4                   04  add	sp,*4
19283                                           !BCC_EOS
19284                                           ! 3097                 extended_memory_size *= 64;
19285                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19286 5790           B8                   0040  mov	ax,*$40
19287 5793           31DB                       xor	bx,bx
19288 5795           53                         push	bx
19289 5796           50                         push	ax
19290 5797           8B46         FC            mov	ax,-4[bp]
19291 579A           8B5E         FE            mov	bx,-2[bp]
19292 579D           8D7E         EE            lea	di,-2+..FFF5[bp]
19293 57A0           E8         A946            call	lmulul
19294 57A3           8946         FC            mov	-4[bp],ax
19295 57A6           895E         FE            mov	-2[bp],bx
19296 57A9           83C4                   04  add	sp,*4
19297                                           !BCC_EOS
19298                                           ! 3098                 if(extended_memory_size > 0x3bc000) {
19299                                           ! Debug: gt long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19300 57AC           B8                   C000  mov	ax,#$C000
19301 57AF           BB                   003B  mov	bx,*$3B
19302 57B2           8D7E         FC            lea	di,-4[bp]
19303 57B5           E8         A913            call	lcmpul
19304 57B8           73           0C            jae 	.41B
19305                       000057BA            .41C:
19306                                           ! 3099                     extended_memory_size = 0x3bc000;
19307                                           ! Debug: eq long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19308 57BA           B8                   C000  mov	ax,#$C000
19309 57BD           BB                   003B  mov	bx,*$3B
19310 57C0           8946         FC            mov	-4[bp],ax
19311 57C3           895E         FE            mov	-2[bp],bx
19312                                           !BCC_EOS
19313                                           ! 3100                 }
19314                                           ! 3101                 extended_memory_size *= 1024;
19315                       000057C6            .41B:
19316                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19317 57C6           B8                   0400  mov	ax,#$400
19318 57C9           31DB                       xor	bx,bx
19319 57CB           53                         push	bx
19320 57CC           50                         push	ax
19321 57CD           8B46         FC            mov	ax,-4[bp]
19322 57D0           8B5E         FE            mov	bx,-2[bp]
19323 57D3           8D7E         EE            lea	di,-2+..FFF5[bp]
19324 57D6           E8         A910            call	lmulul
19325 57D9           8946         FC            mov	-4[bp],ax
19326 57DC           895E         FE            mov	-2[bp],bx
19327 57DF           83C4                   04  add	sp,*4
19328                                           !BCC_EOS
19329                                           ! 3102                 extended_memory_size += (16L * 1024 * 1024);
19330                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19331 57E2           31C0                       xor	ax,ax
19332 57E4           BB                   0100  mov	bx,#$100
19333 57E7           53                         push	bx
19334 57E8           50                         push	ax
19335 57E9           8B46         FC            mov	ax,-4[bp]
19336 57EC           8B5E         FE            mov	bx,-2[bp]
19337 57EF           8D7E         EE            lea	di,-2+..FFF5[bp]
19338 57F2           E8         A8CE            call	laddul
19339 57F5           8946         FC            mov	-4[bp],ax
19340 57F8           895E         FE            mov	-2[bp],bx
19341 57FB           83C4                   04  add	sp,*4
19342                                           !BCC_EOS
19343                                           ! 3103                 if(extended_memory_size <= (16L * 1024 * 1024)) {
19344                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19345 57FE           31C0                       xor	ax,ax
19346 5800           BB                   0100  mov	bx,#$100
19347 5803           8D7E         FC            lea	di,-4[bp]
19348 5806           E8         A8C2            call	lcmpul
19349 5809         0F82         0083            blo 	.41D
19350                       0000580D            .41E:
19351                                           ! 3104                     extended_memory_size = inb_cmos(0x31);
19352                                           ! Debug: list int = const $31 (used reg = )
19353 580D           B8                   0031  mov	ax,*$31
19354 5810           50                         push	ax
19355                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19356 5811           E8         AD73            call	_inb_cmos
19357 5814           44                         inc	sp
19358 5815           44                         inc	sp
19359                                           ! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19360 5816           30E4                       xor	ah,ah
19361 5818           31DB                       xor	bx,bx
19362 581A           8946         FC            mov	-4[bp],ax
19363 581D           895E         FE            mov	-2[bp],bx
19364                                           !BCC_EOS
19365                                           ! 3105                     extended_memory_size <<= 8;
19366                                           ! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19367 5820           8B46         FC            mov	ax,-4[bp]
19368 5823           8B5E         FE            mov	bx,-2[bp]
19369 5826           88DF                       mov	bh,bl
19370 5828           88E3                       mov	bl,ah
19371 582A           88C4                       mov	ah,al
19372 582C           30C0                       xor	al,al
19373 582E           8946         FC            mov	-4[bp],ax
19374 5831           895E         FE            mov	-2[bp],bx
19375                                           !BCC_EOS
19376                                           ! 3106                     extended_memory_size |= inb_cmos(0x30);
19377                                           ! Debug: list int = const $30 (used reg = )
19378 5834           B8                   0030  mov	ax,*$30
19379 5837           50                         push	ax
19380                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19381 5838           E8         AD4C            call	_inb_cmos
19382 583B           44                         inc	sp
19383 583C           44                         inc	sp
19384                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19385 583D           30E4                       xor	ah,ah
19386 583F           31DB                       xor	bx,bx
19387                                           ! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19388 5841           53                         push	bx
19389 5842           50                         push	ax
19390 5843           8B46         FC            mov	ax,-4[bp]
19391 5846           8B5E         FE            mov	bx,-2[bp]
19392 5849           8D7E         EE            lea	di,-2+..FFF5[bp]
19393 584C           E8         A8B8            call	lorul
19394 584F           8946         FC            mov	-4[bp],ax
19395 5852           895E         FE            mov	-2[bp],bx
19396 5855           83C4                   04  add	sp,*4
19397                                           !BCC_EOS
19398                                           ! 3107                     extended_memory_size *= 1024;
19399                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19400 5858           B8                   0400  mov	ax,#$400
19401 585B           31DB                       xor	bx,bx
19402 585D           53                         push	bx
19403 585E           50                         push	ax
19404 585F           8B46         FC            mov	ax,-4[bp]
19405 5862           8B5E         FE            mov	bx,-2[bp]
19406 5865           8D7E         EE            lea	di,-2+..FFF5[bp]
19407 5868           E8         A87E            call	lmulul
19408 586B           8946         FC            mov	-4[bp],ax
19409 586E           895E         FE            mov	-2[bp],bx
19410 5871           83C4                   04  add	sp,*4
19411                                           !BCC_EOS
19412                                           ! 3108                     extended_memory_size += (1L * 1024 * 1024);
19413                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
19414 5874           31C0                       xor	ax,ax
19415 5876           BB                   0010  mov	bx,*$10
19416 5879           53                         push	bx
19417 587A           50                         push	ax
19418 587B           8B46         FC            mov	ax,-4[bp]
19419 587E           8B5E         FE            mov	bx,-2[bp]
19420 5881           8D7E         EE            lea	di,-2+..FFF5[bp]
19421 5884           E8         A83C            call	laddul
19422 5887           8946         FC            mov	-4[bp],ax
19423 588A           895E         FE            mov	-2[bp],bx
19424 588D           83C4                   04  add	sp,*4
19425                                           !BCC_EOS
19426                                           ! 3109                 }
19427                                           ! 3110                 extra_lowbits_memory_size = inb_cmos(0x5c);
19428                       00005890            .41D:
19429                                           ! Debug: list int = const $5C (used reg = )
19430 5890           B8                   005C  mov	ax,*$5C
19431 5893           50                         push	ax
19432                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19433 5894           E8         ACF0            call	_inb_cmos
19434 5897           44                         inc	sp
19435 5898           44                         inc	sp
19436                                           ! Debug: eq unsigned char = al+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19437 5899           30E4                       xor	ah,ah
19438 589B           31DB                       xor	bx,bx
19439 589D           8946         F8            mov	-8[bp],ax
19440 58A0           895E         FA            mov	-6[bp],bx
19441                                           !BCC_EOS
19442                                           ! 3111                 extra_lowbits_memory_size <<= 8;
19443                                           ! Debug: slab int = const 8 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19444 58A3           8B46         F8            mov	ax,-8[bp]
19445 58A6           8B5E         FA            mov	bx,-6[bp]
19446 58A9           88DF                       mov	bh,bl
19447 58AB           88E3                       mov	bl,ah
19448 58AD           88C4                       mov	ah,al
19449 58AF           30C0                       xor	al,al
19450 58B1           8946         F8            mov	-8[bp],ax
19451 58B4           895E         FA            mov	-6[bp],bx
19452                                           !BCC_EOS
19453                                           ! 3112                 extra_lowbits_memory_size |= inb_cmos(0x5b);
19454                                           ! Debug: list int = const $5B (used reg = )
19455 58B7           B8                   005B  mov	ax,*$5B
19456 58BA           50                         push	ax
19457                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19458 58BB           E8         ACC9            call	_inb_cmos
19459 58BE           44                         inc	sp
19460 58BF           44                         inc	sp
19461                                           ! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
19462 58C0           30E4                       xor	ah,ah
19463 58C2           31DB                       xor	bx,bx
19464                                           ! Debug: orab unsigned long = bx+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19465 58C4           53                         push	bx
19466 58C5           50                         push	ax
19467 58C6           8B46         F8            mov	ax,-8[bp]
19468 58C9           8B5E         FA            mov	bx,-6[bp]
19469 58CC           8D7E         EE            lea	di,-2+..FFF5[bp]
19470 58CF           E8         A835            call	lorul
19471 58D2           8946         F8            mov	-8[bp],ax
19472 58D5           895E         FA            mov	-6[bp],bx
19473 58D8           83C4                   04  add	sp,*4
19474                                           !BCC_EOS
19475                                           ! 3113                 extra_lowbits_memory_size *= 64;
19476                                           ! Debug: mulab unsigned long = const $40 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19477 58DB           B8                   0040  mov	ax,*$40
19478 58DE           31DB                       xor	bx,bx
19479 58E0           53                         push	bx
19480 58E1           50                         push	ax
19481 58E2           8B46         F8            mov	ax,-8[bp]
19482 58E5           8B5E         FA            mov	bx,-6[bp]
19483 58E8           8D7E         EE            lea	di,-2+..FFF5[bp]
19484 58EB           E8         A7FB            call	lmulul
19485 58EE           8946         F8            mov	-8[bp],ax
19486 58F1           895E         FA            mov	-6[bp],bx
19487 58F4           83C4                   04  add	sp,*4
19488                                           !BCC_EOS
19489                                           ! 3114                 extra_lowbits_memory_size *= 1024;
19490                                           ! Debug: mulab unsigned long = const $400 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
19491 58F7           B8                   0400  mov	ax,#$400
19492 58FA           31DB                       xor	bx,bx
19493 58FC           53                         push	bx
19494 58FD           50                         push	ax
19495 58FE           8B46         F8            mov	ax,-8[bp]
19496 5901           8B5E         FA            mov	bx,-6[bp]
19497 5904           8D7E         EE            lea	di,-2+..FFF5[bp]
19498 5907           E8         A7DF            call	lmulul
19499 590A           8946         F8            mov	-8[bp],ax
19500 590D           895E         FA            mov	-6[bp],bx
19501 5910           83C4                   04  add	sp,*4
19502                                           !BCC_EOS
19503                                           ! 3115                 extra_highbits_memory_size = inb_cmos(0x5d);
19504                                           ! Debug: list int = const $5D (used reg = )
19505 5913           B8                   005D  mov	ax,*$5D
19506 5916           50                         push	ax
19507                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19508 5917           E8         AC6D            call	_inb_cmos
19509 591A           44                         inc	sp
19510 591B           44                         inc	sp
19511                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
19512 591C           8846         F3            mov	-$D[bp],al
19513                                           !BCC_EOS
19514                                           ! 3116                 switch(regs.u.r16.bx)
19515 591F           8B46         14            mov	ax,$14[bp]
19516                                           ! 3117                 {
19517 5922           E9         019B            br 	.421
19518                                           ! 3118                     case 0:
19519                                           ! 3119                         set_e820_range(ES, regs.u.r16.di,
19520                       00005925            .422:
19521                                           ! 3120                                        0x0000000L, 0x0009f000L, 0, 0, 1);
19522                                           ! Debug: list int = const 1 (used reg = )
19523 5925           B8                   0001  mov	ax,*1
19524 5928           50                         push	ax
19525                                           ! Debug: list int = const 0 (used reg = )
19526 5929           31C0                       xor	ax,ax
19527 592B           50                         push	ax
19528                                           ! Debug: list int = const 0 (used reg = )
19529 592C           31C0                       xor	ax,ax
19530 592E           50                         push	ax
19531                                           ! Debug: list long = const $9F000 (used reg = )
19532 592F           B8                   F000  mov	ax,#$F000
19533 5932           BB                   0009  mov	bx,*9
19534 5935           53                         push	bx
19535 5936           50                         push	ax
19536                                           ! Debug: list long = const 0 (used reg = )
19537 5937           31C0                       xor	ax,ax
19538 5939           31DB                       xor	bx,bx
19539 593B           53                         push	bx
19540 593C           50                         push	ax
19541                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19542 593D           FF76         04            push	4[bp]
19543                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19544 5940           FF76         24            push	$24[bp]
19545                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19546 5943           E8         FC7C            call	_set_e820_range
19547 5946           83C4                   12  add	sp,*$12
19548                                           !BCC_EOS
19549                                           ! 3121                         regs.u.r32.ebx = 1;
19550                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
19551 5949           B8                   0001  mov	ax,*1
19552 594C           31DB                       xor	bx,bx
19553 594E           8946         14            mov	$14[bp],ax
19554 5951           895E         16            mov	$16[bp],bx
19555                                           !BCC_EOS
19556                                           ! 3122                         break;
19557 5954           E9         018C            br 	.41F
19558                                           !BCC_EOS
19559                                           ! 3123                     case 1:
19560                                           ! 3124                         set_e820_range(ES, regs.u.r16.di,
19561                       00005957            .423:
19562                                           ! 3125                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
19563                                           ! Debug: list int = const 2 (used reg = )
19564 5957           B8                   0002  mov	ax,*2
19565 595A           50                         push	ax
19566                                           ! Debug: list int = const 0 (used reg = )
19567 595B           31C0                       xor	ax,ax
19568 595D           50                         push	ax
19569                                           ! Debug: list int = const 0 (used reg = )
19570 595E           31C0                       xor	ax,ax
19571 5960           50                         push	ax
19572                                           ! Debug: list long = const $A0000 (used reg = )
19573 5961           31C0                       xor	ax,ax
19574 5963           BB                   000A  mov	bx,*$A
19575 5966           53                         push	bx
19576 5967           50                         push	ax
19577                                           ! Debug: list long = const $9F000 (used reg = )
19578 5968           B8                   F000  mov	ax,#$F000
19579 596B           BB                   0009  mov	bx,*9
19580 596E           53                         push	bx
19581 596F           50                         push	ax
19582                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19583 5970           FF76         04            push	4[bp]
19584                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19585 5973           FF76         24            push	$24[bp]
19586                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19587 5976           E8         FC49            call	_set_e820_range
19588 5979           83C4                   12  add	sp,*$12
19589                                           !BCC_EOS
19590                                           ! 3126      
19591                                           ! 3126                    regs.u.r32.ebx = 2;
19592                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
19593 597C           B8                   0002  mov	ax,*2
19594 597F           31DB                       xor	bx,bx
19595 5981           8946         14            mov	$14[bp],ax
19596 5984           895E         16            mov	$16[bp],bx
19597                                           !BCC_EOS
19598                                           ! 3127                         break;
19599 5987           E9         0159            br 	.41F
19600                                           !BCC_EOS
19601                                           ! 3128                     case 2:
19602                                           ! 3129                         set_e820_range(ES, regs.u.r16.di,
19603                       0000598A            .424:
19604                                           ! 3130                                        0x000e8000L, 0x00100000L, 0, 0, 2);
19605                                           ! Debug: list int = const 2 (used reg = )
19606 598A           B8                   0002  mov	ax,*2
19607 598D           50                         push	ax
19608                                           ! Debug: list int = const 0 (used reg = )
19609 598E           31C0                       xor	ax,ax
19610 5990           50                         push	ax
19611                                           ! Debug: list int = const 0 (used reg = )
19612 5991           31C0                       xor	ax,ax
19613 5993           50                         push	ax
19614                                           ! Debug: list long = const $100000 (used reg = )
19615 5994           31C0                       xor	ax,ax
19616 5996           BB                   0010  mov	bx,*$10
19617 5999           53                         push	bx
19618 599A           50                         push	ax
19619                                           ! Debug: list long = const $E8000 (used reg = )
19620 599B           B8                   8000  mov	ax,#$8000
19621 599E           BB                   000E  mov	bx,*$E
19622 59A1           53                         push	bx
19623 59A2           50                         push	ax
19624                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19625 59A3           FF76         04            push	4[bp]
19626                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19627 59A6           FF76         24            push	$24[bp]
19628                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19629 59A9           E8         FC16            call	_set_e820_range
19630 59AC           83C4                   12  add	sp,*$12
19631                                           !BCC_EOS
19632                                           ! 3131                         regs.u.r32.ebx = 3;
19633                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
19634 59AF           B8                   0003  mov	ax,*3
19635 59B2           31DB                       xor	bx,bx
19636 59B4           8946         14            mov	$14[bp],ax
19637 59B7           895E         16            mov	$16[bp],bx
19638                                           !BCC_EOS
19639                                           ! 3132                         break;
19640 59BA           E9         0126            br 	.41F
19641                                           !BCC_EOS
19642                                           ! 3133                     case 3:
19643                                           ! 3134                         set_e820_range(ES, regs.u.r16.di,
19644                       000059BD            .425:
19645                                           ! 3135                                        0x00100000L,
19646                                           ! 3136                                        extended_memory_size, 0, 0, 1);
19647                                           ! Debug: list int = const 1 (used reg = )
19648 59BD           B8                   0001  mov	ax,*1
19649 59C0           50                         push	ax
19650                                           ! Debug: list int = const 0 (used reg = )
19651 59C1           31C0                       xor	ax,ax
19652 59C3           50                         push	ax
19653                                           ! Debug: list int = const 0 (used reg = )
19654 59C4           31C0                       xor	ax,ax
19655 59C6           50                         push	ax
19656                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
19657 59C7           FF76         FE            push	-2[bp]
19658 59CA           FF76         FC            push	-4[bp]
19659                                           ! Debug: list long = const $100000 (used reg = )
19660 59CD           31C0                       xor	ax,ax
19661 59CF           BB                   0010  mov	bx,*$10
19662 59D2           53                         push	bx
19663 59D3           50                         push	ax
19664                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19665 59D4           FF76         04            push	4[bp]
19666                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19667 59D7           FF76         24            push	$24[bp]
19668                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19669 59DA           E8         FBE5            call	_set_e820_range
19670 59DD           83C4                   12  add	sp,*$12
19671                                           !BCC_EOS
19672                                           ! 3137                         regs.u.r32.ebx = 5;
19673                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
19674 59E0           B8                   0005  mov	ax,*5
19675 59E3           31DB                       xor	bx,bx
19676 59E5           8946         14            mov	$14[bp],ax
19677 59E8           895E         16            mov	$16[bp],bx
19678                                           !BCC_EOS
19679                                           ! 3138                         break;
19680 59EB           E9         00F5            br 	.41F
19681                                           !BCC_EOS
19682                                           ! 3139                     case 4:
19683                                           ! 3140                         set_e820_range(ES, regs.u.r16.di,
19684                       000059EE            .426:
19685                                           ! 3141                                        extended_memory_size - 0x00010000L,
19686                                           ! 3142                                        extended_memory_size, 0, 0, 3);
19687                                           ! Debug: list int = const 3 (used reg = )
19688 59EE           B8                   0003  mov	ax,*3
19689 59F1           50                         push	ax
19690                                           ! Debug: list int = const 0 (used reg = )
19691 59F2           31C0                       xor	ax,ax
19692 59F4           50                         push	ax
19693                                           ! Debug: list int = const 0 (used reg = )
19694 59F5           31C0                       xor	ax,ax
19695 59F7           50                         push	ax
19696                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
19697 59F8           FF76         FE            push	-2[bp]
19698 59FB           FF76         FC            push	-4[bp]
19699                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
19700 59FE           31C0                       xor	ax,ax
19701 5A00           BB                   0001  mov	bx,*1
19702 5A03           53                         push	bx
19703 5A04           50                         push	ax
19704 5A05           8B46         FC            mov	ax,-4[bp]
19705 5A08           8B5E         FE            mov	bx,-2[bp]
19706 5A0B           8D7E         E4            lea	di,-$C+..FFF5[bp]
19707 5A0E           E8         A6D0            call	lsubul
19708 5A11           83C4                   04  add	sp,*4
19709                                           ! Debug: list unsigned long = bx+0 (used reg = )
19710 5A14           53                         push	bx
19711 5A15           50                         push	ax
19712                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19713 5A16           FF76         04            push	4[bp]
19714                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19715 5A19           FF76         24            push	$24[bp]
19716                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19717 5A1C           E8         FBA3            call	_set_e820_range
19718 5A1F           83C4                   12  add	sp,*$12
19719                                           !BCC_EOS
19720                                           ! 3143                         regs.u.r32.ebx = 5;
19721                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
19722 5A22           B8                   0005  mov	ax,*5
19723 5A25           31DB                       xor	bx,bx
19724 5A27           8946         14            mov	$14[bp],ax
19725 5A2A           895E         16            mov	$16[bp],bx
19726                                           !BCC_EOS
19727                                           ! 3144                         break;
19728 5A2D           E9         00B3            br 	.41F
19729                                           !BCC_EOS
19730                                           ! 3145                     case 5:
19731                                           ! 3146                         set_e820_range(ES, regs.u.r16.di,
19732                       00005A30            .427:
19733                                           ! 3147                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
19734                                           ! Debug: list int = const 2 (used reg = )
19735 5A30           B8                   0002  mov	ax,*2
19736 5A33           50                         push	ax
19737                                           ! Debug: list int = const 0 (used reg = )
19738 5A34           31C0                       xor	ax,ax
19739 5A36           50                         push	ax
19740                                           ! Debug: list int = const 0 (used reg = )
19741 5A37           31C0                       xor	ax,ax
19742 5A39           50                         push	ax
19743                                           ! Debug: list long = const 0 (used reg = )
19744 5A3A           31C0                       xor	ax,ax
19745 5A3C           31DB                       xor	bx,bx
19746 5A3E           53                         push	bx
19747 5A3F           50                         push	ax
19748                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
19749 5A40           31C0                       xor	ax,ax
19750 5A42           BB                   FFFC  mov	bx,#$FFFC
19751 5A45           53                         push	bx
19752 5A46           50                         push	ax
19753                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19754 5A47           FF76         04            push	4[bp]
19755                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19756 5A4A           FF76         24            push	$24[bp]
19757                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19758 5A4D           E8         FB72            call	_set_e820_range
19759 5A50           83C4                   12  add	sp,*$12
19760                                           !BCC_EOS
19761                                           ! 3148                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
19762                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
19763 5A53           8A46         F3            mov	al,-$D[bp]
19764 5A56           30E4                       xor	ah,ah
19765 5A58           31DB                       xor	bx,bx
19766 5A5A           E8         A6B7            call	ltstl
19767 5A5D           75           0B            jne 	.429
19768                       00005A5F            .42A:
19769 5A5F           8B46         F8            mov	ax,-8[bp]
19770 5A62           8B5E         FA            mov	bx,-6[bp]
19771 5A65           E8         A6AC            call	ltstl
19772 5A68           74           0D            je  	.428
19773                       00005A6A            .429:
19774                                           ! 3149                             regs.u.r32.ebx = 6;
19775                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
19776 5A6A           B8                   0006  mov	ax,*6
19777 5A6D           31DB                       xor	bx,bx
19778 5A6F           8946         14            mov	$14[bp],ax
19779 5A72           895E         16            mov	$16[bp],bx
19780                                           !BCC_EOS
19781                                           ! 3150                         else
19782                                           ! 3151                             regs.u.r32.ebx = 0;
19783 5A75           EB           0A            jmp .42B
19784                       00005A77            .428:
19785                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
19786 5A77           31C0                       xor	ax,ax
19787 5A79           31DB                       xor	bx,bx
19788 5A7B           8946         14            mov	$14[bp],ax
19789 5A7E           895E         16            mov	$16[bp],bx
19790                                           !BCC_EOS
19791                                           ! 3152                         break;
19792                       00005A81            .42B:
19793 5A81           EB           60            jmp .41F
19794                                           !BCC_EOS
19795                                           ! 3153                     case 6:
19796                                           ! 3154                         set_e820_range(ES, regs.u.r16.di, 0x00000000L,
19797                       00005A83            .42C:
19798                                           ! 3155                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
19799                                           ! 3156                                        + 1, 1);
19800                                           ! Debug: list int = const 1 (used reg = )
19801 5A83           B8                   0001  mov	ax,*1
19802 5A86           50                         push	ax
19803                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
19804 5A87           8A46         F3            mov	al,-$D[bp]
19805 5A8A           30E4                       xor	ah,ah
19806                                           ! Debug: list unsigned int = ax+1 (used reg = )
19807 5A8C           40                         inc	ax
19808 5A8D           50                         push	ax
19809                                           ! Debug: list int = const 1 (used reg = )
19810 5A8E           B8                   0001  mov	ax,*1
19811 5A91           50                         push	ax
19812                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
19813 5A92           FF76         FA            push	-6[bp]
19814 5A95           FF76         F8            push	-8[bp]
19815                                           ! Debug: list long = const 0 (used reg = )
19816 5A98           31C0                       xor	ax,ax
19817 5A9A           31DB                       xor	bx,bx
19818 5A9C           53                         push	bx
19819 5A9D           50                         push	ax
19820                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
19821 5A9E           FF76         04            push	4[bp]
19822                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
19823 5AA1           FF76         24            push	$24[bp]
19824                                           ! Debug: func () void = set_e820_range+0 (used reg = )
19825 5AA4           E8         FB1B            call	_set_e820_range
19826 5AA7           83C4                   12  add	sp,*$12
19827                                           !BCC_EOS
19828                                           ! 3157                         regs.u.r32.ebx = 0;
19829                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
19830 5AAA           31C0                       xor	ax,ax
19831 5AAC           31DB                       xor	bx,bx
19832 5AAE           8946         14            mov	$14[bp],ax
19833 5AB1           895E         16            mov	$16[bp],bx
19834                                           !BCC_EOS
19835                                           ! 3158                         break;
19836 5AB4           EB           2D            jmp .41F
19837                                           !BCC_EOS
19838                                           ! 3159                     default:
19839                                           ! 3160                         goto int15_unimplemented;
19840                       00005AB6            .42D:
19841 5AB6           83C4                   00  add	sp,#..FFF4-..FFF5
19842 5AB9           E9         00B8            br 	.FFF4
19843                                           !BCC_EOS
19844                                           ! 3161                         break;
19845 5ABC           EB           25            jmp .41F
19846                                           !BCC_EOS
19847                                           ! 3162                 }
19848                                           ! 3163                 regs.u.r32.eax = 0x534D4150;
19849 5ABE           EB           23            jmp .41F
19850                       00005AC0            .421:
19851 5AC0           2D                   0000  sub	ax,*0
19852 5AC3           7C           F1            jl 	.42D
19853 5AC5           3D                   0006  cmp	ax,*6
19854 5AC8           77           17            ja  	.42E
19855 5ACA           D1E0                       shl	ax,*1
19856 5ACC           89C3                       mov	bx,ax
19857 5ACE           2E                         seg	cs
19858 5ACF           FFA7       5AD3            br	.42F[bx]
19859                       00005AD3            .42F:
19860 5AD3                      5925            .word	.422
19861 5AD5                      5957            .word	.423
19862 5AD7                      598A            .word	.424
19863 5AD9                      59BD            .word	.425
19864 5ADB                      59EE            .word	.426
19865 5ADD                      5A30            .word	.427
19866 5ADF                      5A83            .word	.42C
19867                       00005AE1            .42E:
19868 5AE1           EB           D3            jmp	.42D
19869                       00005AE3            .41F:
19870                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
19871 5AE3           B8                   4150  mov	ax,#$4150
19872 5AE6           BB                   534D  mov	bx,#$534D
19873 5AE9           8946         20            mov	$20[bp],ax
19874 5AEC           895E         22            mov	$22[bp],bx
19875                                           !BCC_EOS
19876                                           ! 3164                 regs.u.r32.ecx = 0x14;
19877                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
19878 5AEF           B8                   0014  mov	ax,*$14
19879 5AF2           31DB                       xor	bx,bx
19880 5AF4           8946         1C            mov	$1C[bp],ax
19881 5AF7           895E         1E            mov	$1E[bp],bx
19882                                           !BCC_EOS
19883                                           ! 3165                 FLAGS &= 0xfffe;
19884                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
19885 5AFA           8B46         28            mov	ax,$28[bp]
19886 5AFD           24                     FE  and	al,#$FE
19887 5AFF           8946         28            mov	$28[bp],ax
19888                                           !BCC_EOS
19889                                           ! 3166             } else {
19890 5B02           EB           05            jmp .430
19891                       00005B04            .419:
19892                                           ! 3167               goto int15_unimplemented;
19893 5B04           83C4                   00  add	sp,#..FFF4-..FFF5
19894 5B07           EB           6B            jmp .FFF4
19895                                           !BCC_EOS
19896                                           ! 3168             }
19897                                           ! 3169             break;
19898                       00005B09            .430:
19899 5B09           EB           67            jmp .415
19900                                           !BCC_EOS
19901                                           ! 3170         case 0x01:
19902                                           ! 3171           FLAGS &= 0xfffe;
19903                       00005B0B            .431:
19904                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
19905 5B0B           8B46         28            mov	ax,$28[bp]
19906 5B0E           24                     FE  and	al,#$FE
19907 5B10           8946         28            mov	$28[bp],ax
19908                                           !BCC_EOS
19909                                           ! 3172           regs.u.r8.cl = inb_cmos(0x30);
19910                                           ! Debug: list int = const $30 (used reg = )
19911 5B13           B8                   0030  mov	ax,*$30
19912 5B16           50                         push	ax
19913                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19914 5B17           E8         AA6D            call	_inb_cmos
19915 5B1A           44                         inc	sp
19916 5B1B           44                         inc	sp
19917                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
19918 5B1C           8846         1C            mov	$1C[bp],al
19919                                           !BCC_EOS
19920                                           ! 3173           regs.u
19921                                           ! 3173 .r8.ch = inb_cmos(0x31);
19922                                           ! Debug: list int = const $31 (used reg = )
19923 5B1F           B8                   0031  mov	ax,*$31
19924 5B22           50                         push	ax
19925                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19926 5B23           E8         AA61            call	_inb_cmos
19927 5B26           44                         inc	sp
19928 5B27           44                         inc	sp
19929                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
19930 5B28           8846         1D            mov	$1D[bp],al
19931                                           !BCC_EOS
19932                                           ! 3174           if(regs.u.r16.cx > 0x3c00)
19933                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
19934 5B2B           8B46         1C            mov	ax,$1C[bp]
19935 5B2E           3D                   3C00  cmp	ax,#$3C00
19936 5B31           76           06            jbe 	.432
19937                       00005B33            .433:
19938                                           ! 3175           {
19939                                           ! 3176             regs.u.r16.cx = 0x3c00;
19940                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
19941 5B33           B8                   3C00  mov	ax,#$3C00
19942 5B36           8946         1C            mov	$1C[bp],ax
19943                                           !BCC_EOS
19944                                           ! 3177           }
19945                                           ! 3178           regs.u.r8.dl = inb_cmos(0x34);
19946                       00005B39            .432:
19947                                           ! Debug: list int = const $34 (used reg = )
19948 5B39           B8                   0034  mov	ax,*$34
19949 5B3C           50                         push	ax
19950                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19951 5B3D           E8         AA47            call	_inb_cmos
19952 5B40           44                         inc	sp
19953 5B41           44                         inc	sp
19954                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
19955 5B42           8846         18            mov	$18[bp],al
19956                                           !BCC_EOS
19957                                           ! 3179           regs.u.r8.dh = inb_cmos(0x35);
19958                                           ! Debug: list int = const $35 (used reg = )
19959 5B45           B8                   0035  mov	ax,*$35
19960 5B48           50                         push	ax
19961                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19962 5B49           E8         AA3B            call	_inb_cmos
19963 5B4C           44                         inc	sp
19964 5B4D           44                         inc	sp
19965                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
19966 5B4E           8846         19            mov	$19[bp],al
19967                                           !BCC_EOS
19968                                           ! 3180           regs.u.r16.ax = regs.u.r16.cx;
19969                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
19970 5B51           8B46         1C            mov	ax,$1C[bp]
19971 5B54           8946         20            mov	$20[bp],ax
19972                                           !BCC_EOS
19973                                           ! 3181           regs.u.r16.bx = regs.u.r16.dx;
19974                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
19975 5B57           8B46         18            mov	ax,$18[bp]
19976 5B5A           8946         14            mov	$14[bp],ax
19977                                           !BCC_EOS
19978                                           ! 3182           break;
19979 5B5D           EB           13            jmp .415
19980                                           !BCC_EOS
19981                                           ! 3183         default:
19982                                           ! 3184           goto int15_unimplemented;
19983                       00005B5F            .434:
19984 5B5F           83C4                   00  add	sp,#..FFF4-..FFF5
19985 5B62           EB           10            jmp .FFF4
19986                                           !BCC_EOS
19987                                           ! 3185        }
19988                                           ! 3186        break;
19989 5B64           EB           0C            jmp .415
19990                       00005B66            .417:
19991 5B66           2C                     01  sub	al,*1
19992 5B68           74           A1            je 	.431
19993 5B6A           2C                     1F  sub	al,*$1F
19994 5B6C         0F84         FBBA            beq 	.418
19995 5B70           EB           ED            jmp	.434
19996                       00005B72            .415:
19997 5B72           EB           33            jmp .410
19998                                           !BCC_EOS
19999                                           ! 3187     int15_unimplemented:
20000                       00005B74            .FFF4:
20001                                           ! 3188     default:
20002                                           ! 3189       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
20003                       00005B74            .435:
20004                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
20005 5B74           FF76         14            push	$14[bp]
20006                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
20007 5B77           FF76         20            push	$20[bp]
20008                                           ! Debug: list * char = .436+0 (used reg = )
20009 5B7A           BB                   D3B8  mov	bx,#.436
20010 5B7D           53                         push	bx
20011                                           ! Debug: list int = const 4 (used reg = )
20012 5B7E           B8                   0004  mov	ax,*4
20013 5B81           50                         push	ax
20014                                           ! Debug: func () void = bios_printf+0 (used reg = )
20015 5B82           E8         AE22            call	_bios_printf
20016 5B85           83C4                   08  add	sp,*8
20017                                           !BCC_EOS
20018                                           ! 3190       FLAGS |= 0x0001;
20019                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
20020 5B88           8B46         28            mov	ax,$28[bp]
20021 5B8B           0C                     01  or	al,*1
20022 5B8D           8946         28            mov	$28[bp],ax
20023                                           !BCC_EOS
20024                                           ! 3191       regs.u.r8.ah = 0x86;
20025                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
20026 5B90           B0                     86  mov	al,#$86
20027 5B92           8846         21            mov	$21[bp],al
20028                                           !BCC_EOS
20029                                           ! 3192       break;
20030 5B95           EB           10            jmp .410
20031                                           !BCC_EOS
20032                                           ! 3193     }
20033                                           ! 3194 }
20034 5B97           EB           0E            jmp .410
20035                       00005B99            .412:
20036 5B99           2C                     86  sub	al,#$86
20037 5B9B         0F84         FB3F            beq 	.413
20038 5B9F           2C                     62  sub	al,*$62
20039 5BA1         0F84         FB7F            beq 	.414
20040 5BA5           EB           CD            jmp	.435
20041                       00005BA7            .410:
20042                       FFFFFFF0            ..FFF5	=	-$10
20043                       FFFFFFF0            ..FFF4	=	-$10
20044 5BA7           89EC                       mov	sp,bp
20045 5BA9           5D                         pop	bp
20046 5BAA           C3                         ret
20047                                           ! 3195   void
20048                                           ! Register BX used in function int15_function32
20049                                           ! 3196 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
20050                                           ! 3197   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
20051                                           export	_int16_function
20052                       00005BAB            _int16_function:
20053                                           !BCC_EOS
20054                                           ! 3198 {
20055                                           ! 3199   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
20056                                           !BCC_EOS
20057                                           ! 3200   Bit16u kbd_code, max;
20058                                           !BCC_EOS
20059                                           ! 3201   ;
20060 5BAB           55                         push	bp
20061 5BAC           89E5                       mov	bp,sp
20062 5BAE           83C4                   F6  add	sp,*-$A
20063                                           !BCC_EOS
20064                                           ! 3202   shift_flags = read_byte(0x0040, 0x17);
20065                                           ! Debug: list int = const $17 (used reg = )
20066 5BB1           B8                   0017  mov	ax,*$17
20067 5BB4           50                         push	ax
20068                                           ! Debug: list int = const $40 (used reg = )
20069 5BB5           B8                   0040  mov	ax,*$40
20070 5BB8           50                         push	ax
20071                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20072 5BB9           E8         AA3C            call	_read_byte
20073 5BBC           83C4                   04  add	sp,*4
20074                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20075 5BBF           8846         FD            mov	-3[bp],al
20076                                           !BCC_EOS
20077                                           ! 3203   led_flags = read_byte(0x0040, 0x97);
20078                                           ! Debug: list int = const $97 (used reg = )
20079 5BC2           B8                   0097  mov	ax,#$97
20080 5BC5           50                         push	ax
20081                                           ! Debug: list int = const $40 (used reg = )
20082 5BC6           B8                   0040  mov	ax,*$40
20083 5BC9           50                         push	ax
20084                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20085 5BCA           E8         AA2B            call	_read_byte
20086 5BCD           83C4                   04  add	sp,*4
20087                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
20088 5BD0           8846         FC            mov	-4[bp],al
20089                                           !BCC_EOS
20090                                           ! 3204   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
20091                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
20092 5BD3           8A46         FC            mov	al,-4[bp]
20093 5BD6           24                     07  and	al,*7
20094 5BD8           50                         push	ax
20095                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
20096 5BD9           8A46         FD            mov	al,-3[bp]
20097 5BDC           30E4                       xor	ah,ah
20098 5BDE           B1                     04  mov	cl,*4
20099 5BE0           D3E8                       shr	ax,cl
20100                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
20101 5BE2           24                     07  and	al,*7
20102                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20103 5BE4           3246         F4            xor	al,-$C[bp]
20104 5BE7           44                         inc	sp
20105 5BE8           44                         inc	sp
20106                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
20107 5BE9           84C0                       test	al,al
20108 5BEB         0F84         00A3            beq 	.437
20109                       00005BEF            .438:
20110                                           ! 3205 #asm
20111                                           !BCC_EOS
20112                                           !BCC_ASM
20113                       00000012            _int16_function.BP	set	$12
20114                       00000008            .int16_function.BP	set	8
20115                       00000005            _int16_function.count	set	5
20116                       FFFFFFFB            .int16_function.count	set	-5
20117                       0000001A            _int16_function.CX	set	$1A
20118                       00000010            .int16_function.CX	set	$10
20119                       00000008            _int16_function.ascii_code	set	8
20120                       FFFFFFFE            .int16_function.ascii_code	set	-2
20121                       0000000E            _int16_function.DI	set	$E
20122                       00000004            .int16_function.DI	set	4
20123                       0000001E            _int16_function.FLAGS	set	$1E
20124                       00000014            .int16_function.FLAGS	set	$14
20125                       00000002            _int16_function.kbd_code	set	2
20126                       FFFFFFF8            .int16_function.kbd_code	set	-8
20127                       00000009            _int16_function.scan_code	set	9
20128                       FFFFFFFF            .int16_function.scan_code	set	-1
20129                       00000018            _int16_function.DX	set	$18
20130                       0000000E            .int16_function.DX	set	$E
20131                       00000006            _int16_function.led_flags	set	6
20132                       FFFFFFFC            .int16_function.led_flags	set	-4
20133                       00000010            _int16_function.SI	set	$10
20134                       00000006            .int16_function.SI	set	6
20135                       0000001C            _int16_function.AX	set	$1C
20136                       00000012            .int16_function.AX	set	$12
20137                       00000014            _int16_function.SP	set	$14
20138                       0000000A            .int16_function.SP	set	$A
20139                       00000016            _int16_function.BX	set	$16
20140                       0000000C            .int16_function.BX	set	$C
20141                       00000007            _int16_function.shift_flags	set	7
20142                       FFFFFFFD            .int16_function.shift_flags	set	-3
20143                       00000000            _int16_function.max	set	0
20144                       FFFFFFF6            .int16_function.max	set	-$A
20145 5BEF           FA                             cli
20146                                           ! 3207 endasm
20147                                           !BCC_ENDASM
20148                                           !BCC_EOS
20149                                           ! 3208     outb(0x60, 0xed);
20150                                           ! Debug: list int = const $ED (used reg = )
20151 5BF0           B8                   00ED  mov	ax,#$ED
20152 5BF3           50                         push	ax
20153                                           ! Debug: list int = const $60 (used reg = )
20154 5BF4           B8                   0060  mov	ax,*$60
20155 5BF7           50                         push	ax
20156                                           ! Debug: func () void = outb+0 (used reg = )
20157 5BF8           E8         A95D            call	_outb
20158 5BFB           83C4                   04  add	sp,*4
20159                                           !BCC_EOS
20160                                           ! 3209     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
20161 5BFE           EB           0E            jmp .43A
20162                       00005C00            .43B:
20163                                           ! Debug: list int = const $21 (used reg = )
20164 5C00           B8                   0021  mov	ax,*$21
20165 5C03           50                         push	ax
20166                                           ! Debug: list int = const $80 (used reg = )
20167 5C04           B8                   0080  mov	ax,#$80
20168 5C07           50                         push	ax
20169                                           ! Debug: func () void = outb+0 (used reg = )
20170 5C08           E8         A94D            call	_outb
20171 5C0B           83C4                   04  add	sp,*4
20172                                           !BCC_EOS
20173                                           ! 3210     if ((inb(0x60) == 0xfa)) {
20174                       00005C0E            .43A:
20175                                           ! Debug: list int = const $64 (used reg = )
20176 5C0E           B8                   0064  mov	ax,*$64
20177 5C11           50                         push	ax
20178                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20179 5C12           E8         A92D            call	_inb
20180 5C15           44                         inc	sp
20181 5C16           44                         inc	sp
20182                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20183 5C17           24                     01  and	al,*1
20184                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20185 5C19           84C0                       test	al,al
20186 5C1B           74           E3            je 	.43B
20187                       00005C1D            .43C:
20188                       00005C1D            .439:
20189                                           ! Debug: list int = const $60 (used reg = )
20190 5C1D           B8                   0060  mov	ax,*$60
20191 5C20           50                         push	ax
20192                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20193 5C21           E8         A91E            call	_inb
20194 5C24           44                         inc	sp
20195 5C25           44                         inc	sp
20196                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20197 5C26           3C                     FA  cmp	al,#$FA
20198 5C28           75           67            jne 	.43D
20199                       00005C2A            .43E:
20200                                           ! 3211       led_flags &= 0xf8;
20201                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
20202 5C2A           8A46         FC            mov	al,-4[bp]
20203 5C2D           24                     F8  and	al,#$F8
20204 5C2F           8846         FC            mov	-4[bp],al
20205                                           !BCC_EOS
20206                                           ! 3212       led_flags |= ((shift_flags >> 4) & 0x07);
20207                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
20208 5C32           8A46         FD            mov	al,-3[bp]
20209 5C35           30E4                       xor	ah,ah
20210 5C37           B1                     04  mov	cl,*4
20211 5C39           D3E8                       shr	ax,cl
20212                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
20213 5C3B           24                     07  and	al,*7
20214                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
20215 5C3D           0A46         FC            or	al,-4[bp]
20216 5C40           8846         FC            mov	-4[bp],al
20217                                           !BCC_EOS
20218                                           ! 3213       outb(0x60, led_flags & 0x07);
20219                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
20220 5C43           8A46         FC            mov	al,-4[bp]
20221 5C46           24                     07  and	al,*7
20222                                           ! Debug: list unsigned char = al+0 (used reg = )
20223 5C48           30E4                       xor	ah,ah
20224 5C4A           50                         push	ax
20225                                           ! Debug: list int = const $60 (used reg = )
20226 5C4B           B8                   0060  mov	ax,*$60
20227 5C4E           50                         push	ax
20228                                           ! Debug: func () void = outb+0 (used reg = )
20229 5C4F           E8         A906            call	_outb
20230 5C52           83C4                   04  add	sp,*4
20231                                           !BCC_EOS
20232                                           ! 3214       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
20233 5C55           EB           0E            jmp .440
20234                       00005C57            .441:
20235                                           ! Debug: list int = const $21 (used reg = )
20236 5C57           B8                   0021  mov	ax,*$21
20237 5C5A           50                         push	ax
20238                                           ! Debug: list int = const $80 (used reg = )
20239 5C5B           B8                   0080  mov	ax,#$80
20240 5C5E           50                         push	ax
20241                                           ! Debug: func () void = outb+0 (used reg = )
20242 5C5F           E8         A8F6            call	_outb
20243 5C62           83C4                   04  add	sp,*4
20244                                           !BCC_EOS
20245                                           ! 3215       inb(0x60);
20246                       00005C65            .440:
20247                                           ! Debug: list int = const $64 (used reg = )
20248 5C65           B8                   0064  mov	ax,*$64
20249 5C68           50                         push	ax
20250                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20251 5C69           E8         A8D6            call	_inb
20252 5C6C           44                         inc	sp
20253 5C6D           44                         inc	sp
20254                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20255 5C6E           24                     01  and	al,*1
20256                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20257 5C70           84C0                       test	al,al
20258 5C72           74           E3            je 	.441
20259                       00005C74            .442:
20260                       00005C74            .43F:
20261                                           ! Debug: list int = const $60 (used reg = )
20262 5C74           B8                   0060  mov	ax,*$60
20263 5C77           50                         push	ax
20264                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20265 5C78           E8         A8C7            call	_inb
20266 5C7B           44                         inc	sp
20267 5C7C           44                         inc	sp
20268                                           !BCC_EOS
20269                                           ! 3216       write_byte(0x0040, 0x97, led_flags);
20270                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
20271 5C7D           8A46         FC            mov	al,-4[bp]
20272 5C80           30E4                       xor	ah,ah
20273 5C82           50                         push	ax
20274                                           ! Debug: list int = const $97 (used reg = )
20275 5C83           B8                   0097  mov	ax,#$97
20276 5C86           50                         push	ax
20277                                           ! Debug: list int = const $40 (used reg = )
20278 5C87           B8                   0040  mov	ax,*$40
20279 5C8A           50                         push	ax
20280                                           ! Debug: func () void = write_byte+0 (used reg = )
20281 5C8B           E8         A990            call	_write_byte
20282 5C8E           83C4                   06  add	sp,*6
20283                                           !BCC_EOS
20284                                           ! 3217     }
20285                                           ! 3218 #asm
20286                       00005C91            .43D:
20287                                           !BCC_EOS
20288                                           !BCC_ASM
20289                       00000012            _int16_function.BP	set	$12
20290                       00000008            .int16_function.BP	set	8
20291                       00000005            _int16_function.count	set	5
20292                       FFFFFFFB            .int16_function.count	set	-5
20293                       0000001A            _int16_function.CX	set	$1A
20294                       00000010            .int16_function.CX	set	$10
20295                       00000008            _int16_function.ascii_code	set	8
20296                       FFFFFFFE            .int16_function.ascii_code	set	-2
20297                       0000000E            _int16_function.DI	set	$E
20298                       00000004            .int16_function.DI	set	4
20299                       0000001E            _int16_function.FLAGS	set	$1E
20300                       00000014            .int16_function.FLAGS	set	$14
20301                       00000002            _int16_function.kbd_code	set	2
20302                       FFFFFFF8            .int16_function.kbd_code	set	-8
20303                       00000009            _int16_function.scan_code	set	9
20304                       FFFFFFFF            .int16_function.scan_code	set	-1
20305                       00000018            _int16_function.DX	set	$18
20306                       0000000E            .int16_function.DX	set	$E
20307                       00000006            _int16_function.led_flags	set	6
20308                       FFFFFFFC            .int16_function.led_flags	set	-4
20309                       00000010            _int16_function.SI	set	$10
20310                       00000006            .int16_function.SI	set	6
20311                       0000001C            _int16_function.AX	set	$1C
20312                       00000012            .int16_function.AX	set	$12
20313                       00000014            _int16_function.SP	set	$14
20314                       0000000A            .int16_function.SP	set	$A
20315                       00000016            _int16_function.BX	set	$16
20316                       0000000C            .int16_function.BX	set	$C
20317                       00000007            _int16_function.shift_flags	set	7
20318                       FFFFFFFD            .int16_function.shift_flags	set	-3
20319                       00000000            _int16_function.max	set	0
20320                       FFFFFFF6            .int16_function.max	set	-$A
20321 5C91           FB                             sti
20322                                           ! 3220 endasm
20323                                           !BCC_ENDASM
20324                                           !BCC_EOS
20325                                           ! 3221   }
20326                                           ! 3222   switch (( AX >> 8 )) {
20327                       00005C92            .437:
20328                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
20329 5C92           8B46         12            mov	ax,$12[bp]
20330 5C95           88E0                       mov	al,ah
20331 5C97           30E4                       xor	ah,ah
20332 5C99           E9         0303            br 	.445
20333                                           ! 3223     case 0x00:
20334                                           ! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20335                       00005C9C            .446:
20336                                           ! Debug: list int = const 1 (used reg = )
20337 5C9C           B8                   0001  mov	ax,*1
20338 5C9F           50                         push	ax
20339                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20340 5CA0           8D5E         FE            lea	bx,-2[bp]
20341 5CA3           53                         push	bx
20342                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20343 5CA4           8D5E         FF            lea	bx,-1[bp]
20344 5CA7           53                         push	bx
20345                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20346 5CA8           E8         0342            call	_dequeue_key
20347 5CAB           83C4                   06  add	sp,*6
20348 5CAE           85C0                       test	ax,ax
20349 5CB0           75           0E            jne 	.447
20350                       00005CB2            .448:
20351                                           ! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20352                                           ! Debug: list * char = .449+0 (used reg = )
20353 5CB2           BB                   D394  mov	bx,#.449
20354 5CB5           53                         push	bx
20355                                           ! Debug: list int = const 7 (used reg = )
20356 5CB6           B8                   0007  mov	ax,*7
20357 5CB9           50                         push	ax
20358                                           ! Debug: func () void = bios_printf+0 (used reg = )
20359 5CBA           E8         ACEA            call	_bios_printf
20360 5CBD           83C4                   04  add	sp,*4
20361                                           !BCC_EOS
20362                                           ! 3226       }
20363                                           ! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20364                       00005CC0            .447:
20365                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20366 5CC0           8A46         FF            mov	al,-1[bp]
20367 5CC3           84C0                       test	al,al
20368 5CC5           74           0E            je  	.44A
20369                       00005CC7            .44C:
20370                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20371 5CC7           8A46         FE            mov	al,-2[bp]
20372 5CCA           3C                     F0  cmp	al,#$F0
20373 5CCC           75           07            jne 	.44A
20374                       00005CCE            .44B:
20375                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20376 5CCE           30C0                       xor	al,al
20377 5CD0           8846         FE            mov	-2[bp],al
20378                                           !BCC_EOS
20379                                           ! 3228       else if (ascii_code == 0xE0) ascii_code = 0;
20380 5CD3           EB           0C            jmp .44D
20381                       00005CD5            .44A:
20382                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20383 5CD5           8A46         FE            mov	al,-2[bp]
20384 5CD8           3C                     E0  cmp	al,#$E0
20385 5CDA           75           05            jne 	.44E
20386                       00005CDC            .44F:
20387                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20388 5CDC           30C0                       xor	al,al
20389 5CDE           8846         FE            mov	-2[bp],al
20390                                           !BCC_EOS
20391                                           ! 3229       AX = (scan_code << 8) | ascii_code;
20392                       00005CE1            .44E:
20393                       00005CE1            .44D:
20394                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20395 5CE1           8A46         FF            mov	al,-1[bp]
20396 5CE4           30E4                       xor	ah,ah
20397 5CE6           88C4                       mov	ah,al
20398 5CE8           30C0                       xor	al,al
20399                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20400 5CEA           0A46         FE            or	al,-2[bp]
20401                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20402 5CED           8946         12            mov	$12[bp],ax
20403                                           !BCC_EOS
20404                                           ! 3230       break;
20405 5CF0           E9         02F6            br 	.443
20406                                           !BCC_EOS
20407                                           ! 3231     case 0x01:
20408                                           ! 3232       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20409                       00005CF3            .450:
20410                                           ! Debug: list int = const 0 (used reg = )
20411 5CF3           31C0                       xor	ax,ax
20412 5CF5           50                         push	ax
20413                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20414 5CF6           8D5E         FE            lea	bx,-2[bp]
20415 5CF9           53                         push	bx
20416                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20417 5CFA           8D5E         FF            lea	bx,-1[bp]
20418 5CFD           53                         push	bx
20419                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20420 5CFE           E8         02EC            call	_dequeue_key
20421 5D01           83C4                   06  add	sp,*6
20422 5D04           85C0                       test	ax,ax
20423 5D06           75           0C            jne 	.451
20424                       00005D08            .452:
20425                                           ! 3233         FLAGS |= 0x0040;
20426                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20427 5D08           8B46         14            mov	ax,$14[bp]
20428 5D0B           0C                     40  or	al,*$40
20429 5D0D           8946         14            mov	$14[bp],ax
20430                                           !BCC_EOS
20431                                           ! 3234         return;
20432 5D10           89EC                       mov	sp,bp
20433 5D12           5D                         pop	bp
20434 5D13           C3                         ret
20435                                           !BCC_EOS
20436                                           ! 3235       }
20437                                           ! 3236       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20438                       00005D14            .451:
20439                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20440 5D14           8A46         FF            mov	al,-1[bp]
20441 5D17           84C0                       test	al,al
20442 5D19           74           0E            je  	.453
20443                       00005D1B            .455:
20444                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20445 5D1B           8A46         FE            mov	al,-2[bp]
20446 5D1E           3C                     F0  cmp	al,#$F0
20447 5D20           75           07            jne 	.453
20448                       00005D22            .454:
20449                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20450 5D22           30C0                       xor	al,al
20451 5D24           8846         FE            mov	-2[bp],al
20452                                           !BCC_EOS
20453                                           ! 3237       else if (ascii_code == 0xE0) ascii_code = 0;
20454 5D27           EB           0C            jmp .456
20455                       00005D29            .453:
20456                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20457 5D29           8A46         FE            mov	al,-2[bp]
20458 5D2C           3C                     E0  cmp	al,#$E0
20459 5D2E           75           05            jne 	.457
20460                       00005D30            .458:
20461                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20462 5D30           30C0                       xor	al,al
20463 5D32           8846         FE            mov	-2[bp],al
20464                                           !BCC_EOS
20465                                           ! 3238       AX = (scan_code << 8) | ascii_code;
20466                       00005D35            .457:
20467                       00005D35            .456:
20468                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20469 5D35           8A46         FF            mov	al,-1[bp]
20470 5D38           30E4                       xor	ah,ah
20471 5D3A           88C4                       mov	ah,al
20472 5D3C           30C0                       xor	al,al
20473                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20474 5D3E           0A46         FE            or	al,-2[bp]
20475                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20476 5D41           8946         12            mov	$12[bp],ax
20477                                           !BCC_EOS
20478                                           ! 3239       FLAGS &= 0xffbf;
20479                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20480 5D44           8B46         14            mov	ax,$14[bp]
20481 5D47           24                     BF  and	al,#$BF
20482 5D49           8946         14            mov	$14[bp],ax
20483                                           !BCC_EOS
20484                                           ! 3240       break;
20485 5D4C           E9         029A            br 	.443
20486                                           !BCC_EOS
20487                                           ! 3241     case 0x02:
20488                                           ! 3242       shift_flags = 
20489                       00005D4F            .459:
20490                                           ! 3242 read_byte(0x0040, 0x17);
20491                                           ! Debug: list int = const $17 (used reg = )
20492 5D4F           B8                   0017  mov	ax,*$17
20493 5D52           50                         push	ax
20494                                           ! Debug: list int = const $40 (used reg = )
20495 5D53           B8                   0040  mov	ax,*$40
20496 5D56           50                         push	ax
20497                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20498 5D57           E8         A89E            call	_read_byte
20499 5D5A           83C4                   04  add	sp,*4
20500                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20501 5D5D           8846         FD            mov	-3[bp],al
20502                                           !BCC_EOS
20503                                           ! 3243       AX = ((AX & 0xff00) | (shift_flags));
20504                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20505 5D60           8B46         12            mov	ax,$12[bp]
20506 5D63           30C0                       xor	al,al
20507                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20508 5D65           0A46         FD            or	al,-3[bp]
20509                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20510 5D68           8946         12            mov	$12[bp],ax
20511                                           !BCC_EOS
20512                                           ! 3244       break;
20513 5D6B           E9         027B            br 	.443
20514                                           !BCC_EOS
20515                                           ! 3245     case 0x05:
20516                                           ! 3246       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
20517                       00005D6E            .45A:
20518                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
20519 5D6E           8A46         10            mov	al,$10[bp]
20520                                           ! Debug: list unsigned char = al+0 (used reg = )
20521 5D71           30E4                       xor	ah,ah
20522 5D73           50                         push	ax
20523                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
20524 5D74           8B46         10            mov	ax,$10[bp]
20525 5D77           88E0                       mov	al,ah
20526 5D79           30E4                       xor	ah,ah
20527                                           ! Debug: list unsigned int = ax+0 (used reg = )
20528 5D7B           50                         push	ax
20529                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20530 5D7C           E8         0C0A            call	_enqueue_key
20531 5D7F           83C4                   04  add	sp,*4
20532 5D82           85C0                       test	ax,ax
20533 5D84           75           0C            jne 	.45B
20534                       00005D86            .45C:
20535                                           ! 3247         AX = ((AX & 0xff00) | (1));
20536                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20537 5D86           8B46         12            mov	ax,$12[bp]
20538 5D89           30C0                       xor	al,al
20539                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
20540 5D8B           0C                     01  or	al,*1
20541                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20542 5D8D           8946         12            mov	$12[bp],ax
20543                                           !BCC_EOS
20544                                           ! 3248       }
20545                                           ! 3249       else {
20546 5D90           EB           0A            jmp .45D
20547                       00005D92            .45B:
20548                                           ! 3250         AX = ((AX & 0xff00) | (0));
20549                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20550 5D92           8B46         12            mov	ax,$12[bp]
20551 5D95           30C0                       xor	al,al
20552                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
20553 5D97           0C                     00  or	al,*0
20554                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20555 5D99           8946         12            mov	$12[bp],ax
20556                                           !BCC_EOS
20557                                           ! 3251       }
20558                                           ! 3252       break;
20559                       00005D9C            .45D:
20560 5D9C           E9         024A            br 	.443
20561                                           !BCC_EOS
20562                                           ! 3253     case 0x09:
20563                                           ! 3254       AX = ((AX & 0xff00) | (0x30));
20564                       00005D9F            .45E:
20565                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20566 5D9F           8B46         12            mov	ax,$12[bp]
20567 5DA2           30C0                       xor	al,al
20568                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
20569 5DA4           0C                     30  or	al,*$30
20570                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20571 5DA6           8946         12            mov	$12[bp],ax
20572                                           !BCC_EOS
20573                                           ! 3255       break;
20574 5DA9           E9         023D            br 	.443
20575                                           !BCC_EOS
20576                                           ! 3256     case 0x0A:
20577                                           ! 3257       count = 2;
20578                       00005DAC            .45F:
20579                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
20580 5DAC           B0                     02  mov	al,*2
20581 5DAE           8846         FB            mov	-5[bp],al
20582                                           !BCC_EOS
20583                                           ! 3258       kbd_code = 0x0;
20584                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20585 5DB1           31C0                       xor	ax,ax
20586 5DB3           8946         F8            mov	-8[bp],ax
20587                                           !BCC_EOS
20588                                           ! 3259       outb(0x60, 0xf2);
20589                                           ! Debug: list int = const $F2 (used reg = )
20590 5DB6           B8                   00F2  mov	ax,#$F2
20591 5DB9           50                         push	ax
20592                                           ! Debug: list int = const $60 (used reg = )
20593 5DBA           B8                   0060  mov	ax,*$60
20594 5DBD           50                         push	ax
20595                                           ! Debug: func () void = outb+0 (used reg = )
20596 5DBE           E8         A797            call	_outb
20597 5DC1           83C4                   04  add	sp,*4
20598                                           !BCC_EOS
20599                                           ! 3260       max=0xffff;
20600                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20601 5DC4           B8                   FFFF  mov	ax,#$FFFF
20602 5DC7           8946         F6            mov	-$A[bp],ax
20603                                           !BCC_EOS
20604                                           ! 3261       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20605 5DCA           EB           0D            jmp .461
20606                       00005DCC            .462:
20607                                           ! Debug: list int = const 0 (used reg = )
20608 5DCC           31C0                       xor	ax,ax
20609 5DCE           50                         push	ax
20610                                           ! Debug: list int = const $80 (used reg = )
20611 5DCF           B8                   0080  mov	ax,#$80
20612 5DD2           50                         push	ax
20613                                           ! Debug: func () void = outb+0 (used reg = )
20614 5DD3           E8         A782            call	_outb
20615 5DD6           83C4                   04  add	sp,*4
20616                                           !BCC_EOS
20617                                           ! 3262       if (max>0x0) {
20618                       00005DD9            .461:
20619                                           ! Debug: list int = const $64 (used reg = )
20620 5DD9           B8                   0064  mov	ax,*$64
20621 5DDC           50                         push	ax
20622                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20623 5DDD           E8         A762            call	_inb
20624 5DE0           44                         inc	sp
20625 5DE1           44                         inc	sp
20626                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20627 5DE2           24                     01  and	al,*1
20628                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20629 5DE4           84C0                       test	al,al
20630 5DE6           75           0B            jne 	.463
20631                       00005DE8            .464:
20632                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20633 5DE8           8B46         F6            mov	ax,-$A[bp]
20634 5DEB           48                         dec	ax
20635 5DEC           8946         F6            mov	-$A[bp],ax
20636                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20637 5DEF           85C0                       test	ax,ax
20638 5DF1           75           D9            jne	.462
20639                       00005DF3            .463:
20640                       00005DF3            .460:
20641                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20642 5DF3           8B46         F6            mov	ax,-$A[bp]
20643 5DF6           85C0                       test	ax,ax
20644 5DF8           74           6D            je  	.465
20645                       00005DFA            .466:
20646                                           ! 3263         if ((inb(0x60) == 0xfa)) {
20647                                           ! Debug: list int = const $60 (used reg = )
20648 5DFA           B8                   0060  mov	ax,*$60
20649 5DFD           50                         push	ax
20650                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20651 5DFE           E8         A741            call	_inb
20652 5E01           44                         inc	sp
20653 5E02           44                         inc	sp
20654                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20655 5E03           3C                     FA  cmp	al,#$FA
20656 5E05           75           60            jne 	.467
20657                       00005E07            .468:
20658                                           ! 3264           do {
20659                       00005E07            .46B:
20660                                           ! 3265             max=0xffff;
20661                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20662 5E07           B8                   FFFF  mov	ax,#$FFFF
20663 5E0A           8946         F6            mov	-$A[bp],ax
20664                                           !BCC_EOS
20665                                           ! 3266             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20666 5E0D           EB           0D            jmp .46D
20667                       00005E0F            .46E:
20668                                           ! Debug: list int = const 0 (used reg = )
20669 5E0F           31C0                       xor	ax,ax
20670 5E11           50                         push	ax
20671                                           ! Debug: list int = const $80 (used reg = )
20672 5E12           B8                   0080  mov	ax,#$80
20673 5E15           50                         push	ax
20674                                           ! Debug: func () void = outb+0 (used reg = )
20675 5E16           E8         A73F            call	_outb
20676 5E19           83C4                   04  add	sp,*4
20677                                           !BCC_EOS
20678                                           ! 3267             if (max>0x0) {
20679                       00005E1C            .46D:
20680                                           ! Debug: list int = const $64 (used reg = )
20681 5E1C           B8                   0064  mov	ax,*$64
20682 5E1F           50                         push	ax
20683                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20684 5E20           E8         A71F            call	_inb
20685 5E23           44                         inc	sp
20686 5E24           44                         inc	sp
20687                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20688 5E25           24                     01  and	al,*1
20689                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20690 5E27           84C0                       test	al,al
20691 5E29           75           0B            jne 	.46F
20692                       00005E2B            .470:
20693                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20694 5E2B           8B46         F6            mov	ax,-$A[bp]
20695 5E2E           48                         dec	ax
20696 5E2F           8946         F6            mov	-$A[bp],ax
20697                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20698 5E32           85C0                       test	ax,ax
20699 5E34           75           D9            jne	.46E
20700                       00005E36            .46F:
20701                       00005E36            .46C:
20702                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20703 5E36           8B46         F6            mov	ax,-$A[bp]
20704 5E39           85C0                       test	ax,ax
20705 5E3B           74           1F            je  	.471
20706                       00005E3D            .472:
20707                                           ! 3268               kbd_code >>= 8;
20708                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20709 5E3D           8B46         F8            mov	ax,-8[bp]
20710 5E40           88E0                       mov	al,ah
20711 5E42           30E4                       xor	ah,ah
20712 5E44           8946         F8            mov	-8[bp],ax
20713                                           !BCC_EOS
20714                                           ! 3269               kbd_code |= (inb(0x60) << 8);
20715                                           ! Debug: list int = const $60 (used reg = )
20716 5E47           B8                   0060  mov	ax,*$60
20717 5E4A           50                         push	ax
20718                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20719 5E4B           E8         A6F4            call	_inb
20720 5E4E           44                         inc	sp
20721 5E4F           44                         inc	sp
20722                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20723 5E50           30E4                       xor	ah,ah
20724 5E52           88C4                       mov	ah,al
20725 5E54           30C0                       xor	al,al
20726                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20727 5E56           0B46         F8            or	ax,-8[bp]
20728 5E59           8946         F8            mov	-8[bp],ax
20729                                           !BCC_EOS
20730                                           ! 3270             }
20731                                           ! 3271           } while (--count>0);
20732                       00005E5C            .471:
20733                       00005E5C            .46A:
20734                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20735 5E5C           8A46         FB            mov	al,-5[bp]
20736 5E5F           48                         dec	ax
20737 5E60           8846         FB            mov	-5[bp],al
20738                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20739 5E63           84C0                       test	al,al
20740 5E65           75           A0            jne	.46B
20741                       00005E67            .473:
20742                                           !BCC_EOS
20743                                           ! 3272         }
20744                       00005E67            .469:
20745                                           ! 3273       }
20746                       00005E67            .467:
20747                                           ! 3274       BX=kbd_code;
20748                       00005E67            .465:
20749                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20750 5E67           8B46         F8            mov	ax,-8[bp]
20751 5E6A           8946         0C            mov	$C[bp],ax
20752                                           !BCC_EOS
20753                                           ! 3275       break;
20754 5E6D           E9         0179            br 	.443
20755                                           !BCC_EOS
20756                                           ! 3276     case 0x10:
20757                                           ! 3277       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20758                       00005E70            .474:
20759                                           ! Debug: list int = const 1 (used reg = )
20760 5E70           B8                   0001  mov	ax,*1
20761 5E73           50                         push	ax
20762                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20763 5E74           8D5E         FE            lea	bx,-2[bp]
20764 5E77           53                         push	bx
20765                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20766 5E78           8D5E         FF            lea	bx,-1[bp]
20767 5E7B           53                         push	bx
20768                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20769 5E7C           E8         016E            call	_dequeue_key
20770 5E7F           83C4                   06  add	sp,*6
20771 5E82           85C0                       test	ax,ax
20772 5E84           75           0E            jne 	.475
20773                       00005E86            .476:
20774                                           ! 3278         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20775                                           ! Debug: list * char = .477+0 (used reg = )
20776 5E86           BB                   D370  mov	bx,#.477
20777 5E89           53                         push	bx
20778                                           ! Debug: list int = const 7 (used reg = )
20779 5E8A           B8                   0007  mov	ax,*7
20780 5E8D           50                         push	ax
20781                                           ! Debug: func () void = bios_printf+0 (used reg = )
20782 5E8E           E8         AB16            call	_bios_printf
20783 5E91           83C4                   04  add	sp,*4
20784                                           !BCC_EOS
20785                                           ! 3279       }
20786                                           ! 3280       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20787                       00005E94            .475:
20788                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20789 5E94           8A46         FF            mov	al,-1[bp]
20790 5E97           84C0                       test	al,al
20791 5E99           74           0C            je  	.478
20792                       00005E9B            .47A:
20793                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20794 5E9B           8A46         FE            mov	al,-2[bp]
20795 5E9E           3C                     F0  cmp	al,#$F0
20796 5EA0           75           05            jne 	.478
20797                       00005EA2            .479:
20798                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20799 5EA2           30C0                       xor	al,al
20800 5EA4           8846         FE            mov	-2[bp],al
20801                                           !BCC_EOS
20802                                           ! 3281       AX = (scan_code << 8) | ascii_code;
20803                       00005EA7            .478:
20804                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20805 5EA7           8A46         FF            mov	al,-1[bp]
20806 5EAA           30E4                       xor	ah,ah
20807 5EAC           88C4                       mov	ah,al
20808 5EAE           30C0                       xor	al,al
20809                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20810 5EB0           0A46         FE            or	al,-2[bp]
20811                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20812 5EB3           8946         12            mov	$12[bp],ax
20813                                           !BCC_EOS
20814                                           ! 3282       break;
20815 5EB6           E9         0130            br 	.443
20816                                           !BCC_EOS
20817                                           ! 3283     case 0x11:
20818                                           ! 3284       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20819                       00005EB9            .47B:
20820                                           ! Debug: list int = const 0 (used reg = )
20821 5EB9           31C0                       xor	ax,ax
20822 5EBB           50                         push	ax
20823                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20824 5EBC           8D5E         FE            lea	bx,-2[bp]
20825 5EBF           53                         push	bx
20826                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20827 5EC0           8D5E         FF            lea	bx,-1[bp]
20828 5EC3           53                         push	bx
20829                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20830 5EC4           E8         0126            call	_dequeue_key
20831 5EC7           83C4                   06  add	sp,*6
20832 5ECA           85C0                       test	ax,ax
20833 5ECC           75           0C            jne 	.47C
20834                       00005ECE            .47D:
20835                                           ! 3285         FLAGS |= 0x0040;
20836                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20837 5ECE           8B46         14            mov	ax,$14[bp]
20838 5ED1           0C                     40  or	al,*$40
20839 5ED3           8946         14            mov	$14[bp],ax
20840                                           !BCC_EOS
20841                                           ! 3286         return;
20842 5ED6           89EC                       mov	sp,bp
20843 5ED8           5D                         pop	bp
20844 5ED9           C3                         ret
20845                                           !BCC_EOS
20846                                           ! 3287       }
20847                                           ! 3288       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20848                       00005EDA            .47C:
20849                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20850 5EDA           8A46         FF            mov	al,-1[bp]
20851 5EDD           84C0                       test	al,al
20852 5EDF           74           0C            je  	.47E
20853                       00005EE1            .480:
20854                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20855 5EE1           8A46         FE            mov	al,-2[bp]
20856 5EE4           3C                     F0  cmp	al,#$F0
20857 5EE6           75           05            jne 	.47E
20858                       00005EE8            .47F:
20859                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20860 5EE8           30C0                       xor	al,al
20861 5EEA           8846         FE            mov	-2[bp],al
20862                                           !BCC_EOS
20863                                           ! 3289       AX = (scan_code << 8) | ascii_code;
20864                       00005EED            .47E:
20865                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20866 5EED           8A46         FF            mov	al,-1[bp]
20867 5EF0           30E4                       xor	ah,ah
20868 5EF2           88C4                       mov	ah,al
20869 5EF4           30C0                       xor	al,al
20870                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20871 5EF6           0A46         FE            or	al,-2[bp]
20872                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20873 5EF9           8946         12            mov	$12[bp],ax
20874                                           !BCC_EOS
20875                                           ! 3290       FLAGS &= 0xffbf;
20876                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20877 5EFC           8B46         14            mov	ax,$14[bp]
20878 5EFF           24                     BF  and	al,#$BF
20879 5F01           8946         14            mov	$14[bp],ax
20880                                           !BCC_EOS
20881                                           ! 3291       break;
20882 5F04           E9         00E2            br 	.443
20883                                           !BCC_EOS
20884                                           ! 3292     case 0x12:
20885                                           ! 3293       shift_flags = read_byte(0x0040, 0x17);
20886                       00005F07            .481:
20887                                           ! Debug: list int = const $17 (used reg = )
20888 5F07           B8                   0017  mov	ax,*$17
20889 5F0A           50                         push	ax
20890                                           ! Debug: list int = const $40 (used reg = )
20891 5F0B           B8                   0040  mov	ax,*$40
20892 5F0E           50                         push	ax
20893                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20894 5F0F           E8         A6E6            call	_read_byte
20895 5F12           83C4                   04  add	sp,*4
20896                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20897 5F15           8846         FD            mov	-3[bp],al
20898                                           !BCC_EOS
20899                                           ! 3294       AX = ((AX & 0xff00) | (shift_flags));
20900                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20901 5F18           8B46         12            mov	ax,$12[bp]
20902 5F1B           30C0                       xor	al,al
20903                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20904 5F1D           0A46         FD            or	al,-3[bp]
20905                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20906 5F20           8946         12            mov	$12[bp],ax
20907                                           !BCC_EOS
20908                                           ! 3295       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20909                                           ! Debug: list int = const $18 (used reg = )
20910 5F23           B8                   0018  mov	ax,*$18
20911 5F26           50                         push	ax
20912                                           ! Debug: list int = const $40 (used reg = )
20913 5F27           B8                   0040  mov	ax,*$40
20914 5F2A           50                         push	ax
20915                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20916 5F2B           E8         A6CA            call	_read_byte
20917 5F2E           83C4                   04  add	sp,*4
20918                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20919 5F31           24                     73  and	al,*$73
20920                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20921 5F33           8846         FD            mov	-3[bp],al
20922                                           !BCC_EOS
20923                                           ! 3296       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20924                                           ! Debug: list int = const $96 (used reg = )
20925 5F36           B8                   0096  mov	ax,#$96
20926 5F39           50                         push	ax
20927                                           ! Debug: list int = const $40 (used reg = )
20928 5F3A           B8                   0040  mov	ax,*$40
20929 5F3D           50                         push	ax
20930                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20931 5F3E           E8         A6B7            call	_read_byte
20932 5F41           83C4                   04  add	sp,*4
20933                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20934 5F44           24                     0C  and	al,*$C
20935                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20936 5F46           0A46         FD            or	al,-3[bp]
20937 5F49           8846         FD            mov	-3[bp],al
20938                                           !BCC_EOS
20939                                           ! 3297       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20940                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20941 5F4C           8A46         FD            mov	al,-3[bp]
20942 5F4F           30E4                       xor	ah,ah
20943 5F51           88C4                       mov	ah,al
20944 5F53           30C0                       xor	al,al
20945 5F55           50                         push	ax
20946                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20947 5F56           8A46         12            mov	al,$12[bp]
20948                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20949 5F59           30E4                       xor	ah,ah
20950 5F5B           0B46         F4            or	ax,0+..FFF3[bp]
20951 5F5E           44                         inc	sp
20952 5F5F           44                         inc	sp
20953                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20954 5F60           8946         12            mov	$12[bp],ax
20955                                           !BCC_EOS
20956                                           ! 3298       ;
20957                                           !BCC_EOS
20958                                           ! 3299       break;
20959 5F63           E9         0083            br 	.443
20960                                           !BCC_EOS
20961                                           ! 3300     case 0x92:
20962                                           ! 3301       AX = ((AX & 0x00ff) | ((0x80) << 8));
20963                       00005F66            .482:
20964                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20965 5F66           8A46         12            mov	al,$12[bp]
20966                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20967 5F69           30E4                       xor	ah,ah
20968 5F6B           0D                   8000  or	ax,#-$8000
20969                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20970 5F6E           8946         12            mov	$12[bp],ax
20971                                           !BCC_EOS
20972                                           ! 3302       break;
20973 5F71           EB           76            jmp .443
20974                                           !BCC_EOS
20975                                           ! 3303     case 0xA2:
20976                                           ! 3304       break;
20977                       00005F73            .483:
20978 5F73           EB           74            jmp .443
20979                                           !BCC_EOS
20980                                           ! 3305     case 0x6F:
20981                                           ! 3306       if (( AX & 0x00ff ) == 0x08)
20982                       00005F75            .484:
20983                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20984 5F75           8A46         12            mov	al,$12[bp]
20985                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20986 5F78           3C                     08  cmp	al,*8
20987 5F7A           75           0B            jne 	.485
20988                       00005F7C            .486:
20989                                           ! 3307         AX = ((AX & 0x00ff) | ((0x02) << 8));
20990                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20991 5F7C           8A46         12            mov	al,$12[bp]
20992                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
20993 5F7F           30E4                       xor	ah,ah
20994 5F81           0D                   0200  or	ax,#$200
20995                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20996 5F84           8946         12            mov	$12[bp],ax
20997                                           !BCC_EOS
20998                                           ! 3308     default:
20999                       00005F87            .485:
21000                                           ! 3309       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
21001                       00005F87            .487:
21002                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
21003 5F87           8B46         12            mov	ax,$12[bp]
21004 5F8A           88E0                       mov	al,ah
21005 5F8C           30E4                       xor	ah,ah
21006                                           ! Debug: list unsigned int = ax+0 (used reg = )
21007 5F8E           50                         push	ax
21008                                           ! Debug: list * char = .488+0 (used reg = )
21009 5F8F           BB                   D348  mov	bx,#.488
21010 5F92           53                         push	bx
21011                                           ! Debug: list int = const 4 (used reg = )
21012 5F93           B8                   0004  mov	ax,*4
21013 5F96           50                         push	ax
21014                                           ! Debug: func () void = bios_printf+0 (used reg = )
21015 5F97           E8         AA0D            call	_bios_printf
21016 5F9A           83C4                   06  add	sp,*6
21017                                           !BCC_EOS
21018                                           ! 3310   }
21019                                           ! 3311 }
21020 5F9D           EB           4A            jmp .443
21021                       00005F9F            .445:
21022 5F9F           2D                   0000  sub	ax,*0
21023 5FA2           7C           E3            jl 	.487
21024 5FA4           3D                   0012  cmp	ax,*$12
21025 5FA7           77           2F            ja  	.489
21026 5FA9           D1E0                       shl	ax,*1
21027 5FAB           89C3                       mov	bx,ax
21028 5FAD           2E                         seg	cs
21029 5FAE           FFA7       5FB2            br	.48A[bx]
21030                       00005FB2            .48A:
21031 5FB2                      5C9C            .word	.446
21032 5FB4                      5CF3            .word	.450
21033 5FB6                      5D4F            .word	.459
21034 5FB8                      5F87            .word	.487
21035 5FBA                      5F87            .word	.487
21036 5FBC                      5D6E            .word	.45A
21037 5FBE                      5F87            .word	.487
21038 5FC0                      5F87            .word	.487
21039 5FC2                      5F87            .word	.487
21040 5FC4                      5D9F            .word	.45E
21041 5FC6                      5DAC            .word	.45F
21042 5FC8                      5F87            .word	.487
21043 5FCA                      5F87            .word	.487
21044 5FCC                      5F87            .word	.487
21045 5FCE                      5F87            .word	.487
21046 5FD0                      5F87            .word	.487
21047 5FD2                      5E70            .word	.474
21048 5FD4                      5EB9            .word	.47B
21049 5FD6                      5F07            .word	.481
21050                       00005FD8            .489:
21051 5FD8           2D                   006F  sub	ax,*$6F
21052 5FDB           74           98            je 	.484
21053 5FDD           2D                   0023  sub	ax,*$23
21054 5FE0           74           84            je 	.482
21055 5FE2           2D                   0010  sub	ax,*$10
21056 5FE5           74           8C            je 	.483
21057 5FE7           EB           9E            jmp	.487
21058                       00005FE9            .443:
21059                       FFFFFFF4            ..FFF3	=	-$C
21060 5FE9           89EC                       mov	sp,bp
21061 5FEB           5D                         pop	bp
21062 5FEC           C3                         ret
21063                                           ! 3312   unsigned int
21064                                           ! Register BX used in function int16_function
21065                                           ! 3313 dequeue_key(scan_code, ascii_code, incr)
21066                                           ! 3314   Bit8u *sca
21067                                           export	_dequeue_key
21068                       00005FED            _dequeue_key:
21069                                           ! 3314 n_code;
21070                                           !BCC_EOS
21071                                           ! 3315   Bit8u *ascii_code;
21072                                           !BCC_EOS
21073                                           ! 3316   unsigned int incr;
21074                                           !BCC_EOS
21075                                           ! 3317 {
21076                                           ! 3318   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
21077                                           !BCC_EOS
21078                                           ! 3319   Bit16u ss;
21079                                           !BCC_EOS
21080                                           ! 3320   Bit8u acode, scode;
21081                                           !BCC_EOS
21082                                           ! 3321   buffer_start = read_word(0x0040, 0x0080);
21083 5FED           55                         push	bp
21084 5FEE           89E5                       mov	bp,sp
21085 5FF0           83C4                   F4  add	sp,*-$C
21086                                           ! Debug: list int = const $80 (used reg = )
21087 5FF3           B8                   0080  mov	ax,#$80
21088 5FF6           50                         push	ax
21089                                           ! Debug: list int = const $40 (used reg = )
21090 5FF7           B8                   0040  mov	ax,*$40
21091 5FFA           50                         push	ax
21092                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21093 5FFB           E8         A60D            call	_read_word
21094 5FFE           83C4                   04  add	sp,*4
21095                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
21096 6001           8946         FE            mov	-2[bp],ax
21097                                           !BCC_EOS
21098                                           ! 3322   buffer_end = read_word(0x0040, 0x0082);
21099                                           ! Debug: list int = const $82 (used reg = )
21100 6004           B8                   0082  mov	ax,#$82
21101 6007           50                         push	ax
21102                                           ! Debug: list int = const $40 (used reg = )
21103 6008           B8                   0040  mov	ax,*$40
21104 600B           50                         push	ax
21105                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21106 600C           E8         A5FC            call	_read_word
21107 600F           83C4                   04  add	sp,*4
21108                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
21109 6012           8946         FC            mov	-4[bp],ax
21110                                           !BCC_EOS
21111                                           ! 3323   buffer_head = read_word(0x0040, 0x001a);
21112                                           ! Debug: list int = const $1A (used reg = )
21113 6015           B8                   001A  mov	ax,*$1A
21114 6018           50                         push	ax
21115                                           ! Debug: list int = const $40 (used reg = )
21116 6019           B8                   0040  mov	ax,*$40
21117 601C           50                         push	ax
21118                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21119 601D           E8         A5EB            call	_read_word
21120 6020           83C4                   04  add	sp,*4
21121                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
21122 6023           8946         FA            mov	-6[bp],ax
21123                                           !BCC_EOS
21124                                           ! 3324   buffer_tail = read_word(0x0040, 0x001c);
21125                                           ! Debug: list int = const $1C (used reg = )
21126 6026           B8                   001C  mov	ax,*$1C
21127 6029           50                         push	ax
21128                                           ! Debug: list int = const $40 (used reg = )
21129 602A           B8                   0040  mov	ax,*$40
21130 602D           50                         push	ax
21131                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21132 602E           E8         A5DA            call	_read_word
21133 6031           83C4                   04  add	sp,*4
21134                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
21135 6034           8946         F8            mov	-8[bp],ax
21136                                           !BCC_EOS
21137                                           ! 3325   if (buffer_head != buffer_tail) {
21138                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
21139 6037           8B46         FA            mov	ax,-6[bp]
21140 603A           3B46         F8            cmp	ax,-8[bp]
21141 603D         0F84         0083            beq 	.48B
21142                       00006041            .48C:
21143                                           ! 3326     ss = get_SS();
21144                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21145 6041           E8         A60D            call	_get_SS
21146                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
21147 6044           8946         F6            mov	-$A[bp],ax
21148                                           !BCC_EOS
21149                                           ! 3327     acode = read_byte(0x0040, buffer_head);
21150                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
21151 6047           FF76         FA            push	-6[bp]
21152                                           ! Debug: list int = const $40 (used reg = )
21153 604A           B8                   0040  mov	ax,*$40
21154 604D           50                         push	ax
21155                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21156 604E           E8         A5A7            call	_read_byte
21157 6051           83C4                   04  add	sp,*4
21158                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
21159 6054           8846         F5            mov	-$B[bp],al
21160                                           !BCC_EOS
21161                                           ! 3328     scode = read_byte(0x0040, buffer_head+1);
21162                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
21163 6057           8B46         FA            mov	ax,-6[bp]
21164                                           ! Debug: list unsigned int = ax+1 (used reg = )
21165 605A           40                         inc	ax
21166 605B           50                         push	ax
21167                                           ! Debug: list int = const $40 (used reg = )
21168 605C           B8                   0040  mov	ax,*$40
21169 605F           50                         push	ax
21170                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21171 6060           E8         A595            call	_read_byte
21172 6063           83C4                   04  add	sp,*4
21173                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
21174 6066           8846         F4            mov	-$C[bp],al
21175                                           !BCC_EOS
21176                                           ! 3329     write_byte(ss, ascii_code, acode);
21177                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
21178 6069           8A46         F5            mov	al,-$B[bp]
21179 606C           30E4                       xor	ah,ah
21180 606E           50                         push	ax
21181                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
21182 606F           FF76         06            push	6[bp]
21183                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
21184 6072           FF76         F6            push	-$A[bp]
21185                                           ! Debug: func () void = write_byte+0 (used reg = )
21186 6075           E8         A5A6            call	_write_byte
21187 6078           83C4                   06  add	sp,*6
21188                                           !BCC_EOS
21189                                           ! 3330     write_byte(ss, scan_code, scode);
21190                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
21191 607B           8A46         F4            mov	al,-$C[bp]
21192 607E           30E4                       xor	ah,ah
21193 6080           50                         push	ax
21194                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
21195 6081           FF76         04            push	4[bp]
21196                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
21197 6084           FF76         F6            push	-$A[bp]
21198                                           ! Debug: func () void = write_byte+0 (used reg = )
21199 6087           E8         A594            call	_write_byte
21200 608A           83C4                   06  add	sp,*6
21201                                           !BCC_EOS
21202                                           ! 3331     if (incr) {
21203 608D           8B46         08            mov	ax,8[bp]
21204 6090           85C0                       test	ax,ax
21205 6092           74           27            je  	.48D
21206                       00006094            .48E:
21207                                           ! 3332       buffer_head += 2;
21208                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
21209 6094           8B46         FA            mov	ax,-6[bp]
21210 6097           40                         inc	ax
21211 6098           40                         inc	ax
21212 6099           8946         FA            mov	-6[bp],ax
21213                                           !BCC_EOS
21214                                           ! 3333       if (buffer_head >= buffer_end)
21215                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
21216 609C           8B46         FA            mov	ax,-6[bp]
21217 609F           3B46         FC            cmp	ax,-4[bp]
21218 60A2           72           06            jb  	.48F
21219                       000060A4            .490:
21220                                           ! 3334         buffer_head = buffer_start;
21221                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
21222 60A4           8B46         FE            mov	ax,-2[bp]
21223 60A7           8946         FA            mov	-6[bp],ax
21224                                           !BCC_EOS
21225                                           ! 3335       write_word(0x0040, 0x001a, buffer_head);
21226                       000060AA            .48F:
21227                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
21228 60AA           FF76         FA            push	-6[bp]
21229                                           ! Debug: list int = const $1A (used reg = )
21230 60AD           B8                   001A  mov	ax,*$1A
21231 60B0           50                         push	ax
21232                                           ! Debug: list int = const $40 (used reg = )
21233 60B1           B8                   0040  mov	ax,*$40
21234 60B4           50                         push	ax
21235                                           ! Debug: func () void = write_word+0 (used reg = )
21236 60B5           E8         A57E            call	_write_word
21237 60B8           83C4                   06  add	sp,*6
21238                                           !BCC_EOS
21239                                           ! 3336     }
21240                                           ! 3337     return(1);
21241                       000060BB            .48D:
21242 60BB           B8                   0001  mov	ax,*1
21243 60BE           89EC                       mov	sp,bp
21244 60C0           5D                         pop	bp
21245 60C1           C3                         ret
21246                                           !BCC_EOS
21247                                           ! 3338   }
21248                                           ! 3339   else {
21249 60C2           EB           06            jmp .491
21250                       000060C4            .48B:
21251                                           ! 3340     return(0);
21252 60C4           31C0                       xor	ax,ax
21253 60C6           89EC                       mov	sp,bp
21254 60C8           5D                         pop	bp
21255 60C9           C3                         ret
21256                                           !BCC_EOS
21257                                           ! 3341   }
21258                                           ! 3342 }
21259                       000060CA            .491:
21260 60CA           89EC                       mov	sp,bp
21261 60CC           5D                         pop	bp
21262 60CD           C3                         ret
21263                                           ! 3343 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
21264                                           
21265                       000060CE            _panic_msg_keyb_buffer_full:
21266                       000060CE            .492:
21267 60CE                        25            .ascii	"%s: keyboard input buffer full"
21268 60EC                        0A            .byte	$A
21269 60ED                        00            .byte	0
21270                                           !BCC_EOS
21271                                           ! 3344   Bit8u
21272                                           ! 3345 inhibit_mouse_int_and_events()
21273                                           ! 3346 {
21274                                           
21275                                           export	_inhibit_mouse_int_and_events
21276                       000060EE            _inhibit_mouse_int_and_events:
21277                                           ! 3347   Bit8u command_byte, prev_command_byte;
21278                                           !BCC_EOS
21279                                           ! 3348   if ( inb(0x64) & 0x02 )
21280 60EE           55                         push	bp
21281 60EF           89E5                       mov	bp,sp
21282 60F1           4C                         dec	sp
21283 60F2           4C                         dec	sp
21284                                           ! Debug: list int = const $64 (used reg = )
21285 60F3           B8                   0064  mov	ax,*$64
21286 60F6           50                         push	ax
21287                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21288 60F7           E8         A448            call	_inb
21289 60FA           44                         inc	sp
21290 60FB           44                         inc	sp
21291                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21292 60FC           24                     02  and	al,*2
21293 60FE           84C0                       test	al,al
21294 6100           74           12            je  	.493
21295                       00006102            .494:
21296                                           ! 3349     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21297                                           ! Debug: list * char = .495+0 (used reg = )
21298 6102           BB                   D33D  mov	bx,#.495
21299 6105           53                         push	bx
21300                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21301 6106           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21302 6109           53                         push	bx
21303                                           ! Debug: list int = const 7 (used reg = )
21304 610A           B8                   0007  mov	ax,*7
21305 610D           50                         push	ax
21306                                           ! Debug: func () void = bios_printf+0 (used reg = )
21307 610E           E8         A896            call	_bios_printf
21308 6111           83C4                   06  add	sp,*6
21309                                           !BCC_EOS
21310                                           ! 3350   outb(0x64, 0x20);
21311                       00006114            .493:
21312                                           ! Debug: list int = const $20 (used reg = )
21313 6114           B8                   0020  mov	ax,*$20
21314 6117           50                         push	ax
21315                                           ! Debug: list int = const $64 (used reg = )
21316 6118           B8                   0064  mov	ax,*$64
21317 611B           50                         push	ax
21318                                           ! Debug: func () void = outb+0 (used reg = )
21319 611C           E8         A439            call	_outb
21320 611F           83C4                   04  add	sp,*4
21321                                           !BCC_EOS
21322                                           ! 3351   while ( (inb(0x64) & 0x01) != 0x01 );
21323 6122           EB           00            jmp .497
21324                       00006124            .498:
21325                                           !BCC_EOS
21326                                           ! 3352   prev_command_byte = inb(0x60);
21327                       00006124            .497:
21328                                           ! Debug: list int = const $64 (used reg = )
21329 6124           B8                   0064  mov	ax,*$64
21330 6127           50                         push	ax
21331                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21332 6128           E8         A417            call	_inb
21333 612B           44                         inc	sp
21334 612C           44                         inc	sp
21335                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21336 612D           24                     01  and	al,*1
21337                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21338 612F           3C                     01  cmp	al,*1
21339 6131           75           F1            jne	.498
21340                       00006133            .499:
21341                       00006133            .496:
21342                                           ! Debug: list int = const $60 (used reg = )
21343 6133           B8                   0060  mov	ax,*$60
21344 6136           50                         push	ax
21345                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21346 6137           E8         A408            call	_inb
21347 613A           44                         inc	sp
21348 613B           44                         inc	sp
21349                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
21350 613C           8846         FE            mov	-2[bp],al
21351                                           !BCC_EOS
21352                                           ! 3353   command_byte = prev_command_byte;
21353                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
21354 613F           8A46         FE            mov	al,-2[bp]
21355 6142           8846         FF            mov	-1[bp],al
21356                                           !BCC_EOS
21357                                           ! 3354   if ( inb(0x64) & 0x02 )
21358                                           ! Debug: list int = const $64 (used reg = )
21359 6145           B8                   0064  mov	ax,*$64
21360 6148           50                         push	ax
21361                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21362 6149           E8         A3F6            call	_inb
21363 614C           44                         inc	sp
21364 614D           44                         inc	sp
21365                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21366 614E           24                     02  and	al,*2
21367 6150           84C0                       test	al,al
21368 6152           74           12            je  	.49A
21369                       00006154            .49B:
21370                                           ! 3355     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21371                                           ! Debug: list * char = .49C+0 (used reg = )
21372 6154           BB                   D332  mov	bx,#.49C
21373 6157           53                         push	bx
21374                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21375 6158           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21376 615B           53                         push	bx
21377                                           ! Debug: list int = const 7 (used reg = )
21378 615C           B8                   0007  mov	ax,*7
21379 615F           50                         push	ax
21380                                           ! Debug: func () void = bios_printf+0 (used reg = )
21381 6160           E8         A844            call	_bios_printf
21382 6163           83C4                   06  add	sp,*6
21383                                           !BCC_EOS
21384                                           ! 3356   command_byte &= 0xfd;
21385                       00006166            .49A:
21386                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
21387 6166           8A46         FF            mov	al,-1[bp]
21388 6169           24                     FD  and	al,#$FD
21389 616B           8846         FF            mov	-1[bp],al
21390                                           !BCC_EOS
21391                                           ! 3357   command_byte |= 0x20;
21392                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
21393 616E           8A46         FF            mov	al,-1[bp]
21394 6171           0C                     20  or	al,*$20
21395 6173           8846         FF            mov	-1[bp],al
21396                                           !BCC_EOS
21397                                           ! 3358   outb(0x64, 0x60);
21398                                           ! Debug: list int = const $60 (used reg = )
21399 6176           B8                   0060  mov	ax,*$60
21400 6179           50                         push	ax
21401                                           ! Debug: list int = const $64 (used reg = )
21402 617A           B8                   0064  mov	ax,*$64
21403 617D           50                         push	ax
21404                                           ! Debug: func () void = outb+0 (used reg = )
21405 617E           E8         A3D7            call	_outb
21406 6181           83C4                   04  add	sp,*4
21407                                           !BCC_EOS
21408                                           ! 3359   outb(0x60, command_byte);
21409                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21410 6184           8A46         FF            mov	al,-1[bp]
21411 6187           30E4                       xor	ah,ah
21412 6189           50                         push	ax
21413                                           ! Debug: list int = const $60 (used reg = )
21414 618A           B8                   0060  mov	ax,*$60
21415 618D           50                         push	ax
21416                                           ! Debug: func () void = outb+0 (used reg = )
21417 618E           E8         A3C7            call	_outb
21418 6191           83C4                   04  add	sp,*4
21419                                           !BCC_EOS
21420                                           ! 3360   return(prev_command_byte);
21421 6194           8A46         FE            mov	al,-2[bp]
21422 6197           89EC                       mov	sp,bp
21423 6199           5D                         pop	bp
21424 619A           C3                         ret
21425                                           !BCC_EOS
21426                                           ! 3361 }
21427                                           ! 3362   void
21428                                           ! Register BX used in function inhibit_mouse_int_and_events
21429                                           ! 3363 enable_mouse_int_and_events()
21430                                           ! 3364 {
21431                                           export	_enable_mouse_int_and_events
21432                       0000619B            _enable_mouse_int_and_events:
21433                                           ! 3365   Bit8u command_byte;
21434                                           !BCC_EOS
21435                                           ! 3366   if ( inb(0x64) & 0x02 )
21436 619B           55                         push	bp
21437 619C           89E5                       mov	bp,sp
21438 619E           4C                         dec	sp
21439 619F           4C                         dec	sp
21440                                           ! Debug: list int = const $64 (used reg = )
21441 61A0           B8                   0064  mov	ax,*$64
21442 61A3           50                         push	ax
21443                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21444 61A4           E8         A39B            call	_inb
21445 61A7           44                         inc	sp
21446 61A8           44                         inc	sp
21447                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21448 61A9           24                     02  and	al,*2
21449 61AB           84C0                       test	al,al
21450 61AD           74           12            je  	.49D
21451                       000061AF            .49E:
21452                                           ! 3367     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21453                                           ! Debug: list * char = .49F+0 (used reg = )
21454 61AF           BB                   D328  mov	bx,#.49F
21455 61B2           53                         push	bx
21456                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21457 61B3           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21458 61B6           53                         push	bx
21459                                           ! Debug: list int = const 7 (used reg = )
21460 61B7           B8                   0007  mov	ax,*7
21461 61BA           50                         push	ax
21462                                           ! Debug: func () void = bios_printf+0 (used reg = )
21463 61BB           E8         A7E9            call	_bios_printf
21464 61BE           83C4                   06  add	sp,*6
21465                                           !BCC_EOS
21466                                           ! 3368   outb(0x64, 0x20);
21467                       000061C1            .49D:
21468                                           ! Debug: list int = const $20 (used reg = )
21469 61C1           B8                   0020  mov	ax,*$20
21470 61C4           50                         push	ax
21471                                           ! Debug: list int = const $64 (used reg = )
21472 61C5           B8                   0064  mov	ax,*$64
21473 61C8           50                         push	ax
21474                                           ! Debug: func () void = outb+0 (used reg = )
21475 61C9           E8         A38C            call	_outb
21476 61CC           83C4                   04  add	sp,*4
21477                                           !BCC_EOS
21478                                           ! 3369   while ( (inb(0x64) & 0x01) != 0x01 );
21479 61CF           EB           00            jmp .4A1
21480                       000061D1            .4A2:
21481                                           !BCC_EOS
21482                                           ! 3370   command_byte = inb(0x60);
21483                       000061D1            .4A1:
21484                                           ! Debug: list int = const $64 (used reg = )
21485 61D1           B8                   0064  mov	ax,*$64
21486 61D4           50                         push	ax
21487                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21488 61D5           E8         A36A            call	_inb
21489 61D8           44                         inc	sp
21490 61D9           44                         inc	sp
21491                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21492 61DA           24                     01  and	al,*1
21493                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21494 61DC           3C                     01  cmp	al,*1
21495 61DE           75           F1            jne	.4A2
21496                       000061E0            .4A3:
21497                       000061E0            .4A0:
21498                                           ! Debug: list int = const $60 (used reg = )
21499 61E0           B8                   0060  mov	ax,*$60
21500 61E3           50                         push	ax
21501                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21502 61E4           E8         A35B            call	_inb
21503 61E7           44                         inc	sp
21504 61E8           44                         inc	sp
21505                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
21506 61E9           8846         FF            mov	-1[bp],al
21507                                           !BCC_EOS
21508                                           ! 3371   if ( inb(0x64) & 0x02 )
21509                                           ! Debug: list int = const $64 (used reg = )
21510 61EC           B8                   0064  mov	ax,*$64
21511 61EF           50                         push	ax
21512                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21513 61F0           E8         A34F            call	_inb
21514 61F3           44                         inc	sp
21515 61F4           44                         inc	sp
21516                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21517 61F5           24                     02  and	al,*2
21518 61F7           84C0                       test	al,al
21519 61F9           74           12            je  	.4A4
21520                       000061FB            .4A5:
21521                                           ! 3372     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21522                                           ! Debug: list * char = .4A6+0 (used reg = )
21523 61FB           BB                   D31E  mov	bx,#.4A6
21524 61FE           53                         push	bx
21525                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21526 61FF           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21527 6202           53                         push	bx
21528                                           ! Debug: list int = const 7 (used reg = )
21529 6203           B8                   0007  mov	ax,*7
21530 6206           50                         push	ax
21531                                           ! Debug: func () void = bios_printf+0 (used reg = )
21532 6207           E8         A79D            call	_bios_printf
21533 620A           83C4                   06  add	sp,*6
21534                                           !BCC_EOS
21535                                           ! 3373   command_byte |= 0x02;
21536                       0000620D            .4A4:
21537                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
21538 620D           8A46         FF            mov	al,-1[bp]
21539 6210           0C                     02  or	al,*2
21540 6212           8846         FF            mov	-1[bp],al
21541                                           !BCC_EOS
21542                                           ! 3374   command_byte &= 0xdf;
21543                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
21544 6215           8A46         FF            mov	al,-1[bp]
21545 6218           24                     DF  and	al,#$DF
21546 621A           8846         FF            mov	-1[bp],al
21547                                           !BCC_EOS
21548                                           ! 3375   outb(0x64, 0x60);
21549                                           ! Debug: list int = const $60 (used reg = )
21550 621D           B8                   0060  mov	ax,*$60
21551 6220           50                         push	ax
21552                                           ! Debug: list int = const $64 (used reg = )
21553 6221           B8                   0064  mov	ax,*$64
21554 6224           50                         push	ax
21555                                           ! Debug: func () void = outb+0 (used reg = )
21556 6225           E8         A330            call	_outb
21557 6228           83C4                   04  add	sp,*4
21558                                           !BCC_EOS
21559                                           ! 3376   outb(0x60, command_byte);
21560                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21561 622B           8A46         FF            mov	al,-1[bp]
21562 622E           30E4                       xor	ah,ah
21563 6230           50                         push	ax
21564                                           ! Debug: list int = const $60 (used reg = )
21565 6231           B8                   0060  mov	ax,*$60
21566 6234           50                         push	ax
21567                                           ! Debug: func () void = outb+0 (used reg = )
21568 6235           E8         A320            call	_outb
21569 6238           83C4                   04  add	sp,*4
21570                                           !BCC_EOS
21571                                           ! 3377 }
21572 623B           89EC                       mov	sp,bp
21573 623D           5D                         pop	bp
21574 623E           C3                         ret
21575                                           ! 3378   Bit8u
21576                                           ! Register BX used in function enable_mouse_int_and_events
21577                                           ! 3379 send_to_mouse_ctrl(sendbyte)
21578                                           ! 3380   Bit8u sendbyte;
21579                                           export	_send_to_mouse_ctrl
21580                       0000623F            _send_to_mouse_ctrl:
21581                                           !BCC_EOS
21582                                           ! 3381 {
21583                                           ! 3382   Bit8u response;
21584                                           !BCC_EOS
21585                                           ! 3383   if ( inb(0x64) & 0x02 )
21586 623F           55                         push	bp
21587 6240           89E5                       mov	bp,sp
21588 6242           4C                         dec	sp
21589 6243           4C                         dec	sp
21590                                           ! Debug: list int = const $64 (used reg = )
21591 6244           B8                   0064  mov	ax,*$64
21592 6247           50                         push	ax
21593                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21594 6248           E8         A2F7            call	_inb
21595 624B           44                         inc	sp
21596 624C           44                         inc	sp
21597                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21598 624D           24                     02  and	al,*2
21599 624F           84C0                       test	al,al
21600 6251           74           12            je  	.4A7
21601                       00006253            .4A8:
21602                                           ! 3384     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
21603                                           ! Debug: list * char = .4A9+0 (used reg = )
21604 6253           BB                   D314  mov	bx,#.4A9
21605 6256           53                         push	bx
21606                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21607 6257           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21608 625A           53                         push	bx
21609                                           ! Debug: list int = const 7 (used reg = )
21610 625B           B8                   0007  mov	ax,*7
21611 625E           50                         push	ax
21612                                           ! Debug: func () void = bios_printf+0 (used reg = )
21613 625F           E8         A745            call	_bios_printf
21614 6262           83C4                   06  add	sp,*6
21615                                           !BCC_EOS
21616                                           ! 3385   outb(0x64, 0xD4);
21617                       00006265            .4A7:
21618                                           ! Debug: list int = const $D4 (used reg = )
21619 6265           B8                   00D4  mov	ax,#$D4
21620 6268           50                         push	ax
21621                                           ! Debug: list int = const $64 (used reg = )
21622 6269           B8                   0064  mov	ax,*$64
21623 626C           50                         push	ax
21624                                           ! Debug: func () void = outb+0 (used reg = )
21625 626D           E8         A2E8            call	_outb
21626 6270           83C4                   04  add	sp,*4
21627                                           !BCC_EOS
21628                                           ! 3386   outb(0x60, sendbyte);
21629                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
21630 6273           8A46         04            mov	al,4[bp]
21631 6276           30E4                       xor	ah,ah
21632 6278           50                         push	ax
21633                                           ! Debug: list int = const $60 (used reg = )
21634 6279           B8                   0060  mov	ax,*$60
21635 627C           50                         push	ax
21636                                           ! Debug: func () void = outb+0 (used reg = )
21637 627D           E8         A2D8            call	_outb
21638 6280           83C4                   04  add	sp,*4
21639                                           !BCC_EOS
21640                                           ! 3387   return(0);
21641 6283           30C0                       xor	al,al
21642 6285           89EC                       mov	sp,bp
21643 6287           5D                         pop	bp
21644 6288           C3                         ret
21645                                           !BCC_EOS
21646                                           ! 3388 }
21647                                           ! 3389   Bit8u
21648                                           ! Register BX used in function send_to_mouse_ctrl
21649                                           ! 3390 get
21650                                           ! 3390 _mouse_data(data)
21651                                           ! 3391   Bit8u *data;
21652                                           export	_get_mouse_data
21653                       00006289            _get_mouse_data:
21654                                           !BCC_EOS
21655                                           ! 3392 {
21656                                           ! 3393   Bit8u response;
21657                                           !BCC_EOS
21658                                           ! 3394   Bit16u ss;
21659                                           !BCC_EOS
21660                                           ! 3395   while ((inb(0x64) & 0x21) != 0x21) { }
21661 6289           55                         push	bp
21662 628A           89E5                       mov	bp,sp
21663 628C           83C4                   FC  add	sp,*-4
21664 628F           EB           00            jmp .4AB
21665                       00006291            .4AC:
21666                                           ! 3396   response = inb(0x60);
21667                       00006291            .4AB:
21668                                           ! Debug: list int = const $64 (used reg = )
21669 6291           B8                   0064  mov	ax,*$64
21670 6294           50                         push	ax
21671                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21672 6295           E8         A2AA            call	_inb
21673 6298           44                         inc	sp
21674 6299           44                         inc	sp
21675                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
21676 629A           24                     21  and	al,*$21
21677                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
21678 629C           3C                     21  cmp	al,*$21
21679 629E           75           F1            jne	.4AC
21680                       000062A0            .4AD:
21681                       000062A0            .4AA:
21682                                           ! Debug: list int = const $60 (used reg = )
21683 62A0           B8                   0060  mov	ax,*$60
21684 62A3           50                         push	ax
21685                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21686 62A4           E8         A29B            call	_inb
21687 62A7           44                         inc	sp
21688 62A8           44                         inc	sp
21689                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21690 62A9           8846         FF            mov	-1[bp],al
21691                                           !BCC_EOS
21692                                           ! 3397   ss = get_SS();
21693                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21694 62AC           E8         A3A2            call	_get_SS
21695                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21696 62AF           8946         FC            mov	-4[bp],ax
21697                                           !BCC_EOS
21698                                           ! 3398   write_byte(ss, data, response);
21699                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21700 62B2           8A46         FF            mov	al,-1[bp]
21701 62B5           30E4                       xor	ah,ah
21702 62B7           50                         push	ax
21703                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21704 62B8           FF76         04            push	4[bp]
21705                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21706 62BB           FF76         FC            push	-4[bp]
21707                                           ! Debug: func () void = write_byte+0 (used reg = )
21708 62BE           E8         A35D            call	_write_byte
21709 62C1           83C4                   06  add	sp,*6
21710                                           !BCC_EOS
21711                                           ! 3399   return(0);
21712 62C4           30C0                       xor	al,al
21713 62C6           89EC                       mov	sp,bp
21714 62C8           5D                         pop	bp
21715 62C9           C3                         ret
21716                                           !BCC_EOS
21717                                           ! 3400 }
21718                                           ! 3401   void
21719                                           ! 3402 set_kbd_command_byte(command_byte)
21720                                           ! 3403   Bit8u command_byte;
21721                                           export	_set_kbd_command_byte
21722                       000062CA            _set_kbd_command_byte:
21723                                           !BCC_EOS
21724                                           ! 3404 {
21725                                           ! 3405   if ( inb(0x64) & 0x02 )
21726 62CA           55                         push	bp
21727 62CB           89E5                       mov	bp,sp
21728                                           ! Debug: list int = const $64 (used reg = )
21729 62CD           B8                   0064  mov	ax,*$64
21730 62D0           50                         push	ax
21731                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21732 62D1           E8         A26E            call	_inb
21733 62D4           89EC                       mov	sp,bp
21734                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21735 62D6           24                     02  and	al,*2
21736 62D8           84C0                       test	al,al
21737 62DA           74           11            je  	.4AE
21738                       000062DC            .4AF:
21739                                           ! 3406     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21740                                           ! Debug: list * char = .4B0+0 (used reg = )
21741 62DC           BB                   D309  mov	bx,#.4B0
21742 62DF           53                         push	bx
21743                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21744 62E0           BB                   60CE  mov	bx,#_panic_msg_keyb_buffer_full
21745 62E3           53                         push	bx
21746                                           ! Debug: list int = const 7 (used reg = )
21747 62E4           B8                   0007  mov	ax,*7
21748 62E7           50                         push	ax
21749                                           ! Debug: func () void = bios_printf+0 (used reg = )
21750 62E8           E8         A6BC            call	_bios_printf
21751 62EB           89EC                       mov	sp,bp
21752                                           !BCC_EOS
21753                                           ! 3407   outb(0x64, 0xD4);
21754                       000062ED            .4AE:
21755                                           ! Debug: list int = const $D4 (used reg = )
21756 62ED           B8                   00D4  mov	ax,#$D4
21757 62F0           50                         push	ax
21758                                           ! Debug: list int = const $64 (used reg = )
21759 62F1           B8                   0064  mov	ax,*$64
21760 62F4           50                         push	ax
21761                                           ! Debug: func () void = outb+0 (used reg = )
21762 62F5           E8         A260            call	_outb
21763 62F8           89EC                       mov	sp,bp
21764                                           !BCC_EOS
21765                                           ! 3408   outb(0x64, 0x60);
21766                                           ! Debug: list int = const $60 (used reg = )
21767 62FA           B8                   0060  mov	ax,*$60
21768 62FD           50                         push	ax
21769                                           ! Debug: list int = const $64 (used reg = )
21770 62FE           B8                   0064  mov	ax,*$64
21771 6301           50                         push	ax
21772                                           ! Debug: func () void = outb+0 (used reg = )
21773 6302           E8         A253            call	_outb
21774 6305           89EC                       mov	sp,bp
21775                                           !BCC_EOS
21776                                           ! 3409   outb(0x60, command_byte);
21777                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21778 6307           8A46         04            mov	al,4[bp]
21779 630A           30E4                       xor	ah,ah
21780 630C           50                         push	ax
21781                                           ! Debug: list int = const $60 (used reg = )
21782 630D           B8                   0060  mov	ax,*$60
21783 6310           50                         push	ax
21784                                           ! Debug: func () void = outb+0 (used reg = )
21785 6311           E8         A244            call	_outb
21786 6314           89EC                       mov	sp,bp
21787                                           !BCC_EOS
21788                                           ! 3410 }
21789 6316           5D                         pop	bp
21790 6317           C3                         ret
21791                                           ! 3411   void
21792                                           ! Register BX used in function set_kbd_command_byte
21793                                           ! 3412 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21794                                           ! 3413   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21795                                           export	_int09_function
21796                       00006318            _int09_function:
21797                                           !BCC_EOS
21798                                           ! 3414 {
21799                                           ! 3415   Bit8u scancode, asciicode, shift_flags;
21800                                           !BCC_EOS
21801                                           ! 3416   Bit8u mf2_flags, mf2_state;
21802                                           !BCC_EOS
21803                                           ! 3417   scancode = ( AX & 0x00ff );
21804 6318           55                         push	bp
21805 6319           89E5                       mov	bp,sp
21806 631B           83C4                   FA  add	sp,*-6
21807                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21808 631E           8A46         12            mov	al,$12[bp]
21809                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21810 6321           8846         FF            mov	-1[bp],al
21811                                           !BCC_EOS
21812                                           ! 3418   if (scancode == 0) {
21813                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21814 6324           8A46         FF            mov	al,-1[bp]
21815 6327           84C0                       test	al,al
21816 6329           75           12            jne 	.4B1
21817                       0000632B            .4B2:
21818                                           ! 3419     bios_printf(4, "KBD: int09 handler: AL=0\n");
21819                                           ! Debug: list * char = .4B3+0 (used reg = )
21820 632B           BB                   D2EF  mov	bx,#.4B3
21821 632E           53                         push	bx
21822                                           ! Debug: list int = const 4 (used reg = )
21823 632F           B8                   0004  mov	ax,*4
21824 6332           50                         push	ax
21825                                           ! Debug: func () void = bios_printf+0 (used reg = )
21826 6333           E8         A671            call	_bios_printf
21827 6336           83C4                   04  add	sp,*4
21828                                           !BCC_EOS
21829                                           ! 3420     return;
21830 6339           89EC                       mov	sp,bp
21831 633B           5D                         pop	bp
21832 633C           C3                         ret
21833                                           !BCC_EOS
21834                                           ! 3421   }
21835                                           ! 3422   shift_flags = read_byte(0x0040, 0x17);
21836                       0000633D            .4B1:
21837                                           ! Debug: list int = const $17 (used reg = )
21838 633D           B8                   0017  mov	ax,*$17
21839 6340           50                         push	ax
21840                                           ! Debug: list int = const $40 (used reg = )
21841 6341           B8                   0040  mov	ax,*$40
21842 6344           50                         push	ax
21843                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21844 6345           E8         A2B0            call	_read_byte
21845 6348           83C4                   04  add	sp,*4
21846                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21847 634B           8846         FD            mov	-3[bp],al
21848                                           !BCC_EOS
21849                                           ! 3423   mf2_flags = read_byte(0x0040, 0x18);
21850                                           ! Debug: list int = const $18 (used reg = )
21851 634E           B8                   0018  mov	ax,*$18
21852 6351           50                         push	ax
21853                                           ! Debug: list int = const $40 (used reg = )
21854 6352           B8                   0040  mov	ax,*$40
21855 6355           50                         push	ax
21856                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21857 6356           E8         A29F            call	_read_byte
21858 6359           83C4                   04  add	sp,*4
21859                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21860 635C           8846         FC            mov	-4[bp],al
21861                                           !BCC_EOS
21862                                           ! 3424   mf2_state = read_byte(0x0040, 0x96);
21863                                           ! Debug: list int = const $96 (used reg = )
21864 635F           B8                   0096  mov	ax,#$96
21865 6362           50                         push	ax
21866                                           ! Debug: list int = const $40 (used reg = )
21867 6363           B8                   0040  mov	ax,*$40
21868 6366           50                         push	ax
21869                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21870 6367           E8         A28E            call	_read_byte
21871 636A           83C4                   04  add	sp,*4
21872                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21873 636D           8846         FB            mov	-5[bp],al
21874                                           !BCC_EOS
21875                                           ! 3425   asciicode = 0;
21876                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21877 6370           30C0                       xor	al,al
21878 6372           8846         FE            mov	-2[bp],al
21879                                           !BCC_EOS
21880                                           ! 3426   switch (scancode) {
21881 6375           8A46         FF            mov	al,-1[bp]
21882 6378           E9         0586            br 	.4B6
21883                                           ! 3427     case 0x3a:
21884                                           ! 3428       shift_flags ^= 0x40;
21885                       0000637B            .4B7:
21886                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21887 637B           8A46         FD            mov	al,-3[bp]
21888 637E           34                     40  xor	al,*$40
21889 6380           8846         FD            mov	-3[bp],al
21890                                           !BCC_EOS
21891                                           ! 3429       write_byte(0x0040, 0x17, shift_flags);
21892                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21893 6383           8A46         FD            mov	al,-3[bp]
21894 6386           30E4                       xor	ah,ah
21895 6388           50                         push	ax
21896                                           ! Debug: list int = const $17 (used reg = )
21897 6389           B8                   0017  mov	ax,*$17
21898 638C           50                         push	ax
21899                                           ! Debug: list int = const $40 (used reg = )
21900 638D           B8                   0040  mov	ax,*$40
21901 6390           50                         push	ax
21902                                           ! Debug: func () void = write_byte+0 (used reg = )
21903 6391           E8         A28A            call	_write_byte
21904 6394           83C4                   06  add	sp,*6
21905                                           !BCC_EOS
21906                                           ! 3430       mf2_flags |= 0x40;
21907                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21908 6397           8A46         FC            mov	al,-4[bp]
21909 639A           0C                     40  or	al,*$40
21910 639C           8846         FC            mov	-4[bp],al
21911                                           !BCC_EOS
21912                                           ! 3431       write_byte(0x0040, 0x18, mf2_flags);
21913                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21914 639F           8A46         FC            mov	al,-4[bp]
21915 63A2           30E4                       xor	ah,ah
21916 63A4           50                         push	ax
21917                                           ! Debug: list int = const $18 (used reg = )
21918 63A5           B8                   0018  mov	ax,*$18
21919 63A8           50                         push	ax
21920                                           ! Debug: list int = const $40 (used reg = )
21921 63A9           B8                   0040  mov	ax,*$40
21922 63AC           50                         push	ax
21923                                           ! Debug: func () void = write_byte+0 (used reg = )
21924 63AD           E8         A26E            call	_write_byte
21925 63B0           83C4                   06  add	sp,*6
21926                                           !BCC_EOS
21927                                           ! 3432       break;
21928 63B3           E9         05A2            br 	.4B4
21929                                           !BCC_EOS
21930                                           ! 3433     case 0xba:
21931                                           ! 3434       mf2_flags &= ~0x40;
21932                       000063B6            .4B8:
21933                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21934 63B6           8A46         FC            mov	al,-4[bp]
21935 63B9           24                     BF  and	al,#$BF
21936 63BB           8846         FC            mov	-4[bp],al
21937                                           !BCC_EOS
21938                                           ! 3435       write_byte(0x0040, 0x18, mf2_flags);
21939                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21940 63BE           8A46         FC            mov	al,-4[bp]
21941 63C1           30E4                       xor	ah,ah
21942 63C3           50                         push	ax
21943                                           ! Debug: list int = const $18 (used reg = )
21944 63C4           B8                   0018  mov	ax,*$18
21945 63C7           50                         push	ax
21946                                           ! Debug: list int = const $40 (used reg = )
21947 63C8           B8                   0040  mov	ax,*$40
21948 63CB           50                         push	ax
21949                                           ! Debug: func () void = write_byte+0 (used reg = )
21950 63CC           E8         A24F            call	_write_byte
21951 63CF           83C4                   06  add	sp,*6
21952                                           !BCC_EOS
21953                                           ! 3436       break;
21954 63D2           E9         0583            br 	.4B4
21955                                           !BCC_EOS
21956                                           ! 3437     case 0x2a:
21957                                           ! 3438       shift_flags |= 0x02;
21958                       000063D5            .4B9:
21959                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21960 63D5           8A46         FD            mov	al,-3[bp]
21961 63D8           0C                     02  or	al,*2
21962 63DA           8846         FD            mov	-3[bp],al
21963                                           !BCC_EOS
21964                                           ! 3439       write_byte(0x0040, 0x17, shift_flags);
21965                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21966 63DD           8A46         FD            mov	al,-3[bp]
21967 63E0           30E4                       xor	ah,ah
21968 63E2           50                         push	ax
21969                                           ! Debug: list int = const $17 (used reg = )
21970 63E3           B8                   0017  mov	ax,*$17
21971 63E6           50                         push	ax
21972                                           ! Debug: list int = const $40 (used reg = )
21973 63E7           B8                   0040  mov	ax,*$40
21974 63EA           50                         push	ax
21975                                           ! Debug: func () void = write_byte+0 (used reg = )
21976 63EB           E8         A230            call	_write_byte
21977 63EE           83C4                   06  add	sp,*6
21978                                           !BCC_EOS
21979                                           ! 3440       break;
21980 63F1           E9         0564            br 	.4B4
21981                                           !BCC_EOS
21982                                           ! 3441     case 0xaa:
21983                                           ! 3442       shift_flags &= ~0x02;
21984                       000063F4            .4BA:
21985                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21986 63F4           8A46         FD            mov	al,-3[bp]
21987 63F7           24                     FD  and	al,#$FD
21988 63F9           8846         FD            mov	-3[bp],al
21989                                           !BCC_EOS
21990                                           ! 3443       write_byte(0x0040, 0x17, shift_flags);
21991                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21992 63FC           8A46         FD            mov	al,-3[bp]
21993 63FF           30E4                       xor	ah,ah
21994 6401           50                         push	ax
21995                                           ! Debug: list int = const $17 (used reg = )
21996 6402           B8                   0017  mov	ax,*$17
21997 6405           50                         push	ax
21998                                           ! Debug: list int = const $40 (used reg = )
21999 6406           B8                   0040  mov	ax,*$40
22000 6409           50                         push	ax
22001                                           ! Debug: func () void = write_byte+0 (used reg = )
22002 640A           E8         A211            call	_write_byte
22003 640D           83C4                   06  add	sp,*6
22004                                           !BCC_EOS
22005                                           ! 3444       break;
22006 6410           E9         0545            br 	.4B4
22007                                           !BCC_EOS
22008                                           ! 3445     case 0x36:
22009                                           ! 3446       shift_flags |= 0x01;
22010                       00006413            .4BB:
22011                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
22012 6413           8A46         FD            mov	al,-3[bp]
22013 6416           0C                     01  or	al,*1
22014 6418           8846         FD            mov	-3[bp],al
22015                                           !BCC_EOS
22016                                           ! 3447       write_byte(0x0040, 0x17, shift_flags);
22017                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22018 641B           8A46         FD            mov	al,-3[bp]
22019 641E           30E4                       xor	ah,ah
22020 6420           50                         push	ax
22021                                           ! Debug: list int = const $17 (used reg = )
22022 6421           B8                   0017  mov	ax,*$17
22023 6424           50                         push	ax
22024                                           ! Debug: list int = const $40 (used reg = )
22025 6425           B8                   0040  mov	ax,*$40
22026 6428           50                         push	ax
22027                                           ! Debug: func () void = write_byte+0 (used reg = )
22028 6429           E8         A1F2            call	_write_byte
22029 642C           83C4                   06  add	sp,*6
22030                                           !BCC_EOS
22031                                           ! 3448       break;
22032 642F           E9         0526            br 	.4B4
22033                                           !BCC_EOS
22034                                           ! 3449     case 0xb6:
22035                                           ! 3450       shift_flags &= ~0x01;
22036                       00006432            .4BC:
22037                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
22038 6432           8A46         FD            mov	al,-3[bp]
22039 6435           24                     FE  and	al,#$FE
22040 6437           8846         FD            mov	-3[bp],al
22041                                           !BCC_EOS
22042                                           ! 3451       write_byte(0x0040, 0x17, shift_flags);
22043                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22044 643A           8A46         FD            mov	al,-3[bp]
22045 643D           30E4                       xor	ah,ah
22046 643F           50                         push	ax
22047                                           ! Debug: list int = const $17 (used reg = )
22048 6440           B8                   0017  mov	ax,*$17
22049 6443           50                         push	ax
22050                                           ! Debug: list int = const $40 (used reg = )
22051 6444           B8                   0040  mov	ax,*$40
22052 6447           50                         push	ax
22053                                           ! Debug: func () void = write_byte+0 (used reg = )
22054 6448           E8         A1D3            call	_write_byte
22055 644B           83C4                   06  add	sp,*6
22056                                           !BCC_EOS
22057                                           ! 3452       break;
22058 644E           E9         0507            br 	.4B4
22059                                           !BCC_EOS
22060                                           ! 3453     case 0x1d:
22061                                           ! 3454       if ((mf2_state & 0x01) == 0) {
22062                       00006451            .4BD:
22063                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
22064 6451           8A46         FB            mov	al,-5[bp]
22065 6454           24                     01  and	al,*1
22066                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22067 6456           84C0                       test	al,al
22068 6458           75           5F            jne 	.4BE
22069                       0000645A            .4BF:
22070                                           ! 3455         shift_flags |= 0x04;
22071                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22072 645A           8A46         FD            mov	al,-3[bp]
22073 645D           0C                     04  or	al,*4
22074 645F           8846         FD            mov	-3[bp],al
22075                                           !BCC_EOS
22076                                           ! 3456         write_byte(0x0040, 0x17, shift_flags);
22077                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22078 6462           8A46         FD            mov	al,-3[bp]
22079 6465           30E4                       xor	ah,ah
22080 6467           50                         push	ax
22081                                           ! Debug: list int = const $17 (used reg = )
22082 6468           B8                   0017  mov	ax,*$17
22083 646B           50                         push	ax
22084                                           ! Debug: list int = const $40 (used reg = )
22085 646C           B8                   0040  mov	ax,*$40
22086 646F           50                         push	ax
22087                                           ! Debug: func () void = write_byte+0 (used reg = )
22088 6470           E8         A1AB            call	_write_byte
22089 6473           83C4                   06  add	sp,*6
22090                                           !BCC_EOS
22091                                           ! 3457         if (mf2_state & 0x02) {
22092                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22093 6476           8A46         FB            mov	al,-5[bp]
22094 6479           24                     02  and	al,*2
22095 647B           84C0                       test	al,al
22096 647D           74           1E            je  	.4C0
22097                       0000647F            .4C1:
22098                                           ! 3458           mf2_state |= 0x04;
22099                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
22100 647F           8A46         FB            mov	al,-5[bp]
22101 6482           0C                     04  or	al,*4
22102 6484           8846         FB            mov	-5[bp],al
22103                                           !BCC_EOS
22104                                           ! 3459           write_byte(0x0040, 0x96, mf2_state);
22105                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22106 6487           8A46         FB            mov	al,-5[bp]
22107 648A           30E4                       xor	ah,ah
22108 648C           50                         push	ax
22109                                           ! Debug: list int = const $96 (used reg = )
22110 648D           B8                   0096  mov	ax,#$96
22111 6490           50                         push	ax
22112                                           ! Debug: list int = const $40 (used reg = )
22113 6491           B8                   0040  mov	ax,*$40
22114 6494           50                         push	ax
22115                                           ! Debug: func () void = write_byte+0 (used reg = )
22116 6495           E8         A186            call	_write_byte
22117 6498           83C4                   06  add	sp,*6
22118                                           !BCC_EOS
22119                                           ! 3460         } else {
22120 649B           EB           1C            jmp .4C2
22121                       0000649D            .4C0:
22122                                           ! 3461           mf2_flags |= 0x01;
22123                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
22124 649D           8A46         FC            mov	al,-4[bp]
22125 64A0           0C                     01  or	al,*1
22126 64A2           8846         FC            mov	-4[bp],al
22127                                           !BCC_EOS
22128                                           ! 3462           write_byte(0x0040, 0x18, mf2_flags);
22129                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22130 64A5           8A46         FC            mov	al,-4[bp]
22131 64A8           30E4                       xor	ah,ah
22132 64AA           50                         push	ax
22133                                           ! Debug: list int = const $18 (used reg = )
22134 64AB           B8                   0018  mov	ax,*$18
22135 64AE           50                         push	ax
22136                                           ! Debug: list int = const $40 (used reg = )
22137 64AF           B8                   0040  mov	ax,*$40
22138 64B2           50                         push	ax
22139                                           ! Debug: func () void = write_byte+0 (used reg = )
22140 64B3           E8         A168            call	_write_byte
22141 64B6           83C4                   06  add	sp,*6
22142                                           !BCC_EOS
22143                                           ! 3463         }
22144                                           ! 3464       }
22145                       000064B9            .4C2:
22146                                           ! 3465       break;
22147                       000064B9            .4BE:
22148 64B9           E9         049C            br 	.4B4
22149                                           !BCC_EOS
22150                                           ! 3466     case 0x9d:
22151                                           ! 3467       if ((mf2_state & 0x01) == 0) {
22152                       000064BC            .4C3:
22153                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
22154 64BC           8A46         FB            mov	al,-5[bp]
22155 64BF           24                     01  and	al,*1
22156                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22157 64C1           84C0                       test	al,al
22158 64C3           75           5F            jne 	.4C4
22159                       000064C5            .4C5:
22160                                           ! 3468         shift_flags &= ~0x04;
22161                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
22162 64C5           8A46         FD            mov	al,-3[bp]
22163 64C8           24                     FB  and	al,#$FB
22164 64CA           8846         FD            mov	-3[bp],al
22165                                           !BCC_EOS
22166                                           ! 3469         write_byte(0x0040, 0x17, shift_flags);
22167                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22168 64CD           8A46         FD            mov	al,-3[bp]
22169 64D0           30E4                       xor	ah,ah
22170 64D2           50                         push	ax
22171                                           ! Debug: list int = const $17 (used reg = )
22172 64D3           B8                   0017  mov	ax,*$17
22173 64D6           50                         push	ax
22174                                           ! Debug: list int = const $40 (used reg = )
22175 64D7           B8                   0040  mov	ax,*$40
22176 64DA           50                         push	ax
22177                                           ! Debug: func () void = write_byte+0 (used reg = )
22178 64DB           E8         A140            call	_write_byte
22179 64DE           83C4                   06  add	sp,*6
22180                                           !BCC_EOS
22181                                           ! 3470         if (mf2_
22182                                           ! 3470 state & 0x02) {
22183                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22184 64E1           8A46         FB            mov	al,-5[bp]
22185 64E4           24                     02  and	al,*2
22186 64E6           84C0                       test	al,al
22187 64E8           74           1E            je  	.4C6
22188                       000064EA            .4C7:
22189                                           ! 3471           mf2_state &= ~0x04;
22190                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
22191 64EA           8A46         FB            mov	al,-5[bp]
22192 64ED           24                     FB  and	al,#$FB
22193 64EF           8846         FB            mov	-5[bp],al
22194                                           !BCC_EOS
22195                                           ! 3472           write_byte(0x0040, 0x96, mf2_state);
22196                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22197 64F2           8A46         FB            mov	al,-5[bp]
22198 64F5           30E4                       xor	ah,ah
22199 64F7           50                         push	ax
22200                                           ! Debug: list int = const $96 (used reg = )
22201 64F8           B8                   0096  mov	ax,#$96
22202 64FB           50                         push	ax
22203                                           ! Debug: list int = const $40 (used reg = )
22204 64FC           B8                   0040  mov	ax,*$40
22205 64FF           50                         push	ax
22206                                           ! Debug: func () void = write_byte+0 (used reg = )
22207 6500           E8         A11B            call	_write_byte
22208 6503           83C4                   06  add	sp,*6
22209                                           !BCC_EOS
22210                                           ! 3473         } else {
22211 6506           EB           1C            jmp .4C8
22212                       00006508            .4C6:
22213                                           ! 3474           mf2_flags &= ~0x01;
22214                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22215 6508           8A46         FC            mov	al,-4[bp]
22216 650B           24                     FE  and	al,#$FE
22217 650D           8846         FC            mov	-4[bp],al
22218                                           !BCC_EOS
22219                                           ! 3475           write_byte(0x0040, 0x18, mf2_flags);
22220                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22221 6510           8A46         FC            mov	al,-4[bp]
22222 6513           30E4                       xor	ah,ah
22223 6515           50                         push	ax
22224                                           ! Debug: list int = const $18 (used reg = )
22225 6516           B8                   0018  mov	ax,*$18
22226 6519           50                         push	ax
22227                                           ! Debug: list int = const $40 (used reg = )
22228 651A           B8                   0040  mov	ax,*$40
22229 651D           50                         push	ax
22230                                           ! Debug: func () void = write_byte+0 (used reg = )
22231 651E           E8         A0FD            call	_write_byte
22232 6521           83C4                   06  add	sp,*6
22233                                           !BCC_EOS
22234                                           ! 3476         }
22235                                           ! 3477       }
22236                       00006524            .4C8:
22237                                           ! 3478       break;
22238                       00006524            .4C4:
22239 6524           E9         0431            br 	.4B4
22240                                           !BCC_EOS
22241                                           ! 3479     case 0x38:
22242                                           ! 3480       shift_flags |= 0x08;
22243                       00006527            .4C9:
22244                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22245 6527           8A46         FD            mov	al,-3[bp]
22246 652A           0C                     08  or	al,*8
22247 652C           8846         FD            mov	-3[bp],al
22248                                           !BCC_EOS
22249                                           ! 3481       write_byte(0x0040, 0x17, shift_flags);
22250                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22251 652F           8A46         FD            mov	al,-3[bp]
22252 6532           30E4                       xor	ah,ah
22253 6534           50                         push	ax
22254                                           ! Debug: list int = const $17 (used reg = )
22255 6535           B8                   0017  mov	ax,*$17
22256 6538           50                         push	ax
22257                                           ! Debug: list int = const $40 (used reg = )
22258 6539           B8                   0040  mov	ax,*$40
22259 653C           50                         push	ax
22260                                           ! Debug: func () void = write_byte+0 (used reg = )
22261 653D           E8         A0DE            call	_write_byte
22262 6540           83C4                   06  add	sp,*6
22263                                           !BCC_EOS
22264                                           ! 3482       if (mf2_state & 0x02) {
22265                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22266 6543           8A46         FB            mov	al,-5[bp]
22267 6546           24                     02  and	al,*2
22268 6548           84C0                       test	al,al
22269 654A           74           1E            je  	.4CA
22270                       0000654C            .4CB:
22271                                           ! 3483         mf2_state |= 0x08;
22272                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
22273 654C           8A46         FB            mov	al,-5[bp]
22274 654F           0C                     08  or	al,*8
22275 6551           8846         FB            mov	-5[bp],al
22276                                           !BCC_EOS
22277                                           ! 3484         write_byte(0x0040, 0x96, mf2_state);
22278                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22279 6554           8A46         FB            mov	al,-5[bp]
22280 6557           30E4                       xor	ah,ah
22281 6559           50                         push	ax
22282                                           ! Debug: list int = const $96 (used reg = )
22283 655A           B8                   0096  mov	ax,#$96
22284 655D           50                         push	ax
22285                                           ! Debug: list int = const $40 (used reg = )
22286 655E           B8                   0040  mov	ax,*$40
22287 6561           50                         push	ax
22288                                           ! Debug: func () void = write_byte+0 (used reg = )
22289 6562           E8         A0B9            call	_write_byte
22290 6565           83C4                   06  add	sp,*6
22291                                           !BCC_EOS
22292                                           ! 3485       } else {
22293 6568           EB           1C            jmp .4CC
22294                       0000656A            .4CA:
22295                                           ! 3486         mf2_flags |= 0x02;
22296                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22297 656A           8A46         FC            mov	al,-4[bp]
22298 656D           0C                     02  or	al,*2
22299 656F           8846         FC            mov	-4[bp],al
22300                                           !BCC_EOS
22301                                           ! 3487         write_byte(0x0040, 0x18, mf2_flags);
22302                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22303 6572           8A46         FC            mov	al,-4[bp]
22304 6575           30E4                       xor	ah,ah
22305 6577           50                         push	ax
22306                                           ! Debug: list int = const $18 (used reg = )
22307 6578           B8                   0018  mov	ax,*$18
22308 657B           50                         push	ax
22309                                           ! Debug: list int = const $40 (used reg = )
22310 657C           B8                   0040  mov	ax,*$40
22311 657F           50                         push	ax
22312                                           ! Debug: func () void = write_byte+0 (used reg = )
22313 6580           E8         A09B            call	_write_byte
22314 6583           83C4                   06  add	sp,*6
22315                                           !BCC_EOS
22316                                           ! 3488       }
22317                                           ! 3489       break;
22318                       00006586            .4CC:
22319 6586           E9         03CF            br 	.4B4
22320                                           !BCC_EOS
22321                                           ! 3490     case 0xb8:
22322                                           ! 3491       shift_flags &= ~0x08;
22323                       00006589            .4CD:
22324                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
22325 6589           8A46         FD            mov	al,-3[bp]
22326 658C           24                     F7  and	al,#$F7
22327 658E           8846         FD            mov	-3[bp],al
22328                                           !BCC_EOS
22329                                           ! 3492       write_byte(0x0040, 0x17, shift_flags);
22330                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22331 6591           8A46         FD            mov	al,-3[bp]
22332 6594           30E4                       xor	ah,ah
22333 6596           50                         push	ax
22334                                           ! Debug: list int = const $17 (used reg = )
22335 6597           B8                   0017  mov	ax,*$17
22336 659A           50                         push	ax
22337                                           ! Debug: list int = const $40 (used reg = )
22338 659B           B8                   0040  mov	ax,*$40
22339 659E           50                         push	ax
22340                                           ! Debug: func () void = write_byte+0 (used reg = )
22341 659F           E8         A07C            call	_write_byte
22342 65A2           83C4                   06  add	sp,*6
22343                                           !BCC_EOS
22344                                           ! 3493       if (mf2_state & 0x02) {
22345                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22346 65A5           8A46         FB            mov	al,-5[bp]
22347 65A8           24                     02  and	al,*2
22348 65AA           84C0                       test	al,al
22349 65AC           74           1E            je  	.4CE
22350                       000065AE            .4CF:
22351                                           ! 3494         mf2_state &= ~0x08;
22352                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
22353 65AE           8A46         FB            mov	al,-5[bp]
22354 65B1           24                     F7  and	al,#$F7
22355 65B3           8846         FB            mov	-5[bp],al
22356                                           !BCC_EOS
22357                                           ! 3495         write_byte(0x0040, 0x96, mf2_state);
22358                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22359 65B6           8A46         FB            mov	al,-5[bp]
22360 65B9           30E4                       xor	ah,ah
22361 65BB           50                         push	ax
22362                                           ! Debug: list int = const $96 (used reg = )
22363 65BC           B8                   0096  mov	ax,#$96
22364 65BF           50                         push	ax
22365                                           ! Debug: list int = const $40 (used reg = )
22366 65C0           B8                   0040  mov	ax,*$40
22367 65C3           50                         push	ax
22368                                           ! Debug: func () void = write_byte+0 (used reg = )
22369 65C4           E8         A057            call	_write_byte
22370 65C7           83C4                   06  add	sp,*6
22371                                           !BCC_EOS
22372                                           ! 3496       } else {
22373 65CA           EB           1C            jmp .4D0
22374                       000065CC            .4CE:
22375                                           ! 3497         mf2_flags &= ~0x02;
22376                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
22377 65CC           8A46         FC            mov	al,-4[bp]
22378 65CF           24                     FD  and	al,#$FD
22379 65D1           8846         FC            mov	-4[bp],al
22380                                           !BCC_EOS
22381                                           ! 3498         write_byte(0x0040, 0x18, mf2_flags);
22382                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22383 65D4           8A46         FC            mov	al,-4[bp]
22384 65D7           30E4                       xor	ah,ah
22385 65D9           50                         push	ax
22386                                           ! Debug: list int = const $18 (used reg = )
22387 65DA           B8                   0018  mov	ax,*$18
22388 65DD           50                         push	ax
22389                                           ! Debug: list int = const $40 (used reg = )
22390 65DE           B8                   0040  mov	ax,*$40
22391 65E1           50                         push	ax
22392                                           ! Debug: func () void = write_byte+0 (used reg = )
22393 65E2           E8         A039            call	_write_byte
22394 65E5           83C4                   06  add	sp,*6
22395                                           !BCC_EOS
22396                                           ! 3499       }
22397                                           ! 3500       break;
22398                       000065E8            .4D0:
22399 65E8           E9         036D            br 	.4B4
22400                                           !BCC_EOS
22401                                           ! 3501     case 0x45:
22402                                           ! 3502       if ((mf2_state & 0x03) == 0) {
22403                       000065EB            .4D1:
22404                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22405 65EB           8A46         FB            mov	al,-5[bp]
22406 65EE           24                     03  and	al,*3
22407                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22408 65F0           84C0                       test	al,al
22409 65F2           75           38            jne 	.4D2
22410                       000065F4            .4D3:
22411                                           ! 3503         mf2_flags |= 0x20;
22412                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
22413 65F4           8A46         FC            mov	al,-4[bp]
22414 65F7           0C                     20  or	al,*$20
22415 65F9           8846         FC            mov	-4[bp],al
22416                                           !BCC_EOS
22417                                           ! 3504         write_byte(0x0040, 0x18, mf2_flags);
22418                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22419 65FC           8A46         FC            mov	al,-4[bp]
22420 65FF           30E4                       xor	ah,ah
22421 6601           50                         push	ax
22422                                           ! Debug: list int = const $18 (used reg = )
22423 6602           B8                   0018  mov	ax,*$18
22424 6605           50                         push	ax
22425                                           ! Debug: list int = const $40 (used reg = )
22426 6606           B8                   0040  mov	ax,*$40
22427 6609           50                         push	ax
22428                                           ! Debug: func () void = write_byte+0 (used reg = )
22429 660A           E8         A011            call	_write_byte
22430 660D           83C4                   06  add	sp,*6
22431                                           !BCC_EOS
22432                                           ! 3505         shift_flags ^= 0x20;
22433                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
22434 6610           8A46         FD            mov	al,-3[bp]
22435 6613           34                     20  xor	al,*$20
22436 6615           8846         FD            mov	-3[bp],al
22437                                           !BCC_EOS
22438                                           ! 3506         write_byte(0x0040, 0x17, shift_flags);
22439                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22440 6618           8A46         FD            mov	al,-3[bp]
22441 661B           30E4                       xor	ah,ah
22442 661D           50                         push	ax
22443                                           ! Debug: list int = const $17 (used reg = )
22444 661E           B8                   0017  mov	ax,*$17
22445 6621           50                         push	ax
22446                                           ! Debug: list int = const $40 (used reg = )
22447 6622           B8                   0040  mov	ax,*$40
22448 6625           50                         push	ax
22449                                           ! Debug: func () void = write_byte+0 (used reg = )
22450 6626           E8         9FF5            call	_write_byte
22451 6629           83C4                   06  add	sp,*6
22452                                           !BCC_EOS
22453                                           ! 3507       }
22454                                           ! 3508       break;
22455                       0000662C            .4D2:
22456 662C           E9         0329            br 	.4B4
22457                                           !BCC_EOS
22458                                           ! 3509     case 0xc5:
22459                                           ! 3510       if ((mf2_state & 0x03) == 0) {
22460                       0000662F            .4D4:
22461                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22462 662F           8A46         FB            mov	al,-5[bp]
22463 6632           24                     03  and	al,*3
22464                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22465 6634           84C0                       test	al,al
22466 6636           75           1C            jne 	.4D5
22467                       00006638            .4D6:
22468                                           ! 3511         mf2_flags &= ~0x20;
22469                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
22470 6638           8A46         FC            mov	al,-4[bp]
22471 663B           24                     DF  and	al,#$DF
22472 663D           8846         FC            mov	-4[bp],al
22473                                           !BCC_EOS
22474                                           ! 3512         write_byte(0x0040, 0x18, mf2_flags);
22475                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22476 6640           8A46         FC            mov	al,-4[bp]
22477 6643           30E4                       xor	ah,ah
22478 6645           50                         push	ax
22479                                           ! Debug: list int = const $18 (used reg = )
22480 6646           B8                   0018  mov	ax,*$18
22481 6649           50                         push	ax
22482                                           ! Debug: list int = const $40 (used reg = )
22483 664A           B8                   0040  mov	ax,*$40
22484 664D           50                         push	ax
22485                                           ! Debug: func () void = write_byte+0 (used reg = )
22486 664E           E8         9FCD            call	_write_byte
22487 6651           83C4                   06  add	sp,*6
22488                                           !BCC_EOS
22489                                           ! 3513       }
22490                                           ! 3514       break;
22491                       00006654            .4D5:
22492 6654           E9         0301            br 	.4B4
22493                                           !BCC_EOS
22494                                           ! 3515     case 0x46:
22495                                           ! 3516       mf2_flags |= 0x10;
22496                       00006657            .4D7:
22497                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
22498 6657           8A46         FC            mov	al,-4[bp]
22499 665A           0C                     10  or	al,*$10
22500 665C           8846         FC            mov	-4[bp],al
22501                                           !BCC_EOS
22502                                           ! 3517       write_byte(0x0040, 0x18, mf2_flags);
22503                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22504 665F           8A46         FC            mov	al,-4[bp]
22505 6662           30E4                       xor	ah,ah
22506 6664           50                         push	ax
22507                                           ! Debug: list int = const $18 (used reg = )
22508 6665           B8                   0018  mov	ax,*$18
22509 6668           50                         push	ax
22510                                           ! Debug: list int = const $40 (used reg = )
22511 6669           B8                   0040  mov	ax,*$40
22512 666C           50                         push	ax
22513                                           ! Debug: func () void = write_byte+0 (used reg = )
22514 666D           E8         9FAE            call	_write_byte
22515 6670           83C4                   06  add	sp,*6
22516                                           !BCC_EOS
22517                                           ! 3518       shift_flags ^= 0x10;
22518                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
22519 6673           8A46         FD            mov	al,-3[bp]
22520 6676           34                     10  xor	al,*$10
22521 6678           8846         FD            mov	-3[bp],al
22522                                           !BCC_EOS
22523                                           ! 3519       write_byte(0x0040, 0x17, shift_flags);
22524                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22525 667B           8A46         FD            mov	al,-3[bp]
22526 667E           30E4                       xor	ah,ah
22527 6680           50                         push	ax
22528                                           ! Debug: list int = const $17 (used reg = )
22529 6681           B8                   0017  mov	ax,*$17
22530 6684           50                         push	ax
22531                                           ! Debug: list int = const $40 (used reg = )
22532 6685           B8                   0040  mov	ax,*$40
22533 6688           50                         push	ax
22534                                           ! Debug: func () void = write_byte+0 (used reg = )
22535 6689           E8         9F92            call	_write_byte
22536 668C           83C4                   06  add	sp,*6
22537                                           !BCC_EOS
22538                                           ! 3520       break;
22539 668F           E9         02C6            br 	.4B4
22540                                           !BCC_EOS
22541                                           ! 3521     case 0xc6:
22542                                           ! 3522       mf2_flags &= ~0x10;
22543                       00006692            .4D8:
22544                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
22545 6692           8A46         FC            mov	al,-4[bp]
22546 6695           24                     EF  and	al,#$EF
22547 6697           8846         FC            mov	-4[bp],al
22548                                           !BCC_EOS
22549                                           ! 3523       write_byte(0x0040, 0x18, mf2_flags);
22550                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22551 669A           8A46         FC            mov	al,-4[bp]
22552 669D           30E4                       xor	ah,ah
22553 669F           50                         push	ax
22554                                           ! Debug: list int = const $18 (used reg = )
22555 66A0           B8                   0018  mov	ax,*$18
22556 66A3           50                         push	ax
22557                                           ! Debug: list int = const $40 (used reg = )
22558 66A4           B8                   0040  mov	ax,*$40
22559 66A7           50                         push	ax
22560                                           ! Debug: func () void = write_byte+0 (used reg = )
22561 66A8           E8         9F73            call	_write_byte
22562 66AB           83C4                   06  add	sp,*6
22563                                           !BCC_EOS
22564                                           ! 3524       break;
22565 66AE           E9         02A7            br 	.4B4
22566                                           !BCC_EOS
22567                                           ! 3525     default:
22568                                           ! 3526       if (scancode & 0x80) {
22569                       000066B1            .4D9:
22570                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
22571 66B1           8A46         FF            mov	al,-1[bp]
22572 66B4           24                     80  and	al,#$80
22573 66B6           84C0                       test	al,al
22574 66B8           74           03            je  	.4DA
22575                       000066BA            .4DB:
22576                                           ! 3527         break;
22577 66BA           E9         029B            br 	.4B4
22578                                           !BCC_EOS
22579                                           ! 3528       }
22580                                           ! 3529       if (scancode > 0x58) {
22581                       000066BD            .4DA:
22582                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
22583 66BD           8A46         FF            mov	al,-1[bp]
22584 66C0           3C                     58  cmp	al,*$58
22585 66C2           76           18            jbe 	.4DC
22586                       000066C4            .4DD:
22587                                           ! 3530         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
22588                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
22589 66C4           8A46         FF            mov	al,-1[bp]
22590 66C7           30E4                       xor	ah,ah
22591 66C9           50                         push	ax
22592                                           ! Debug: list * char = .4DE+0 (used reg = )
22593 66CA           BB                   D2B8  mov	bx,#.4DE
22594 66CD           53                         push	bx
22595                                           ! Debug: list int = const 4 (used reg = )
22596 66CE           B8                   0004  mov	ax,*4
22597 66D1           50                         push	ax
22598                                           ! Debug: func () void = bios_printf+0 (used reg = )
22599 66D2           E8         A2D2            call	_bios_printf
22600 66D5           83C4                   06  add	sp,*6
22601                                           !BCC_EOS
22602                                           ! 3531         return;
22603 66D8           89EC                       mov	sp,bp
22604 66DA           5D                         pop	bp
22605 66DB           C3                         ret
22606                                           !BCC_EOS
22607                                           ! 3532       }
22608                                           ! 3533       if (shift_flags & 0x08) {
22609                       000066DC            .4DC:
22610                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22611 66DC           8A46         FD            mov	al,-3[bp]
22612 66DF           24                     08  and	al,*8
22613 66E1           84C0                       test	al,al
22614 66E3           74           3D            je  	.4DF
22615                       000066E5            .4E0:
22616                                           ! 3534         asciicode = scan_to_scanascii[scancode].alt;
22617                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22618 66E5           8A46         FF            mov	al,-1[bp]
22619 66E8           30E4                       xor	ah,ah
22620 66EA           89C2                       mov	dx,ax
22621 66EC           D1E0                       shl	ax,*1
22622 66EE           D1E0                       shl	ax,*1
22623 66F0           01D0                       add	ax,dx
22624 66F2           D1E0                       shl	ax,*1
22625 66F4           89C3                       mov	bx,ax
22626 66F6           81C3                 01C8  add	bx,#_scan_to_scanascii
22627                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
22628 66FA           8A47         06            mov	al,6[bx]
22629 66FD           8846         FE            mov	-2[bp],al
22630                                           !BCC_EOS
22631                                           ! 3535         scancode = scan_to_scanascii[scancode].alt >> 8;
22632                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22633 6700           8A46         FF            mov	al,-1[bp]
22634 6703           30E4                       xor	ah,ah
22635 6705           89C2                       mov	dx,ax
22636 6707           D1E0                       shl	ax,*1
22637 6709           D1E0                       shl	ax,*1
22638 670B           01D0                       add	ax,dx
22639 670D           D1E0                       shl	ax,*1
22640 670F           89C3                       mov	bx,ax
22641 6711           81C3                 01C8  add	bx,#_scan_to_scanascii
22642                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
22643 6715           8B47         06            mov	ax,6[bx]
22644 6718           88E0                       mov	al,ah
22645 671A           30E4                       xor	ah,ah
22646                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22647 671C           8846         FF            mov	-1[bp],al
22648                                           !BCC_EOS
22649                                           ! 3536       } else if (shift_flags & 0x04) {
22650 671F           E9         01AD            br 	.4E1
22651                       00006722            .4DF:
22652                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22653 6722           8A46         FD            mov	al,-3[bp]
22654 6725           24                     04  and	al,*4
22655 6727           84C0                       test	al,al
22656 6729           74           3D            je  	.4E2
22657                       0000672B            .4E3:
22658                                           ! 3537         asciicode = scan_to_scanascii[scancode].control;
22659                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22660 672B           8A46         FF            mov	al,-1[bp]
22661 672E           30E4                       xor	ah,ah
22662 6730           89C2                       mov	dx,ax
22663 6732           D1E0                       shl	ax,*1
22664 6734           D1E0                       shl	ax,*1
22665 6736           01D0                       add	ax,dx
22666 6738           D1E0                       shl	ax,*1
22667 673A           89C3                       mov	bx,ax
22668 673C           81C3                 01C8  add	bx,#_scan_to_scanascii
22669                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
22670 6740           8A47         04            mov	al,4[bx]
22671 6743           8846         FE            mov	-2[bp],al
22672                                           !BCC_EOS
22673                                           ! 3538         scancode = scan_to_scanascii[scancode].control >> 8;
22674                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22675 6746           8A46         FF            mov	al,-1[bp]
22676 6749           30E4                       xor	ah,ah
22677 674B           89C2                       mov	dx,ax
22678 674D           D1E0                       shl	ax,*1
22679 674F           D1E0                       shl	ax,*1
22680 6751           01D0                       add	ax,dx
22681 6753           D1E0                       shl	ax,*1
22682 6755           89C3                       mov	bx,ax
22683 6757           81C3                 01C8  add	bx,#_scan_to_scanascii
22684                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
22685 675B           8B47         04            mov	ax,4[bx]
22686 675E           88E0                       mov	al,ah
22687 6760           30E4                       xor	ah,ah
22688                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22689 6762           8846         FF            mov	-1[bp],al
22690                                           !BCC_EOS
22691                                           ! 3539       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
22692 6765           E9         0167            br 	.4E4
22693                       00006768            .4E2:
22694                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22695 6768           8A46         FB            mov	al,-5[bp]
22696 676B           24                     02  and	al,*2
22697                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22698 676D           84C0                       test	al,al
22699 676F           74           32            je  	.4E5
22700                       00006771            .4E7:
22701                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22702 6771           8A46         FF            mov	al,-1[bp]
22703 6774           3C                     47  cmp	al,*$47
22704 6776           72           2B            jb  	.4E5
22705                       00006778            .4E8:
22706                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22707 6778           8A46         FF            mov	al,-1[bp]
22708 677B           3C                     53  cmp	al,*$53
22709 677D           77           24            ja  	.4E5
22710                       0000677F            .4E6:
22711                                           ! 3540 
22712                                           ! 3540         asciicode = 0xe0;
22713                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22714 677F           B0                     E0  mov	al,#$E0
22715 6781           8846         FE            mov	-2[bp],al
22716                                           !BCC_EOS
22717                                           ! 3541         scancode = scan_to_scanascii[scancode].normal >> 8;
22718                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22719 6784           8A46         FF            mov	al,-1[bp]
22720 6787           30E4                       xor	ah,ah
22721 6789           89C2                       mov	dx,ax
22722 678B           D1E0                       shl	ax,*1
22723 678D           D1E0                       shl	ax,*1
22724 678F           01D0                       add	ax,dx
22725 6791           D1E0                       shl	ax,*1
22726 6793           89C3                       mov	bx,ax
22727                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22728 6795           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22729 6799           88E0                       mov	al,ah
22730 679B           30E4                       xor	ah,ah
22731                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22732 679D           8846         FF            mov	-1[bp],al
22733                                           !BCC_EOS
22734                                           ! 3542       } else if (shift_flags & 0x03) {
22735 67A0           E9         012C            br 	.4E9
22736                       000067A3            .4E5:
22737                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22738 67A3           8A46         FD            mov	al,-3[bp]
22739 67A6           24                     03  and	al,*3
22740 67A8           84C0                       test	al,al
22741 67AA         0F84         0092            beq 	.4EA
22742                       000067AE            .4EB:
22743                                           ! 3543         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22744                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22745 67AE           8A46         FF            mov	al,-1[bp]
22746 67B1           30E4                       xor	ah,ah
22747 67B3           89C2                       mov	dx,ax
22748 67B5           D1E0                       shl	ax,*1
22749 67B7           D1E0                       shl	ax,*1
22750 67B9           01D0                       add	ax,dx
22751 67BB           D1E0                       shl	ax,*1
22752 67BD           89C3                       mov	bx,ax
22753 67BF           81C3                 01C8  add	bx,#_scan_to_scanascii
22754                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22755 67C3           8A46         FD            mov	al,-3[bp]
22756 67C6           2247         08            and	al,8[bx]
22757 67C9           84C0                       test	al,al
22758 67CB           74           36            je  	.4EC
22759                       000067CD            .4ED:
22760                                           ! 3544           asciicode = scan_to_scanascii[scancode].normal;
22761                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22762 67CD           8A46         FF            mov	al,-1[bp]
22763 67D0           30E4                       xor	ah,ah
22764 67D2           89C2                       mov	dx,ax
22765 67D4           D1E0                       shl	ax,*1
22766 67D6           D1E0                       shl	ax,*1
22767 67D8           01D0                       add	ax,dx
22768 67DA           D1E0                       shl	ax,*1
22769 67DC           89C3                       mov	bx,ax
22770                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22771 67DE           8A87       01C8            mov	al,_scan_to_scanascii[bx]
22772 67E2           8846         FE            mov	-2[bp],al
22773                                           !BCC_EOS
22774                                           ! 3545           scancode = scan_to_scanascii[scancode].normal >> 8;
22775                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22776 67E5           8A46         FF            mov	al,-1[bp]
22777 67E8           30E4                       xor	ah,ah
22778 67EA           89C2                       mov	dx,ax
22779 67EC           D1E0                       shl	ax,*1
22780 67EE           D1E0                       shl	ax,*1
22781 67F0           01D0                       add	ax,dx
22782 67F2           D1E0                       shl	ax,*1
22783 67F4           89C3                       mov	bx,ax
22784                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22785 67F6           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22786 67FA           88E0                       mov	al,ah
22787 67FC           30E4                       xor	ah,ah
22788                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22789 67FE           8846         FF            mov	-1[bp],al
22790                                           !BCC_EOS
22791                                           ! 3546         } else {
22792 6801           EB           3A            jmp .4EE
22793                       00006803            .4EC:
22794                                           ! 3547           asciicode = scan_to_scanascii[scancode].shift;
22795                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22796 6803           8A46         FF            mov	al,-1[bp]
22797 6806           30E4                       xor	ah,ah
22798 6808           89C2                       mov	dx,ax
22799 680A           D1E0                       shl	ax,*1
22800 680C           D1E0                       shl	ax,*1
22801 680E           01D0                       add	ax,dx
22802 6810           D1E0                       shl	ax,*1
22803 6812           89C3                       mov	bx,ax
22804 6814           81C3                 01C8  add	bx,#_scan_to_scanascii
22805                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22806 6818           8A47         02            mov	al,2[bx]
22807 681B           8846         FE            mov	-2[bp],al
22808                                           !BCC_EOS
22809                                           ! 3548           scancode = scan_to_scanascii[scancode].shift >> 8;
22810                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22811 681E           8A46         FF            mov	al,-1[bp]
22812 6821           30E4                       xor	ah,ah
22813 6823           89C2                       mov	dx,ax
22814 6825           D1E0                       shl	ax,*1
22815 6827           D1E0                       shl	ax,*1
22816 6829           01D0                       add	ax,dx
22817 682B           D1E0                       shl	ax,*1
22818 682D           89C3                       mov	bx,ax
22819 682F           81C3                 01C8  add	bx,#_scan_to_scanascii
22820                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22821 6833           8B47         02            mov	ax,2[bx]
22822 6836           88E0                       mov	al,ah
22823 6838           30E4                       xor	ah,ah
22824                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22825 683A           8846         FF            mov	-1[bp],al
22826                                           !BCC_EOS
22827                                           ! 3549         }
22828                                           ! 3550       } else {
22829                       0000683D            .4EE:
22830 683D           E9         008F            br 	.4EF
22831                       00006840            .4EA:
22832                                           ! 3551         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22833                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22834 6840           8A46         FF            mov	al,-1[bp]
22835 6843           30E4                       xor	ah,ah
22836 6845           89C2                       mov	dx,ax
22837 6847           D1E0                       shl	ax,*1
22838 6849           D1E0                       shl	ax,*1
22839 684B           01D0                       add	ax,dx
22840 684D           D1E0                       shl	ax,*1
22841 684F           89C3                       mov	bx,ax
22842 6851           81C3                 01C8  add	bx,#_scan_to_scanascii
22843                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22844 6855           8A46         FD            mov	al,-3[bp]
22845 6858           2247         08            and	al,8[bx]
22846 685B           84C0                       test	al,al
22847 685D           74           3C            je  	.4F0
22848                       0000685F            .4F1:
22849                                           ! 3552           asciicode = scan_to_scanascii[scancode].shift;
22850                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22851 685F           8A46         FF            mov	al,-1[bp]
22852 6862           30E4                       xor	ah,ah
22853 6864           89C2                       mov	dx,ax
22854 6866           D1E0                       shl	ax,*1
22855 6868           D1E0                       shl	ax,*1
22856 686A           01D0                       add	ax,dx
22857 686C           D1E0                       shl	ax,*1
22858 686E           89C3                       mov	bx,ax
22859 6870           81C3                 01C8  add	bx,#_scan_to_scanascii
22860                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22861 6874           8A47         02            mov	al,2[bx]
22862 6877           8846         FE            mov	-2[bp],al
22863                                           !BCC_EOS
22864                                           ! 3553           scancode = scan_to_scanascii[scancode].shift >> 8;
22865                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22866 687A           8A46         FF            mov	al,-1[bp]
22867 687D           30E4                       xor	ah,ah
22868 687F           89C2                       mov	dx,ax
22869 6881           D1E0                       shl	ax,*1
22870 6883           D1E0                       shl	ax,*1
22871 6885           01D0                       add	ax,dx
22872 6887           D1E0                       shl	ax,*1
22873 6889           89C3                       mov	bx,ax
22874 688B           81C3                 01C8  add	bx,#_scan_to_scanascii
22875                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22876 688F           8B47         02            mov	ax,2[bx]
22877 6892           88E0                       mov	al,ah
22878 6894           30E4                       xor	ah,ah
22879                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22880 6896           8846         FF            mov	-1[bp],al
22881                                           !BCC_EOS
22882                                           ! 3554         } else {
22883 6899           EB           34            jmp .4F2
22884                       0000689B            .4F0:
22885                                           ! 3555           asciicode = scan_to_scanascii[scancode].normal;
22886                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22887 689B           8A46         FF            mov	al,-1[bp]
22888 689E           30E4                       xor	ah,ah
22889 68A0           89C2                       mov	dx,ax
22890 68A2           D1E0                       shl	ax,*1
22891 68A4           D1E0                       shl	ax,*1
22892 68A6           01D0                       add	ax,dx
22893 68A8           D1E0                       shl	ax,*1
22894 68AA           89C3                       mov	bx,ax
22895                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22896 68AC           8A87       01C8            mov	al,_scan_to_scanascii[bx]
22897 68B0           8846         FE            mov	-2[bp],al
22898                                           !BCC_EOS
22899                                           ! 3556           scancode = scan_to_scanascii[scancode].normal >> 8;
22900                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22901 68B3           8A46         FF            mov	al,-1[bp]
22902 68B6           30E4                       xor	ah,ah
22903 68B8           89C2                       mov	dx,ax
22904 68BA           D1E0                       shl	ax,*1
22905 68BC           D1E0                       shl	ax,*1
22906 68BE           01D0                       add	ax,dx
22907 68C0           D1E0                       shl	ax,*1
22908 68C2           89C3                       mov	bx,ax
22909                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22910 68C4           8B87       01C8            mov	ax,_scan_to_scanascii[bx]
22911 68C8           88E0                       mov	al,ah
22912 68CA           30E4                       xor	ah,ah
22913                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22914 68CC           8846         FF            mov	-1[bp],al
22915                                           !BCC_EOS
22916                                           ! 3557         }
22917                                           ! 3558       }
22918                       000068CF            .4F2:
22919                                           ! 3559       if (scancode==0 && asciicode==0) {
22920                       000068CF            .4EF:
22921                       000068CF            .4E9:
22922                       000068CF            .4E4:
22923                       000068CF            .4E1:
22924                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22925 68CF           8A46         FF            mov	al,-1[bp]
22926 68D2           84C0                       test	al,al
22927 68D4           75           15            jne 	.4F3
22928                       000068D6            .4F5:
22929                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22930 68D6           8A46         FE            mov	al,-2[bp]
22931 68D9           84C0                       test	al,al
22932 68DB           75           0E            jne 	.4F3
22933                       000068DD            .4F4:
22934                                           ! 3560         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
22935                                           ! Debug: list * char = .4F6+0 (used reg = )
22936 68DD           BB                   D281  mov	bx,#.4F6
22937 68E0           53                         push	bx
22938                                           ! Debug: list int = const 4 (used reg = )
22939 68E1           B8                   0004  mov	ax,*4
22940 68E4           50                         push	ax
22941                                           ! Debug: func () void = bios_printf+0 (used reg = )
22942 68E5           E8         A0BF            call	_bios_printf
22943 68E8           83C4                   04  add	sp,*4
22944                                           !BCC_EOS
22945                                           ! 3561       }
22946                                           ! 3562       enqueue_key(scancode, asciicode);
22947                       000068EB            .4F3:
22948                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22949 68EB           8A46         FE            mov	al,-2[bp]
22950 68EE           30E4                       xor	ah,ah
22951 68F0           50                         push	ax
22952                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22953 68F1           8A46         FF            mov	al,-1[bp]
22954 68F4           30E4                       xor	ah,ah
22955 68F6           50                         push	ax
22956                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22957 68F7           E8         008F            call	_enqueue_key
22958 68FA           83C4                   04  add	sp,*4
22959                                           !BCC_EOS
22960                                           ! 3563       break;
22961 68FD           EB           59            jmp .4B4
22962                                           !BCC_EOS
22963                                           ! 3564   }
22964                                           ! 3565   if ((scancode & 0x7f) != 0x1d) {
22965 68FF           EB           57            jmp .4B4
22966                       00006901            .4B6:
22967 6901           2C                     1D  sub	al,*$1D
22968 6903         0F84         FB4A            beq 	.4BD
22969 6907           2C                     0D  sub	al,*$D
22970 6909         0F84         FAC8            beq 	.4B9
22971 690D           2C                     0C  sub	al,*$C
22972 690F         0F84         FB00            beq 	.4BB
22973 6913           2C                     02  sub	al,*2
22974 6915         0F84         FC0E            beq 	.4C9
22975 6919           2C                     02  sub	al,*2
22976 691B         0F84         FA5C            beq 	.4B7
22977 691F           2C                     0B  sub	al,*$B
22978 6921         0F84         FCC6            beq 	.4D1
22979 6925           2C                     01  sub	al,*1
22980 6927         0F84         FD2C            beq 	.4D7
22981 692B           2C                     57  sub	al,*$57
22982 692D         0F84         FB8B            beq 	.4C3
22983 6931           2C                     0D  sub	al,*$D
22984 6933         0F84         FABD            beq 	.4BA
22985 6937           2C                     0C  sub	al,*$C
22986 6939         0F84         FAF5            beq 	.4BC
22987 693D           2C                     02  sub	al,*2
22988 693F         0F84         FC46            beq 	.4CD
22989 6943           2C                     02  sub	al,*2
22990 6945         0F84         FA6D            beq 	.4B8
22991 6949           2C                     0B  sub	al,*$B
22992 694B         0F84         FCE0            beq 	.4D4
22993 694F           2C                     01  sub	al,*1
22994 6951         0F84         FD3D            beq 	.4D8
22995 6955           E9         FD59            br 	.4D9
22996                       00006958            .4B4:
22997                       FFFFFFF8            ..FFF2	=	-8
22998                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
22999 6958           8A46         FF            mov	al,-1[bp]
23000 695B           24                     7F  and	al,*$7F
23001                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
23002 695D           3C                     1D  cmp	al,*$1D
23003 695F           74           08            je  	.4F7
23004                       00006961            .4F8:
23005                                           ! 3566     mf2_state &= ~0x01;
23006                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
23007 6961           8A46         FB            mov	al,-5[bp]
23008 6964           24                     FE  and	al,#$FE
23009 6966           8846         FB            mov	-5[bp],al
23010                                           !BCC_EOS
23011                                           ! 3567   }
23012                                           ! 3568   mf2_state &= ~0x02;
23013                       00006969            .4F7:
23014                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
23015 6969           8A46         FB            mov	al,-5[bp]
23016 696C           24                     FD  and	al,#$FD
23017 696E           8846         FB            mov	-5[bp],al
23018                                           !BCC_EOS
23019                                           ! 3569   write_byte(0x0040, 0x96, mf2_state);
23020                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
23021 6971           8A46         FB            mov	al,-5[bp]
23022 6974           30E4                       xor	ah,ah
23023 6976           50                         push	ax
23024                                           ! Debug: list int = const $96 (used reg = )
23025 6977           B8                   0096  mov	ax,#$96
23026 697A           50                         push	ax
23027                                           ! Debug: list int = const $40 (used reg = )
23028 697B           B8                   0040  mov	ax,*$40
23029 697E           50                         push	ax
23030                                           ! Debug: func () void = write_byte+0 (used reg = )
23031 697F           E8         9C9C            call	_write_byte
23032 6982           83C4                   06  add	sp,*6
23033                                           !BCC_EOS
23034                                           ! 3570 }
23035 6985           89EC                       mov	sp,bp
23036 6987           5D                         pop	bp
23037 6988           C3                         ret
23038                                           ! 3571   unsigned int
23039                                           ! Register BX used in function int09_function
23040                                           ! 3572 enqueue_key(scan_code, ascii_code)
23041                                           ! 3573   Bit8u scan_code, ascii_code;
23042                                           export	_enqueue_key
23043                       00006989            _enqueue_key:
23044                                           !BCC_EOS
23045                                           ! 3574 {
23046                                           ! 3575   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
23047                                           !BCC_EOS
23048                                           ! 3576   buffer_start = read_word(0x0040, 0x0080);
23049 6989           55                         push	bp
23050 698A           89E5                       mov	bp,sp
23051 698C           83C4                   F6  add	sp,*-$A
23052                                           ! Debug: list int = const $80 (used reg = )
23053 698F           B8                   0080  mov	ax,#$80
23054 6992           50                         push	ax
23055                                           ! Debug: list int = const $40 (used reg = )
23056 6993           B8                   0040  mov	ax,*$40
23057 6996           50                         push	ax
23058                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23059 6997           E8         9C71            call	_read_word
23060 699A           83C4                   04  add	sp,*4
23061                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
23062 699D           8946         FE            mov	-2[bp],ax
23063                                           !BCC_EOS
23064                                           ! 3577   buffer_end = read_word(0x0040, 0x0082);
23065                                           ! Debug: list int = const $82 (used reg = )
23066 69A0           B8                   0082  mov	ax,#$82
23067 69A3           50                         push	ax
23068                                           ! Debug: list int = const $40 (used reg = )
23069 69A4           B8                   0040  mov	ax,*$40
23070 69A7           50                         push	ax
23071                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23072 69A8           E8         9C60            call	_read_word
23073 69AB           83C4                   04  add	sp,*4
23074                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
23075 69AE           8946         FC            mov	-4[bp],ax
23076                                           !BCC_EOS
23077                                           ! 3578   buffer_head = read_word(0x0040, 0x001A);
23078                                           ! Debug: list int = const $1A (used reg = )
23079 69B1           B8                   001A  mov	ax,*$1A
23080 69B4           50                         push	ax
23081                                           ! Debug: list int = const $40 (used reg = )
23082 69B5           B8                   0040  mov	ax,*$40
23083 69B8           50                         push	ax
23084                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23085 69B9           E8         9C4F            call	_read_word
23086 69BC           83C4                   04  add	sp,*4
23087                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
23088 69BF           8946         FA            mov	-6[bp],ax
23089                                           !BCC_EOS
23090                                           ! 3579   buffer_tail = read_word(0x0040, 0x001C);
23091                                           ! Debug: list int = const $1C (used reg = )
23092 69C2           B8                   001C  mov	ax,*$1C
23093 69C5           50                         push	ax
23094                                           ! Debug: list int = const $40 (used reg = )
23095 69C6           B8                   0040  mov	ax,*$40
23096 69C9           50                         push	ax
23097                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23098 69CA           E8         9C3E            call	_read_word
23099 69CD           83C4                   04  add	sp,*4
23100                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23101 69D0           8946         F8            mov	-8[bp],ax
23102                                           !BCC_EOS
23103                                           ! 3580   temp_tail = buffer_tail;
23104                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
23105 69D3           8B46         F8            mov	ax,-8[bp]
23106 69D6           8946         F6            mov	-$A[bp],ax
23107                                           !BCC_EOS
23108                                           ! 3581   buffer_tail += 2;
23109                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23110 69D9           8B46         F8            mov	ax,-8[bp]
23111 69DC           40                         inc	ax
23112 69DD           40                         inc	ax
23113 69DE           8946         F8            mov	-8[bp],ax
23114                                           !BCC_EOS
23115                                           ! 3582   if (buffer_tail >= buffer_end)
23116                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23117 69E1           8B46         F8            mov	ax,-8[bp]
23118 69E4           3B46         FC            cmp	ax,-4[bp]
23119 69E7           72           06            jb  	.4F9
23120                       000069E9            .4FA:
23121                                           ! 3583     buffer_tail = buffer_start;
23122                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23123 69E9           8B46         FE            mov	ax,-2[bp]
23124 69EC           8946         F8            mov	-8[bp],ax
23125                                           !BCC_EOS
23126                                           ! 3584   if (buffer_tail == buffer_head) {
23127                       000069EF            .4F9:
23128                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
23129 69EF           8B46         F8            mov	ax,-8[bp]
23130 69F2           3B46         FA            cmp	ax,-6[bp]
23131 69F5           75           06            jne 	.4FB
23132                       000069F7            .4FC:
23133                                           ! 3585     return(0);
23134 69F7           31C0                       xor	ax,ax
23135 69F9           89EC                       mov	sp,bp
23136 69FB           5D                         pop	bp
23137 69FC           C3                         ret
23138                                           !BCC_EOS
23139                                           ! 3586   }
23140                                           ! 3587   write_byte(0x0040, temp_tail, ascii_code);
23141                       000069FD            .4FB:
23142                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
23143 69FD           8A46         06            mov	al,6[bp]
23144 6A00           30E4                       xor	ah,ah
23145 6A02           50                         push	ax
23146                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
23147 6A03           FF76         F6            push	-$A[bp]
23148                                           ! Debug: list int = const $40 (used reg = )
23149 6A06           B8                   0040  mov	ax,*$40
23150 6A09           50                         push	ax
23151                                           ! Debug: func () void = write_byte+0 (used reg = )
23152 6A0A           E8         9C11            call	_write_byte
23153 6A0D           83C4                   06  add	sp,*6
23154                                           !BCC_EOS
23155                                           ! 3588   write_byte(0x0040, temp_tail+1, scan_code);
23156                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
23157 6A10           8A46         04            mov	al,4[bp]
23158 6A13           30E4                       xor	ah,ah
23159 6A15           50                         push	ax
23160                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
23161 6A16           8B46         F6            mov	ax,-$A[bp]
23162                                           ! Debug: list unsigned int = ax+1 (used reg = )
23163 6A19           40                         inc	ax
23164 6A1A           50                         push	ax
23165                                           ! Debug: list int = const $40 (used reg = )
23166 6A1B           B8                   0040  mov	ax,*$40
23167 6A1E           50                         push	ax
23168                                           ! Debug: func () void = write_byte+0 (used reg = )
23169 6A1F           E8         9BFC            call	_write_byte
23170 6A22           83C4                   06  add	sp,*6
23171                                           !BCC_EOS
23172                                           ! 3589   write_word(0x0040, 0x001C, buffer_tail);
23173                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
23174 6A25           FF76         F8            push	-8[bp]
23175                                           ! Debug: list int = const $1C (used reg = )
23176 6A28           B8                   001C  mov	ax,*$1C
23177 6A2B           50                         push	ax
23178                                           ! Debug: list int = const $40 (used reg = )
23179 6A2C           B8                   0040  mov	ax,*$40
23180 6A2F           50                         push	ax
23181                                           ! Debug: func () void = write_word+0 (used reg = )
23182 6A30           E8         9C03            call	_write_word
23183 6A33           83C4                   06  add	sp,*6
23184                                           !BCC_EOS
23185                                           ! 3590   return(1);
23186 6A36           B8                   0001  mov	ax,*1
23187 6A39           89EC                       mov	sp,bp
23188 6A3B           5D                         pop	bp
23189 6A3C           C3                         ret
23190                                           !BCC_EOS
23191                                           ! 3591 }
23192                                           ! 3592   void
23193                                           ! 3593 int74_function(make_farcall, Z, Y, X, status)
23194                                           ! 3594   Bit16u make_farcall, Z, Y, X, status;
23195                                           export	_int74_function
23196                       00006A3D            _int74_function:
23197                                           !BCC_EOS
23198                                           ! 3595 {
23199                                           ! 3596   Bit16u ebda_seg=read_word(0x0040,0x000E);
23200 6A3D           55                         push	bp
23201 6A3E           89E5                       mov	bp,sp
23202 6A40           4C                         dec	sp
23203 6A41           4C                         dec	sp
23204                                           ! Debug: list int = const $E (used reg = )
23205 6A42           B8                   000E  mov	ax,*$E
23206 6A45           50                         push	ax
23207                                           ! Debug: list int = const $40 (used reg = )
23208 6A46           B8                   0040  mov	ax,*$40
23209 6A49           50                         push	ax
23210                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23211 6A4A           E8         9BBE            call	_read_word
23212 6A4D           83C4                   04  add	sp,*4
23213                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
23214 6A50           8946         FE            mov	-2[bp],ax
23215                                           !BCC_EOS
23216                                           ! 3597   Bit8u in_byte, index, package_count;
23217                                           !BCC_EOS
23218                                           ! 3598   Bit8u mouse_flags_1, mouse_flags_2;
23219                                           !BCC_EOS
23220                                           ! 3599 ;
23221 6A53           83C4                   FA  add	sp,*-6
23222                                           !BCC_EOS
23223                                           ! 3600   make_farcall = 0;
23224                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
23225 6A56           31C0                       xor	ax,ax
23226 6A58           8946         04            mov	4[bp],ax
23227                                           !BCC_EOS
23228                                           ! 3601   in_byte = inb(0x64);
23229                                           ! Debug: list int = const $64 (used reg = )
23230 6A5B           B8                   0064  mov	ax,*$64
23231 6A5E           50                         push	ax
23232                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23233 6A5F           E8         9AE0            call	_inb
23234 6A62           44                         inc	sp
23235 6A63           44                         inc	sp
23236                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23237 6A64           8846         FD            mov	-3[bp],al
23238                                           !BCC_EOS
23239                                           ! 3602   if ((in_byte 
23240                                           ! 3602 & 0x21) != 0x21) {
23241                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
23242 6A67           8A46         FD            mov	al,-3[bp]
23243 6A6A           24                     21  and	al,*$21
23244                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
23245 6A6C           3C                     21  cmp	al,*$21
23246 6A6E           74           04            je  	.4FD
23247                       00006A70            .4FE:
23248                                           ! 3603     return;
23249 6A70           89EC                       mov	sp,bp
23250 6A72           5D                         pop	bp
23251 6A73           C3                         ret
23252                                           !BCC_EOS
23253                                           ! 3604   }
23254                                           ! 3605   in_byte = inb(0x60);
23255                       00006A74            .4FD:
23256                                           ! Debug: list int = const $60 (used reg = )
23257 6A74           B8                   0060  mov	ax,*$60
23258 6A77           50                         push	ax
23259                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23260 6A78           E8         9AC7            call	_inb
23261 6A7B           44                         inc	sp
23262 6A7C           44                         inc	sp
23263                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23264 6A7D           8846         FD            mov	-3[bp],al
23265                                           !BCC_EOS
23266                                           ! 3606 ;
23267                                           !BCC_EOS
23268                                           ! 3607   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
23269                                           ! Debug: list int = const $26 (used reg = )
23270 6A80           B8                   0026  mov	ax,*$26
23271 6A83           50                         push	ax
23272                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23273 6A84           FF76         FE            push	-2[bp]
23274                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23275 6A87           E8         9B6E            call	_read_byte
23276 6A8A           83C4                   04  add	sp,*4
23277                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23278 6A8D           8846         FA            mov	-6[bp],al
23279                                           !BCC_EOS
23280                                           ! 3608   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
23281                                           ! Debug: list int = const $27 (used reg = )
23282 6A90           B8                   0027  mov	ax,*$27
23283 6A93           50                         push	ax
23284                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23285 6A94           FF76         FE            push	-2[bp]
23286                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23287 6A97           E8         9B5E            call	_read_byte
23288 6A9A           83C4                   04  add	sp,*4
23289                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23290 6A9D           8846         F9            mov	-7[bp],al
23291                                           !BCC_EOS
23292                                           ! 3609   if ((mouse_flags_2 & 0x80) != 0x80) {
23293                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23294 6AA0           8A46         F9            mov	al,-7[bp]
23295 6AA3           24                     80  and	al,#$80
23296                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
23297 6AA5           3C                     80  cmp	al,#$80
23298 6AA7           74           04            je  	.4FF
23299                       00006AA9            .500:
23300                                           ! 3610       return;
23301 6AA9           89EC                       mov	sp,bp
23302 6AAB           5D                         pop	bp
23303 6AAC           C3                         ret
23304                                           !BCC_EOS
23305                                           ! 3611   }
23306                                           ! 3612   package_count = mouse_flags_2 & 0x07;
23307                       00006AAD            .4FF:
23308                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23309 6AAD           8A46         F9            mov	al,-7[bp]
23310 6AB0           24                     07  and	al,*7
23311                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
23312 6AB2           8846         FB            mov	-5[bp],al
23313                                           !BCC_EOS
23314                                           ! 3613   index = mouse_flags_1 & 0x07;
23315                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23316 6AB5           8A46         FA            mov	al,-6[bp]
23317 6AB8           24                     07  and	al,*7
23318                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
23319 6ABA           8846         FC            mov	-4[bp],al
23320                                           !BCC_EOS
23321                                           ! 3614   write_byte(ebda_seg, 0x28 + index, in_byte);
23322                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
23323 6ABD           8A46         FD            mov	al,-3[bp]
23324 6AC0           30E4                       xor	ah,ah
23325 6AC2           50                         push	ax
23326                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
23327                                           ! Debug: expression subtree swapping
23328 6AC3           8A46         FC            mov	al,-4[bp]
23329 6AC6           30E4                       xor	ah,ah
23330                                           ! Debug: list unsigned int = ax+$28 (used reg = )
23331 6AC8           05                   0028  add	ax,*$28
23332 6ACB           50                         push	ax
23333                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23334 6ACC           FF76         FE            push	-2[bp]
23335                                           ! Debug: func () void = write_byte+0 (used reg = )
23336 6ACF           E8         9B4C            call	_write_byte
23337 6AD2           83C4                   06  add	sp,*6
23338                                           !BCC_EOS
23339                                           ! 3615   if ( (index+1) >= package_count ) {
23340                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
23341 6AD5           8A46         FC            mov	al,-4[bp]
23342 6AD8           30E4                       xor	ah,ah
23343                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
23344 6ADA           40                         inc	ax
23345 6ADB           50                         push	ax
23346 6ADC           8A46         FB            mov	al,-5[bp]
23347 6ADF           30E4                       xor	ah,ah
23348 6AE1           3B46         F6            cmp	ax,-$A[bp]
23349 6AE4           8D66         F8            lea	sp,-8[bp]
23350 6AE7           77           51            ja  	.501
23351                       00006AE9            .502:
23352                                           ! 3616 ;
23353                                           !BCC_EOS
23354                                           ! 3617     status = read_byte(ebda_seg, 0x0028 + 0);
23355                                           ! Debug: list int = const $28 (used reg = )
23356 6AE9           B8                   0028  mov	ax,*$28
23357 6AEC           50                         push	ax
23358                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23359 6AED           FF76         FE            push	-2[bp]
23360                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23361 6AF0           E8         9B05            call	_read_byte
23362 6AF3           83C4                   04  add	sp,*4
23363                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
23364 6AF6           30E4                       xor	ah,ah
23365 6AF8           8946         0C            mov	$C[bp],ax
23366                                           !BCC_EOS
23367                                           ! 3618     X = read_byte(ebda_seg, 0x0028 + 1);
23368                                           ! Debug: list int = const $29 (used reg = )
23369 6AFB           B8                   0029  mov	ax,*$29
23370 6AFE           50                         push	ax
23371                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23372 6AFF           FF76         FE            push	-2[bp]
23373                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23374 6B02           E8         9AF3            call	_read_byte
23375 6B05           83C4                   04  add	sp,*4
23376                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
23377 6B08           30E4                       xor	ah,ah
23378 6B0A           8946         0A            mov	$A[bp],ax
23379                                           !BCC_EOS
23380                                           ! 3619     Y = read_byte(ebda_seg, 0x0028 + 2);
23381                                           ! Debug: list int = const $2A (used reg = )
23382 6B0D           B8                   002A  mov	ax,*$2A
23383 6B10           50                         push	ax
23384                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23385 6B11           FF76         FE            push	-2[bp]
23386                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23387 6B14           E8         9AE1            call	_read_byte
23388 6B17           83C4                   04  add	sp,*4
23389                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
23390 6B1A           30E4                       xor	ah,ah
23391 6B1C           8946         08            mov	8[bp],ax
23392                                           !BCC_EOS
23393                                           ! 3620     Z = 0;
23394                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
23395 6B1F           31C0                       xor	ax,ax
23396 6B21           8946         06            mov	6[bp],ax
23397                                           !BCC_EOS
23398                                           ! 3621     mouse_flags_1 = 0;
23399                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23400 6B24           30C0                       xor	al,al
23401 6B26           8846         FA            mov	-6[bp],al
23402                                           !BCC_EOS
23403                                           ! 3622     if (mouse_flags_2 & 0x80)
23404                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23405 6B29           8A46         F9            mov	al,-7[bp]
23406 6B2C           24                     80  and	al,#$80
23407 6B2E           84C0                       test	al,al
23408 6B30           74           06            je  	.503
23409                       00006B32            .504:
23410                                           ! 3623       make_farcall = 1;
23411                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
23412 6B32           B8                   0001  mov	ax,*1
23413 6B35           8946         04            mov	4[bp],ax
23414                                           !BCC_EOS
23415                                           ! 3624     }
23416                       00006B38            .503:
23417                                           ! 3625   else {
23418 6B38           EB           07            jmp .505
23419                       00006B3A            .501:
23420                                           ! 3626     mouse_flags_1++;
23421                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23422 6B3A           8A46         FA            mov	al,-6[bp]
23423 6B3D           40                         inc	ax
23424 6B3E           8846         FA            mov	-6[bp],al
23425                                           !BCC_EOS
23426                                           ! 3627   }
23427                                           ! 3628   write_byte(ebda_seg, 0x0026, mouse_flags_1);
23428                       00006B41            .505:
23429                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23430 6B41           8A46         FA            mov	al,-6[bp]
23431 6B44           30E4                       xor	ah,ah
23432 6B46           50                         push	ax
23433                                           ! Debug: list int = const $26 (used reg = )
23434 6B47           B8                   0026  mov	ax,*$26
23435 6B4A           50                         push	ax
23436                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23437 6B4B           FF76         FE            push	-2[bp]
23438                                           ! Debug: func () void = write_byte+0 (used reg = )
23439 6B4E           E8         9ACD            call	_write_byte
23440 6B51           83C4                   06  add	sp,*6
23441                                           !BCC_EOS
23442                                           ! 3629 }
23443 6B54           89EC                       mov	sp,bp
23444 6B56           5D                         pop	bp
23445 6B57           C3                         ret
23446                                           ! 3630   void
23447                                           ! 3631 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23448                                           ! 3632   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23449                                           export	_int13_harddisk
23450                       00006B58            _int13_harddisk:
23451                                           !BCC_EOS
23452                                           ! 3633 {
23453                                           ! 3634   Bit32u lba_low, lba_high;
23454                                           !BCC_EOS
23455                                           ! 3635   Bit16u ebda_seg=read_word(0x0040,0x000E);
23456 6B58           55                         push	bp
23457 6B59           89E5                       mov	bp,sp
23458 6B5B           83C4                   F6  add	sp,*-$A
23459                                           ! Debug: list int = const $E (used reg = )
23460 6B5E           B8                   000E  mov	ax,*$E
23461 6B61           50                         push	ax
23462                                           ! Debug: list int = const $40 (used reg = )
23463 6B62           B8                   0040  mov	ax,*$40
23464 6B65           50                         push	ax
23465                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23466 6B66           E8         9AA2            call	_read_word
23467 6B69           83C4                   04  add	sp,*4
23468                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
23469 6B6C           8946         F6            mov	-$A[bp],ax
23470                                           !BCC_EOS
23471                                           ! 3636   Bit16u cylinder, head, sector;
23472                                           !BCC_EOS
23473                                           ! 3637   Bit16u segment, offset;
23474                                           !BCC_EOS
23475                                           ! 3638   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
23476                                           !BCC_EOS
23477                                           ! 3639   Bit16u size, count;
23478                                           !BCC_EOS
23479                                           ! 3640   Bit8u device, status;
23480                                           !BCC_EOS
23481                                           ! 3641   ;
23482 6B6F           83C4                   E4  add	sp,*-$1C
23483                                           !BCC_EOS
23484                                           ! 3642   write_byte(0x0040, 0x008e, 0);
23485                                           ! Debug: list int = const 0 (used reg = )
23486 6B72           31C0                       xor	ax,ax
23487 6B74           50                         push	ax
23488                                           ! Debug: list int = const $8E (used reg = )
23489 6B75           B8                   008E  mov	ax,#$8E
23490 6B78           50                         push	ax
23491                                           ! Debug: list int = const $40 (used reg = )
23492 6B79           B8                   0040  mov	ax,*$40
23493 6B7C           50                         push	ax
23494                                           ! Debug: func () void = write_byte+0 (used reg = )
23495 6B7D           E8         9A9E            call	_write_byte
23496 6B80           83C4                   06  add	sp,*6
23497                                           !BCC_EOS
23498                                           ! 3643   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
23499                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23500 6B83           8A46         10            mov	al,$10[bp]
23501                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
23502 6B86           3C                     80  cmp	al,#$80
23503 6B88           72           07            jb  	.507
23504                       00006B8A            .508:
23505                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23506 6B8A           8A46         10            mov	al,$10[bp]
23507                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
23508 6B8D           3C                     88  cmp	al,#$88
23509 6B8F           72           22            jb  	.506
23510                       00006B91            .507:
23511                                           ! 3644     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23512                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23513 6B91           8A46         10            mov	al,$10[bp]
23514                                           ! Debug: list unsigned char = al+0 (used reg = )
23515 6B94           30E4                       xor	ah,ah
23516 6B96           50                         push	ax
23517                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23518 6B97           8B46         18            mov	ax,$18[bp]
23519 6B9A           88E0                       mov	al,ah
23520 6B9C           30E4                       xor	ah,ah
23521                                           ! Debug: list unsigned int = ax+0 (used reg = )
23522 6B9E           50                         push	ax
23523                                           ! Debug: list * char = .509+0 (used reg = )
23524 6B9F           BB                   D24A  mov	bx,#.509
23525 6BA2           53                         push	bx
23526                                           ! Debug: list int = const 4 (used reg = )
23527 6BA3           B8                   0004  mov	ax,*4
23528 6BA6           50                         push	ax
23529                                           ! Debug: func () void = bios_printf+0 (used reg = )
23530 6BA7           E8         9DFD            call	_bios_printf
23531 6BAA           83C4                   08  add	sp,*8
23532                                           !BCC_EOS
23533                                           ! 3645     goto int13_fail;
23534 6BAD           83C4                   00  add	sp,#..FFF1+$28
23535 6BB0           E9         0F40            br 	.FFF1
23536                                           !BCC_EOS
23537                                           ! 3646   }
23538                                           ! 3647   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
23539                       00006BB3            .506:
23540                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23541 6BB3           8A46         10            mov	al,$10[bp]
23542                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
23543 6BB6           30E4                       xor	ah,ah
23544                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
23545 6BB8           05                   FF80  add	ax,*-$80
23546 6BBB           89C3                       mov	bx,ax
23547                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
23548                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
23549 6BBD           81C3                 0233  add	bx,#$233
23550 6BC1           53                         push	bx
23551                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23552 6BC2           FF76         F6            push	-$A[bp]
23553                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23554 6BC5           E8         9A30            call	_read_byte
23555 6BC8           83C4                   04  add	sp,*4
23556                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
23557 6BCB           8846         DB            mov	-$25[bp],al
23558                                           !BCC_EOS
23559                                           ! 3648   if (device >= (4*2)) {
23560                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
23561 6BCE           8A46         DB            mov	al,-$25[bp]
23562 6BD1           3C                     08  cmp	al,*8
23563 6BD3           72           22            jb  	.50A
23564                       00006BD5            .50B:
23565                                           ! 3649     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23566                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23567 6BD5           8A46         10            mov	al,$10[bp]
23568                                           ! Debug: list unsigned char = al+0 (used reg = )
23569 6BD8           30E4                       xor	ah,ah
23570 6BDA           50                         push	ax
23571                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23572 6BDB           8B46         18            mov	ax,$18[bp]
23573 6BDE           88E0                       mov	al,ah
23574 6BE0           30E4                       xor	ah,ah
23575                                           ! Debug: list unsigned int = ax+0 (used reg = )
23576 6BE2           50                         push	ax
23577                                           ! Debug: list * char = .50C+0 (used reg = )
23578 6BE3           BB                   D20C  mov	bx,#.50C
23579 6BE6           53                         push	bx
23580                                           ! Debug: list int = const 4 (used reg = )
23581 6BE7           B8                   0004  mov	ax,*4
23582 6BEA           50                         push	ax
23583                                           ! Debug: func () void = bios_printf+0 (used reg = )
23584 6BEB           E8         9DB9            call	_bios_printf
23585 6BEE           83C4                   08  add	sp,*8
23586                                           !BCC_EOS
23587                                           ! 3650     goto int13_fail;
23588 6BF1           83C4                   00  add	sp,#..FFF1+$28
23589 6BF4           E9         0EFC            br 	.FFF1
23590                                           !BCC_EOS
23591                                           ! 3651   }
23592                                           ! 3652   switch (( AX >> 8 )) {
23593                       00006BF7            .50A:
23594                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23595 6BF7           8B46         18            mov	ax,$18[bp]
23596 6BFA           88E0                       mov	al,ah
23597 6BFC           30E4                       xor	ah,ah
23598 6BFE           E9         0E71            br 	.50F
23599                                           ! 3653     case 0x00:
23600                                           ! 3654       ata_reset (device);
23601                       00006C01            .510:
23602                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
23603 6C01           8A46         DB            mov	al,-$25[bp]
23604 6C04           30E4                       xor	ah,ah
23605 6C06           50                         push	ax
23606                                           ! Debug: func () void = ata_reset+0 (used reg = )
23607 6C07           E8         C0C2            call	_ata_reset
23608 6C0A           44                         inc	sp
23609 6C0B           44                         inc	sp
23610                                           !BCC_EOS
23611                                           ! 3655       goto int13_success;
23612 6C0C           83C4                   0E  add	sp,#..FFEF-..FFF0
23613 6C0F           E9         0F0E            br 	.FFEF
23614                                           !BCC_EOS
23615                                           ! 3656       break;
23616 6C12           E9         0EDB            br 	.50D
23617                                           !BCC_EOS
23618                                           ! 3657     case 0x01:
23619                                           ! 3658       status = read_byte(0x0040, 0x0074);
23620                       00006C15            .511:
23621                                           ! Debug: list int = const $74 (used reg = )
23622 6C15           B8                   0074  mov	ax,*$74
23623 6C18           50                         push	ax
23624                                           ! Debug: list int = const $40 (used reg = )
23625 6C19           B8                   0040  mov	ax,*$40
23626 6C1C           50                         push	ax
23627                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23628 6C1D           E8         99D8            call	_read_byte
23629 6C20           83C4                   04  add	sp,*4
23630                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23631 6C23           8846         DA            mov	-$26[bp],al
23632                                           !BCC_EOS
23633                                           ! 3659       AX = ((AX & 0x00ff) | ((status) << 8));
23634                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
23635 6C26           8A46         DA            mov	al,-$26[bp]
23636 6C29           30E4                       xor	ah,ah
23637 6C2B           88C4                       mov	ah,al
23638 6C2D           30C0                       xor	al,al
23639 6C2F           50                         push	ax
23640                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
23641 6C30           8A46         18            mov	al,$18[bp]
23642                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23643 6C33           30E4                       xor	ah,ah
23644 6C35           0B46         CA            or	ax,0+..FFF0[bp]
23645 6C38           44                         inc	sp
23646 6C39           44                         inc	sp
23647                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23648 6C3A           8946         18            mov	$18[bp],ax
23649                                           !BCC_EOS
23650                                           ! 3660       write_byte(0x0040, 0x0074, 0);
23651                                           ! Debug: list int = const 0 (used reg = )
23652 6C3D           31C0                       xor	ax,ax
23653 6C3F           50                         push	ax
23654                                           ! Debug: list int = const $74 (used reg = )
23655 6C40           B8                   0074  mov	ax,*$74
23656 6C43           50                         push	ax
23657                                           ! Debug: list int = const $40 (used reg = )
23658 6C44           B8                   0040  mov	ax,*$40
23659 6C47           50                         push	ax
23660                                           ! Debug: func () void = write_byte+0 (used reg = )
23661 6C48           E8         99D3            call	_write_byte
23662 6C4B           83C4                   06  add	sp,*6
23663                                           !BCC_EOS
23664                                           ! 3661       if (status) goto int13_fail_nostatus;
23665 6C4E           8A46         DA            mov	al,-$26[bp]
23666 6C51           84C0                       test	al,al
23667 6C53           74           08            je  	.512
23668                       00006C55            .513:
23669 6C55           83C4                   0E  add	sp,#..FFEE-..FFF0
23670 6C58           E9         0EB9            br 	.FFEE
23671                                           !BCC_EOS
23672                                           ! 3662       else goto int13_success_noah;
23673 6C5B           EB           06            jmp .514
23674                       00006C5D            .512:
23675 6C5D           83C4                   0E  add	sp,#..FFED-..FFF0
23676 6C60           E9         0EC7            br 	.FFED
23677                                           !BCC_EOS
23678                                           ! 3663       break;
23679                       00006C63            .514:
23680 6C63           E9         0E8A            br 	.50D
23681                                           !BCC_EOS
23682                                           ! 3664     case 0x02:
23683                                           ! 3665     case 0x03:
23684                       00006C66            .515:
23685                                           ! 3666     case 0x04:
23686                       00006C66            .516:
23687                                           ! 3667       count = ( AX & 0x00ff );
23688                       00006C66            .517:
23689                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23690 6C66           8A46         18            mov	al,$18[bp]
23691                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23692 6C69           30E4                       xor	ah,ah
23693 6C6B           8946         DC            mov	-$24[bp],ax
23694                                           !BCC_EOS
23695                                           ! 3668       cylinder = ( CX >> 8 );
23696                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
23697 6C6E           8B46         16            mov	ax,$16[bp]
23698 6C71           88E0                       mov	al,ah
23699 6C73           30E4                       xor	ah,ah
23700                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23701 6C75           8946         F4            mov	-$C[bp],ax
23702                                           !BCC_EOS
23703                                           ! 3669       cylinder |= ( ((Bit16u) ( CX & 0x00ff
23704                                           ! 3669  )) << 2) & 0x300;
23705                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23706 6C78           8A46         16            mov	al,$16[bp]
23707                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
23708 6C7B           30E4                       xor	ah,ah
23709                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
23710 6C7D           D1E0                       shl	ax,*1
23711 6C7F           D1E0                       shl	ax,*1
23712                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
23713 6C81           25                   0300  and	ax,#$300
23714                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23715 6C84           0B46         F4            or	ax,-$C[bp]
23716 6C87           8946         F4            mov	-$C[bp],ax
23717                                           !BCC_EOS
23718                                           ! 3670       sector = (( CX & 0x00ff ) & 0x3f);
23719                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23720 6C8A           8A46         16            mov	al,$16[bp]
23721                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
23722 6C8D           24                     3F  and	al,*$3F
23723                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
23724 6C8F           30E4                       xor	ah,ah
23725 6C91           8946         F0            mov	-$10[bp],ax
23726                                           !BCC_EOS
23727                                           ! 3671       head = ( DX >> 8 );
23728                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
23729 6C94           8B46         14            mov	ax,$14[bp]
23730 6C97           88E0                       mov	al,ah
23731 6C99           30E4                       xor	ah,ah
23732                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
23733 6C9B           8946         F2            mov	-$E[bp],ax
23734                                           !BCC_EOS
23735                                           ! 3672       segment = ES;
23736                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
23737 6C9E           8B46         08            mov	ax,8[bp]
23738 6CA1           8946         EE            mov	-$12[bp],ax
23739                                           !BCC_EOS
23740                                           ! 3673       offset = BX;
23741                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
23742 6CA4           8B46         12            mov	ax,$12[bp]
23743 6CA7           8946         EC            mov	-$14[bp],ax
23744                                           !BCC_EOS
23745                                           ! 3674       if ((count > 128) || (count == 0) || (sector == 0)) {
23746                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23747 6CAA           8B46         DC            mov	ax,-$24[bp]
23748 6CAD           3D                   0080  cmp	ax,#$80
23749 6CB0           77           0E            ja  	.519
23750                       00006CB2            .51B:
23751                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23752 6CB2           8B46         DC            mov	ax,-$24[bp]
23753 6CB5           85C0                       test	ax,ax
23754 6CB7           74           07            je  	.519
23755                       00006CB9            .51A:
23756                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23757 6CB9           8B46         F0            mov	ax,-$10[bp]
23758 6CBC           85C0                       test	ax,ax
23759 6CBE           75           1C            jne 	.518
23760                       00006CC0            .519:
23761                                           ! 3675         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",( AX >> 8 ));
23762                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23763 6CC0           8B46         18            mov	ax,$18[bp]
23764 6CC3           88E0                       mov	al,ah
23765 6CC5           30E4                       xor	ah,ah
23766                                           ! Debug: list unsigned int = ax+0 (used reg = )
23767 6CC7           50                         push	ax
23768                                           ! Debug: list * char = .51C+0 (used reg = )
23769 6CC8           BB                   D1D4  mov	bx,#.51C
23770 6CCB           53                         push	bx
23771                                           ! Debug: list int = const 4 (used reg = )
23772 6CCC           B8                   0004  mov	ax,*4
23773 6CCF           50                         push	ax
23774                                           ! Debug: func () void = bios_printf+0 (used reg = )
23775 6CD0           E8         9CD4            call	_bios_printf
23776 6CD3           83C4                   06  add	sp,*6
23777                                           !BCC_EOS
23778                                           ! 3676         goto int13_fail;
23779 6CD6           83C4                   0E  add	sp,#..FFF1-..FFF0
23780 6CD9           E9         0E17            br 	.FFF1
23781                                           !BCC_EOS
23782                                           ! 3677       }
23783                                           ! 3678       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23784                       00006CDC            .518:
23785                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23786 6CDC           8A46         DB            mov	al,-$25[bp]
23787 6CDF           30E4                       xor	ah,ah
23788 6CE1           B9                   001E  mov	cx,*$1E
23789 6CE4           F7E9                       imul	cx
23790 6CE6           89C3                       mov	bx,ax
23791                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23792                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23793 6CE8           81C3                 014E  add	bx,#$14E
23794 6CEC           53                         push	bx
23795                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23796 6CED           FF76         F6            push	-$A[bp]
23797                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23798 6CF0           E8         9918            call	_read_word
23799 6CF3           83C4                   04  add	sp,*4
23800                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23801 6CF6           8946         E4            mov	-$1C[bp],ax
23802                                           !BCC_EOS
23803                                           ! 3679       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23804                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23805 6CF9           8A46         DB            mov	al,-$25[bp]
23806 6CFC           30E4                       xor	ah,ah
23807 6CFE           B9                   001E  mov	cx,*$1E
23808 6D01           F7E9                       imul	cx
23809 6D03           89C3                       mov	bx,ax
23810                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23811                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23812 6D05           81C3                 014C  add	bx,#$14C
23813 6D09           53                         push	bx
23814                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23815 6D0A           FF76         F6            push	-$A[bp]
23816                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23817 6D0D           E8         98FB            call	_read_word
23818 6D10           83C4                   04  add	sp,*4
23819                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23820 6D13           8946         E2            mov	-$1E[bp],ax
23821                                           !BCC_EOS
23822                                           ! 3680       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23823                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23824 6D16           8A46         DB            mov	al,-$25[bp]
23825 6D19           30E4                       xor	ah,ah
23826 6D1B           B9                   001E  mov	cx,*$1E
23827 6D1E           F7E9                       imul	cx
23828 6D20           89C3                       mov	bx,ax
23829                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23830                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23831 6D22           81C3                 0150  add	bx,#$150
23832 6D26           53                         push	bx
23833                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23834 6D27           FF76         F6            push	-$A[bp]
23835                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23836 6D2A           E8         98DE            call	_read_word
23837 6D2D           83C4                   04  add	sp,*4
23838                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23839 6D30           8946         E0            mov	-$20[bp],ax
23840                                           !BCC_EOS
23841                                           ! 3681       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
23842                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23843 6D33           8B46         F4            mov	ax,-$C[bp]
23844 6D36           3B46         E4            cmp	ax,-$1C[bp]
23845 6D39           73           10            jae 	.51E
23846                       00006D3B            .520:
23847                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23848 6D3B           8B46         F2            mov	ax,-$E[bp]
23849 6D3E           3B46         E2            cmp	ax,-$1E[bp]
23850 6D41           73           08            jae 	.51E
23851                       00006D43            .51F:
23852                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23853 6D43           8B46         F0            mov	ax,-$10[bp]
23854 6D46           3B46         E0            cmp	ax,-$20[bp]
23855 6D49           76           25            jbe 	.51D
23856                       00006D4B            .51E:
23857                                           ! 3682         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
23858                                           ! Debug: list unsigned short sector = [S+$28-$12] (used reg = )
23859 6D4B           FF76         F0            push	-$10[bp]
23860                                           ! Debug: list unsigned short head = [S+$2A-$10] (used reg = )
23861 6D4E           FF76         F2            push	-$E[bp]
23862                                           ! Debug: list unsigned short cylinder = [S+$2C-$E] (used reg = )
23863 6D51           FF76         F4            push	-$C[bp]
23864                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2E+$16] (used reg = )
23865 6D54           8B46         18            mov	ax,$18[bp]
23866 6D57           88E0                       mov	al,ah
23867 6D59           30E4                       xor	ah,ah
23868                                           ! Debug: list unsigned int = ax+0 (used reg = )
23869 6D5B           50                         push	ax
23870                                           ! Debug: list * char = .521+0 (used reg = )
23871 6D5C           BB                   D18C  mov	bx,#.521
23872 6D5F           53                         push	bx
23873                                           ! Debug: list int = const 4 (used reg = )
23874 6D60           B8                   0004  mov	ax,*4
23875 6D63           50                         push	ax
23876                                           ! Debug: func () void = bios_printf+0 (used reg = )
23877 6D64           E8         9C40            call	_bios_printf
23878 6D67           83C4                   0C  add	sp,*$C
23879                                           !BCC_EOS
23880                                           ! 3683         goto int13_fail;
23881 6D6A           83C4                   0E  add	sp,#..FFF1-..FFF0
23882 6D6D           E9         0D83            br 	.FFF1
23883                                           !BCC_EOS
23884                                           ! 3684       }
23885                                           ! 3685       if (( AX >> 8 ) == 0x04) goto int13_success;
23886                       00006D70            .51D:
23887                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23888 6D70           8B46         18            mov	ax,$18[bp]
23889 6D73           88E0                       mov	al,ah
23890 6D75           30E4                       xor	ah,ah
23891                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23892 6D77           3D                   0004  cmp	ax,*4
23893 6D7A           75           06            jne 	.522
23894                       00006D7C            .523:
23895 6D7C           83C4                   0E  add	sp,#..FFEF-..FFF0
23896 6D7F           E9         0D9E            br 	.FFEF
23897                                           !BCC_EOS
23898                                           ! 3686       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23899                       00006D82            .522:
23900                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23901 6D82           8A46         DB            mov	al,-$25[bp]
23902 6D85           30E4                       xor	ah,ah
23903 6D87           B9                   001E  mov	cx,*$1E
23904 6D8A           F7E9                       imul	cx
23905 6D8C           89C3                       mov	bx,ax
23906                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23907                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23908 6D8E           81C3                 0152  add	bx,#$152
23909 6D92           53                         push	bx
23910                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23911 6D93           FF76         F6            push	-$A[bp]
23912                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23913 6D96           E8         9872            call	_read_word
23914 6D99           83C4                   04  add	sp,*4
23915                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23916 6D9C           8946         E8            mov	-$18[bp],ax
23917                                           !BCC_EOS
23918                                           ! 3687       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23919                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23920 6D9F           8A46         DB            mov	al,-$25[bp]
23921 6DA2           30E4                       xor	ah,ah
23922 6DA4           B9                   001E  mov	cx,*$1E
23923 6DA7           F7E9                       imul	cx
23924 6DA9           89C3                       mov	bx,ax
23925                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23926                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23927 6DAB           81C3                 0156  add	bx,#$156
23928 6DAF           53                         push	bx
23929                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23930 6DB0           FF76         F6            push	-$A[bp]
23931                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23932 6DB3           E8         9855            call	_read_word
23933 6DB6           83C4                   04  add	sp,*4
23934                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23935 6DB9           8946         E6            mov	-$1A[bp],ax
23936                                           !BCC_EOS
23937                                           ! 3688       if ( (nph != nlh) || (npspt != nlspt)) {
23938                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23939 6DBC           8B46         E8            mov	ax,-$18[bp]
23940 6DBF           3B46         E2            cmp	ax,-$1E[bp]
23941 6DC2           75           08            jne 	.525
23942                       00006DC4            .526:
23943                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23944 6DC4           8B46         E6            mov	ax,-$1A[bp]
23945 6DC7           3B46         E0            cmp	ax,-$20[bp]
23946 6DCA           74           72            je  	.524
23947                       00006DCC            .525:
23948                                           ! 3689         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23949                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23950 6DCC           8B46         F0            mov	ax,-$10[bp]
23951 6DCF           31DB                       xor	bx,bx
23952 6DD1           53                         push	bx
23953 6DD2           50                         push	ax
23954                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23955 6DD3           8B46         E0            mov	ax,-$20[bp]
23956 6DD6           31DB                       xor	bx,bx
23957 6DD8           53                         push	bx
23958 6DD9           50                         push	ax
23959                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23960 6DDA           8B46         F2            mov	ax,-$E[bp]
23961 6DDD           31DB                       xor	bx,bx
23962 6DDF           53                         push	bx
23963 6DE0           50                         push	ax
23964                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23965 6DE1           8B46         E2            mov	ax,-$1E[bp]
23966 6DE4           31DB                       xor	bx,bx
23967 6DE6           53                         push	bx
23968 6DE7           50                         push	ax
23969                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23970 6DE8           8B46         F4            mov	ax,-$C[bp]
23971 6DEB           31DB                       xor	bx,bx
23972                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23973 6DED           8D7E         BC            lea	di,-$E+..FFF0[bp]
23974 6DF0           E8         92F6            call	lmulul
23975 6DF3           83C4                   04  add	sp,*4
23976                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23977 6DF6           8D7E         C0            lea	di,-$A+..FFF0[bp]
23978 6DF9           E8         92C7            call	laddul
23979 6DFC           83C4                   04  add	sp,*4
23980                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23981 6DFF           8D7E         C4            lea	di,-6+..FFF0[bp]
23982 6E02           E8         92E4            call	lmulul
23983 6E05           83C4                   04  add	sp,*4
23984                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23985 6E08           8D7E         C8            lea	di,-2+..FFF0[bp]
23986 6E0B           E8         92B5            call	laddul
23987 6E0E           83C4                   04  add	sp,*4
23988                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23989 6E11           53                         push	bx
23990 6E12           50                         push	ax
23991 6E13           B8                   0001  mov	ax,*1
23992 6E16           31DB                       xor	bx,bx
23993 6E18           53                         push	bx
23994 6E19           50                         push	ax
23995 6E1A           8B46         C8            mov	ax,-2+..FFF0[bp]
23996 6E1D           8B5E         CA            mov	bx,0+..FFF0[bp]
23997 6E20           8D7E         C4            lea	di,-6+..FFF0[bp]
23998 6E23           E8         92BB            call	lsubul
23999 6E26           83C4                   08  add	sp,*8
24000                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24001 6E29           8946         FC            mov	-4[bp],ax
24002 6E2C           895E         FE            mov	-2[bp],bx
24003                                           !BCC_EOS
24004                                           ! 3690         lba_high = 0;
24005                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24006 6E2F           31C0                       xor	ax,ax
24007 6E31           31DB                       xor	bx,bx
24008 6E33           8946         F8            mov	-8[bp],ax
24009 6E36           895E         FA            mov	-6[bp],bx
24010                                           !BCC_EOS
24011                                           ! 3691         sector = 0;
24012                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
24013 6E39           31C0                       xor	ax,ax
24014 6E3B           8946         F0            mov	-$10[bp],ax
24015                                           !BCC_EOS
24016                                           ! 3692       }
24017                                           ! 3693       if (( AX >> 8 ) == 0x02)
24018                       00006E3E            .524:
24019                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24020 6E3E           8B46         18            mov	ax,$18[bp]
24021 6E41           88E0                       mov	al,ah
24022 6E43           30E4                       xor	ah,ah
24023                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
24024 6E45           3D                   0002  cmp	ax,*2
24025 6E48           75           33            jne 	.527
24026                       00006E4A            .528:
24027                                           ! 3694         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
24028                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24029 6E4A           FF76         EC            push	-$14[bp]
24030                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24031 6E4D           FF76         EE            push	-$12[bp]
24032                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24033 6E50           FF76         FA            push	-6[bp]
24034 6E53           FF76         F8            push	-8[bp]
24035                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24036 6E56           FF76         FE            push	-2[bp]
24037 6E59           FF76         FC            push	-4[bp]
24038                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
24039 6E5C           FF76         F0            push	-$10[bp]
24040                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
24041 6E5F           FF76         F2            push	-$E[bp]
24042                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
24043 6E62           FF76         F4            push	-$C[bp]
24044                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24045 6E65           FF76         DC            push	-$24[bp]
24046                                           ! Debug: list int = const $20 (used reg = )
24047 6E68           B8                   0020  mov	ax,*$20
24048 6E6B           50                         push	ax
24049                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24050 6E6C           8A46         DB            mov	al,-$25[bp]
24051 6E6F           30E4                       xor	ah,ah
24052 6E71           50                         push	ax
24053                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24054 6E72           E8         BFAF            call	_ata_cmd_data_in
24055 6E75           83C4                   18  add	sp,*$18
24056                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24057 6E78           8846         DA            mov	-$26[bp],al
24058                                           !BCC_EOS
24059                                           ! 3695       else
24060                                           ! 3696         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
24061 6E7B           EB           31            jmp .529
24062                       00006E7D            .527:
24063                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24064 6E7D           FF76         EC            push	-$14[bp]
24065                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24066 6E80           FF76         EE            push	-$12[bp]
24067                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24068 6E83           FF76         FA            push	-6[bp]
24069 6E86           FF76         F8            push	-8[bp]
24070                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24071 6E89           FF76         FE            push	-2[bp]
24072 6E8C           FF76         FC            push	-4[bp]
24073                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
24074 6E8F           FF76         F0            push	-$10[bp]
24075                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
24076 6E92           FF76         F2            push	-$E[bp]
24077                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
24078 6E95           FF76         F4            push	-$C[bp]
24079                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24080 6E98           FF76         DC            push	-$24[bp]
24081                                           ! Debug: list int = const $30 (used reg = )
24082 6E9B           B8                   0030  mov	ax,*$30
24083 6E9E           50                         push	ax
24084                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24085 6E9F           8A46         DB            mov	al,-$25[bp]
24086 6EA2           30E4                       xor	ah,ah
24087 6EA4           50                         push	ax
24088                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24089 6EA5           E8         C365            call	_ata_cmd_data_out
24090 6EA8           83C4                   18  add	sp,*$18
24091                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24092 6EAB           8846         DA            mov	-$26[bp],al
24093                                           !BCC_EOS
24094                                           ! 3697       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
24095                       00006EAE            .529:
24096                                           ! Debug: list * unsigned short = const $254 (used reg = )
24097 6EAE           B8                   0254  mov	ax,#$254
24098 6EB1           50                         push	ax
24099                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24100 6EB2           FF76         F6            push	-$A[bp]
24101                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24102 6EB5           E8         9753            call	_read_word
24103 6EB8           83C4                   04  add	sp,*4
24104 6EBB           50                         push	ax
24105                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
24106 6EBC           8B46         18            mov	ax,$18[bp]
24107 6EBF           30C0                       xor	al,al
24108                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
24109 6EC1           0B46         CA            or	ax,0+..FFF0[bp]
24110 6EC4           44                         inc	sp
24111 6EC5           44                         inc	sp
24112                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24113 6EC6           8946         18            mov	$18[bp],ax
24114                                           !BCC_EOS
24115                                           ! 3698       if (status != 0) {
24116                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24117 6EC9           8A46         DA            mov	al,-$26[bp]
24118 6ECC           84C0                       test	al,al
24119 6ECE           74           2D            je  	.52A
24120                       00006ED0            .52B:
24121                                           ! 3699         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
24122                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
24123 6ED0           8A46         DA            mov	al,-$26[bp]
24124 6ED3           30E4                       xor	ah,ah
24125 6ED5           50                         push	ax
24126                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
24127 6ED6           8B46         18            mov	ax,$18[bp]
24128 6ED9           88E0                       mov	al,ah
24129 6EDB           30E4                       xor	ah,ah
24130                                           ! Debug: list unsigned int = ax+0 (used reg = )
24131 6EDD           50                         push	ax
24132                                           ! Debug: list * char = .52C+0 (used reg = )
24133 6EDE           BB                   D15F  mov	bx,#.52C
24134 6EE1           53                         push	bx
24135                                           ! Debug: list int = const 4 (used reg = )
24136 6EE2           B8                   0004  mov	ax,*4
24137 6EE5           50                         push	ax
24138                                           ! Debug: func () void = bios_printf+0 (used reg = )
24139 6EE6           E8         9ABE            call	_bios_printf
24140 6EE9           83C4                   08  add	sp,*8
24141                                           !BCC_EOS
24142                                           ! 3700         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24143                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24144 6EEC           8A46         18            mov	al,$18[bp]
24145                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24146 6EEF           30E4                       xor	ah,ah
24147 6EF1           0D                   0C00  or	ax,#$C00
24148                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24149 6EF4           8946         18            mov	$18[bp],ax
24150                                           !BCC_EOS
24151                                           ! 3701         goto int13_fail_noah;
24152 6EF7           83C4                   0E  add	sp,#..FFEC-..FFF0
24153 6EFA           E9         0C01            br 	.FFEC
24154                                           !BCC_EOS
24155                                           ! 3702       }
24156                                           ! 3703       goto int13_success;
24157                       00006EFD            .52A:
24158 6EFD           83C4                   0E  add	sp,#..FFEF-..FFF0
24159 6F00           E9         0C1D            br 	.FFEF
24160                                           !BCC_EOS
24161                                           ! 3704       break;
24162 6F03           E9         0BEA            br 	.50D
24163                                           !BCC_EOS
24164                                           ! 3705     case 0x05:
24165                                           ! 3706       bios_printf(4, "format disk track called\n");
24166                       00006F06            .52D:
24167                                           ! Debug: list * char = .52E+0 (used reg = )
24168 6F06           BB                   D145  mov	bx,#.52E
24169 6F09           53                         push	bx
24170                                           ! Debug: list int = const 4 (used reg = )
24171 6F0A           B8                   0004  mov	ax,*4
24172 6F0D           50                         push	ax
24173                                           ! Debug: func () void = bios_printf+0 (used reg = )
24174 6F0E           E8         9A96            call	_bios_printf
24175 6F11           83C4                   04  add	sp,*4
24176                                           !BCC_EOS
24177                                           ! 3707       goto int13_success;
24178 6F14           83C4                   0E  add	sp,#..FFEF-..FFF0
24179 6F17           E9         0C06            br 	.FFEF
24180                                           !BCC_EOS
24181                                           ! 3708       return;
24182 6F1A           89EC                       mov	sp,bp
24183 6F1C           5D                         pop	bp
24184 6F1D           C3                         ret
24185                                           !BCC_EOS
24186                                           ! 3709       break;
24187 6F1E           E9         0BCF            br 	.50D
24188                                           !BCC_EOS
24189                                           ! 3710     case 0x08:
24190                                           ! 3711       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices
24191                       00006F21            .52F:
24192                                           ! 3711 [device].lchs.cylinders);
24193                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24194 6F21           8A46         DB            mov	al,-$25[bp]
24195 6F24           30E4                       xor	ah,ah
24196 6F26           B9                   001E  mov	cx,*$1E
24197 6F29           F7E9                       imul	cx
24198 6F2B           89C3                       mov	bx,ax
24199                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24200                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24201 6F2D           81C3                 014E  add	bx,#$14E
24202 6F31           53                         push	bx
24203                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24204 6F32           FF76         F6            push	-$A[bp]
24205                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24206 6F35           E8         96D3            call	_read_word
24207 6F38           83C4                   04  add	sp,*4
24208                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24209 6F3B           8946         E4            mov	-$1C[bp],ax
24210                                           !BCC_EOS
24211                                           ! 3712       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24212                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24213 6F3E           8A46         DB            mov	al,-$25[bp]
24214 6F41           30E4                       xor	ah,ah
24215 6F43           B9                   001E  mov	cx,*$1E
24216 6F46           F7E9                       imul	cx
24217 6F48           89C3                       mov	bx,ax
24218                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24219                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24220 6F4A           81C3                 014C  add	bx,#$14C
24221 6F4E           53                         push	bx
24222                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24223 6F4F           FF76         F6            push	-$A[bp]
24224                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24225 6F52           E8         96B6            call	_read_word
24226 6F55           83C4                   04  add	sp,*4
24227                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24228 6F58           8946         E2            mov	-$1E[bp],ax
24229                                           !BCC_EOS
24230                                           ! 3713       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24231                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24232 6F5B           8A46         DB            mov	al,-$25[bp]
24233 6F5E           30E4                       xor	ah,ah
24234 6F60           B9                   001E  mov	cx,*$1E
24235 6F63           F7E9                       imul	cx
24236 6F65           89C3                       mov	bx,ax
24237                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24238                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24239 6F67           81C3                 0150  add	bx,#$150
24240 6F6B           53                         push	bx
24241                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24242 6F6C           FF76         F6            push	-$A[bp]
24243                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24244 6F6F           E8         9699            call	_read_word
24245 6F72           83C4                   04  add	sp,*4
24246                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24247 6F75           8946         E0            mov	-$20[bp],ax
24248                                           !BCC_EOS
24249                                           ! 3714       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
24250                                           ! Debug: list * unsigned char = const $232 (used reg = )
24251 6F78           B8                   0232  mov	ax,#$232
24252 6F7B           50                         push	ax
24253                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24254 6F7C           FF76         F6            push	-$A[bp]
24255                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24256 6F7F           E8         9676            call	_read_byte
24257 6F82           83C4                   04  add	sp,*4
24258                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
24259 6F85           30E4                       xor	ah,ah
24260 6F87           8946         DC            mov	-$24[bp],ax
24261                                           !BCC_EOS
24262                                           ! 3715       nlc = nlc - 2;
24263                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24264 6F8A           8B46         E4            mov	ax,-$1C[bp]
24265                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24266 6F8D           48                         dec	ax
24267 6F8E           48                         dec	ax
24268 6F8F           8946         E4            mov	-$1C[bp],ax
24269                                           !BCC_EOS
24270                                           ! 3716       AX = ((AX & 0xff00) | (0));
24271                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
24272 6F92           8B46         18            mov	ax,$18[bp]
24273 6F95           30C0                       xor	al,al
24274                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
24275 6F97           0C                     00  or	al,*0
24276                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24277 6F99           8946         18            mov	$18[bp],ax
24278                                           !BCC_EOS
24279                                           ! 3717       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
24280                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
24281 6F9C           8A46         E4            mov	al,-$1C[bp]
24282                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
24283 6F9F           30E4                       xor	ah,ah
24284 6FA1           88C4                       mov	ah,al
24285 6FA3           30C0                       xor	al,al
24286 6FA5           50                         push	ax
24287                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
24288 6FA6           8A46         16            mov	al,$16[bp]
24289                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24290 6FA9           30E4                       xor	ah,ah
24291 6FAB           0B46         CA            or	ax,0+..FFF0[bp]
24292 6FAE           44                         inc	sp
24293 6FAF           44                         inc	sp
24294                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24295 6FB0           8946         16            mov	$16[bp],ax
24296                                           !BCC_EOS
24297                                           ! 3718       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
24298                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
24299 6FB3           8A46         E0            mov	al,-$20[bp]
24300 6FB6           24                     3F  and	al,*$3F
24301 6FB8           50                         push	ax
24302                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
24303 6FB9           8B46         E4            mov	ax,-$1C[bp]
24304 6FBC           D1E8                       shr	ax,*1
24305 6FBE           D1E8                       shr	ax,*1
24306                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
24307 6FC0           24                     C0  and	al,#$C0
24308                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24309 6FC2           0A46         CA            or	al,0+..FFF0[bp]
24310 6FC5           44                         inc	sp
24311 6FC6           44                         inc	sp
24312 6FC7           50                         push	ax
24313                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
24314 6FC8           8B46         16            mov	ax,$16[bp]
24315 6FCB           30C0                       xor	al,al
24316                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
24317 6FCD           0A46         CA            or	al,0+..FFF0[bp]
24318 6FD0           44                         inc	sp
24319 6FD1           44                         inc	sp
24320                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24321 6FD2           8946         16            mov	$16[bp],ax
24322                                           !BCC_EOS
24323                                           ! 3719       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
24324                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
24325 6FD5           8B46         E2            mov	ax,-$1E[bp]
24326                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
24327 6FD8           48                         dec	ax
24328 6FD9           88C4                       mov	ah,al
24329 6FDB           30C0                       xor	al,al
24330 6FDD           50                         push	ax
24331                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
24332 6FDE           8A46         14            mov	al,$14[bp]
24333                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24334 6FE1           30E4                       xor	ah,ah
24335 6FE3           0B46         CA            or	ax,0+..FFF0[bp]
24336 6FE6           44                         inc	sp
24337 6FE7           44                         inc	sp
24338                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24339 6FE8           8946         14            mov	$14[bp],ax
24340                                           !BCC_EOS
24341                                           ! 3720       DX = ((DX & 0xff00) | (count));
24342                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
24343 6FEB           8B46         14            mov	ax,$14[bp]
24344 6FEE           30C0                       xor	al,al
24345                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
24346 6FF0           0B46         DC            or	ax,-$24[bp]
24347                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24348 6FF3           8946         14            mov	$14[bp],ax
24349                                           !BCC_EOS
24350                                           ! 3721       goto int13_success;
24351 6FF6           83C4                   0E  add	sp,#..FFEF-..FFF0
24352 6FF9           E9         0B24            br 	.FFEF
24353                                           !BCC_EOS
24354                                           ! 3722       break;
24355 6FFC           E9         0AF1            br 	.50D
24356                                           !BCC_EOS
24357                                           ! 3723     case 0x10:
24358                                           ! 3724       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
24359                       00006FFF            .530:
24360                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
24361 6FFF           8A46         DB            mov	al,-$25[bp]
24362 7002           30E4                       xor	ah,ah
24363 7004           D1E8                       shr	ax,*1
24364                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
24365 7006           B1                     03  mov	cl,*3
24366 7008           D3E0                       shl	ax,cl
24367 700A           89C3                       mov	bx,ax
24368                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24369                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24370 700C           81C3                 0124  add	bx,#$124
24371 7010           53                         push	bx
24372                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24373 7011           FF76         F6            push	-$A[bp]
24374                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24375 7014           E8         95F4            call	_read_word
24376 7017           83C4                   04  add	sp,*4
24377                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
24378                                           ! Debug: list unsigned int = ax+7 (used reg = )
24379 701A           05                   0007  add	ax,*7
24380 701D           50                         push	ax
24381                                           ! Debug: func () unsigned char = inb+0 (used reg = )
24382 701E           E8         9521            call	_inb
24383 7021           44                         inc	sp
24384 7022           44                         inc	sp
24385                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
24386 7023           8846         DA            mov	-$26[bp],al
24387                                           !BCC_EOS
24388                                           ! 3725       if ( (status & (0x80 | 0x40)) == 0x40 ) {
24389                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
24390 7026           8A46         DA            mov	al,-$26[bp]
24391 7029           24                     C0  and	al,#$C0
24392                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
24393 702B           3C                     40  cmp	al,*$40
24394 702D           75           08            jne 	.531
24395                       0000702F            .532:
24396                                           ! 3726         goto int13_success;
24397 702F           83C4                   0E  add	sp,#..FFEF-..FFF0
24398 7032           E9         0AEB            br 	.FFEF
24399                                           !BCC_EOS
24400                                           ! 3727       }
24401                                           ! 3728       else {
24402 7035           EB           11            jmp .533
24403                       00007037            .531:
24404                                           ! 3729         AX = ((AX & 0x00ff) | ((0xAA) << 8));
24405                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24406 7037           8A46         18            mov	al,$18[bp]
24407                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
24408 703A           30E4                       xor	ah,ah
24409 703C           0D                   AA00  or	ax,#-$5600
24410                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24411 703F           8946         18            mov	$18[bp],ax
24412                                           !BCC_EOS
24413                                           ! 3730         goto int13_fail_noah;
24414 7042           83C4                   0E  add	sp,#..FFEC-..FFF0
24415 7045           E9         0AB6            br 	.FFEC
24416                                           !BCC_EOS
24417                                           ! 3731       }
24418                                           ! 3732       break;
24419                       00007048            .533:
24420 7048           E9         0AA5            br 	.50D
24421                                           !BCC_EOS
24422                                           ! 3733     case 0x15:
24423                                           ! 3734       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
24424                       0000704B            .534:
24425                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24426 704B           8A46         DB            mov	al,-$25[bp]
24427 704E           30E4                       xor	ah,ah
24428 7050           B9                   001E  mov	cx,*$1E
24429 7053           F7E9                       imul	cx
24430 7055           89C3                       mov	bx,ax
24431                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24432                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24433 7057           81C3                 014E  add	bx,#$14E
24434 705B           53                         push	bx
24435                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24436 705C           FF76         F6            push	-$A[bp]
24437                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24438 705F           E8         95A9            call	_read_word
24439 7062           83C4                   04  add	sp,*4
24440                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24441 7065           8946         E4            mov	-$1C[bp],ax
24442                                           !BCC_EOS
24443                                           ! 3735       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24444                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24445 7068           8A46         DB            mov	al,-$25[bp]
24446 706B           30E4                       xor	ah,ah
24447 706D           B9                   001E  mov	cx,*$1E
24448 7070           F7E9                       imul	cx
24449 7072           89C3                       mov	bx,ax
24450                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24451                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24452 7074           81C3                 014C  add	bx,#$14C
24453 7078           53                         push	bx
24454                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24455 7079           FF76         F6            push	-$A[bp]
24456                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24457 707C           E8         958C            call	_read_word
24458 707F           83C4                   04  add	sp,*4
24459                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24460 7082           8946         E2            mov	-$1E[bp],ax
24461                                           !BCC_EOS
24462                                           ! 3736       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24463                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24464 7085           8A46         DB            mov	al,-$25[bp]
24465 7088           30E4                       xor	ah,ah
24466 708A           B9                   001E  mov	cx,*$1E
24467 708D           F7E9                       imul	cx
24468 708F           89C3                       mov	bx,ax
24469                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24470                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24471 7091           81C3                 0150  add	bx,#$150
24472 7095           53                         push	bx
24473                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24474 7096           FF76         F6            push	-$A[bp]
24475                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24476 7099           E8         956F            call	_read_word
24477 709C           83C4                   04  add	sp,*4
24478                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24479 709F           8946         E0            mov	-$20[bp],ax
24480                                           !BCC_EOS
24481                                           ! 3737       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
24482                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24483 70A2           8B46         E0            mov	ax,-$20[bp]
24484 70A5           31DB                       xor	bx,bx
24485 70A7           53                         push	bx
24486 70A8           50                         push	ax
24487                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
24488 70A9           8B46         E2            mov	ax,-$1E[bp]
24489 70AC           31DB                       xor	bx,bx
24490 70AE           53                         push	bx
24491 70AF           50                         push	ax
24492                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
24493 70B0           8B46         E4            mov	ax,-$1C[bp]
24494                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
24495 70B3           48                         dec	ax
24496 70B4           31DB                       xor	bx,bx
24497                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
24498 70B6           8D7E         C4            lea	di,-6+..FFF0[bp]
24499 70B9           E8         902D            call	lmulul
24500 70BC           83C4                   04  add	sp,*4
24501                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
24502 70BF           8D7E         C8            lea	di,-2+..FFF0[bp]
24503 70C2           E8         9024            call	lmulul
24504 70C5           83C4                   04  add	sp,*4
24505                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24506 70C8           8946         FC            mov	-4[bp],ax
24507 70CB           895E         FE            mov	-2[bp],bx
24508                                           !BCC_EOS
24509                                           ! 3738       CX = lba_low >> 16;
24510                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
24511 70CE           8B46         FC            mov	ax,-4[bp]
24512 70D1           8B5E         FE            mov	bx,-2[bp]
24513 70D4           93                         xchg	bx,ax
24514 70D5           31DB                       xor	bx,bx
24515                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
24516 70D7           8946         16            mov	$16[bp],ax
24517                                           !BCC_EOS
24518                                           ! 3739       DX = lba_low & 0xffff;
24519                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
24520                                           ! Debug: expression subtree swapping
24521 70DA           B8                   FFFF  mov	ax,#$FFFF
24522 70DD           31DB                       xor	bx,bx
24523 70DF           8D7E         FC            lea	di,-4[bp]
24524 70E2           E8         8FD6            call	landul
24525                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
24526 70E5           8946         14            mov	$14[bp],ax
24527                                           !BCC_EOS
24528                                           ! 3740       AX = ((AX & 0x00ff) | ((3) << 8));
24529                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24530 70E8           8A46         18            mov	al,$18[bp]
24531                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
24532 70EB           30E4                       xor	ah,ah
24533 70ED           0D                   0300  or	ax,#$300
24534                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24535 70F0           8946         18            mov	$18[bp],ax
24536                                           !BCC_EOS
24537                                           ! 3741       goto int13_success_noah;
24538 70F3           83C4                   0E  add	sp,#..FFED-..FFF0
24539 70F6           E9         0A31            br 	.FFED
24540                                           !BCC_EOS
24541                                           ! 3742       break;
24542 70F9           E9         09F4            br 	.50D
24543                                           !BCC_EOS
24544                                           ! 3743     case 0x41:
24545                                           ! 3744       BX=0xaa55;
24546                       000070FC            .535:
24547                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
24548 70FC           B8                   AA55  mov	ax,#$AA55
24549 70FF           8946         12            mov	$12[bp],ax
24550                                           !BCC_EOS
24551                                           ! 3745       AX = ((AX & 0x00ff) | ((0x30) << 8));
24552                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24553 7102           8A46         18            mov	al,$18[bp]
24554                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
24555 7105           30E4                       xor	ah,ah
24556 7107           0D                   3000  or	ax,#$3000
24557                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24558 710A           8946         18            mov	$18[bp],ax
24559                                           !BCC_EOS
24560                                           ! 3746       CX=0x0007;
24561                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
24562 710D           B8                   0007  mov	ax,*7
24563 7110           8946         16            mov	$16[bp],ax
24564                                           !BCC_EOS
24565                                           ! 3747       goto int13_success_noah;
24566 7113           83C4                   0E  add	sp,#..FFED-..FFF0
24567 7116           E9         0A11            br 	.FFED
24568                                           !BCC_EOS
24569                                           ! 3748       break;
24570 7119           E9         09D4            br 	.50D
24571                                           !BCC_EOS
24572                                           ! 3749     case 0x42:
24573                                           ! 3750     case 0x43:
24574                       0000711C            .536:
24575                                           ! 3751     case 0x44:
24576                       0000711C            .537:
24577                                           ! 3752     case 0x47:
24578                       0000711C            .538:
24579                                           ! 3753       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
24580                       0000711C            .539:
24581                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
24582 711C           8B46         0C            mov	ax,$C[bp]
24583                                           ! Debug: list unsigned int = ax+2 (used reg = )
24584 711F           40                         inc	ax
24585 7120           40                         inc	ax
24586 7121           50                         push	ax
24587                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24588 7122           FF76         06            push	6[bp]
24589                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24590 7125           E8         94E3            call	_read_word
24591 7128           83C4                   04  add	sp,*4
24592                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24593 712B           8946         DC            mov	-$24[bp],ax
24594                                           !BCC_EOS
24595                                           ! 3754       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
24596                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
24597 712E           8B46         0C            mov	ax,$C[bp]
24598                                           ! Debug: list unsigned int = ax+6 (used reg = )
24599 7131           05                   0006  add	ax,*6
24600 7134           50                         push	ax
24601                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24602 7135           FF76         06            push	6[bp]
24603                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24604 7138           E8         94D0            call	_read_word
24605 713B           83C4                   04  add	sp,*4
24606                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
24607 713E           8946         EE            mov	-$12[bp],ax
24608                                           !BCC_EOS
24609                                           ! 3755       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
24610                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
24611 7141           8B46         0C            mov	ax,$C[bp]
24612                                           ! Debug: list unsigned int = ax+4 (used reg = )
24613 7144           05                   0004  add	ax,*4
24614 7147           50                         push	ax
24615                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24616 7148           FF76         06            push	6[bp]
24617                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24618 714B           E8         94BD            call	_read_word
24619 714E           83C4                   04  add	sp,*4
24620                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
24621 7151           8946         EC            mov	-$14[bp],ax
24622                                           !BCC_EOS
24623                                           ! 3756       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
24624                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
24625 7154           8B46         0C            mov	ax,$C[bp]
24626                                           ! Debug: list unsigned int = ax+$C (used reg = )
24627 7157           05                   000C  add	ax,*$C
24628 715A           50                         push	ax
24629                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24630 715B           FF76         06            push	6[bp]
24631                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24632 715E           E8         8F22            call	_read_dword
24633 7161           89D3                       mov	bx,dx
24634 7163           83C4                   04  add	sp,*4
24635                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24636 7166           8946         F8            mov	-8[bp],ax
24637 7169           895E         FA            mov	-6[bp],bx
24638                                           !BCC_EOS
24639                                           ! 3757       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
24640                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24641 716C           8A46         DB            mov	al,-$25[bp]
24642 716F           30E4                       xor	ah,ah
24643 7171           B9                   001E  mov	cx,*$1E
24644 7174           F7E9                       imul	cx
24645 7176           89C3                       mov	bx,ax
24646                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24647                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24648 7178           81C3                 015C  add	bx,#$15C
24649 717C           53                         push	bx
24650                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24651 717D           FF76         F6            push	-$A[bp]
24652                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24653 7180           E8         8F00            call	_read_dword
24654 7183           89D3                       mov	bx,dx
24655 7185           83C4                   04  add	sp,*4
24656                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24657 7188           8D7E         F8            lea	di,-8[bp]
24658 718B           E8         8F3D            call	lcmpul
24659 718E           73           1C            jae 	.53A
24660                       00007190            .53B:
24661                                           ! 3758         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24662                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24663 7190           8B46         18            mov	ax,$18[bp]
24664 7193           88E0                       mov	al,ah
24665 7195           30E4                       xor	ah,ah
24666                                           ! Debug: list unsigned int = ax+0 (used reg = )
24667 7197           50                         push	ax
24668                                           ! Debug: list * char = .53C+0 (used reg = )
24669 7198           BB                   D114  mov	bx,#.53C
24670 719B           53                         push	bx
24671                                           ! Debug: list int = const 4 (used reg = )
24672 719C           B8                   0004  mov	ax,*4
24673 719F           50                         push	ax
24674                                           ! Debug: func () void = bios_printf+0 (used reg = )
24675 71A0           E8         9804            call	_bios_printf
24676 71A3           83C4                   06  add	sp,*6
24677                                           !BCC_EOS
24678                                           ! 3759         goto int13_fail;
24679 71A6           83C4                   0E  add	sp,#..FFF1-..FFF0
24680 71A9           E9         0947            br 	.FFF1
24681                                           !BCC_EOS
24682                                           ! 3760  
24683                                           ! 3760      }
24684                                           ! 3761       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24685                       000071AC            .53A:
24686                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
24687 71AC           8B46         0C            mov	ax,$C[bp]
24688                                           ! Debug: list unsigned int = ax+8 (used reg = )
24689 71AF           05                   0008  add	ax,*8
24690 71B2           50                         push	ax
24691                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24692 71B3           FF76         06            push	6[bp]
24693                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24694 71B6           E8         8ECA            call	_read_dword
24695 71B9           89D3                       mov	bx,dx
24696 71BB           83C4                   04  add	sp,*4
24697                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24698 71BE           8946         FC            mov	-4[bp],ax
24699 71C1           895E         FE            mov	-2[bp],bx
24700                                           !BCC_EOS
24701                                           ! 3762       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
24702                                           ! 3763           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
24703                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24704 71C4           8A46         DB            mov	al,-$25[bp]
24705 71C7           30E4                       xor	ah,ah
24706 71C9           B9                   001E  mov	cx,*$1E
24707 71CC           F7E9                       imul	cx
24708 71CE           89C3                       mov	bx,ax
24709                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24710                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24711 71D0           81C3                 015C  add	bx,#$15C
24712 71D4           53                         push	bx
24713                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24714 71D5           FF76         F6            push	-$A[bp]
24715                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24716 71D8           E8         8EA8            call	_read_dword
24717 71DB           89D3                       mov	bx,dx
24718 71DD           83C4                   04  add	sp,*4
24719                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24720                                           ! Debug: expression subtree swapping
24721 71E0           8D7E         F8            lea	di,-8[bp]
24722 71E3           E8         8EE5            call	lcmpul
24723 71E6           75           40            jne 	.53D
24724                       000071E8            .53F:
24725                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24726 71E8           8A46         DB            mov	al,-$25[bp]
24727 71EB           30E4                       xor	ah,ah
24728 71ED           B9                   001E  mov	cx,*$1E
24729 71F0           F7E9                       imul	cx
24730 71F2           89C3                       mov	bx,ax
24731                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24732                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24733 71F4           81C3                 0158  add	bx,#$158
24734 71F8           53                         push	bx
24735                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24736 71F9           FF76         F6            push	-$A[bp]
24737                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24738 71FC           E8         8E84            call	_read_dword
24739 71FF           89D3                       mov	bx,dx
24740 7201           83C4                   04  add	sp,*4
24741                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24742 7204           8D7E         FC            lea	di,-4[bp]
24743 7207           E8         8EC1            call	lcmpul
24744 720A           77           1C            ja  	.53D
24745                       0000720C            .53E:
24746                                           ! 3764         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24747                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24748 720C           8B46         18            mov	ax,$18[bp]
24749 720F           88E0                       mov	al,ah
24750 7211           30E4                       xor	ah,ah
24751                                           ! Debug: list unsigned int = ax+0 (used reg = )
24752 7213           50                         push	ax
24753                                           ! Debug: list * char = .540+0 (used reg = )
24754 7214           BB                   D0E3  mov	bx,#.540
24755 7217           53                         push	bx
24756                                           ! Debug: list int = const 4 (used reg = )
24757 7218           B8                   0004  mov	ax,*4
24758 721B           50                         push	ax
24759                                           ! Debug: func () void = bios_printf+0 (used reg = )
24760 721C           E8         9788            call	_bios_printf
24761 721F           83C4                   06  add	sp,*6
24762                                           !BCC_EOS
24763                                           ! 3765         goto int13_fail;
24764 7222           83C4                   0E  add	sp,#..FFF1-..FFF0
24765 7225           E9         08CB            br 	.FFF1
24766                                           !BCC_EOS
24767                                           ! 3766       }
24768                                           ! 3767       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24769                       00007228            .53D:
24770                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24771 7228           8B46         18            mov	ax,$18[bp]
24772 722B           88E0                       mov	al,ah
24773 722D           30E4                       xor	ah,ah
24774                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24775 722F           3D                   0044  cmp	ax,*$44
24776 7232           74           0C            je  	.542
24777                       00007234            .543:
24778                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24779 7234           8B46         18            mov	ax,$18[bp]
24780 7237           88E0                       mov	al,ah
24781 7239           30E4                       xor	ah,ah
24782                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24783 723B           3D                   0047  cmp	ax,*$47
24784 723E           75           06            jne 	.541
24785                       00007240            .542:
24786                                           ! 3768         goto int13_success;
24787 7240           83C4                   0E  add	sp,#..FFEF-..FFF0
24788 7243           E9         08DA            br 	.FFEF
24789                                           !BCC_EOS
24790                                           ! 3769       if (( AX >> 8 ) == 0x42)
24791                       00007246            .541:
24792                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24793 7246           8B46         18            mov	ax,$18[bp]
24794 7249           88E0                       mov	al,ah
24795 724B           30E4                       xor	ah,ah
24796                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
24797 724D           3D                   0042  cmp	ax,*$42
24798 7250           75           33            jne 	.544
24799                       00007252            .545:
24800                                           ! 3770         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24801                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24802 7252           FF76         EC            push	-$14[bp]
24803                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24804 7255           FF76         EE            push	-$12[bp]
24805                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24806 7258           FF76         FA            push	-6[bp]
24807 725B           FF76         F8            push	-8[bp]
24808                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24809 725E           FF76         FE            push	-2[bp]
24810 7261           FF76         FC            push	-4[bp]
24811                                           ! Debug: list int = const 0 (used reg = )
24812 7264           31C0                       xor	ax,ax
24813 7266           50                         push	ax
24814                                           ! Debug: list int = const 0 (used reg = )
24815 7267           31C0                       xor	ax,ax
24816 7269           50                         push	ax
24817                                           ! Debug: list int = const 0 (used reg = )
24818 726A           31C0                       xor	ax,ax
24819 726C           50                         push	ax
24820                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24821 726D           FF76         DC            push	-$24[bp]
24822                                           ! Debug: list int = const $20 (used reg = )
24823 7270           B8                   0020  mov	ax,*$20
24824 7273           50                         push	ax
24825                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24826 7274           8A46         DB            mov	al,-$25[bp]
24827 7277           30E4                       xor	ah,ah
24828 7279           50                         push	ax
24829                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24830 727A           E8         BBA7            call	_ata_cmd_data_in
24831 727D           83C4                   18  add	sp,*$18
24832                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24833 7280           8846         DA            mov	-$26[bp],al
24834                                           !BCC_EOS
24835                                           ! 3771       else
24836                                           ! 3772         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24837 7283           EB           31            jmp .546
24838                       00007285            .544:
24839                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24840 7285           FF76         EC            push	-$14[bp]
24841                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24842 7288           FF76         EE            push	-$12[bp]
24843                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24844 728B           FF76         FA            push	-6[bp]
24845 728E           FF76         F8            push	-8[bp]
24846                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24847 7291           FF76         FE            push	-2[bp]
24848 7294           FF76         FC            push	-4[bp]
24849                                           ! Debug: list int = const 0 (used reg = )
24850 7297           31C0                       xor	ax,ax
24851 7299           50                         push	ax
24852                                           ! Debug: list int = const 0 (used reg = )
24853 729A           31C0                       xor	ax,ax
24854 729C           50                         push	ax
24855                                           ! Debug: list int = const 0 (used reg = )
24856 729D           31C0                       xor	ax,ax
24857 729F           50                         push	ax
24858                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24859 72A0           FF76         DC            push	-$24[bp]
24860                                           ! Debug: list int = const $30 (used reg = )
24861 72A3           B8                   0030  mov	ax,*$30
24862 72A6           50                         push	ax
24863                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24864 72A7           8A46         DB            mov	al,-$25[bp]
24865 72AA           30E4                       xor	ah,ah
24866 72AC           50                         push	ax
24867                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24868 72AD           E8         BF5D            call	_ata_cmd_data_out
24869 72B0           83C4                   18  add	sp,*$18
24870                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24871 72B3           8846         DA            mov	-$26[bp],al
24872                                           !BCC_EOS
24873                                           ! 3773       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24874                       000072B6            .546:
24875                                           ! Debug: list * unsigned short = const $254 (used reg = )
24876 72B6           B8                   0254  mov	ax,#$254
24877 72B9           50                         push	ax
24878                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24879 72BA           FF76         F6            push	-$A[bp]
24880                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24881 72BD           E8         934B            call	_read_word
24882 72C0           83C4                   04  add	sp,*4
24883                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24884 72C3           8946         DC            mov	-$24[bp],ax
24885                                           !BCC_EOS
24886                                           ! 3774       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24887                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24888 72C6           FF76         DC            push	-$24[bp]
24889                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24890 72C9           8B46         0C            mov	ax,$C[bp]
24891                                           ! Debug: list unsigned int = ax+2 (used reg = )
24892 72CC           40                         inc	ax
24893 72CD           40                         inc	ax
24894 72CE           50                         push	ax
24895                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24896 72CF           FF76         06            push	6[bp]
24897                                           ! Debug: func () void = write_word+0 (used reg = )
24898 72D2           E8         9361            call	_write_word
24899 72D5           83C4                   06  add	sp,*6
24900                                           !BCC_EOS
24901                                           ! 3775       if (status != 0) {
24902                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24903 72D8           8A46         DA            mov	al,-$26[bp]
24904 72DB           84C0                       test	al,al
24905 72DD           74           2D            je  	.547
24906                       000072DF            .548:
24907                                           ! 3776         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
24908                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
24909 72DF           8A46         DA            mov	al,-$26[bp]
24910 72E2           30E4                       xor	ah,ah
24911 72E4           50                         push	ax
24912                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
24913 72E5           8B46         18            mov	ax,$18[bp]
24914 72E8           88E0                       mov	al,ah
24915 72EA           30E4                       xor	ah,ah
24916                                           ! Debug: list unsigned int = ax+0 (used reg = )
24917 72EC           50                         push	ax
24918                                           ! Debug: list * char = .549+0 (used reg = )
24919 72ED           BB                   D0B6  mov	bx,#.549
24920 72F0           53                         push	bx
24921                                           ! Debug: list int = const 4 (used reg = )
24922 72F1           B8                   0004  mov	ax,*4
24923 72F4           50                         push	ax
24924                                           ! Debug: func () void = bios_printf+0 (used reg = )
24925 72F5           E8         96AF            call	_bios_printf
24926 72F8           83C4                   08  add	sp,*8
24927                                           !BCC_EOS
24928                                           ! 3777         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24929                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24930 72FB           8A46         18            mov	al,$18[bp]
24931                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24932 72FE           30E4                       xor	ah,ah
24933 7300           0D                   0C00  or	ax,#$C00
24934                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24935 7303           8946         18            mov	$18[bp],ax
24936                                           !BCC_EOS
24937                                           ! 3778         goto int13_fail_noah;
24938 7306           83C4                   0E  add	sp,#..FFEC-..FFF0
24939 7309           E9         07F2            br 	.FFEC
24940                                           !BCC_EOS
24941                                           ! 3779       }
24942                                           ! 3780       goto int13_success;
24943                       0000730C            .547:
24944 730C           83C4                   0E  add	sp,#..FFEF-..FFF0
24945 730F           E9         080E            br 	.FFEF
24946                                           !BCC_EOS
24947                                           ! 3781       break;
24948 7312           E9         07DB            br 	.50D
24949                                           !BCC_EOS
24950                                           ! 3782     case 0x45:
24951                                           ! 3783     case 0x49:
24952                       00007315            .54A:
24953                                           ! 3784       goto int13_success;
24954                       00007315            .54B:
24955 7315           83C4                   0E  add	sp,#..FFEF-..FFF0
24956 7318           E9         0805            br 	.FFEF
24957                                           !BCC_EOS
24958                                           ! 3785       break;
24959 731B           E9         07D2            br 	.50D
24960                                           !BCC_EOS
24961                                           ! 3786     case 0x46:
24962                                           ! 3787       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24963                       0000731E            .54C:
24964                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24965 731E           8A46         18            mov	al,$18[bp]
24966                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24967 7321           30E4                       xor	ah,ah
24968 7323           0D                   B200  or	ax,#-$4E00
24969                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24970 7326           8946         18            mov	$18[bp],ax
24971                                           !BCC_EOS
24972                                           ! 3788       goto int13_fail_noah;
24973 7329           83C4                   0E  add	sp,#..FFEC-..FFF0
24974 732C           E9         07CF            br 	.FFEC
24975                                           !BCC_EOS
24976                                           ! 3789       break;
24977 732F           E9         07BE            br 	.50D
24978                                           !BCC_EOS
24979                                           ! 3790     case 0x48:
24980                                           ! 3791       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24981                       00007332            .54D:
24982                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24983 7332           8B46         0C            mov	ax,$C[bp]
24984                                           ! Debug: list unsigned int = ax+0 (used reg = )
24985 7335           50                         push	ax
24986                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24987 7336           FF76         06            push	6[bp]
24988                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24989 7339           E8         92CF            call	_read_word
24990 733C           83C4                   04  add	sp,*4
24991                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
24992 733F           8946         DE            mov	-$22[bp],ax
24993                                           !BCC_EOS
24994                                           ! 3792       if(size < 0x1a)
24995                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24996 7342           8B46         DE            mov	ax,-$22[bp]
24997 7345           3D                   001A  cmp	ax,*$1A
24998 7348           73           06            jae 	.54E
24999                       0000734A            .54F:
25000                                           ! 3793         goto int13_fail;
25001 734A           83C4                   0E  add	sp,#..FFF1-..FFF0
25002 734D           E9         07A3            br 	.FFF1
25003                                           !BCC_EOS
25004                                           ! 3794       if(size >= 0x1a) {
25005                       00007350            .54E:
25006                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
25007 7350           8B46         DE            mov	ax,-$22[bp]
25008 7353           3D                   001A  cmp	ax,*$1A
25009 7356         0F82         01E3            blo 	.550
25010                       0000735A            .551:
25011                                           ! 3795         Bit16u blksize;
25012                                           !BCC_EOS
25013                                           ! 3796         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
25014                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25015 735A           8A46         DB            mov	al,-$25[bp]
25016 735D           30E4                       xor	ah,ah
25017 735F           B9                   001E  mov	cx,*$1E
25018 7362           F7E9                       imul	cx
25019 7364           89C3                       mov	bx,ax
25020                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
25021                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
25022 7366           81C3                 0154  add	bx,#$154
25023 736A           53                         push	bx
25024                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25025 736B           FF76         F6            push	-$A[bp]
25026                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25027 736E           E8         929A            call	_read_word
25028 7371           83C4                   04  add	sp,*4
25029                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
25030 7374           8946         EA            mov	-$16[bp],ax
25031                                           !BCC_EOS
25032                                           ! 3797         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
25033                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25034 7377           8A46         DB            mov	al,-$25[bp]
25035 737A           30E4                       xor	ah,ah
25036 737C           B9                   001E  mov	cx,*$1E
25037 737F           F7E9                       imul	cx
25038 7381           89C3                       mov	bx,ax
25039                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
25040                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
25041 7383           81C3                 0152  add	bx,#$152
25042 7387           53                         push	bx
25043                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25044 7388           FF76         F6            push	-$A[bp]
25045                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25046 738B           E8         927D            call	_read_word
25047 738E           83C4                   04  add	sp,*4
25048                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25049 7391           8946         E8            mov	-$18[bp],ax
25050                                           !BCC_EOS
25051                                           ! 3798         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
25052                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25053 7394           8A46         DB            mov	al,-$25[bp]
25054 7397           30E4                       xor	ah,ah
25055 7399           B9                   001E  mov	cx,*$1E
25056 739C           F7E9                       imul	cx
25057 739E           89C3                       mov	bx,ax
25058                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
25059                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
25060 73A0           81C3                 0156  add	bx,#$156
25061 73A4           53                         push	bx
25062                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25063 73A5           FF76         F6            push	-$A[bp]
25064                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25065 73A8           E8         9260            call	_read_word
25066 73AB           83C4                   04  add	sp,*4
25067                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
25068 73AE           8946         E6            mov	-$1A[bp],ax
25069                                           !BCC_EOS
25070                                           ! 3799         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
25071                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25072 73B1           8A46         DB            mov	al,-$25[bp]
25073 73B4           30E4                       xor	ah,ah
25074 73B6           B9                   001E  mov	cx,*$1E
25075 73B9           F7E9                       imul	cx
25076 73BB           89C3                       mov	bx,ax
25077                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
25078                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
25079 73BD           81C3                 0158  add	bx,#$158
25080 73C1           53                         push	bx
25081                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25082 73C2           FF76         F6            push	-$A[bp]
25083                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
25084 73C5           E8         8CBB            call	_read_dword
25085 73C8           89D3                       mov	bx,dx
25086 73CA           83C4                   04  add	sp,*4
25087                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
25088 73CD           8946         FC            mov	-4[bp],ax
25089 73D0           895E         FE            mov	-2[bp],bx
25090                                           !BCC_EOS
25091                                           ! 3800         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
25092                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25093 73D3           8A46         DB            mov	al,-$25[bp]
25094 73D6           30E4                       xor	ah,ah
25095 73D8           B9                   001E  mov	cx,*$1E
25096 73DB           F7E9                       imul	cx
25097 73DD           89C3                       mov	bx,ax
25098                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
25099                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
25100 73DF           81C3                 015C  add	bx,#$15C
25101 73E3           53                         push	bx
25102                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25103 73E4           FF76         F6            push	-$A[bp]
25104                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
25105 73E7           E8         8C99            call	_read_dword
25106 73EA           89D3                       mov	bx,dx
25107 73EC           83C4                   04  add	sp,*4
25108                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
25109 73EF           8946         F8            mov	-8[bp],ax
25110 73F2           895E         FA            mov	-6[bp],bx
25111                                           !BCC_EOS
25112                                           ! 3801         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
25113                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
25114 73F5           8A46         DB            mov	al,-$25[bp]
25115 73F8           30E4                       xor	ah,ah
25116 73FA           B9                   001E  mov	cx,*$1E
25117 73FD           F7E9                       imul	cx
25118 73FF           89C3                       mov	bx,ax
25119                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
25120                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
25121 7401           81C3                 0148  add	bx,#$148
25122 7405           53                         push	bx
25123                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
25124 7406           FF76         F6            push	-$A[bp]
25125                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25126 7409           E8         91FF            call	_read_word
25127 740C           83C4                   04  add	sp,*4
25128                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
25129 740F           8946         D8            mov	-$28[bp],ax
25130                                           !BCC_EOS
25131                                           ! 3802         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)
25132                                           ! 3802 ->size, 0x1a);
25133                                           ! Debug: list int = const $1A (used reg = )
25134 7412           B8                   001A  mov	ax,*$1A
25135 7415           50                         push	ax
25136                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
25137 7416           8B46         0C            mov	ax,$C[bp]
25138                                           ! Debug: list unsigned int = ax+0 (used reg = )
25139 7419           50                         push	ax
25140                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25141 741A           FF76         06            push	6[bp]
25142                                           ! Debug: func () void = write_word+0 (used reg = )
25143 741D           E8         9216            call	_write_word
25144 7420           83C4                   06  add	sp,*6
25145                                           !BCC_EOS
25146                                           ! 3803         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
25147 7423           8B46         F8            mov	ax,-8[bp]
25148 7426           8B5E         FA            mov	bx,-6[bp]
25149 7429           E8         8CE8            call	ltstl
25150 742C           75           50            jne 	.553
25151                       0000742E            .554:
25152                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25153 742E           8B46         E8            mov	ax,-$18[bp]
25154 7431           31DB                       xor	bx,bx
25155 7433           53                         push	bx
25156 7434           50                         push	ax
25157                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
25158 7435           8B46         E6            mov	ax,-$1A[bp]
25159 7438           31DB                       xor	bx,bx
25160                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
25161 743A           53                         push	bx
25162 743B           50                         push	ax
25163 743C           8B46         FC            mov	ax,-4[bp]
25164 743F           8B5E         FE            mov	bx,-2[bp]
25165 7442           8D7E         C4            lea	di,-6+..FFF0[bp]
25166 7445           E8         8D26            call	ldivul
25167 7448           83C4                   04  add	sp,*4
25168                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
25169 744B           8D7E         C8            lea	di,-2+..FFF0[bp]
25170 744E           E8         8D1D            call	ldivul
25171 7451           83C4                   04  add	sp,*4
25172                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
25173 7454           53                         push	bx
25174 7455           50                         push	ax
25175 7456           B8                   3FFF  mov	ax,#$3FFF
25176 7459           31DB                       xor	bx,bx
25177 745B           53                         push	bx
25178 745C           50                         push	ax
25179 745D           8B46         C8            mov	ax,-2+..FFF0[bp]
25180 7460           8B5E         CA            mov	bx,0+..FFF0[bp]
25181 7463           8D7E         C4            lea	di,-6+..FFF0[bp]
25182 7466           E8         8C62            call	lcmpul
25183 7469           76           04            jbe	.555
25184 746B           B0                     01  mov	al,*1
25185 746D           EB           02            jmp	.556
25186                       0000746F            .555:
25187 746F           30C0                       xor	al,al
25188                       00007471            .556:
25189 7471           83C4                   08  add	sp,*8
25190                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
25191 7474           30E4                       xor	ah,ah
25192 7476           99                         cwd
25193 7477           89D3                       mov	bx,dx
25194 7479           E8         8C98            call	ltstl
25195 747C           74           28            je  	.552
25196                       0000747E            .553:
25197                                           ! 3804         {
25198                                           ! 3805           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
25199                                           ! Debug: list int = const 0 (used reg = )
25200 747E           31C0                       xor	ax,ax
25201 7480           50                         push	ax
25202                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25203 7481           8B46         0C            mov	ax,$C[bp]
25204                                           ! Debug: list unsigned int = ax+2 (used reg = )
25205 7484           40                         inc	ax
25206 7485           40                         inc	ax
25207 7486           50                         push	ax
25208                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25209 7487           FF76         06            push	6[bp]
25210                                           ! Debug: func () void = write_word+0 (used reg = )
25211 748A           E8         91A9            call	_write_word
25212 748D           83C4                   06  add	sp,*6
25213                                           !BCC_EOS
25214                                           ! 3806           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
25215                                           ! Debug: list int = const $3FFF (used reg = )
25216 7490           B8                   3FFF  mov	ax,#$3FFF
25217 7493           50                         push	ax
25218                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
25219 7494           8B46         0C            mov	ax,$C[bp]
25220                                           ! Debug: list unsigned int = ax+4 (used reg = )
25221 7497           05                   0004  add	ax,*4
25222 749A           50                         push	ax
25223                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25224 749B           FF76         06            push	6[bp]
25225                                           ! Debug: func () void = write_dword+0 (used reg = )
25226 749E           E8         8BFA            call	_write_dword
25227 74A1           83C4                   06  add	sp,*6
25228                                           !BCC_EOS
25229                                           ! 3807         }
25230                                           ! 3808         else
25231                                           ! 3809         {
25232 74A4           EB           2A            jmp .558
25233                       000074A6            .552:
25234                                           ! 3810           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
25235                                           ! Debug: list int = const 2 (used reg = )
25236 74A6           B8                   0002  mov	ax,*2
25237 74A9           50                         push	ax
25238                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25239 74AA           8B46         0C            mov	ax,$C[bp]
25240                                           ! Debug: list unsigned int = ax+2 (used reg = )
25241 74AD           40                         inc	ax
25242 74AE           40                         inc	ax
25243 74AF           50                         push	ax
25244                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25245 74B0           FF76         06            push	6[bp]
25246                                           ! Debug: func () void = write_word+0 (used reg = )
25247 74B3           E8         9180            call	_write_word
25248 74B6           83C4                   06  add	sp,*6
25249                                           !BCC_EOS
25250                                           ! 3811           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
25251                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
25252 74B9           8B46         EA            mov	ax,-$16[bp]
25253 74BC           31DB                       xor	bx,bx
25254                                           ! Debug: list unsigned long = bx+0 (used reg = )
25255 74BE           53                         push	bx
25256 74BF           50                         push	ax
25257                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
25258 74C0           8B46         0C            mov	ax,$C[bp]
25259                                           ! Debug: list unsigned int = ax+4 (used reg = )
25260 74C3           05                   0004  add	ax,*4
25261 74C6           50                         push	ax
25262                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25263 74C7           FF76         06            push	6[bp]
25264                                           ! Debug: func () void = write_dword+0 (used reg = )
25265 74CA           E8         8BCE            call	_write_dword
25266 74CD           83C4                   08  add	sp,*8
25267                                           !BCC_EOS
25268                                           ! 3812         }
25269                                           ! 3813         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
25270                       000074D0            .558:
25271                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25272 74D0           8B46         E8            mov	ax,-$18[bp]
25273 74D3           31DB                       xor	bx,bx
25274                                           ! Debug: list unsigned long = bx+0 (used reg = )
25275 74D5           53                         push	bx
25276 74D6           50                         push	ax
25277                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
25278 74D7           8B46         0C            mov	ax,$C[bp]
25279                                           ! Debug: list unsigned int = ax+8 (used reg = )
25280 74DA           05                   0008  add	ax,*8
25281 74DD           50                         push	ax
25282                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25283 74DE           FF76         06            push	6[bp]
25284                                           ! Debug: func () void = write_dword+0 (used reg = )
25285 74E1           E8         8BB7            call	_write_dword
25286 74E4           83C4                   08  add	sp,*8
25287                                           !BCC_EOS
25288                                           ! 3814         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
25289                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
25290 74E7           8B46         E6            mov	ax,-$1A[bp]
25291 74EA           31DB                       xor	bx,bx
25292                                           ! Debug: list unsigned long = bx+0 (used reg = )
25293 74EC           53                         push	bx
25294 74ED           50                         push	ax
25295                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
25296 74EE           8B46         0C            mov	ax,$C[bp]
25297                                           ! Debug: list unsigned int = ax+$C (used reg = )
25298 74F1           05                   000C  add	ax,*$C
25299 74F4           50                         push	ax
25300                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25301 74F5           FF76         06            push	6[bp]
25302                                           ! Debug: func () void = write_dword+0 (used reg = )
25303 74F8           E8         8BA0            call	_write_dword
25304 74FB           83C4                   08  add	sp,*8
25305                                           !BCC_EOS
25306                                           ! 3815         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
25307                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
25308 74FE           FF76         FE            push	-2[bp]
25309 7501           FF76         FC            push	-4[bp]
25310                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
25311 7504           8B46         0C            mov	ax,$C[bp]
25312                                           ! Debug: list unsigned int = ax+$10 (used reg = )
25313 7507           05                   0010  add	ax,*$10
25314 750A           50                         push	ax
25315                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25316 750B           FF76         06            push	6[bp]
25317                                           ! Debug: func () void = write_dword+0 (used reg = )
25318 750E           E8         8B8A            call	_write_dword
25319 7511           83C4                   08  add	sp,*8
25320                                           !BCC_EOS
25321                                           ! 3816         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
25322                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
25323 7514           FF76         FA            push	-6[bp]
25324 7517           FF76         F8            push	-8[bp]
25325                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
25326 751A           8B46         0C            mov	ax,$C[bp]
25327                                           ! Debug: list unsigned int = ax+$14 (used reg = )
25328 751D           05                   0014  add	ax,*$14
25329 7520           50                         push	ax
25330                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25331 7521           FF76         06            push	6[bp]
25332                                           ! Debug: func () void = write_dword+0 (used reg = )
25333 7524           E8         8B74            call	_write_dword
25334 7527           83C4                   08  add	sp,*8
25335                                           !BCC_EOS
25336                                           ! 3817         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
25337                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
25338 752A           FF76         D8            push	-$28[bp]
25339                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
25340 752D           8B46         0C            mov	ax,$C[bp]
25341                                           ! Debug: list unsigned int = ax+$18 (used reg = )
25342 7530           05                   0018  add	ax,*$18
25343 7533           50                         push	ax
25344                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25345 7534           FF76         06            push	6[bp]
25346                                           ! Debug: func () void = write_word+0 (used reg = )
25347 7537           E8         90FC            call	_write_word
25348 753A           83C4                   06  add	sp,*6
25349                                           !BCC_EOS
25350                                           ! 3818       }
25351                                           ! 3819       if(size >= 0x1e) {
25352                       0000753D            .550:
25353                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
25354 753D           8B46         DE            mov	ax,-$22[bp]
25355 7540           3D                   001E  cmp	ax,*$1E
25356 7543         0F82         0273            blo 	.559
25357                       00007547            .55A:
25358                                           ! 3820         Bit8u channel, dev, irq, mode, checksum, i, translation;
25359                                           !BCC_EOS
25360                                           ! 3821         Bit16u iobase1, iobase2, options;
25361                                           !BCC_EOS
25362                                           ! 3822         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
25363                                           ! Debug: list int = const $1E (used reg = )
25364 7547           B8                   001E  mov	ax,*$1E
25365 754A           50                         push	ax
25366                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
25367 754B           8B46         0C            mov	ax,$C[bp]
25368                                           ! Debug: list unsigned int = ax+0 (used reg = )
25369 754E           50                         push	ax
25370                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25371 754F           FF76         06            push	6[bp]
25372                                           ! Debug: func () void = write_word+0 (used reg = )
25373 7552           E8         90E1            call	_write_word
25374 7555           83C4                   06  add	sp,*6
25375                                           !BCC_EOS
25376                                           ! 3823         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
25377                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
25378 7558           FF76         F6            push	-$A[bp]
25379                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
25380 755B           8B46         0C            mov	ax,$C[bp]
25381                                           ! Debug: list unsigned int = ax+$1C (used reg = )
25382 755E           05                   001C  add	ax,*$1C
25383 7561           50                         push	ax
25384                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25385 7562           FF76         06            push	6[bp]
25386                                           ! Debug: func () void = write_word+0 (used reg = )
25387 7565           E8         90CE            call	_write_word
25388 7568           83C4                   06  add	sp,*6
25389                                           !BCC_EOS
25390                                           ! 3824         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
25391                                           ! Debug: list * struct  = const $244 (used reg = )
25392 756B           B8                   0244  mov	ax,#$244
25393 756E           50                         push	ax
25394                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
25395 756F           8B46         0C            mov	ax,$C[bp]
25396                                           ! Debug: list unsigned int = ax+$1A (used reg = )
25397 7572           05                   001A  add	ax,*$1A
25398 7575           50                         push	ax
25399                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25400 7576           FF76         06            push	6[bp]
25401                                           ! Debug: func () void = write_word+0 (used reg = )
25402 7579           E8         90BA            call	_write_word
25403 757C           83C4                   06  add	sp,*6
25404                                           !BCC_EOS
25405                                           ! 3825         channel = device / 2;
25406                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25407 757F           8A46         DB            mov	al,-$25[bp]
25408 7582           30E4                       xor	ah,ah
25409 7584           D1E8                       shr	ax,*1
25410                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
25411 7586           8846         D9            mov	-$27[bp],al
25412                                           !BCC_EOS
25413                                           ! 3826         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25414                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25415 7589           8A46         D9            mov	al,-$27[bp]
25416 758C           30E4                       xor	ah,ah
25417 758E           B1                     03  mov	cl,*3
25418 7590           D3E0                       shl	ax,cl
25419 7592           89C3                       mov	bx,ax
25420                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25421                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25422 7594           81C3                 0124  add	bx,#$124
25423 7598           53                         push	bx
25424                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25425 7599           FF76         F6            push	-$A[bp]
25426                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25427 759C           E8         906C            call	_read_word
25428 759F           83C4                   04  add	sp,*4
25429                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
25430 75A2           8946         D0            mov	-$30[bp],ax
25431                                           !BCC_EOS
25432                                           ! 3827         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
25433                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25434 75A5           8A46         D9            mov	al,-$27[bp]
25435 75A8           30E4                       xor	ah,ah
25436 75AA           B1                     03  mov	cl,*3
25437 75AC           D3E0                       shl	ax,cl
25438 75AE           89C3                       mov	bx,ax
25439                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
25440                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
25441 75B0           81C3                 0126  add	bx,#$126
25442 75B4           53                         push	bx
25443                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25444 75B5           FF76         F6            push	-$A[bp]
25445                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25446 75B8           E8         9050            call	_read_word
25447 75BB           83C4                   04  add	sp,*4
25448                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25449 75BE           8946         CE            mov	-$32[bp],ax
25450                                           !BCC_EOS
25451                                           ! 3828         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
25452                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25453 75C1           8A46         D9            mov	al,-$27[bp]
25454 75C4           30E4                       xor	ah,ah
25455 75C6           B1                     03  mov	cl,*3
25456 75C8           D3E0                       shl	ax,cl
25457 75CA           89C3                       mov	bx,ax
25458                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
25459                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
25460 75CC           81C3                 0128  add	bx,#$128
25461 75D0           53                         push	bx
25462                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25463 75D1           FF76         F6            push	-$A[bp]
25464                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25465 75D4           E8         9021            call	_read_byte
25466 75D7           83C4                   04  add	sp,*4
25467                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
25468 75DA           8846         D7            mov	-$29[bp],al
25469                                           !BCC_EOS
25470                                           ! 3829         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
25471                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25472 75DD           8A46         DB            mov	al,-$25[bp]
25473 75E0           30E4                       xor	ah,ah
25474 75E2           B9                   001E  mov	cx,*$1E
25475 75E5           F7E9                       imul	cx
25476 75E7           89C3                       mov	bx,ax
25477                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
25478                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
25479 75E9           81C3                 0146  add	bx,#$146
25480 75ED           53                         push	bx
25481                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25482 75EE           FF76         F6            push	-$A[bp]
25483                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25484 75F1           E8         9004            call	_read_byte
25485 75F4           83C4                   04  add	sp,*4
25486                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
25487 75F7           8846         D6            mov	-$2A[bp],al
25488                                           !BCC_EOS
25489                                           ! 3830         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
25490                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25491 75FA           8A46         DB            mov	al,-$25[bp]
25492 75FD           30E4                       xor	ah,ah
25493 75FF           B9                   001E  mov	cx,*$1E
25494 7602           F7E9                       imul	cx
25495 7604           89C3                       mov	bx,ax
25496                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
25497                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
25498 7606           81C3                 014A  add	bx,#$14A
25499 760A           53                         push	bx
25500                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25501 760B           FF76         F6            push	-$A[bp]
25502                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25503 760E           E8         8FE7            call	_read_byte
25504 7611           83C4                   04  add	sp,*4
25505                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
25506 7614           8846         D3            mov	-$2D[bp],al
25507                                           !BCC_EOS
25508                                           ! 3831         options = (translation==0?0:1)<<3;
25509                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
25510 7617           8A46         D3            mov	al,-$2D[bp]
25511 761A           84C0                       test	al,al
25512 761C           75           04            jne 	.55B
25513                       0000761E            .55C:
25514 761E           30C0                       xor	al,al
25515 7620           EB           02            jmp .55D
25516                       00007622            .55B:
25517 7622           B0                     01  mov	al,*1
25518                       00007624            .55D:
25519                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
25520 7624           30E4                       xor	ah,ah
25521 7626           B1                     03  mov	cl,*3
25522 7628           D3E0                       shl	ax,cl
25523                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25524 762A           8946         CC            mov	-$34[bp],ax
25525                                           !BCC_EOS
25526                                           ! 3832         options |= (1<<4);
25527                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
25528 762D           8B46         CC            mov	ax,-$34[bp]
25529 7630           0C                     10  or	al,*$10
25530 7632           8946         CC            mov	-$34[bp],ax
25531                                           !BCC_EOS
25532                                           ! 3833         options |= (mode==0x01?1:0)<<7;
25533                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
25534 7635           8A46         D6            mov	al,-$2A[bp]
25535 7638           3C                     01  cmp	al,*1
25536 763A           75           04            jne 	.55E
25537                       0000763C            .55F:
25538 763C           B0                     01  mov	al,*1
25539 763E           EB           02            jmp .560
25540                       00007640            .55E:
25541 7640           30C0                       xor	al,al
25542                       00007642            .560:
25543                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
25544 7642           30E4                       xor	ah,ah
25545 7644           B1                     07  mov	cl,*7
25546 7646           D3E0                       shl	ax,cl
25547                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25548 7648           0B46         CC            or	ax,-$34[bp]
25549 764B           8946         CC            mov	-$34[bp],ax
25550                                           !BCC_EOS
25551                                           ! 3834         options |= (translation==1?1:0)<<9;
25552                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
25553 764E           8A46         D3            mov	al,-$2D[bp]
25554 7651           3C                     01  cmp	al,*1
25555 7653           75           04            jne 	.561
25556                       00007655            .562:
25557 7655           B0                     01  mov	al,*1
25558 7657           EB           02            jmp .563
25559                       00007659            .561:
25560 7659           30C0                       xor	al,al
25561                       0000765B            .563:
25562                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25563 765B           30E4                       xor	ah,ah
25564 765D           88C4                       mov	ah,al
25565 765F           30C0                       xor	al,al
25566 7661           D1E0                       shl	ax,*1
25567                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25568 7663           0B46         CC            or	ax,-$34[bp]
25569 7666           8946         CC            mov	-$34[bp],ax
25570                                           !BCC_EOS
25571                                           ! 3835         options |= (translation==3?3:0)<<9;
25572                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
25573 7669           8A46         D3            mov	al,-$2D[bp]
25574 766C           3C                     03  cmp	al,*3
25575 766E           75           04            jne 	.564
25576                       00007670            .565:
25577 7670           B0                     03  mov	al,*3
25578 7672           EB           02            jmp .566
25579                       00007674            .564:
25580 7674           30C0                       xor	al,al
25581                       00007676            .566:
25582                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25583 7676           30E4                       xor	ah,ah
25584 7678           88C4                       mov	ah,al
25585 767A           30C0                       xor	al,al
25586 767C           D1E0                       shl	ax,*1
25587                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25588 767E           0B46         CC            or	ax,-$34[bp]
25589 7681           8946         CC            mov	-$34[bp],ax
25590                                           !BCC_EOS
25591                                           ! 3836         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
25592                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
25593 7684           FF76         D0            push	-$30[bp]
25594                                           ! Debug: list * unsigned short = const $244 (used reg = )
25595 7687           B8                   0244  mov	ax,#$244
25596 768A           50                         push	ax
25597                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25598 768B           FF76         F6            push	-$A[bp]
25599                                           ! Debug: func () void = write_word+0 (used reg = )
25600 768E           E8         8FA5            call	_write_word
25601 7691           83C4                   06  add	sp,*6
25602                                           !BCC_EOS
25603                                           ! 3837         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
25604                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25605 7694           8B46         CE            mov	ax,-$32[bp]
25606                                           ! Debug: list unsigned int = ax+6 (used reg = )
25607 7697           05                   0006  add	ax,*6
25608 769A           50                         push	ax
25609                                           ! Debug: list * unsigned short = const $246 (used reg = )
25610 769B           B8                   0246  mov	ax,#$246
25611 769E           50                         push	ax
25612                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25613 769F           FF76         F6            push	-$A[bp]
25614                                           ! Debug: func () void = write_word+0 (used reg = )
25615 76A2           E8         8F91            call	_write_word
25616 76A5           83C4                   06  add	sp,*6
25617                                           !BCC_EOS
25618                                           ! 3838         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pre
25619                                           ! 3838 fix, (0xe | (device % 2))<<4 );
25620                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25621 76A8           8A46         DB            mov	al,-$25[bp]
25622 76AB           30E4                       xor	ah,ah
25623 76AD           24                     01  and	al,*1
25624                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
25625                                           ! Debug: expression subtree swapping
25626 76AF           0C                     0E  or	al,*$E
25627                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
25628 76B1           30E4                       xor	ah,ah
25629 76B3           B1                     04  mov	cl,*4
25630 76B5           D3E0                       shl	ax,cl
25631                                           ! Debug: list unsigned int = ax+0 (used reg = )
25632 76B7           50                         push	ax
25633                                           ! Debug: list * unsigned char = const $248 (used reg = )
25634 76B8           B8                   0248  mov	ax,#$248
25635 76BB           50                         push	ax
25636                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25637 76BC           FF76         F6            push	-$A[bp]
25638                                           ! Debug: func () void = write_byte+0 (used reg = )
25639 76BF           E8         8F5C            call	_write_byte
25640 76C2           83C4                   06  add	sp,*6
25641                                           !BCC_EOS
25642                                           ! 3839         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
25643                                           ! Debug: list int = const $CB (used reg = )
25644 76C5           B8                   00CB  mov	ax,#$CB
25645 76C8           50                         push	ax
25646                                           ! Debug: list * unsigned char = const $249 (used reg = )
25647 76C9           B8                   0249  mov	ax,#$249
25648 76CC           50                         push	ax
25649                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25650 76CD           FF76         F6            push	-$A[bp]
25651                                           ! Debug: func () void = write_byte+0 (used reg = )
25652 76D0           E8         8F4B            call	_write_byte
25653 76D3           83C4                   06  add	sp,*6
25654                                           !BCC_EOS
25655                                           ! 3840         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
25656                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
25657 76D6           8A46         D7            mov	al,-$29[bp]
25658 76D9           30E4                       xor	ah,ah
25659 76DB           50                         push	ax
25660                                           ! Debug: list * unsigned char = const $24A (used reg = )
25661 76DC           B8                   024A  mov	ax,#$24A
25662 76DF           50                         push	ax
25663                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25664 76E0           FF76         F6            push	-$A[bp]
25665                                           ! Debug: func () void = write_byte+0 (used reg = )
25666 76E3           E8         8F38            call	_write_byte
25667 76E6           83C4                   06  add	sp,*6
25668                                           !BCC_EOS
25669                                           ! 3841         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
25670                                           ! Debug: list int = const 1 (used reg = )
25671 76E9           B8                   0001  mov	ax,*1
25672 76EC           50                         push	ax
25673                                           ! Debug: list * unsigned char = const $24B (used reg = )
25674 76ED           B8                   024B  mov	ax,#$24B
25675 76F0           50                         push	ax
25676                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25677 76F1           FF76         F6            push	-$A[bp]
25678                                           ! Debug: func () void = write_byte+0 (used reg = )
25679 76F4           E8         8F27            call	_write_byte
25680 76F7           83C4                   06  add	sp,*6
25681                                           !BCC_EOS
25682                                           ! 3842         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
25683                                           ! Debug: list int = const 0 (used reg = )
25684 76FA           31C0                       xor	ax,ax
25685 76FC           50                         push	ax
25686                                           ! Debug: list * unsigned char = const $24C (used reg = )
25687 76FD           B8                   024C  mov	ax,#$24C
25688 7700           50                         push	ax
25689                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25690 7701           FF76         F6            push	-$A[bp]
25691                                           ! Debug: func () void = write_byte+0 (used reg = )
25692 7704           E8         8F17            call	_write_byte
25693 7707           83C4                   06  add	sp,*6
25694                                           !BCC_EOS
25695                                           ! 3843         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
25696                                           ! Debug: list int = const 0 (used reg = )
25697 770A           31C0                       xor	ax,ax
25698 770C           50                         push	ax
25699                                           ! Debug: list * unsigned char = const $24D (used reg = )
25700 770D           B8                   024D  mov	ax,#$24D
25701 7710           50                         push	ax
25702                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25703 7711           FF76         F6            push	-$A[bp]
25704                                           ! Debug: func () void = write_byte+0 (used reg = )
25705 7714           E8         8F07            call	_write_byte
25706 7717           83C4                   06  add	sp,*6
25707                                           !BCC_EOS
25708                                           ! 3844         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25709                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
25710 771A           FF76         CC            push	-$34[bp]
25711                                           ! Debug: list * unsigned short = const $24E (used reg = )
25712 771D           B8                   024E  mov	ax,#$24E
25713 7720           50                         push	ax
25714                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25715 7721           FF76         F6            push	-$A[bp]
25716                                           ! Debug: func () void = write_word+0 (used reg = )
25717 7724           E8         8F0F            call	_write_word
25718 7727           83C4                   06  add	sp,*6
25719                                           !BCC_EOS
25720                                           ! 3845         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25721                                           ! Debug: list int = const 0 (used reg = )
25722 772A           31C0                       xor	ax,ax
25723 772C           50                         push	ax
25724                                           ! Debug: list * unsigned short = const $250 (used reg = )
25725 772D           B8                   0250  mov	ax,#$250
25726 7730           50                         push	ax
25727                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25728 7731           FF76         F6            push	-$A[bp]
25729                                           ! Debug: func () void = write_word+0 (used reg = )
25730 7734           E8         8EFF            call	_write_word
25731 7737           83C4                   06  add	sp,*6
25732                                           !BCC_EOS
25733                                           ! 3846         if (size >=0x42)
25734                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
25735 773A           8B46         DE            mov	ax,-$22[bp]
25736 773D           3D                   0042  cmp	ax,*$42
25737 7740           72           13            jb  	.567
25738                       00007742            .568:
25739                                           ! 3847           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25740                                           ! Debug: list int = const $11 (used reg = )
25741 7742           B8                   0011  mov	ax,*$11
25742 7745           50                         push	ax
25743                                           ! Debug: list * unsigned char = const $252 (used reg = )
25744 7746           B8                   0252  mov	ax,#$252
25745 7749           50                         push	ax
25746                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25747 774A           FF76         F6            push	-$A[bp]
25748                                           ! Debug: func () void = write_byte+0 (used reg = )
25749 774D           E8         8ECE            call	_write_byte
25750 7750           83C4                   06  add	sp,*6
25751                                           !BCC_EOS
25752                                           ! 3848         else
25753                                           ! 3849           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
25754 7753           EB           11            jmp .569
25755                       00007755            .567:
25756                                           ! Debug: list int = const $10 (used reg = )
25757 7755           B8                   0010  mov	ax,*$10
25758 7758           50                         push	ax
25759                                           ! Debug: list * unsigned char = const $252 (used reg = )
25760 7759           B8                   0252  mov	ax,#$252
25761 775C           50                         push	ax
25762                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25763 775D           FF76         F6            push	-$A[bp]
25764                                           ! Debug: func () void = write_byte+0 (used reg = )
25765 7760           E8         8EBB            call	_write_byte
25766 7763           83C4                   06  add	sp,*6
25767                                           !BCC_EOS
25768                                           ! 3850         checksum=0;
25769                       00007766            .569:
25770                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25771 7766           30C0                       xor	al,al
25772 7768           8846         D5            mov	-$2B[bp],al
25773                                           !BCC_EOS
25774                                           ! 3851         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
25775                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
25776 776B           30C0                       xor	al,al
25777 776D           8846         D4            mov	-$2C[bp],al
25778                                           !BCC_EOS
25779                                           !BCC_EOS
25780 7770           EB           24            jmp .56C
25781                       00007772            .56D:
25782                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
25783 7772           8A46         D4            mov	al,-$2C[bp]
25784 7775           30E4                       xor	ah,ah
25785                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
25786 7777           05                   0244  add	ax,#$244
25787 777A           50                         push	ax
25788                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25789 777B           FF76         F6            push	-$A[bp]
25790                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25791 777E           E8         8E77            call	_read_byte
25792 7781           83C4                   04  add	sp,*4
25793                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25794 7784           30E4                       xor	ah,ah
25795 7786           0246         D5            add	al,-$2B[bp]
25796 7789           80D4                   00  adc	ah,*0
25797 778C           8846         D5            mov	-$2B[bp],al
25798                                           !BCC_EOS
25799                                           ! 3852         checksum = ~checksum;
25800                       0000778F            .56B:
25801                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
25802 778F           8A46         D4            mov	al,-$2C[bp]
25803 7792           40                         inc	ax
25804 7793           8846         D4            mov	-$2C[bp],al
25805                       00007796            .56C:
25806                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
25807 7796           8A46         D4            mov	al,-$2C[bp]
25808 7799           3C                     0F  cmp	al,*$F
25809 779B           72           D5            jb 	.56D
25810                       0000779D            .56E:
25811                       0000779D            .56A:
25812                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
25813 779D           8A46         D5            mov	al,-$2B[bp]
25814 77A0           30E4                       xor	ah,ah
25815 77A2           F7D0                       not	ax
25816                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25817 77A4           8846         D5            mov	-$2B[bp],al
25818                                           !BCC_EOS
25819                                           ! 3853         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25820                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
25821 77A7           8A46         D5            mov	al,-$2B[bp]
25822 77AA           30E4                       xor	ah,ah
25823 77AC           50                         push	ax
25824                                           ! Debug: list * unsigned char = const $253 (used reg = )
25825 77AD           B8                   0253  mov	ax,#$253
25826 77B0           50                         push	ax
25827                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25828 77B1           FF76         F6            push	-$A[bp]
25829                                           ! Debug: func () void = write_byte+0 (used reg = )
25830 77B4           E8         8E67            call	_write_byte
25831 77B7           83C4                   06  add	sp,*6
25832                                           !BCC_EOS
25833                                           ! 3854       }
25834                                           ! 3855       if(size >= 0x42) {
25835                       000077BA            .559:
25836                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
25837 77BA           8B46         DE            mov	ax,-$22[bp]
25838 77BD           3D                   0042  cmp	ax,*$42
25839 77C0         0F82         023B            blo 	.56F
25840                       000077C4            .570:
25841                                           ! 3856         Bit8u channel, iface, checksum, i;
25842                                           !BCC_EOS
25843                                           ! 3857         Bit16u iobase1;
25844                                           !BCC_EOS
25845                                           ! 3858         channel = device / 2;
25846                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25847 77C4           8A46         DB            mov	al,-$25[bp]
25848 77C7           30E4                       xor	ah,ah
25849 77C9           D1E8                       shr	ax,*1
25850                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
25851 77CB           8846         D9            mov	-$27[bp],al
25852                                           !BCC_EOS
25853                                           ! 3859         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25854                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25855 77CE           8A46         D9            mov	al,-$27[bp]
25856 77D1           30E4                       xor	ah,ah
25857 77D3           B1                     03  mov	cl,*3
25858 77D5           D3E0                       shl	ax,cl
25859 77D7           89C3                       mov	bx,ax
25860                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25861                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25862 77D9           81C3                 0122  add	bx,#$122
25863 77DD           53                         push	bx
25864                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25865 77DE           FF76         F6            push	-$A[bp]
25866                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25867 77E1           E8         8E14            call	_read_byte
25868 77E4           83C4                   04  add	sp,*4
25869                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25870 77E7           8846         D8            mov	-$28[bp],al
25871                                           !BCC_EOS
25872                                           ! 3860         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25873                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25874 77EA           8A46         D9            mov	al,-$27[bp]
25875 77ED           30E4                       xor	ah,ah
25876 77EF           B1                     03  mov	cl,*3
25877 77F1           D3E0                       shl	ax,cl
25878 77F3           89C3                       mov	bx,ax
25879                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25880                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25881 77F5           81C3                 0124  add	bx,#$124
25882 77F9           53                         push	bx
25883                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25884 77FA           FF76         F6            push	-$A[bp]
25885                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25886 77FD           E8         8E0B            call	_read_word
25887 7800           83C4                   04  add	sp,*4
25888                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25889 7803           8946         D4            mov	-$2C[bp],ax
25890                                           !BCC_EOS
25891                                           ! 3861         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25892                                           ! Debug: list int = const $42 (used reg = )
25893 7806           B8                   0042  mov	ax,*$42
25894 7809           50                         push	ax
25895                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25896 780A           8B46         0C            mov	ax,$C[bp]
25897                                           ! Debug: list unsigned int = ax+0 (used reg = )
25898 780D           50                         push	ax
25899                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25900 780E           FF76         06            push	6[bp]
25901                                           ! Debug: func () void = write_word+0 (used reg = )
25902 7811           E8         8E22            call	_write_word
25903 7814           83C4                   06  add	sp,*6
25904                                           !BCC_EOS
25905                                           ! 3862         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25906                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25907 7817           B8                   BEDD  mov	ax,#$BEDD
25908 781A           50                         push	ax
25909                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25910 781B           8B46         0C            mov	ax,$C[bp]
25911                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25912 781E           05                   001E  add	ax,*$1E
25913 7821           50                         push	ax
25914                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25915 7822           FF76         06            push	6[bp]
25916                                           ! Debug: func () void = write_word+0 (used reg = )
25917 7825           E8         8E0E            call	_write_word
25918 7828           83C4                   06  add	sp,*6
25919                                           !BCC_EOS
25920                                           ! 3863         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25921                                           ! Debug: list int = const $24 (used reg = )
25922 782B           B8                   0024  mov	ax,*$24
25923 782E           50                         push	ax
25924                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25925 782F           8B46         0C            mov	ax,$C[bp]
25926                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25927 7832           05                   0020  add	ax,*$20
25928 7835           50                         push	ax
25929                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25930 7836           FF76         06            push	6[bp]
25931                                           ! Debug: func () void = write_byte+0 (used reg = )
25932 7839           E8         8DE2            call	_write_byte
25933 783C           83C4                   06  add	sp,*6
25934                                           !BCC_EOS
25935                                           ! 3864         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25936                                           ! Debug: list int = const 0 (used reg = )
25937 783F           31C0                       xor	ax,ax
25938 7841           50                         push	ax
25939                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25940 7842           8B46         0C            mov	ax,$C[bp]
25941                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25942 7845           05                   0021  add	ax,*$21
25943 7848           50                         push	ax
25944                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25945 7849           FF76         06            push	6[bp]
25946                                           ! Debug: func () void = write_byte+0 (used reg = )
25947 784C           E8         8DCF            call	_write_byte
25948 784F           83C4                   06  add	sp,*6
25949                                           !BCC_EOS
25950                                           ! 3865         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25951                                           ! Debug: list int = const 0 (used reg = )
25952 7852           31C0                       xor	ax,ax
25953 7854           50                         push	ax
25954                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25955 7855           8B46         0C            mov	ax,$C[bp]
25956                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25957 7858           05                   0022  add	ax,*$22
25958 785B           50                         push	ax
25959                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25960 785C           FF76         06            push	6[bp]
25961                                           ! Debug: func () void = write_word+0 (used reg = )
25962 785F           E8         8DD4            call	_write_word
25963 7862           83C4                   06  add	sp,*6
25964                                           !BCC_EOS
25965                                           ! 3866         if (iface==0x00) {
25966                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25967 7865           8A46         D8            mov	al,-$28[bp]
25968 7868           84C0                       test	al,al
25969 786A           75           51            jne 	.571
25970                       0000786C            .572:
25971                                           ! 3867           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25972                                           ! Debug: list int = const $49 (used reg = )
25973 786C           B8                   0049  mov	ax,*$49
25974 786F           50                         push	ax
25975                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25976 7870           8B46         0C            mov	ax,$C[bp]
25977                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25978 7873           05                   0024  add	ax,*$24
25979 7876           50                         push	ax
25980                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25981 7877           FF76         06            push	6[bp]
25982                                           ! Debug: func () void = write_byte+0 (used reg = )
25983 787A           E8         8DA1            call	_write_byte
25984 787D           83C4                   06  add	sp,*6
25985                                           !BCC_EOS
25986                                           ! 3868           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25987                                           ! Debug: list int = const $53 (used reg = )
25988 7880           B8                   0053  mov	ax,*$53
25989 7883           50                         push	ax
25990                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
25991 7884           8B46         0C            mov	ax,$C[bp]
25992                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25993 7887           05                   0025  add	ax,*$25
25994 788A           50                         push	ax
25995                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25996 788B           FF76         06            push	6[bp]
25997                                           ! Debug: func () void = write_byte+0 (used reg = )
25998 788E           E8         8D8D            call	_write_byte
25999 7891           83C4                   06  add	sp,*6
26000                                           !BCC_EOS
26001                                           ! 3869           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
26002                                           ! Debug: list int = const $41 (used reg = )
26003 7894           B8                   0041  mov	ax,*$41
26004 7897           50                         push	ax
26005                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
26006 7898           8B46         0C            mov	ax,$C[bp]
26007                                           ! Debug: list unsigned int = ax+$26 (used reg = )
26008 789B           05                   0026  add	ax,*$26
26009 789E           50                         push	ax
26010                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26011 789F           FF76         06            push	6[bp]
26012                                           ! Debug: func () void = write_byte+0 (used reg = )
26013 78A2           E8         8D79            call	_write_byte
26014 78A5           83C4                   06  add	sp,*6
26015                                           !BCC_EOS
26016                                           ! 3870           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
26017                                           ! Debug: list int = const 0 (used reg = )
26018 78A8           31C0                       xor	ax,ax
26019 78AA           50                         push	ax
26020                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
26021 78AB           8B46         0C            mov	ax,$C[bp]
26022                                           ! Debug: list unsigned int = ax+$27 (used reg = )
26023 78AE           05                   0027  add	ax,*$27
26024 78B1           50                         push	ax
26025                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26026 78B2           FF76         06            push	6[bp]
26027                                           ! Debug: func () void = write_byte+0 (used reg = )
26028 78B5           E8         8D66            call	_write_byte
26029 78B8           83C4                   06  add	sp,*6
26030                                           !BCC_EOS
26031                                           ! 3871         }
26032                                           ! 3872         else {
26033 78BB           EB           00            jmp .573
26034                       000078BD            .571:
26035                                           ! 3873         }
26036                                           ! 3874         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
26037                       000078BD            .573:
26038                                           ! Debug: list int = const $41 (used reg = )
26039 78BD           B8                   0041  mov	ax,*$41
26040 78C0           50                         push	ax
26041                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
26042 78C1           8B46         0C            mov	ax,$C[bp]
26043                                           ! Debug: list unsigned int = ax+$28 (used reg = )
26044 78C4           05                   0028  add	ax,*$28
26045 78C7           50                         push	ax
26046                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26047 78C8           FF76         06            push	6[bp]
26048                                           ! Debug: func () void = write_byte+0 (used reg = )
26049 78CB           E8         8D50            call	_write_byte
26050 78CE           83C4                   06  add	sp,*6
26051                                           !BCC_EOS
26052                                           ! 3875         write_
26053                                           ! 3875 byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
26054                                           ! Debug: list int = const $54 (used reg = )
26055 78D1           B8                   0054  mov	ax,*$54
26056 78D4           50                         push	ax
26057                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
26058 78D5           8B46         0C            mov	ax,$C[bp]
26059                                           ! Debug: list unsigned int = ax+$29 (used reg = )
26060 78D8           05                   0029  add	ax,*$29
26061 78DB           50                         push	ax
26062                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26063 78DC           FF76         06            push	6[bp]
26064                                           ! Debug: func () void = write_byte+0 (used reg = )
26065 78DF           E8         8D3C            call	_write_byte
26066 78E2           83C4                   06  add	sp,*6
26067                                           !BCC_EOS
26068                                           ! 3876         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
26069                                           ! Debug: list int = const $41 (used reg = )
26070 78E5           B8                   0041  mov	ax,*$41
26071 78E8           50                         push	ax
26072                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
26073 78E9           8B46         0C            mov	ax,$C[bp]
26074                                           ! Debug: list unsigned int = ax+$2A (used reg = )
26075 78EC           05                   002A  add	ax,*$2A
26076 78EF           50                         push	ax
26077                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26078 78F0           FF76         06            push	6[bp]
26079                                           ! Debug: func () void = write_byte+0 (used reg = )
26080 78F3           E8         8D28            call	_write_byte
26081 78F6           83C4                   06  add	sp,*6
26082                                           !BCC_EOS
26083                                           ! 3877         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
26084                                           ! Debug: list int = const 0 (used reg = )
26085 78F9           31C0                       xor	ax,ax
26086 78FB           50                         push	ax
26087                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
26088 78FC           8B46         0C            mov	ax,$C[bp]
26089                                           ! Debug: list unsigned int = ax+$2B (used reg = )
26090 78FF           05                   002B  add	ax,*$2B
26091 7902           50                         push	ax
26092                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26093 7903           FF76         06            push	6[bp]
26094                                           ! Debug: func () void = write_byte+0 (used reg = )
26095 7906           E8         8D15            call	_write_byte
26096 7909           83C4                   06  add	sp,*6
26097                                           !BCC_EOS
26098                                           ! 3878         if (iface==0x00) {
26099                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
26100 790C           8A46         D8            mov	al,-$28[bp]
26101 790F           84C0                       test	al,al
26102 7911           75           3E            jne 	.574
26103                       00007913            .575:
26104                                           ! 3879           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
26105                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
26106 7913           FF76         D4            push	-$2C[bp]
26107                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
26108 7916           8B46         0C            mov	ax,$C[bp]
26109                                           ! Debug: list unsigned int = ax+$30 (used reg = )
26110 7919           05                   0030  add	ax,*$30
26111 791C           50                         push	ax
26112                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26113 791D           FF76         06            push	6[bp]
26114                                           ! Debug: func () void = write_word+0 (used reg = )
26115 7920           E8         8D13            call	_write_word
26116 7923           83C4                   06  add	sp,*6
26117                                           !BCC_EOS
26118                                           ! 3880           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
26119                                           ! Debug: list int = const 0 (used reg = )
26120 7926           31C0                       xor	ax,ax
26121 7928           50                         push	ax
26122                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
26123 7929           8B46         0C            mov	ax,$C[bp]
26124                                           ! Debug: list unsigned int = ax+$32 (used reg = )
26125 792C           05                   0032  add	ax,*$32
26126 792F           50                         push	ax
26127                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26128 7930           FF76         06            push	6[bp]
26129                                           ! Debug: func () void = write_word+0 (used reg = )
26130 7933           E8         8D00            call	_write_word
26131 7936           83C4                   06  add	sp,*6
26132                                           !BCC_EOS
26133                                           ! 3881           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
26134                                           ! Debug: list long = const 0 (used reg = )
26135 7939           31C0                       xor	ax,ax
26136 793B           31DB                       xor	bx,bx
26137 793D           53                         push	bx
26138 793E           50                         push	ax
26139                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
26140 793F           8B46         0C            mov	ax,$C[bp]
26141                                           ! Debug: list unsigned int = ax+$34 (used reg = )
26142 7942           05                   0034  add	ax,*$34
26143 7945           50                         push	ax
26144                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
26145 7946           FF76         06            push	6[bp]
26146                                           ! Debug: func () void = write_dword+0 (used reg = )
26147 7949           E8         874F            call	_write_dword
26148 794C           83C4                   08  add	sp,*8
26149                                           !BCC_EOS
26150                                           ! 3882         }
26151                                           ! 3883         else {
26152 794F           EB           00            jmp .576
26153                       00007951            .574:
26154                                           ! 3884         }
26155                                           ! 3885         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
26156                       00007951            .576:
26157                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
26158 7951           8A46         DB            mov	al,-$25[bp]
26159 7954           30E4                       xor	ah,ah
26160 7956           24                     01  and	al,*1
26161                                           ! Debug: list unsigned char = al+0 (used reg = )
26162 7958           30E4                       xor	ah,ah
26163 795A           50                         push	ax
26164                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
26165 795B           8B46         0C            mov	ax,$C[bp]
26166                                           ! Debug: list unsigned int = ax+$38 (used reg = )
26167 795E           05                   0038  add	ax,*$38
26168 7961           50                         push	ax
26169                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26170 7962           FF76         06            push	6[bp]
26171                                           ! Debug: func () void = write_byte+0 (used reg = )
26172 7965           E8         8CB6            call	_write_byte
26173 7968           83C4                   06  add	sp,*6
26174                                           !BCC_EOS
26175                                           ! 3886         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
26176                                           ! Debug: list int = const 0 (used reg = )
26177 796B           31C0                       xor	ax,ax
26178 796D           50                         push	ax
26179                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
26180 796E           8B46         0C            mov	ax,$C[bp]
26181                                           ! Debug: list unsigned int = ax+$39 (used reg = )
26182 7971           05                   0039  add	ax,*$39
26183 7974           50                         push	ax
26184                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26185 7975           FF76         06            push	6[bp]
26186                                           ! Debug: func () void = write_byte+0 (used reg = )
26187 7978           E8         8CA3            call	_write_byte
26188 797B           83C4                   06  add	sp,*6
26189                                           !BCC_EOS
26190                                           ! 3887         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
26191                                           ! Debug: list int = const 0 (used reg = )
26192 797E           31C0                       xor	ax,ax
26193 7980           50                         push	ax
26194                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
26195 7981           8B46         0C            mov	ax,$C[bp]
26196                                           ! Debug: list unsigned int = ax+$3A (used reg = )
26197 7984           05                   003A  add	ax,*$3A
26198 7987           50                         push	ax
26199                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26200 7988           FF76         06            push	6[bp]
26201                                           ! Debug: func () void = write_word+0 (used reg = )
26202 798B           E8         8CA8            call	_write_word
26203 798E           83C4                   06  add	sp,*6
26204                                           !BCC_EOS
26205                                           ! 3888         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
26206                                           ! Debug: list long = const 0 (used reg = )
26207 7991           31C0                       xor	ax,ax
26208 7993           31DB                       xor	bx,bx
26209 7995           53                         push	bx
26210 7996           50                         push	ax
26211                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
26212 7997           8B46         0C            mov	ax,$C[bp]
26213                                           ! Debug: list unsigned int = ax+$3C (used reg = )
26214 799A           05                   003C  add	ax,*$3C
26215 799D           50                         push	ax
26216                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
26217 799E           FF76         06            push	6[bp]
26218                                           ! Debug: func () void = write_dword+0 (used reg = )
26219 79A1           E8         86F7            call	_write_dword
26220 79A4           83C4                   08  add	sp,*8
26221                                           !BCC_EOS
26222                                           ! 3889         checksum=0;
26223                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26224 79A7           30C0                       xor	al,al
26225 79A9           8846         D7            mov	-$29[bp],al
26226                                           !BCC_EOS
26227                                           ! 3890         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
26228                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
26229 79AC           B0                     1E  mov	al,*$1E
26230 79AE           8846         D6            mov	-$2A[bp],al
26231                                           !BCC_EOS
26232                                           !BCC_EOS
26233 79B1           EB           25            jmp .579
26234                       000079B3            .57A:
26235                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
26236 79B3           8B46         0C            mov	ax,$C[bp]
26237 79B6           0246         D6            add	al,-$2A[bp]
26238 79B9           80D4                   00  adc	ah,*0
26239                                           ! Debug: list unsigned int = ax+0 (used reg = )
26240 79BC           50                         push	ax
26241                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26242 79BD           FF76         06            push	6[bp]
26243                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26244 79C0           E8         8C35            call	_read_byte
26245 79C3           83C4                   04  add	sp,*4
26246                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26247 79C6           30E4                       xor	ah,ah
26248 79C8           0246         D7            add	al,-$29[bp]
26249 79CB           80D4                   00  adc	ah,*0
26250 79CE           8846         D7            mov	-$29[bp],al
26251                                           !BCC_EOS
26252                                           ! 3891         checksum = ~checksum;
26253                       000079D1            .578:
26254                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
26255 79D1           8A46         D6            mov	al,-$2A[bp]
26256 79D4           40                         inc	ax
26257 79D5           8846         D6            mov	-$2A[bp],al
26258                       000079D8            .579:
26259                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
26260 79D8           8A46         D6            mov	al,-$2A[bp]
26261 79DB           3C                     40  cmp	al,*$40
26262 79DD           72           D4            jb 	.57A
26263                       000079DF            .57B:
26264                       000079DF            .577:
26265                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
26266 79DF           8A46         D7            mov	al,-$29[bp]
26267 79E2           30E4                       xor	ah,ah
26268 79E4           F7D0                       not	ax
26269                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26270 79E6           8846         D7            mov	-$29[bp],al
26271                                           !BCC_EOS
26272                                           ! 3892         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
26273                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
26274 79E9           8A46         D7            mov	al,-$29[bp]
26275 79EC           30E4                       xor	ah,ah
26276 79EE           50                         push	ax
26277                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
26278 79EF           8B46         0C            mov	ax,$C[bp]
26279                                           ! Debug: list unsigned int = ax+$41 (used reg = )
26280 79F2           05                   0041  add	ax,*$41
26281 79F5           50                         push	ax
26282                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26283 79F6           FF76         06            push	6[bp]
26284                                           ! Debug: func () void = write_byte+0 (used reg = )
26285 79F9           E8         8C22            call	_write_byte
26286 79FC           83C4                   06  add	sp,*6
26287                                           !BCC_EOS
26288                                           ! 3893       }
26289                                           ! 3894       goto int13_success;
26290                       000079FF            .56F:
26291 79FF           83C4                   0E  add	sp,#..FFEF-..FFF0
26292 7A02           E9         011B            br 	.FFEF
26293                                           !BCC_EOS
26294                                           ! 3895       break;
26295 7A05           E9         00E8            br 	.50D
26296                                           !BCC_EOS
26297                                           ! 3896     case 0x4e:
26298                                           ! 3897       switch (( AX & 0x00ff )) {
26299                       00007A08            .57C:
26300                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26301 7A08           8A46         18            mov	al,$18[bp]
26302 7A0B           EB           10            jmp .57F
26303                                           ! 3898         case 0x01:
26304                                           ! 3899         case 0x03:
26305                       00007A0D            .580:
26306                                           ! 3900         case 0x04:
26307                       00007A0D            .581:
26308                                           ! 3901         case 0x06:
26309                       00007A0D            .582:
26310                                           ! 3902           goto int13_success;
26311                       00007A0D            .583:
26312 7A0D           83C4                   0E  add	sp,#..FFEF-..FFF0
26313 7A10           E9         010D            br 	.FFEF
26314                                           !BCC_EOS
26315                                           ! 3903           break;
26316 7A13           EB           1A            jmp .57D
26317                                           !BCC_EOS
26318                                           ! 3904         default:
26319                                           ! 3905           goto int13_fail;
26320                       00007A15            .584:
26321 7A15           83C4                   0E  add	sp,#..FFF1-..FFF0
26322 7A18           E9         00D8            br 	.FFF1
26323                                           !BCC_EOS
26324                                           ! 3906       }
26325                                           ! 3907       break;
26326 7A1B           EB           12            jmp .57D
26327                       00007A1D            .57F:
26328 7A1D           2C                     01  sub	al,*1
26329 7A1F           74           EC            je 	.580
26330 7A21           2C                     02  sub	al,*2
26331 7A23           74           E8            je 	.581
26332 7A25           2C                     01  sub	al,*1
26333 7A27           74           E4            je 	.582
26334 7A29           2C                     02  sub	al,*2
26335 7A2B           74           E0            je 	.583
26336 7A2D           EB           E6            jmp	.584
26337                       00007A2F            .57D:
26338 7A2F           E9         00BE            br 	.50D
26339                                           !BCC_EOS
26340                                           ! 3908     case 0x09:
26341                                           ! 3909     case 0x0c:
26342                       00007A32            .585:
26343                                           ! 3910     case 0x0d:
26344                       00007A32            .586:
26345                                           ! 3911     case 0x11:
26346                       00007A32            .587:
26347                                           ! 3912     case 0x14:
26348                       00007A32            .588:
26349                                           ! 3913       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", ( AX >> 8 ));
26350                       00007A32            .589:
26351                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26352 7A32           8B46         18            mov	ax,$18[bp]
26353 7A35           88E0                       mov	al,ah
26354 7A37           30E4                       xor	ah,ah
26355                                           ! Debug: list unsigned int = ax+0 (used reg = )
26356 7A39           50                         push	ax
26357                                           ! Debug: list * char = .58A+0 (used reg = )
26358 7A3A           BB                   D077  mov	bx,#.58A
26359 7A3D           53                         push	bx
26360                                           ! Debug: list int = const 4 (used reg = )
26361 7A3E           B8                   0004  mov	ax,*4
26362 7A41           50                         push	ax
26363                                           ! Debug: func () void = bios_printf+0 (used reg = )
26364 7A42           E8         8F62            call	_bios_printf
26365 7A45           83C4                   06  add	sp,*6
26366                                           !BCC_EOS
26367                                           ! 3914       goto int13_success;
26368 7A48           83C4                   0E  add	sp,#..FFEF-..FFF0
26369 7A4B           E9         00D2            br 	.FFEF
26370                                           !BCC_EOS
26371                                           ! 3915       break;
26372 7A4E           E9         009F            br 	.50D
26373                                           !BCC_EOS
26374                                           ! 3916     case 0x0a:
26375                                           ! 3917     case 0x0b:
26376                       00007A51            .58B:
26377                                           ! 3918     case 0x18:
26378                       00007A51            .58C:
26379                                           ! 3919     case 0x50:
26380                       00007A51            .58D:
26381                                           ! 3920     default:
26382                       00007A51            .58E:
26383                                           ! 3921       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", ( AX >> 8 ));
26384                       00007A51            .58F:
26385                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26386 7A51           8B46         18            mov	ax,$18[bp]
26387 7A54           88E0                       mov	al,ah
26388 7A56           30E4                       xor	ah,ah
26389                                           ! Debug: list unsigned int = ax+0 (used reg = )
26390 7A58           50                         push	ax
26391                                           ! Debug: list * char = .590+0 (used reg = )
26392 7A59           BB                   D03D  mov	bx,#.590
26393 7A5C           53                         push	bx
26394                                           ! Debug: list int = const 4 (used reg = )
26395 7A5D           B8                   0004  mov	ax,*4
26396 7A60           50                         push	ax
26397                                           ! Debug: func () void = bios_printf+0 (used reg = )
26398 7A61           E8         8F43            call	_bios_printf
26399 7A64           83C4                   06  add	sp,*6
26400                                           !BCC_EOS
26401                                           ! 3922       goto int13_fail;
26402 7A67           83C4                   0E  add	sp,#..FFF1-..FFF0
26403 7A6A           E9         0086            br 	.FFF1
26404                                           !BCC_EOS
26405                                           ! 3923       break;
26406 7A6D           E9         0080            br 	.50D
26407                                           !BCC_EOS
26408                                           ! 3924   }
26409                                           ! 3925 int13_fail:
26410 7A70           EB           7E            jmp .50D
26411                       00007A72            .50F:
26412 7A72           83C4                   F2  add	sp,*-$E
26413 7A75           2D                   0000  sub	ax,*0
26414 7A78           7C           D7            jl 	.58F
26415 7A7A           3D                   0018  cmp	ax,*$18
26416 7A7D           77           3B            ja  	.591
26417 7A7F           D1E0                       shl	ax,*1
26418 7A81           89C3                       mov	bx,ax
26419 7A83           2E                         seg	cs
26420 7A84           FFA7       7A88            br	.592[bx]
26421                       00007A88            .592:
26422 7A88                      6C01            .word	.510
26423 7A8A                      6C15            .word	.511
26424 7A8C                      6C66            .word	.515
26425 7A8E                      6C66            .word	.516
26426 7A90                      6C66            .word	.517
26427 7A92                      6F06            .word	.52D
26428 7A94                      7A51            .word	.58F
26429 7A96                      7A51            .word	.58F
26430 7A98                      6F21            .word	.52F
26431 7A9A                      7A32            .word	.585
26432 7A9C                      7A51            .word	.58B
26433 7A9E                      7A51            .word	.58C
26434 7AA0                      7A32            .word	.586
26435 7AA2                      7A32            .word	.587
26436 7AA4                      7A51            .word	.58F
26437 7AA6                      7A51            .word	.58F
26438 7AA8                      6FFF            .word	.530
26439 7AAA                      7A32            .word	.588
26440 7AAC                      7A51            .word	.58F
26441 7AAE                      7A51            .word	.58F
26442 7AB0                      7A32            .word	.589
26443 7AB2                      704B            .word	.534
26444 7AB4                      7A51            .word	.58F
26445 7AB6                      7A51            .word	.58F
26446 7AB8                      7A51            .word	.58D
26447                       00007ABA            .591:
26448 7ABA           2D                   0041  sub	ax,*$41
26449 7ABD           72           92            jb 	.58F
26450 7ABF           3D                   000F  cmp	ax,*$F
26451 7AC2           77           29            ja  	.593
26452 7AC4           D1E0                       shl	ax,*1
26453 7AC6           89C3                       mov	bx,ax
26454 7AC8           2E                         seg	cs
26455 7AC9           FFA7       7ACD            br	.594[bx]
26456                       00007ACD            .594:
26457 7ACD                      70FC            .word	.535
26458 7ACF                      711C            .word	.536
26459 7AD1                      711C            .word	.537
26460 7AD3                      711C            .word	.538
26461 7AD5                      7315            .word	.54A
26462 7AD7                      731E            .word	.54C
26463 7AD9                      711C            .word	.539
26464 7ADB                      7332            .word	.54D
26465 7ADD                      7315            .word	.54B
26466 7ADF                      7A51            .word	.58F
26467 7AE1                      7A51            .word	.58F
26468 7AE3                      7A51            .word	.58F
26469 7AE5                      7A51            .word	.58F
26470 7AE7                      7A08            .word	.57C
26471 7AE9                      7A51            .word	.58F
26472 7AEB                      7A51            .word	.58E
26473                       00007AED            .593:
26474 7AED           E9         FF61            br 	.58F
26475                       00007AF0            .50D:
26476                       FFFFFFCA            ..FFF0	=	-$36
26477 7AF0           83C4                   0E  add	sp,*$E
26478                       00007AF3            .FFF1:
26479                       FFFFFFD8            ..FFF1	=	-$28
26480                                           ! 3926   AX = ((AX & 0x00ff) | ((0x01) << 8));
26481                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26482 7AF3           8A46         18            mov	al,$18[bp]
26483                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
26484 7AF6           30E4                       xor	ah,ah
26485 7AF8           0D                   0100  or	ax,#$100
26486                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
26487 7AFB           8946         18            mov	$18[bp],ax
26488                                           !BCC_EOS
26489                                           ! 3927 int13_fail_noah:
26490                       00007AFE            .FFEC:
26491                       FFFFFFD8            ..FFEC	=	-$28
26492                                           ! 3928   write_byte(0x0040, 0x0074, ( AX >> 8 ));
26493                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26494 7AFE           8B46         18            mov	ax,$18[bp]
26495 7B01           88E0                       mov	al,ah
26496 7B03           30E4                       xor	ah,ah
26497                                           ! Debug: list unsigned int = ax+0 (used reg = )
26498 7B05           50                         push	ax
26499                                           ! Debug: list int = const $74 (used reg = )
26500 7B06           B8                   0074  mov	ax,*$74
26501 7B09           50                         push	ax
26502                                           ! Debug: list int = const $40 (used reg = )
26503 7B0A           B8                   0040  mov	ax,*$40
26504 7B0D           50                         push	ax
26505                                           ! Debug: func () void = write_byte+0 (used reg = )
26506 7B0E           E8         8B0D            call	_write_byte
26507 7B11           83C4                   06  add	sp,*6
26508                                           !BCC_EOS
26509                                           ! 3929 int13_fail_nostatus:
26510                       00007B14            .FFEE:
26511                       FFFFFFD8            ..FFEE	=	-$28
26512                                           ! 3930   FLAGS |= 0x0001;
26513                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26514 7B14           8B46         1E            mov	ax,$1E[bp]
26515 7B17           0C                     01  or	al,*1
26516 7B19           8946         1E            mov	$1E[bp],ax
26517                                           !BCC_EOS
26518                                           ! 3931   return;
26519 7B1C           89EC                       mov	sp,bp
26520 7B1E           5D                         pop	bp
26521 7B1F           C3                         ret
26522                                           !BCC_EOS
26523                                           ! 3932 int13_success:
26524                       00007B20            .FFEF:
26525                       FFFFFFD8            ..FFEF	=	-$28
26526                                           ! 3933   AX = ((AX & 0x00ff) | ((0x00) << 8));
26527                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26528 7B20           8A46         18            mov	al,$18[bp]
26529                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
26530 7B23           0C                     00  or	al,*0
26531                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
26532 7B25           30E4                       xor	ah,ah
26533 7B27           8946         18            mov	$18[bp],ax
26534                                           !BCC_EOS
26535                                           ! 3934 int13_success_noah:
26536                       00007B2A            .FFED:
26537                       FFFFFFD8            ..FFED	=	-$28
26538                                           ! 3935   write_byte(0x0040, 0x0074, 0x00);
26539                                           ! Debug: list int = const 0 (used reg = )
26540 7B2A           31C0                       xor	ax,ax
26541 7B2C           50                         push	ax
26542                                           ! Debug: list int = const $74 (used reg = )
26543 7B2D           B8                   0074  mov	ax,*$74
26544 7B30           50                         push	ax
26545                                           ! Debug: list int = const $40 (used reg = )
26546 7B31           B8                   0040  mov	ax,*$40
26547 7B34           50                         push	ax
26548                                           ! Debug: func () void = write_byte+0 (used reg = )
26549 7B35           E8         8AE6            call	_write_byte
26550 7B38           83C4                   06  add	sp,*6
26551                                           !BCC_EOS
26552                                           ! 3936   FLAGS &= 0xfffe;
26553                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26554 7B3B           8B46         1E            mov	ax,$1E[bp]
26555 7B3E           24                     FE  and	al,#$FE
26556 7B40           8946         1E            mov	$1E[bp],ax
26557                                           !BCC_EOS
26558                                           ! 3937 }
26559 7B43           89EC                       mov	sp,bp
26560 7B45           5D                         pop	bp
26561 7B46           C3                         ret
26562                                           ! 3938   void
26563                                           ! Register BX used in function int13_harddisk
26564                                           ! 3939 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
26565                                           ! 3940   Bit16u E
26566                                           export	_int13_cdrom
26567                       00007B47            _int13_cdrom:
26568                                           ! 3940 HBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
26569                                           !BCC_EOS
26570                                           ! 3941 {
26571                                           ! 3942   Bit16u ebda_seg=read_word(0x0040,0x000E);
26572 7B47           55                         push	bp
26573 7B48           89E5                       mov	bp,sp
26574 7B4A           4C                         dec	sp
26575 7B4B           4C                         dec	sp
26576                                           ! Debug: list int = const $E (used reg = )
26577 7B4C           B8                   000E  mov	ax,*$E
26578 7B4F           50                         push	ax
26579                                           ! Debug: list int = const $40 (used reg = )
26580 7B50           B8                   0040  mov	ax,*$40
26581 7B53           50                         push	ax
26582                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26583 7B54           E8         8AB4            call	_read_word
26584 7B57           83C4                   04  add	sp,*4
26585                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
26586 7B5A           8946         FE            mov	-2[bp],ax
26587                                           !BCC_EOS
26588                                           ! 3943   Bit8u device, status, locks;
26589                                           !BCC_EOS
26590                                           ! 3944   Bit8u atacmd[12];
26591                                           !BCC_EOS
26592                                           ! 3945   Bit32u lba;
26593                                           !BCC_EOS
26594                                           ! 3946   Bit16u count, segment, offset, i, size;
26595                                           !BCC_EOS
26596                                           ! 3947   ;
26597 7B5D           83C4                   E2  add	sp,*-$1E
26598                                           !BCC_EOS
26599                                           ! 3948   write_byte(0x0040, 0x0074, 0x00);
26600                                           ! Debug: list int = const 0 (used reg = )
26601 7B60           31C0                       xor	ax,ax
26602 7B62           50                         push	ax
26603                                           ! Debug: list int = const $74 (used reg = )
26604 7B63           B8                   0074  mov	ax,*$74
26605 7B66           50                         push	ax
26606                                           ! Debug: list int = const $40 (used reg = )
26607 7B67           B8                   0040  mov	ax,*$40
26608 7B6A           50                         push	ax
26609                                           ! Debug: func () void = write_byte+0 (used reg = )
26610 7B6B           E8         8AB0            call	_write_byte
26611 7B6E           83C4                   06  add	sp,*6
26612                                           !BCC_EOS
26613                                           ! 3949   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
26614                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26615 7B71           8A46         10            mov	al,$10[bp]
26616                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
26617 7B74           3C                     E0  cmp	al,#$E0
26618 7B76           72           07            jb  	.596
26619                       00007B78            .597:
26620                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26621 7B78           8A46         10            mov	al,$10[bp]
26622                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
26623 7B7B           3C                     E8  cmp	al,#$E8
26624 7B7D           72           22            jb  	.595
26625                       00007B7F            .596:
26626                                           ! 3950     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26627                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26628 7B7F           8A46         10            mov	al,$10[bp]
26629                                           ! Debug: list unsigned char = al+0 (used reg = )
26630 7B82           30E4                       xor	ah,ah
26631 7B84           50                         push	ax
26632                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26633 7B85           8B46         18            mov	ax,$18[bp]
26634 7B88           88E0                       mov	al,ah
26635 7B8A           30E4                       xor	ah,ah
26636                                           ! Debug: list unsigned int = ax+0 (used reg = )
26637 7B8C           50                         push	ax
26638                                           ! Debug: list * char = .598+0 (used reg = )
26639 7B8D           BB                   D009  mov	bx,#.598
26640 7B90           53                         push	bx
26641                                           ! Debug: list int = const 4 (used reg = )
26642 7B91           B8                   0004  mov	ax,*4
26643 7B94           50                         push	ax
26644                                           ! Debug: func () void = bios_printf+0 (used reg = )
26645 7B95           E8         8E0F            call	_bios_printf
26646 7B98           83C4                   08  add	sp,*8
26647                                           !BCC_EOS
26648                                           ! 3951     goto int13_fail;
26649 7B9B           83C4                   00  add	sp,#..FFEB+$22
26650 7B9E           E9         0A81            br 	.FFEB
26651                                           !BCC_EOS
26652                                           ! 3952   }
26653                                           ! 3953   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
26654                       00007BA1            .595:
26655                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26656 7BA1           8A46         10            mov	al,$10[bp]
26657                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
26658 7BA4           30E4                       xor	ah,ah
26659                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
26660 7BA6           05                   FF20  add	ax,#-$E0
26661 7BA9           89C3                       mov	bx,ax
26662                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
26663                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
26664 7BAB           81C3                 023C  add	bx,#$23C
26665 7BAF           53                         push	bx
26666                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26667 7BB0           FF76         FE            push	-2[bp]
26668                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26669 7BB3           E8         8A42            call	_read_byte
26670 7BB6           83C4                   04  add	sp,*4
26671                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
26672 7BB9           8846         FD            mov	-3[bp],al
26673                                           !BCC_EOS
26674                                           ! 3954   if (device >= (4*2)) {
26675                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
26676 7BBC           8A46         FD            mov	al,-3[bp]
26677 7BBF           3C                     08  cmp	al,*8
26678 7BC1           72           22            jb  	.599
26679                       00007BC3            .59A:
26680                                           ! 3955     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26681                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26682 7BC3           8A46         10            mov	al,$10[bp]
26683                                           ! Debug: list unsigned char = al+0 (used reg = )
26684 7BC6           30E4                       xor	ah,ah
26685 7BC8           50                         push	ax
26686                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26687 7BC9           8B46         18            mov	ax,$18[bp]
26688 7BCC           88E0                       mov	al,ah
26689 7BCE           30E4                       xor	ah,ah
26690                                           ! Debug: list unsigned int = ax+0 (used reg = )
26691 7BD0           50                         push	ax
26692                                           ! Debug: list * char = .59B+0 (used reg = )
26693 7BD1           BB                   CFCE  mov	bx,#.59B
26694 7BD4           53                         push	bx
26695                                           ! Debug: list int = const 4 (used reg = )
26696 7BD5           B8                   0004  mov	ax,*4
26697 7BD8           50                         push	ax
26698                                           ! Debug: func () void = bios_printf+0 (used reg = )
26699 7BD9           E8         8DCB            call	_bios_printf
26700 7BDC           83C4                   08  add	sp,*8
26701                                           !BCC_EOS
26702                                           ! 3956     goto int13_fail;
26703 7BDF           83C4                   00  add	sp,#..FFEB+$22
26704 7BE2           E9         0A3D            br 	.FFEB
26705                                           !BCC_EOS
26706                                           ! 3957   }
26707                                           ! 3958   switch (( AX >> 8 )) {
26708                       00007BE5            .599:
26709                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26710 7BE5           8B46         18            mov	ax,$18[bp]
26711 7BE8           88E0                       mov	al,ah
26712 7BEA           30E4                       xor	ah,ah
26713 7BEC           E9         09B2            br 	.59E
26714                                           ! 3959     case 0x00:
26715                                           ! 3960     case 0x09:
26716                       00007BEF            .59F:
26717                                           ! 3961     case 0x0c:
26718                       00007BEF            .5A0:
26719                                           ! 3962     case 0x0d:
26720                       00007BEF            .5A1:
26721                                           ! 3963     case 0x10:
26722                       00007BEF            .5A2:
26723                                           ! 3964     case 0x11:
26724                       00007BEF            .5A3:
26725                                           ! 3965     case 0x14:
26726                       00007BEF            .5A4:
26727                                           ! 3966     case 0x16:
26728                       00007BEF            .5A5:
26729                                           ! 3967       goto int13_success;
26730                       00007BEF            .5A6:
26731 7BEF           83C4                   0C  add	sp,#..FFE9-..FFEA
26732 7BF2           E9         0A5A            br 	.FFE9
26733                                           !BCC_EOS
26734                                           ! 3968       break;
26735 7BF5           E9         0A27            br 	.59C
26736                                           !BCC_EOS
26737                                           ! 3969     case 0x03:
26738                                           ! 3970     case 0x05:
26739                       00007BF8            .5A7:
26740                                           ! 3971     case 0x43:
26741                       00007BF8            .5A8:
26742                                           ! 3972       AX = ((AX & 0x00ff) | ((0x03) << 8));
26743                       00007BF8            .5A9:
26744                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26745 7BF8           8A46         18            mov	al,$18[bp]
26746                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
26747 7BFB           30E4                       xor	ah,ah
26748 7BFD           0D                   0300  or	ax,#$300
26749                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26750 7C00           8946         18            mov	$18[bp],ax
26751                                           !BCC_EOS
26752                                           ! 3973       goto int13_fail_noah;
26753 7C03           83C4                   0C  add	sp,#..FFE8-..FFEA
26754 7C06           E9         0A24            br 	.FFE8
26755                                           !BCC_EOS
26756                                           ! 3974       break;
26757 7C09           E9         0A13            br 	.59C
26758                                           !BCC_EOS
26759                                           ! 3975     case 0x01:
26760                                           ! 3976       status = read_byte(0x0040, 0x0074);
26761                       00007C0C            .5AA:
26762                                           ! Debug: list int = const $74 (used reg = )
26763 7C0C           B8                   0074  mov	ax,*$74
26764 7C0F           50                         push	ax
26765                                           ! Debug: list int = const $40 (used reg = )
26766 7C10           B8                   0040  mov	ax,*$40
26767 7C13           50                         push	ax
26768                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26769 7C14           E8         89E1            call	_read_byte
26770 7C17           83C4                   04  add	sp,*4
26771                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
26772 7C1A           8846         FC            mov	-4[bp],al
26773                                           !BCC_EOS
26774                                           ! 3977       AX = ((AX & 0x00ff) | ((status) << 8));
26775                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
26776 7C1D           8A46         FC            mov	al,-4[bp]
26777 7C20           30E4                       xor	ah,ah
26778 7C22           88C4                       mov	ah,al
26779 7C24           30C0                       xor	al,al
26780 7C26           50                         push	ax
26781                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
26782 7C27           8A46         18            mov	al,$18[bp]
26783                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
26784 7C2A           30E4                       xor	ah,ah
26785 7C2C           0B46         D2            or	ax,0+..FFEA[bp]
26786 7C2F           44                         inc	sp
26787 7C30           44                         inc	sp
26788                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26789 7C31           8946         18            mov	$18[bp],ax
26790                                           !BCC_EOS
26791                                           ! 3978       write_byte(0x0040, 0x0074, 0);
26792                                           ! Debug: list int = const 0 (used reg = )
26793 7C34           31C0                       xor	ax,ax
26794 7C36           50                         push	ax
26795                                           ! Debug: list int = const $74 (used reg = )
26796 7C37           B8                   0074  mov	ax,*$74
26797 7C3A           50                         push	ax
26798                                           ! Debug: list int = const $40 (used reg = )
26799 7C3B           B8                   0040  mov	ax,*$40
26800 7C3E           50                         push	ax
26801                                           ! Debug: func () void = write_byte+0 (used reg = )
26802 7C3F           E8         89DC            call	_write_byte
26803 7C42           83C4                   06  add	sp,*6
26804                                           !BCC_EOS
26805                                           ! 3979       if (status) goto int13_fail_nostatus;
26806 7C45           8A46         FC            mov	al,-4[bp]
26807 7C48           84C0                       test	al,al
26808 7C4A           74           08            je  	.5AB
26809                       00007C4C            .5AC:
26810 7C4C           83C4                   0C  add	sp,#..FFE7-..FFEA
26811 7C4F           E9         09F1            br 	.FFE7
26812                                           !BCC_EOS
26813                                           ! 3980       else goto int13_success_noah;
26814 7C52           EB           06            jmp .5AD
26815                       00007C54            .5AB:
26816 7C54           83C4                   0C  add	sp,#..FFE6-..FFEA
26817 7C57           E9         09FF            br 	.FFE6
26818                                           !BCC_EOS
26819                                           ! 3981       break;
26820                       00007C5A            .5AD:
26821 7C5A           E9         09C2            br 	.59C
26822                                           !BCC_EOS
26823                                           ! 3982     case 0x15:
26824                                           ! 3983       AX = ((AX & 0x00ff) | ((0x02) << 8));
26825                       00007C5D            .5AE:
26826                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26827 7C5D           8A46         18            mov	al,$18[bp]
26828                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
26829 7C60           30E4                       xor	ah,ah
26830 7C62           0D                   0200  or	ax,#$200
26831                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26832 7C65           8946         18            mov	$18[bp],ax
26833                                           !BCC_EOS
26834                                           ! 3984       goto int13_fail_noah;
26835 7C68           83C4                   0C  add	sp,#..FFE8-..FFEA
26836 7C6B           E9         09BF            br 	.FFE8
26837                                           !BCC_EOS
26838                                           ! 3985       break;
26839 7C6E           E9         09AE            br 	.59C
26840                                           !BCC_EOS
26841                                           ! 3986     case 0x41:
26842                                           ! 3987       BX=0xaa55;
26843                       00007C71            .5AF:
26844                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
26845 7C71           B8                   AA55  mov	ax,#$AA55
26846 7C74           8946         12            mov	$12[bp],ax
26847                                           !BCC_EOS
26848                                           ! 3988       AX = ((AX & 0x00ff) | ((0x30) << 8));
26849                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26850 7C77           8A46         18            mov	al,$18[bp]
26851                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
26852 7C7A           30E4                       xor	ah,ah
26853 7C7C           0D                   3000  or	ax,#$3000
26854                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26855 7C7F           8946         18            mov	$18[bp],ax
26856                                           !BCC_EOS
26857                                           ! 3989       CX=0x0007;
26858                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
26859 7C82           B8                   0007  mov	ax,*7
26860 7C85           8946         16            mov	$16[bp],ax
26861                                           !BCC_EOS
26862                                           ! 3990       goto int13_success_noah;
26863 7C88           83C4                   0C  add	sp,#..FFE6-..FFEA
26864 7C8B           E9         09CB            br 	.FFE6
26865                                           !BCC_EOS
26866                                           ! 3991       break;
26867 7C8E           E9         098E            br 	.59C
26868                                           !BCC_EOS
26869                                           ! 3992     case 0x42:
26870                                           ! 3993     case 0x44:
26871                       00007C91            .5B0:
26872                                           ! 3994     case 0x47:
26873                       00007C91            .5B1:
26874                                           ! 3995       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
26875                       00007C91            .5B2:
26876                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
26877 7C91           8B46         0C            mov	ax,$C[bp]
26878                                           ! Debug: list unsigned int = ax+2 (used reg = )
26879 7C94           40                         inc	ax
26880 7C95           40                         inc	ax
26881 7C96           50                         push	ax
26882                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26883 7C97           FF76         06            push	6[bp]
26884                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26885 7C9A           E8         896E            call	_read_word
26886 7C9D           83C4                   04  add	sp,*4
26887                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26888 7CA0           8946         E8            mov	-$18[bp],ax
26889                                           !BCC_EOS
26890                                           ! 3996       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
26891                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
26892 7CA3           8B46         0C            mov	ax,$C[bp]
26893                                           ! Debug: list unsigned int = ax+6 (used reg = )
26894 7CA6           05                   0006  add	ax,*6
26895 7CA9           50                         push	ax
26896                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26897 7CAA           FF76         06            push	6[bp]
26898                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26899 7CAD           E8         895B            call	_read_word
26900 7CB0           83C4                   04  add	sp,*4
26901                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
26902 7CB3           8946         E6            mov	-$1A[bp],ax
26903                                           !BCC_EOS
26904                                           ! 3997       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
26905                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
26906 7CB6           8B46         0C            mov	ax,$C[bp]
26907                                           ! Debug: list unsigned int = ax+4 (used reg = )
26908 7CB9           05                   0004  add	ax,*4
26909 7CBC           50                         push	ax
26910                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26911 7CBD           FF76         06            push	6[bp]
26912                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26913 7CC0           E8         8948            call	_read_word
26914 7CC3           83C4                   04  add	sp,*4
26915                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
26916 7CC6           8946         E4            mov	-$1C[bp],ax
26917                                           !BCC_EOS
26918                                           ! 3998       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
26919                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
26920 7CC9           8B46         0C            mov	ax,$C[bp]
26921                                           ! Debug: list unsigned int = ax+$C (used reg = )
26922 7CCC           05                   000C  add	ax,*$C
26923 7CCF           50                         push	ax
26924                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26925 7CD0           FF76         06            push	6[bp]
26926                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26927 7CD3           E8         83AD            call	_read_dword
26928 7CD6           89D3                       mov	bx,dx
26929 7CD8           83C4                   04  add	sp,*4
26930                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26931 7CDB           8946         EA            mov	-$16[bp],ax
26932 7CDE           895E         EC            mov	-$14[bp],bx
26933                                           !BCC_EOS
26934                                           ! 3999       if (lba != 0L) {
26935                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26936                                           ! Debug: expression subtree swapping
26937 7CE1           31C0                       xor	ax,ax
26938 7CE3           31DB                       xor	bx,bx
26939 7CE5           53                         push	bx
26940 7CE6           50                         push	ax
26941 7CE7           8B46         EA            mov	ax,-$16[bp]
26942 7CEA           8B5E         EC            mov	bx,-$14[bp]
26943 7CED           8D7E         D0            lea	di,-2+..FFEA[bp]
26944 7CF0           E8         83D8            call	lcmpul
26945 7CF3           8D66         D4            lea	sp,2+..FFEA[bp]
26946 7CF6           74           1C            je  	.5B3
26947                       00007CF8            .5B4:
26948                                           ! 4000         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26949                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26950 7CF8           8B46         18            mov	ax,$18[bp]
26951 7CFB           88E0                       mov	al,ah
26952 7CFD           30E4                       xor	ah,ah
26953                                           ! Debug: list unsigned int = ax+0 (used reg = )
26954 7CFF           50                         push	ax
26955                                           ! Debug: list * char = .5B5+0 (used reg = )
26956 7D00           BB                   CF9C  mov	bx,#.5B5
26957 7D03           53                         push	bx
26958                                           ! Debug: list int = const 7 (used reg = )
26959 7D04           B8                   0007  mov	ax,*7
26960 7D07           50                         push	ax
26961                                           ! Debug: func () void = bios_printf+0 (used reg = )
26962 7D08           E8         8C9C            call	_bios_printf
26963 7D0B           83C4                   06  add	sp,*6
26964                                           !BCC_EOS
26965                                           ! 4001         goto int13_fail;
26966 7D0E           83C4                   0C  add	sp,#..FFEB-..FFEA
26967 7D11           E9         090E            br 	.FFEB
26968                                           !BCC_EOS
26969                                           ! 4002       }
26970                                           ! 4003       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
26971                       00007D14            .5B3:
26972                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26973 7D14           8B46         0C            mov	ax,$C[bp]
26974                                           ! Debug: list unsigned int = ax+8 (used reg = )
26975 7D17           05                   0008  add	ax,*8
26976 7D1A           50                         push	ax
26977                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26978 7D1B           FF76         06            push	6[bp]
26979                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26980 7D1E           E8         8362            call	_read_dword
26981 7D21           89D3                       mov	bx,dx
26982 7D23           83C4                   04  add	sp,*4
26983                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26984 7D26           8946         EA            mov	-$16[bp],ax
26985 7D29           895E         EC            mov	-$14[bp],bx
26986                                           !BCC_EOS
26987                                           ! 4004       if ((( AX 
26988                                           ! 4004 >> 8 ) == 0x44) || (( AX >> 8 ) == 0x47))
26989                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26990 7D2C           8B46         18            mov	ax,$18[bp]
26991 7D2F           88E0                       mov	al,ah
26992 7D31           30E4                       xor	ah,ah
26993                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
26994 7D33           3D                   0044  cmp	ax,*$44
26995 7D36           74           0C            je  	.5B7
26996                       00007D38            .5B8:
26997                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26998 7D38           8B46         18            mov	ax,$18[bp]
26999 7D3B           88E0                       mov	al,ah
27000 7D3D           30E4                       xor	ah,ah
27001                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
27002 7D3F           3D                   0047  cmp	ax,*$47
27003 7D42           75           06            jne 	.5B6
27004                       00007D44            .5B7:
27005                                           ! 4005         goto int13_success;
27006 7D44           83C4                   0C  add	sp,#..FFE9-..FFEA
27007 7D47           E9         0905            br 	.FFE9
27008                                           !BCC_EOS
27009                                           ! 4006       memsetb(get_SS(),atacmd,0,12);
27010                       00007D4A            .5B6:
27011                                           ! Debug: list int = const $C (used reg = )
27012 7D4A           B8                   000C  mov	ax,*$C
27013 7D4D           50                         push	ax
27014                                           ! Debug: list int = const 0 (used reg = )
27015 7D4E           31C0                       xor	ax,ax
27016 7D50           50                         push	ax
27017                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
27018 7D51           8D5E         EF            lea	bx,-$11[bp]
27019 7D54           53                         push	bx
27020                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27021 7D55           E8         88F9            call	_get_SS
27022                                           ! Debug: list unsigned short = ax+0 (used reg = )
27023 7D58           50                         push	ax
27024                                           ! Debug: func () void = memsetb+0 (used reg = )
27025 7D59           E8         82A4            call	_memsetb
27026 7D5C           83C4                   08  add	sp,*8
27027                                           !BCC_EOS
27028                                           ! 4007       atacmd[0]=0x28;
27029                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
27030 7D5F           B0                     28  mov	al,*$28
27031 7D61           8846         EF            mov	-$11[bp],al
27032                                           !BCC_EOS
27033                                           ! 4008       atacmd[7]=(count & 0xff00) >> 8;
27034                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
27035 7D64           8B46         E8            mov	ax,-$18[bp]
27036 7D67           30C0                       xor	al,al
27037                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
27038 7D69           88E0                       mov	al,ah
27039 7D6B           30E4                       xor	ah,ah
27040                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
27041 7D6D           8846         F6            mov	-$A[bp],al
27042                                           !BCC_EOS
27043                                           ! 4009       atacmd[8]=(count & 0x00ff);
27044                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
27045 7D70           8A46         E8            mov	al,-$18[bp]
27046                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
27047 7D73           8846         F7            mov	-9[bp],al
27048                                           !BCC_EOS
27049                                           ! 4010       atacmd[2]=(lba & 0xff000000) >> 24;
27050                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
27051                                           ! Debug: expression subtree swapping
27052 7D76           31C0                       xor	ax,ax
27053 7D78           BB                   FF00  mov	bx,#$FF00
27054 7D7B           8D7E         EA            lea	di,-$16[bp]
27055 7D7E           E8         833A            call	landul
27056                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
27057 7D81           93                         xchg	bx,ax
27058 7D82           88E0                       mov	al,ah
27059 7D84           30E4                       xor	ah,ah
27060 7D86           31DB                       xor	bx,bx
27061                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
27062 7D88           8846         F1            mov	-$F[bp],al
27063                                           !BCC_EOS
27064                                           ! 4011       atacmd[3]=(lba & 0x00ff0000) >> 16;
27065                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
27066                                           ! Debug: expression subtree swapping
27067 7D8B           31C0                       xor	ax,ax
27068 7D8D           BB                   00FF  mov	bx,#$FF
27069 7D90           8D7E         EA            lea	di,-$16[bp]
27070 7D93           E8         8325            call	landul
27071                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
27072 7D96           93                         xchg	bx,ax
27073 7D97           31DB                       xor	bx,bx
27074                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
27075 7D99           8846         F2            mov	-$E[bp],al
27076                                           !BCC_EOS
27077                                           ! 4012       atacmd[4]=(lba & 0x0000ff00) >> 8;
27078                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
27079                                           ! Debug: expression subtree swapping
27080 7D9C           B8                   FF00  mov	ax,#$FF00
27081 7D9F           31DB                       xor	bx,bx
27082 7DA1           8D7E         EA            lea	di,-$16[bp]
27083 7DA4           E8         8314            call	landul
27084                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
27085 7DA7           88E0                       mov	al,ah
27086 7DA9           88DC                       mov	ah,bl
27087 7DAB           88FB                       mov	bl,bh
27088 7DAD           28FF                       sub	bh,bh
27089                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
27090 7DAF           8846         F3            mov	-$D[bp],al
27091                                           !BCC_EOS
27092                                           ! 4013       atacmd[5]=(lba & 0x000000ff);
27093                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
27094                                           ! Debug: expression subtree swapping
27095 7DB2           B8                   00FF  mov	ax,#$FF
27096 7DB5           31DB                       xor	bx,bx
27097 7DB7           8D7E         EA            lea	di,-$16[bp]
27098 7DBA           E8         82FE            call	landul
27099                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
27100 7DBD           8846         F4            mov	-$C[bp],al
27101                                           !BCC_EOS
27102                                           ! 4014       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
27103                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
27104 7DC0           FF76         E4            push	-$1C[bp]
27105                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
27106 7DC3           FF76         E6            push	-$1A[bp]
27107                                           ! Debug: list int = const 1 (used reg = )
27108 7DC6           B8                   0001  mov	ax,*1
27109 7DC9           50                         push	ax
27110                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
27111 7DCA           8B46         E8            mov	ax,-$18[bp]
27112 7DCD           31DB                       xor	bx,bx
27113                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
27114 7DCF           53                         push	bx
27115 7DD0           50                         push	ax
27116 7DD1           B8                   0800  mov	ax,#$800
27117 7DD4           31DB                       xor	bx,bx
27118 7DD6           53                         push	bx
27119 7DD7           50                         push	ax
27120 7DD8           8B46         CA            mov	ax,-8+..FFEA[bp]
27121 7DDB           8B5E         CC            mov	bx,-6+..FFEA[bp]
27122 7DDE           8D7E         C6            lea	di,-$C+..FFEA[bp]
27123 7DE1           E8         8305            call	lmulul
27124 7DE4           83C4                   08  add	sp,*8
27125                                           ! Debug: list unsigned long = bx+0 (used reg = )
27126 7DE7           53                         push	bx
27127 7DE8           50                         push	ax
27128                                           ! Debug: list int = const 0 (used reg = )
27129 7DE9           31C0                       xor	ax,ax
27130 7DEB           50                         push	ax
27131                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
27132 7DEC           8D5E         EF            lea	bx,-$11[bp]
27133 7DEF           53                         push	bx
27134                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27135 7DF0           E8         885E            call	_get_SS
27136                                           ! Debug: list unsigned short = ax+0 (used reg = )
27137 7DF3           50                         push	ax
27138                                           ! Debug: list int = const $C (used reg = )
27139 7DF4           B8                   000C  mov	ax,*$C
27140 7DF7           50                         push	ax
27141                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
27142 7DF8           8A46         FD            mov	al,-3[bp]
27143 7DFB           30E4                       xor	ah,ah
27144 7DFD           50                         push	ax
27145                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
27146 7DFE           E8         B7E6            call	_ata_cmd_packet
27147 7E01           83C4                   14  add	sp,*$14
27148                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
27149 7E04           8846         FC            mov	-4[bp],al
27150                                           !BCC_EOS
27151                                           ! 4015       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
27152                                           ! Debug: list * unsigned long = const $256 (used reg = )
27153 7E07           B8                   0256  mov	ax,#$256
27154 7E0A           50                         push	ax
27155                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27156 7E0B           FF76         FE            push	-2[bp]
27157                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
27158 7E0E           E8         8272            call	_read_dword
27159 7E11           89D3                       mov	bx,dx
27160 7E13           83C4                   04  add	sp,*4
27161                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
27162 7E16           88E0                       mov	al,ah
27163 7E18           88DC                       mov	ah,bl
27164 7E1A           88FB                       mov	bl,bh
27165 7E1C           28FF                       sub	bh,bh
27166 7E1E           BF                   0003  mov	di,*3
27167 7E21           E8         8305            call	lsrul
27168                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
27169                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
27170 7E24           8946         E8            mov	-$18[bp],ax
27171                                           !BCC_EOS
27172                                           ! 4016       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
27173                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
27174 7E27           FF76         E8            push	-$18[bp]
27175                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
27176 7E2A           8B46         0C            mov	ax,$C[bp]
27177                                           ! Debug: list unsigned int = ax+2 (used reg = )
27178 7E2D           40                         inc	ax
27179 7E2E           40                         inc	ax
27180 7E2F           50                         push	ax
27181                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
27182 7E30           FF76         06            push	6[bp]
27183                                           ! Debug: func () void = write_word+0 (used reg = )
27184 7E33           E8         8800            call	_write_word
27185 7E36           83C4                   06  add	sp,*6
27186                                           !BCC_EOS
27187                                           ! 4017       if (status != 0) {
27188                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27189 7E39           8A46         FC            mov	al,-4[bp]
27190 7E3C           84C0                       test	al,al
27191 7E3E           74           2D            je  	.5B9
27192                       00007E40            .5BA:
27193                                           ! 4018         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
27194                                           ! Debug: list unsigned char status = [S+$22-6] (used reg = )
27195 7E40           8A46         FC            mov	al,-4[bp]
27196 7E43           30E4                       xor	ah,ah
27197 7E45           50                         push	ax
27198                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
27199 7E46           8B46         18            mov	ax,$18[bp]
27200 7E49           88E0                       mov	al,ah
27201 7E4B           30E4                       xor	ah,ah
27202                                           ! Debug: list unsigned int = ax+0 (used reg = )
27203 7E4D           50                         push	ax
27204                                           ! Debug: list * char = .5BB+0 (used reg = )
27205 7E4E           BB                   CF71  mov	bx,#.5BB
27206 7E51           53                         push	bx
27207                                           ! Debug: list int = const 4 (used reg = )
27208 7E52           B8                   0004  mov	ax,*4
27209 7E55           50                         push	ax
27210                                           ! Debug: func () void = bios_printf+0 (used reg = )
27211 7E56           E8         8B4E            call	_bios_printf
27212 7E59           83C4                   08  add	sp,*8
27213                                           !BCC_EOS
27214                                           ! 4019         AX = ((AX & 0x00ff) | ((0x0c) << 8));
27215                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27216 7E5C           8A46         18            mov	al,$18[bp]
27217                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
27218 7E5F           30E4                       xor	ah,ah
27219 7E61           0D                   0C00  or	ax,#$C00
27220                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27221 7E64           8946         18            mov	$18[bp],ax
27222                                           !BCC_EOS
27223                                           ! 4020         goto int13_fail_noah;
27224 7E67           83C4                   0C  add	sp,#..FFE8-..FFEA
27225 7E6A           E9         07C0            br 	.FFE8
27226                                           !BCC_EOS
27227                                           ! 4021       }
27228                                           ! 4022       goto int13_success;
27229                       00007E6D            .5B9:
27230 7E6D           83C4                   0C  add	sp,#..FFE9-..FFEA
27231 7E70           E9         07DC            br 	.FFE9
27232                                           !BCC_EOS
27233                                           ! 4023       break;
27234 7E73           E9         07A9            br 	.59C
27235                                           !BCC_EOS
27236                                           ! 4024     case 0x45:
27237                                           ! 4025       if (( AX & 0x00ff ) > 2) goto int13_fail;
27238                       00007E76            .5BC:
27239                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27240 7E76           8A46         18            mov	al,$18[bp]
27241                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
27242 7E79           3C                     02  cmp	al,*2
27243 7E7B           76           06            jbe 	.5BD
27244                       00007E7D            .5BE:
27245 7E7D           83C4                   0C  add	sp,#..FFEB-..FFEA
27246 7E80           E9         079F            br 	.FFEB
27247                                           !BCC_EOS
27248                                           ! 4026       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27249                       00007E83            .5BD:
27250                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27251 7E83           8A46         FD            mov	al,-3[bp]
27252 7E86           30E4                       xor	ah,ah
27253 7E88           B9                   001E  mov	cx,*$1E
27254 7E8B           F7E9                       imul	cx
27255 7E8D           89C3                       mov	bx,ax
27256                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27257                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27258 7E8F           81C3                 0145  add	bx,#$145
27259 7E93           53                         push	bx
27260                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27261 7E94           FF76         FE            push	-2[bp]
27262                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27263 7E97           E8         875E            call	_read_byte
27264 7E9A           83C4                   04  add	sp,*4
27265                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27266 7E9D           8846         FB            mov	-5[bp],al
27267                                           !BCC_EOS
27268                                           ! 4027       switch (( AX & 0x00ff )) {
27269                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27270 7EA0           8A46         18            mov	al,$18[bp]
27271 7EA3           E9         00D5            br 	.5C1
27272                                           ! 4028         case 0 :
27273                                           ! 4029           if (locks == 0xff) {
27274                       00007EA6            .5C2:
27275                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
27276 7EA6           8A46         FB            mov	al,-5[bp]
27277 7EA9           3C                     FF  cmp	al,#$FF
27278 7EAB           75           1B            jne 	.5C3
27279                       00007EAD            .5C4:
27280                                           ! 4030             AX = ((AX & 0x00ff) | ((0xb4) << 8));
27281                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27282 7EAD           8A46         18            mov	al,$18[bp]
27283                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
27284 7EB0           30E4                       xor	ah,ah
27285 7EB2           0D                   B400  or	ax,#-$4C00
27286                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27287 7EB5           8946         18            mov	$18[bp],ax
27288                                           !BCC_EOS
27289                                           ! 4031             AX = ((AX & 0xff00) | (1));
27290                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27291 7EB8           8B46         18            mov	ax,$18[bp]
27292 7EBB           30C0                       xor	al,al
27293                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27294 7EBD           0C                     01  or	al,*1
27295                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27296 7EBF           8946         18            mov	$18[bp],ax
27297                                           !BCC_EOS
27298                                           ! 4032             goto int13_fail_noah;
27299 7EC2           83C4                   0C  add	sp,#..FFE8-..FFEA
27300 7EC5           E9         0765            br 	.FFE8
27301                                           !BCC_EOS
27302                                           ! 4033           }
27303                                           ! 4034           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
27304                       00007EC8            .5C3:
27305                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
27306 7EC8           8A46         FB            mov	al,-5[bp]
27307 7ECB           40                         inc	ax
27308 7ECC           8846         FB            mov	-5[bp],al
27309                                           ! Debug: list unsigned char = al+0 (used reg = )
27310 7ECF           30E4                       xor	ah,ah
27311 7ED1           50                         push	ax
27312                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27313 7ED2           8A46         FD            mov	al,-3[bp]
27314 7ED5           30E4                       xor	ah,ah
27315 7ED7           B9                   001E  mov	cx,*$1E
27316 7EDA           F7E9                       imul	cx
27317 7EDC           89C3                       mov	bx,ax
27318                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27319                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27320 7EDE           81C3                 0145  add	bx,#$145
27321 7EE2           53                         push	bx
27322                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27323 7EE3           FF76         FE            push	-2[bp]
27324                                           ! Debug: func () void = write_byte+0 (used reg = )
27325 7EE6           E8         8735            call	_write_byte
27326 7EE9           83C4                   06  add	sp,*6
27327                                           !BCC_EOS
27328                                           ! 4035           AX = ((AX & 0xff00) | (1));
27329                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27330 7EEC           8B46         18            mov	ax,$18[bp]
27331 7EEF           30C0                       xor	al,al
27332                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27333 7EF1           0C                     01  or	al,*1
27334                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27335 7EF3           8946         18            mov	$18[bp],ax
27336                                           !BCC_EOS
27337                                           ! 4036           break;
27338 7EF6           E9         0092            br 	.5BF
27339                                           !BCC_EOS
27340                                           ! 4037         case 1 :
27341                                           ! 4038           if (locks == 0x00) {
27342                       00007EF9            .5C5:
27343                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27344 7EF9           8A46         FB            mov	al,-5[bp]
27345 7EFC           84C0                       test	al,al
27346 7EFE           75           1B            jne 	.5C6
27347                       00007F00            .5C7:
27348                                           ! 4039             AX = ((AX & 0x00ff) | ((0xb0) << 8));
27349                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27350 7F00           8A46         18            mov	al,$18[bp]
27351                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
27352 7F03           30E4                       xor	ah,ah
27353 7F05           0D                   B000  or	ax,#-$5000
27354                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27355 7F08           8946         18            mov	$18[bp],ax
27356                                           !BCC_EOS
27357                                           ! 4040             AX = ((AX & 0xff00) | (0));
27358                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27359 7F0B           8B46         18            mov	ax,$18[bp]
27360 7F0E           30C0                       xor	al,al
27361                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27362 7F10           0C                     00  or	al,*0
27363                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27364 7F12           8946         18            mov	$18[bp],ax
27365                                           !BCC_EOS
27366                                           ! 4041             goto int13_fail_noah;
27367 7F15           83C4                   0C  add	sp,#..FFE8-..FFEA
27368 7F18           E9         0712            br 	.FFE8
27369                                           !BCC_EOS
27370                                           ! 4042           }
27371                                           ! 4043           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
27372                       00007F1B            .5C6:
27373                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
27374 7F1B           8A46         FB            mov	al,-5[bp]
27375 7F1E           48                         dec	ax
27376 7F1F           8846         FB            mov	-5[bp],al
27377                                           ! Debug: list unsigned char = al+0 (used reg = )
27378 7F22           30E4                       xor	ah,ah
27379 7F24           50                         push	ax
27380                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27381 7F25           8A46         FD            mov	al,-3[bp]
27382 7F28           30E4                       xor	ah,ah
27383 7F2A           B9                   001E  mov	cx,*$1E
27384 7F2D           F7E9                       imul	cx
27385 7F2F           89C3                       mov	bx,ax
27386                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27387                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27388 7F31           81C3                 0145  add	bx,#$145
27389 7F35           53                         push	bx
27390                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27391 7F36           FF76         FE            push	-2[bp]
27392                                           ! Debug: func () void = write_byte+0 (used reg = )
27393 7F39           E8         86E2            call	_write_byte
27394 7F3C           83C4                   06  add	sp,*6
27395                                           !BCC_EOS
27396                                           ! 4044           AX = ((AX & 0xff00) | (locks==0?0:1));
27397                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27398 7F3F           8A46         FB            mov	al,-5[bp]
27399 7F42           84C0                       test	al,al
27400 7F44           75           04            jne 	.5C8
27401                       00007F46            .5C9:
27402 7F46           30C0                       xor	al,al
27403 7F48           EB           02            jmp .5CA
27404                       00007F4A            .5C8:
27405 7F4A           B0                     01  mov	al,*1
27406                       00007F4C            .5CA:
27407 7F4C           50                         push	ax
27408                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27409 7F4D           8B46         18            mov	ax,$18[bp]
27410 7F50           30C0                       xor	al,al
27411                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27412 7F52           0A46         D2            or	al,0+..FFEA[bp]
27413 7F55           44                         inc	sp
27414 7F56           44                         inc	sp
27415                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27416 7F57           8946         18            mov	$18[bp],ax
27417                                           !BCC_EOS
27418                                           ! 4045           break;
27419 7F5A           EB           2F            jmp .5BF
27420                                           !BCC_EOS
27421                                           ! 4046         case 2 :
27422                                           ! 4047           AX = ((AX & 0xff00) | (locks==0?0:1));
27423                       00007F5C            .5CB:
27424                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27425 7F5C           8A46         FB            mov	al,-5[bp]
27426 7F5F           84C0                       test	al,al
27427 7F61           75           04            jne 	.5CC
27428                       00007F63            .5CD:
27429 7F63           30C0                       xor	al,al
27430 7F65           EB           02            jmp .5CE
27431                       00007F67            .5CC:
27432 7F67           B0                     01  mov	al,*1
27433                       00007F69            .5CE:
27434 7F69           50                         push	ax
27435                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27436 7F6A           8B46         18            mov	ax,$18[bp]
27437 7F6D           30C0                       xor	al,al
27438                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27439 7F6F           0A46         D2            or	al,0+..FFEA[bp]
27440 7F72           44                         inc	sp
27441 7F73           44                         inc	sp
27442                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27443 7F74           8946         18            mov	$18[bp],ax
27444                                           !BCC_EOS
27445                                           ! 4048           break;
27446 7F77           EB           12            jmp .5BF
27447                                           !BCC_EOS
27448                                           ! 4049       }
27449                                           ! 4050       goto int13_success;
27450 7F79           EB           10            jmp .5BF
27451                       00007F7B            .5C1:
27452 7F7B           2C                     00  sub	al,*0
27453 7F7D         0F84         FF25            beq 	.5C2
27454 7F81           2C                     01  sub	al,*1
27455 7F83         0F84         FF72            beq 	.5C5
27456 7F87           2C                     01  sub	al,*1
27457 7F89           74           D1            je 	.5CB
27458                       00007F8B            .5BF:
27459 7F8B           83C4                   0C  add	sp,#..FFE9-..FFEA
27460 7F8E           E9         06BE            br 	.FFE9
27461                                           !BCC_EOS
27462                                           ! 4051       break;
27463 7F91           E9         068B            br 	.59C
27464                                           !BCC_EOS
27465                                           ! 4052     case 0x46:
27466                                           ! 4053       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27467                       00007F94            .5CF:
27468                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27469 7F94           8A46         FD            mov	al,-3[bp]
27470 7F97           30E4                       xor	ah,ah
27471 7F99           B9                   001E  mov	cx,*$1E
27472 7F9C           F7E9                       imul	cx
27473 7F9E           89C3                       mov	bx,ax
27474                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27475                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27476 7FA0           81C3                 0145  add	bx,#$145
27477 7FA4           53                         push	bx
27478                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27479 7FA5           FF76         FE            push	-2[bp]
27480                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27481 7FA8           E8         864D            call	_read_byte
27482 7FAB           83C4                   04  add	sp,*4
27483                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27484 7FAE           8846         FB            mov	-5[bp],al
27485                                           !BCC_EOS
27486                                           ! 4054       if (locks != 0) {
27487                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27488 7FB1           8A46         FB            mov	al,-5[bp]
27489 7FB4           84C0                       test	al,al
27490 7FB6           74           11            je  	.5D0
27491                       00007FB8            .5D1:
27492                                           ! 4055         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27493                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27494 7FB8           8A46         18            mov	al,$18[bp]
27495                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27496 7FBB           30E4                       xor	ah,ah
27497 7FBD           0D                   B100  or	ax,#-$4F00
27498                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27499 7FC0           8946         18            mov	$18[bp],ax
27500                                           !BCC_EOS
27501                                           ! 4056         goto int13_fail_noah;
27502 7FC3           83C4                   0C  add	sp,#..FFE8-..FFEA
27503 7FC6           E9         0664            br 	.FFE8
27504                                           !BCC_EOS
27505                                           ! 4057       }
27506                                           ! 4058 #asm
27507                       00007FC9            .5D0:
27508                                           !BCC_EOS
27509                                           !BCC_ASM
27510                       0000002E            _int13_cdrom.BP	set	$2E
27511                       0000000E            .int13_cdrom.BP	set	$E
27512                       00000024            _int13_cdrom.EHBX	set	$24
27513                       00000004            .int13_cdrom.EHBX	set	4
27514                       0000003C            _int13_cdrom.CS	set	$3C
27515                       0000001C            .int13_cdrom.CS	set	$1C
27516                       00000008            _int13_cdrom.count	set	8
27517                       FFFFFFE8            .int13_cdrom.count	set	-$18
27518                       00000036            _int13_cdrom.CX	set	$36
27519                       00000016            .int13_cdrom.CX	set	$16
27520                       00000006            _int13_cdrom.segment	set	6
27521                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
27522                       0000002A            _int13_cdrom.DI	set	$2A
27523                       0000000A            .int13_cdrom.DI	set	$A
27524                       0000003E            _int13_cdrom.FLAGS	set	$3E
27525                       0000001E            .int13_cdrom.FLAGS	set	$1E
27526                       00000026            _int13_cdrom.DS	set	$26
27527                       00000006            .int13_cdrom.DS	set	6
27528                       00000030            _int13_cdrom.ELDX	set	$30
27529                       00000010            .int13_cdrom.ELDX	set	$10
27530                       00000034            _int13_cdrom.DX	set	$34
27531                       00000014            .int13_cdrom.DX	set	$14
27532                       00000000            _int13_cdrom.size	set	0
27533                       FFFFFFE0            .int13_cdrom.size	set	-$20
27534                       00000002            _int13_cdrom.i	set	2
27535                       FFFFFFE2            .int13_cdrom.i	set	-$1E
27536                       0000001D            _int13_cdrom.device	set	$1D
27537                       FFFFFFFD            .int13_cdrom.device	set	-3
27538                       00000028            _int13_cdrom.ES	set	$28
27539                       00000008            .int13_cdrom.ES	set	8
27540                       0000001E            _int13_cdrom.ebda_seg	set	$1E
27541                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
27542                       0000002C            _int13_cdrom.SI	set	$2C
27543                       0000000C            .int13_cdrom.SI	set	$C
27544                       0000003A            _int13_cdrom.IP	set	$3A
27545                       0000001A            .int13_cdrom.IP	set	$1A
27546                       0000000A            _int13_cdrom.lba	set	$A
27547                       FFFFFFEA            .int13_cdrom.lba	set	-$16
27548                       0000001C            _int13_cdrom.status	set	$1C
27549                       FFFFFFFC            .int13_cdrom.status	set	-4
27550                       0000000F            _int13_cdrom.atacmd	set	$F
27551                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
27552                       00000038            _int13_cdrom.AX	set	$38
27553                       00000018            .int13_cdrom.AX	set	$18
27554                       00000004            _int13_cdrom.offset	set	4
27555                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
27556                       00000032            _int13_cdrom.BX	set	$32
27557                       00000012            .int13_cdrom.BX	set	$12
27558                       0000001B            _int13_cdrom.locks	set	$1B
27559                       FFFFFFFB            .int13_cdrom.locks	set	-5
27560 7FC9           55                                 push bp
27561 7FCA           89E5                               mov bp, sp
27562 7FCC           B4                     52          mov ah, #0x52
27563 7FCE           CD                     15          int #0x15
27564 7FD0           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
27565 7FD3           73           06                    jnc int13_cdrom_rme_end
27566 7FD5           C706       001C      0001          mov _int13_cdrom.status, #1
27567                       00007FDB            int13_cdrom_rme_end:
27568 7FDB           5D                                 pop bp
27569                                           ! 4068 endasm
27570                                           !BCC_ENDASM
27571                                           !BCC_EOS
27572                                           ! 4069       if (status != 0) {
27573                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27574 7FDC           8A46         FC            mov	al,-4[bp]
27575 7FDF           84C0                       test	al,al
27576 7FE1           74           11            je  	.5D2
27577                       00007FE3            .5D3:
27578                                           ! 4070         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27579                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27580 7FE3           8A46         18            mov	al,$18[bp]
27581                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27582 7FE6           30E4                       xor	ah,ah
27583 7FE8           0D                   B100  or	ax,#-$4F00
27584                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27585 7FEB           8946         18            mov	$18[bp],ax
27586                                           !BCC_EOS
27587                                           ! 4071         goto int13_fail_noah;
27588 7FEE           83C4                   0C  add	sp,#..FFE8-..FFEA
27589 7FF1           E9         0639            br 	.FFE8
27590                                           !BCC_EOS
27591                                           ! 4072       }
27592                                           ! 4073       goto int13_success;
27593                       00007FF4            .5D2:
27594 7FF4           83C4                   0C  add	sp,#..FFE9-..FFEA
27595 7FF7           E9         0655            br 	.FFE9
27596                                           !BCC_EOS
27597                                           ! 4074       break;
27598 7FFA           E9         0622            br 	.59C
27599                                           !BCC_EOS
27600                                           ! 4075     case 0x48:
27601                                           ! 4076       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
27602                       00007FFD            .5D4:
27603                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
27604 7FFD           8B46         0C            mov	ax,$C[bp]
27605                                           ! Debug: list unsigned int = ax+0 (used reg = )
27606 8000           50                         push	ax
27607                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
27608 8001           FF76         06            push	6[bp]
27609                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27610 8004           E8         8604            call	_read_word
27611 8007           83C4                   04  add	sp,*4
27612                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
27613 800A           8946         E0            mov	-$20[bp],ax
27614                                           !BCC_EOS
27615                                           ! 4077       if(size < 0x1a)
27616                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27617 800D           8B46         E0            mov	ax,-$20[bp]
27618 8010           3D                   001A  cmp	ax,*$1A
27619 8013           73           06            jae 	.5D5
27620                       00008015            .5D6:
27621                                           ! 4078         goto int13_fail;
27622 8015           83C4                   0C  add	sp,#..FFEB-..FFEA
27623 8018           E9         0607            br 	.FFEB
27624                                           !BCC_EOS
27625                                           ! 4079       if(size >= 0x1a) {
27626                       0000801B            .5D5:
27627                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27628 801B           8B46         E0            mov	ax,-$20[bp]
27629 801E           3D                   001A  cmp	ax,*$1A
27630 8021         0F82         00CC            blo 	.5D7
27631                       00008025            .5D8:
27632                                           ! 4080         Bit16u cylinders, heads, spt, blksize;
27633                                           !BCC_EOS
27634                                           ! 4081         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
27635                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
27636 8025           8A46         FD            mov	al,-3[bp]
27637 8028           30E4                       xor	ah,ah
27638 802A           B9                   001E  mov	cx,*$1E
27639 802D           F7E9                       imul	cx
27640 802F           89C3                       mov	bx,ax
27641                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
27642                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
27643 8031           81C3                 0148  add	bx,#$148
27644 8035           53                         push	bx
27645                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
27646 8036           FF76         FE            push	-2[bp]
27647                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27648 8039           E8         85CF            call	_read_word
27649 803C           83C4                   04  add	sp,*4
27650                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
27651 803F           8946         D8            mov	-$28[bp],ax
27652                                           !BCC_EOS
27653                                           ! 4082         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
27654                                           ! Debug: list int = const $1A (used reg = )
27655 8042           B8                   001A  mov	ax,*$1A
27656 8045           50                         push	ax
27657                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
27658 8046           8B46         0C            mov	ax,$C[bp]
27659                                           ! Debug: list unsigned int = ax+0 (used reg = )
27660 8049           50                         push	ax
27661                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27662 804A           FF76         06            push	6[bp]
27663                                           ! Debug: func () void = write_word+0 (used reg = )
27664 804D           E8         85E6            call	_write_word
27665 8050           83C4                   06  add	sp,*6
27666                                           !BCC_EOS
27667                                           ! 4083         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
27668                                           ! Debug: list int = const $74 (used reg = )
27669 8053           B8                   0074  mov	ax,*$74
27670 8056           50                         push	ax
27671                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
27672 8057           8B46         0C            mov	ax,$C[bp]
27673                                           ! Debug: list unsigned int = ax+2 (used reg = )
27674 805A           40                         inc	ax
27675 805B           40                         inc	ax
27676 805C           50                         push	ax
27677                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27678 805D           FF76         06            push	6[bp]
27679                                           ! Debug: func () void = write_word+0 (used reg = )
27680 8060           E8         85D3            call	_write_word
27681 8063           83C4                   06  add	sp,*6
27682                                           !BCC_EOS
27683                                           ! 4084         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
27684                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27685 8066           B8                   FFFF  mov	ax,#$FFFF
27686 8069           BB                   FFFF  mov	bx,#$FFFF
27687 806C           53                         push	bx
27688 806D           50                         push	ax
27689                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
27690 806E           8B46         0C            mov	ax,$C[bp]
27691                                           ! Debug: list unsigned int = ax+4 (used reg = )
27692 8071           05                   0004  add	ax,*4
27693 8074           50                         push	ax
27694                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27695 8075           FF76         06            push	6[bp]
27696                                           ! Debug: func () void = write_dword+0 (used reg = )
27697 8078           E8         8020            call	_write_dword
27698 807B           83C4                   08  add	sp,*8
27699                                           !BCC_EOS
27700                                           ! 4085         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
27701                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27702 807E           B8                   FFFF  mov	ax,#$FFFF
27703 8081           BB                   FFFF  mov	bx,#$FFFF
27704 8084           53                         push	bx
27705 8085           50                         push	ax
27706                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
27707 8086           8B46         0C            mov	ax,$C[bp]
27708                                           ! Debug: list unsigned int = ax+8 (used reg = )
27709 8089           05                   0008  add	ax,*8
27710 808C           50                         push	ax
27711                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27712 808D           FF76         06            push	6[bp]
27713                                           ! Debug: func () void = write_dword+0 (used reg = )
27714 8090           E8         8008            call	_write_dword
27715 8093           83C4                   08  add	sp,*8
27716                                           !BCC_EOS
27717                                           ! 4086         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
27718                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27719 8096           B8                   FFFF  mov	ax,#$FFFF
27720 8099           BB                   FFFF  mov	bx,#$FFFF
27721 809C           53                         push	bx
27722 809D           50                         push	ax
27723                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
27724 809E           8B46         0C            mov	ax,$C[bp]
27725                                           ! Debug: list unsigned int = ax+$C (used reg = )
27726 80A1           05                   000C  add	ax,*$C
27727 80A4           50                         push	ax
27728                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27729 80A5           FF76         06            push	6[bp]
27730                                           ! Debug: func () void = write_dword+0 (used reg = )
27731 80A8           E8         7FF0            call	_write_dword
27732 80AB           83C4                   08  add	sp,*8
27733                                           !BCC_EOS
27734                                           ! 4087         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
27735                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27736 80AE           B8                   FFFF  mov	ax,#$FFFF
27737 80B1           BB                   FFFF  mov	bx,#$FFFF
27738 80B4           53                         push	bx
27739 80B5           50                         push	ax
27740                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
27741 80B6           8B46         0C            mov	ax,$C[bp]
27742                                           ! Debug: list unsigned int = ax+$10 (used reg = )
27743 80B9           05                   0010  add	ax,*$10
27744 80BC           50                         push	ax
27745                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27746 80BD           FF76         06            push	6[bp]
27747                                           ! Debug: func () void = write_dword+0 (used reg = )
27748 80C0           E8         7FD8            call	_write_dword
27749 80C3           83C4                   08  add	sp,*8
27750                                           !BCC_EOS
27751                                           ! 4088         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
27752                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27753 80C6           B8                   FFFF  mov	ax,#$FFFF
27754 80C9           BB                   FFFF  mov	bx,#$FFFF
27755 80CC           53                         push	bx
27756 80CD           50                         push	ax
27757                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
27758 80CE           8B46         0C            mov	ax,$C[bp]
27759                                           ! Debug: list unsigned int = ax+$14 (used reg = )
27760 80D1           05                   0014  add	ax,*$14
27761 80D4           50                         push	ax
27762                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27763 80D5           FF76         06            push	6[bp]
27764                                           ! Debug: func () void = write_dword+0 (used reg = )
27765 80D8           E8         7FC0            call	_write_dword
27766 80DB           83C4                   08  add	sp,*8
27767                                           !BCC_EOS
27768                                           ! 4089         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
27769                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
27770 80DE           FF76         D8            push	-$28[bp]
27771                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
27772 80E1           8B46         0C            mov	ax,$C[bp]
27773                                           ! Debug: list unsigned int = ax+$18 (used reg = )
27774 80E4           05                   0018  add	ax,*$18
27775 80E7           50                         push	ax
27776                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27777 80E8           FF76         06            push	6[bp]
27778                                           ! Debug: func () void = write_word+0 (used reg = )
27779 80EB           E8         8548            call	_write_word
27780 80EE           83C4                   06  add	sp,*6
27781                                           !BCC_EOS
27782                                           ! 4090       }
27783                                           ! 4091       if(size >= 0x1e) {
27784                       000080F1            .5D7:
27785                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
27786 80F1           8B46         E0            mov	ax,-$20[bp]
27787 80F4           3D                   001E  cmp	ax,*$1E
27788 80F7         0F82         01F9            blo 	.5D9
27789                       000080FB            .5DA:
27790                                           ! 4092         Bit8u channel, dev, irq, mode, checksum, i;
27791                                           !BCC_EOS
27792                                           ! 4093         Bit16u iobase1, iobase2, options;
27793                                           !BCC_EOS
27794                                           ! 4094         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
27795                                           ! Debug: list int = const $1E (used reg = )
27796 80FB           B8                   001E  mov	ax,*$1E
27797 80FE           50                         push	ax
27798                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
27799 80FF           8B46         0C            mov	ax,$C[bp]
27800                                           ! Debug: list unsigned int = ax+0 (used reg = )
27801 8102           50                         push	ax
27802                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27803 8103           FF76         06            push	6[bp]
27804                                           ! Debug: func () void = write_word+0 (used reg = )
27805 8106           E8         852D            call	_write_word
27806 8109           83C4                   06  add	sp,*6
27807                                           !BCC_EOS
27808                                           ! 4095         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
27809                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
27810 810C           FF76         FE            push	-2[bp]
27811                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
27812 810F           8B46         0C            mov	ax,$C[bp]
27813                                           ! Debug: list unsigned int = ax+$1C (used reg = )
27814 8112           05                   001C  add	ax,*$1C
27815 8115           50                         push	ax
27816                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27817 8116           FF76         06            push	6[bp]
27818                                           ! Debug: func () void = write_word+0 (used reg = )
27819 8119           E8         851A            call	_write_word
27820 811C           83C4                   06  add	sp,*6
27821                                           !BCC_EOS
27822                                           ! 4096         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
27823                                           ! Debug: list * struct  = const $244 (used reg = )
27824 811F           B8                   0244  mov	ax,#$244
27825 8122           50                         push	ax
27826                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
27827 8123           8B46         0C            mov	ax,$C[bp]
27828                                           ! Debug: list unsigned int = ax+$1A (used reg = )
27829 8126           05                   001A  add	ax,*$1A
27830 8129           50                         push	ax
27831                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27832 812A           FF76         06            push	6[bp]
27833                                           ! Debug: func () void = write_word+0 (used reg = )
27834 812D           E8         8506            call	_write_word
27835 8130           83C4                   06  add	sp,*6
27836                                           !BCC_EOS
27837                                           ! 4097         channel = device / 2;
27838                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27839 8133           8A46         FD            mov	al,-3[bp]
27840 8136           30E4                       xor	ah,ah
27841 8138           D1E8                       shr	ax,*1
27842                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
27843 813A           8846         DF            mov	-$21[bp],al
27844                                           !BCC_EOS
27845                                           ! 4098         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27846                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27847 813D           8A46         DF            mov	al,-$21[bp]
27848 8140           30E4                       xor	ah,ah
27849 8142           B1                     03  mov	cl,*3
27850 8144           D3E0                       shl	ax,cl
27851 8146           89C3                       mov	bx,ax
27852                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27853                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27854 8148           81C3                 0124  add	bx,#$124
27855 814C           53                         push	bx
27856                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27857 814D           FF76         FE            push	-2[bp]
27858                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27859 8150           E8         84B8            call	_read_word
27860 8153           83C4                   04  add	sp,*4
27861                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27862 8156           8946         D8            mov	-$28[bp],ax
27863                                           !BCC_EOS
27864                                           ! 4099         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
27865                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27866 8159           8A46         DF            mov	al,-$21[bp]
27867 815C           30E4                       xor	ah,ah
27868 815E           B1                     03  mov	cl,*3
27869 8160           D3E0                       shl	ax,cl
27870 8162           89C3                       mov	bx,ax
27871                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
27872                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
27873 8164           81C3                 0126  add	bx,#$126
27874 8168           53                         push	bx
27875                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27876 8169           FF76         FE            push	-2[bp]
27877                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27878 816C           E8         849C            call	_read_word
27879 816F           83C4                   04  add	sp,*4
27880                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27881 8172           8946         D6            mov	-$2A[bp],ax
27882                                           !BCC_EOS
27883                                           ! 4100         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
27884                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27885 8175           8A46         DF            mov	al,-$21[bp]
27886 8178           30E4                       xor	ah,ah
27887 817A           B1                     03  mov	cl,*3
27888 817C           D3E0                       shl	ax,cl
27889 817E           89C3                       mov	bx,ax
27890                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
27891                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
27892 8180           81C3                 0128  add	bx,#$128
27893 8184           53                         push	bx
27894                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27895 8185           FF76         FE            push	-2[bp]
27896                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27897 8188           E8         846D            call	_read_byte
27898 818B           83C4                   04  add	sp,*4
27899                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
27900 818E           8846         DD            mov	-$23[bp],al
27901                                           !BCC_EOS
27902                                           ! 4101         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
27903                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
27904 8191           8A46         FD            mov	al,-3[bp]
27905 8194           30E4                       xor	ah,ah
27906 8196           B9                   001E  mov	cx,*$1E
27907 8199           F7E9                       imul	cx
27908 819B           89C3                       mov	bx,ax
27909                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
27910                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
27911 819D           81C3                 0146  add	bx,#$146
27912 81A1           53                         push	bx
27913                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27914 81A2           FF76         FE            push	-2[bp]
27915                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27916 81A5           E8         8450            call	_read_byte
27917 81A8           83C4                   04  add	sp,*4
27918                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
27919 81AB           8846         DC            mov	-$24[bp],al
27920                                           !BCC_EOS
27921                                           ! 4102         options = (1<<4);
27922                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
27923 81AE           B8                   0010  mov	ax,*$10
27924 81B1           8946         D4            mov	-$2C[bp],ax
27925                                           !BCC_EOS
27926                                           ! 4103         options |= (1<<5);
27927                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
27928 81B4           8B46         D4            mov	ax,-$2C[bp]
27929 81B7           0C                     20  or	al,*$20
27930 81B9           8946         D4            mov	-$2C[bp],ax
27931                                           !BCC_EOS
27932                                           ! 4104         options |= 
27933                                           ! 4104 (1<<6);
27934                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
27935 81BC           8B46         D4            mov	ax,-$2C[bp]
27936 81BF           0C                     40  or	al,*$40
27937 81C1           8946         D4            mov	-$2C[bp],ax
27938                                           !BCC_EOS
27939                                           ! 4105         options |= (mode==0x01?1:0<<7);
27940                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
27941 81C4           8A46         DC            mov	al,-$24[bp]
27942 81C7           3C                     01  cmp	al,*1
27943 81C9           75           04            jne 	.5DB
27944                       000081CB            .5DC:
27945 81CB           B0                     01  mov	al,*1
27946 81CD           EB           02            jmp .5DD
27947                       000081CF            .5DB:
27948 81CF           30C0                       xor	al,al
27949                       000081D1            .5DD:
27950                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27951 81D1           30E4                       xor	ah,ah
27952 81D3           0B46         D4            or	ax,-$2C[bp]
27953 81D6           8946         D4            mov	-$2C[bp],ax
27954                                           !BCC_EOS
27955                                           ! 4106         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27956                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27957 81D9           FF76         D8            push	-$28[bp]
27958                                           ! Debug: list * unsigned short = const $244 (used reg = )
27959 81DC           B8                   0244  mov	ax,#$244
27960 81DF           50                         push	ax
27961                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27962 81E0           FF76         FE            push	-2[bp]
27963                                           ! Debug: func () void = write_word+0 (used reg = )
27964 81E3           E8         8450            call	_write_word
27965 81E6           83C4                   06  add	sp,*6
27966                                           !BCC_EOS
27967                                           ! 4107         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27968                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27969 81E9           8B46         D6            mov	ax,-$2A[bp]
27970                                           ! Debug: list unsigned int = ax+6 (used reg = )
27971 81EC           05                   0006  add	ax,*6
27972 81EF           50                         push	ax
27973                                           ! Debug: list * unsigned short = const $246 (used reg = )
27974 81F0           B8                   0246  mov	ax,#$246
27975 81F3           50                         push	ax
27976                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27977 81F4           FF76         FE            push	-2[bp]
27978                                           ! Debug: func () void = write_word+0 (used reg = )
27979 81F7           E8         843C            call	_write_word
27980 81FA           83C4                   06  add	sp,*6
27981                                           !BCC_EOS
27982                                           ! 4108         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
27983                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27984 81FD           8A46         FD            mov	al,-3[bp]
27985 8200           30E4                       xor	ah,ah
27986 8202           24                     01  and	al,*1
27987                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27988                                           ! Debug: expression subtree swapping
27989 8204           0C                     0E  or	al,*$E
27990                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
27991 8206           30E4                       xor	ah,ah
27992 8208           B1                     04  mov	cl,*4
27993 820A           D3E0                       shl	ax,cl
27994                                           ! Debug: list unsigned int = ax+0 (used reg = )
27995 820C           50                         push	ax
27996                                           ! Debug: list * unsigned char = const $248 (used reg = )
27997 820D           B8                   0248  mov	ax,#$248
27998 8210           50                         push	ax
27999                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28000 8211           FF76         FE            push	-2[bp]
28001                                           ! Debug: func () void = write_byte+0 (used reg = )
28002 8214           E8         8407            call	_write_byte
28003 8217           83C4                   06  add	sp,*6
28004                                           !BCC_EOS
28005                                           ! 4109         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
28006                                           ! Debug: list int = const $CB (used reg = )
28007 821A           B8                   00CB  mov	ax,#$CB
28008 821D           50                         push	ax
28009                                           ! Debug: list * unsigned char = const $249 (used reg = )
28010 821E           B8                   0249  mov	ax,#$249
28011 8221           50                         push	ax
28012                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28013 8222           FF76         FE            push	-2[bp]
28014                                           ! Debug: func () void = write_byte+0 (used reg = )
28015 8225           E8         83F6            call	_write_byte
28016 8228           83C4                   06  add	sp,*6
28017                                           !BCC_EOS
28018                                           ! 4110         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
28019                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
28020 822B           8A46         DD            mov	al,-$23[bp]
28021 822E           30E4                       xor	ah,ah
28022 8230           50                         push	ax
28023                                           ! Debug: list * unsigned char = const $24A (used reg = )
28024 8231           B8                   024A  mov	ax,#$24A
28025 8234           50                         push	ax
28026                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28027 8235           FF76         FE            push	-2[bp]
28028                                           ! Debug: func () void = write_byte+0 (used reg = )
28029 8238           E8         83E3            call	_write_byte
28030 823B           83C4                   06  add	sp,*6
28031                                           !BCC_EOS
28032                                           ! 4111         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
28033                                           ! Debug: list int = const 1 (used reg = )
28034 823E           B8                   0001  mov	ax,*1
28035 8241           50                         push	ax
28036                                           ! Debug: list * unsigned char = const $24B (used reg = )
28037 8242           B8                   024B  mov	ax,#$24B
28038 8245           50                         push	ax
28039                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28040 8246           FF76         FE            push	-2[bp]
28041                                           ! Debug: func () void = write_byte+0 (used reg = )
28042 8249           E8         83D2            call	_write_byte
28043 824C           83C4                   06  add	sp,*6
28044                                           !BCC_EOS
28045                                           ! 4112         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
28046                                           ! Debug: list int = const 0 (used reg = )
28047 824F           31C0                       xor	ax,ax
28048 8251           50                         push	ax
28049                                           ! Debug: list * unsigned char = const $24C (used reg = )
28050 8252           B8                   024C  mov	ax,#$24C
28051 8255           50                         push	ax
28052                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28053 8256           FF76         FE            push	-2[bp]
28054                                           ! Debug: func () void = write_byte+0 (used reg = )
28055 8259           E8         83C2            call	_write_byte
28056 825C           83C4                   06  add	sp,*6
28057                                           !BCC_EOS
28058                                           ! 4113         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
28059                                           ! Debug: list int = const 0 (used reg = )
28060 825F           31C0                       xor	ax,ax
28061 8261           50                         push	ax
28062                                           ! Debug: list * unsigned char = const $24D (used reg = )
28063 8262           B8                   024D  mov	ax,#$24D
28064 8265           50                         push	ax
28065                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28066 8266           FF76         FE            push	-2[bp]
28067                                           ! Debug: func () void = write_byte+0 (used reg = )
28068 8269           E8         83B2            call	_write_byte
28069 826C           83C4                   06  add	sp,*6
28070                                           !BCC_EOS
28071                                           ! 4114         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
28072                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
28073 826F           FF76         D4            push	-$2C[bp]
28074                                           ! Debug: list * unsigned short = const $24E (used reg = )
28075 8272           B8                   024E  mov	ax,#$24E
28076 8275           50                         push	ax
28077                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28078 8276           FF76         FE            push	-2[bp]
28079                                           ! Debug: func () void = write_word+0 (used reg = )
28080 8279           E8         83BA            call	_write_word
28081 827C           83C4                   06  add	sp,*6
28082                                           !BCC_EOS
28083                                           ! 4115         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
28084                                           ! Debug: list int = const 0 (used reg = )
28085 827F           31C0                       xor	ax,ax
28086 8281           50                         push	ax
28087                                           ! Debug: list * unsigned short = const $250 (used reg = )
28088 8282           B8                   0250  mov	ax,#$250
28089 8285           50                         push	ax
28090                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28091 8286           FF76         FE            push	-2[bp]
28092                                           ! Debug: func () void = write_word+0 (used reg = )
28093 8289           E8         83AA            call	_write_word
28094 828C           83C4                   06  add	sp,*6
28095                                           !BCC_EOS
28096                                           ! 4116         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
28097                                           ! Debug: list int = const $11 (used reg = )
28098 828F           B8                   0011  mov	ax,*$11
28099 8292           50                         push	ax
28100                                           ! Debug: list * unsigned char = const $252 (used reg = )
28101 8293           B8                   0252  mov	ax,#$252
28102 8296           50                         push	ax
28103                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28104 8297           FF76         FE            push	-2[bp]
28105                                           ! Debug: func () void = write_byte+0 (used reg = )
28106 829A           E8         8381            call	_write_byte
28107 829D           83C4                   06  add	sp,*6
28108                                           !BCC_EOS
28109                                           ! 4117         checksum=0;
28110                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28111 82A0           30C0                       xor	al,al
28112 82A2           8846         DB            mov	-$25[bp],al
28113                                           !BCC_EOS
28114                                           ! 4118         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
28115                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
28116 82A5           30C0                       xor	al,al
28117 82A7           8846         DA            mov	-$26[bp],al
28118                                           !BCC_EOS
28119                                           !BCC_EOS
28120 82AA           EB           24            jmp .5E0
28121                       000082AC            .5E1:
28122                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
28123 82AC           8A46         DA            mov	al,-$26[bp]
28124 82AF           30E4                       xor	ah,ah
28125                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
28126 82B1           05                   0244  add	ax,#$244
28127 82B4           50                         push	ax
28128                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
28129 82B5           FF76         FE            push	-2[bp]
28130                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28131 82B8           E8         833D            call	_read_byte
28132 82BB           83C4                   04  add	sp,*4
28133                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28134 82BE           30E4                       xor	ah,ah
28135 82C0           0246         DB            add	al,-$25[bp]
28136 82C3           80D4                   00  adc	ah,*0
28137 82C6           8846         DB            mov	-$25[bp],al
28138                                           !BCC_EOS
28139                                           ! 4119         checksum = ~checksum;
28140                       000082C9            .5DF:
28141                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
28142 82C9           8A46         DA            mov	al,-$26[bp]
28143 82CC           40                         inc	ax
28144 82CD           8846         DA            mov	-$26[bp],al
28145                       000082D0            .5E0:
28146                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
28147 82D0           8A46         DA            mov	al,-$26[bp]
28148 82D3           3C                     0F  cmp	al,*$F
28149 82D5           72           D5            jb 	.5E1
28150                       000082D7            .5E2:
28151                       000082D7            .5DE:
28152                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
28153 82D7           8A46         DB            mov	al,-$25[bp]
28154 82DA           30E4                       xor	ah,ah
28155 82DC           F7D0                       not	ax
28156                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
28157 82DE           8846         DB            mov	-$25[bp],al
28158                                           !BCC_EOS
28159                                           ! 4120         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
28160                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
28161 82E1           8A46         DB            mov	al,-$25[bp]
28162 82E4           30E4                       xor	ah,ah
28163 82E6           50                         push	ax
28164                                           ! Debug: list * unsigned char = const $253 (used reg = )
28165 82E7           B8                   0253  mov	ax,#$253
28166 82EA           50                         push	ax
28167                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
28168 82EB           FF76         FE            push	-2[bp]
28169                                           ! Debug: func () void = write_byte+0 (used reg = )
28170 82EE           E8         832D            call	_write_byte
28171 82F1           83C4                   06  add	sp,*6
28172                                           !BCC_EOS
28173                                           ! 4121       }
28174                                           ! 4122       if(size >= 0x42) {
28175                       000082F4            .5D9:
28176                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
28177 82F4           8B46         E0            mov	ax,-$20[bp]
28178 82F7           3D                   0042  cmp	ax,*$42
28179 82FA         0F82         023B            blo 	.5E3
28180                       000082FE            .5E4:
28181                                           ! 4123         Bit8u channel, iface, checksum, i;
28182                                           !BCC_EOS
28183                                           ! 4124         Bit16u iobase1;
28184                                           !BCC_EOS
28185                                           ! 4125         channel = device / 2;
28186                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28187 82FE           8A46         FD            mov	al,-3[bp]
28188 8301           30E4                       xor	ah,ah
28189 8303           D1E8                       shr	ax,*1
28190                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
28191 8305           8846         DF            mov	-$21[bp],al
28192                                           !BCC_EOS
28193                                           ! 4126         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
28194                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28195 8308           8A46         DF            mov	al,-$21[bp]
28196 830B           30E4                       xor	ah,ah
28197 830D           B1                     03  mov	cl,*3
28198 830F           D3E0                       shl	ax,cl
28199 8311           89C3                       mov	bx,ax
28200                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
28201                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
28202 8313           81C3                 0122  add	bx,#$122
28203 8317           53                         push	bx
28204                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28205 8318           FF76         FE            push	-2[bp]
28206                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28207 831B           E8         82DA            call	_read_byte
28208 831E           83C4                   04  add	sp,*4
28209                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
28210 8321           8846         DE            mov	-$22[bp],al
28211                                           !BCC_EOS
28212                                           ! 4127         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
28213                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28214 8324           8A46         DF            mov	al,-$21[bp]
28215 8327           30E4                       xor	ah,ah
28216 8329           B1                     03  mov	cl,*3
28217 832B           D3E0                       shl	ax,cl
28218 832D           89C3                       mov	bx,ax
28219                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
28220                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
28221 832F           81C3                 0124  add	bx,#$124
28222 8333           53                         push	bx
28223                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28224 8334           FF76         FE            push	-2[bp]
28225                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28226 8337           E8         82D1            call	_read_word
28227 833A           83C4                   04  add	sp,*4
28228                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
28229 833D           8946         DA            mov	-$26[bp],ax
28230                                           !BCC_EOS
28231                                           ! 4128         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
28232                                           ! Debug: list int = const $42 (used reg = )
28233 8340           B8                   0042  mov	ax,*$42
28234 8343           50                         push	ax
28235                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
28236 8344           8B46         0C            mov	ax,$C[bp]
28237                                           ! Debug: list unsigned int = ax+0 (used reg = )
28238 8347           50                         push	ax
28239                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28240 8348           FF76         06            push	6[bp]
28241                                           ! Debug: func () void = write_word+0 (used reg = )
28242 834B           E8         82E8            call	_write_word
28243 834E           83C4                   06  add	sp,*6
28244                                           !BCC_EOS
28245                                           ! 4129         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
28246                                           ! Debug: list unsigned int = const $BEDD (used reg = )
28247 8351           B8                   BEDD  mov	ax,#$BEDD
28248 8354           50                         push	ax
28249                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
28250 8355           8B46         0C            mov	ax,$C[bp]
28251                                           ! Debug: list unsigned int = ax+$1E (used reg = )
28252 8358           05                   001E  add	ax,*$1E
28253 835B           50                         push	ax
28254                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28255 835C           FF76         06            push	6[bp]
28256                                           ! Debug: func () void = write_word+0 (used reg = )
28257 835F           E8         82D4            call	_write_word
28258 8362           83C4                   06  add	sp,*6
28259                                           !BCC_EOS
28260                                           ! 4130         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
28261                                           ! Debug: list int = const $24 (used reg = )
28262 8365           B8                   0024  mov	ax,*$24
28263 8368           50                         push	ax
28264                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
28265 8369           8B46         0C            mov	ax,$C[bp]
28266                                           ! Debug: list unsigned int = ax+$20 (used reg = )
28267 836C           05                   0020  add	ax,*$20
28268 836F           50                         push	ax
28269                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28270 8370           FF76         06            push	6[bp]
28271                                           ! Debug: func () void = write_byte+0 (used reg = )
28272 8373           E8         82A8            call	_write_byte
28273 8376           83C4                   06  add	sp,*6
28274                                           !BCC_EOS
28275                                           ! 4131         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
28276                                           ! Debug: list int = const 0 (used reg = )
28277 8379           31C0                       xor	ax,ax
28278 837B           50                         push	ax
28279                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
28280 837C           8B46         0C            mov	ax,$C[bp]
28281                                           ! Debug: list unsigned int = ax+$21 (used reg = )
28282 837F           05                   0021  add	ax,*$21
28283 8382           50                         push	ax
28284                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28285 8383           FF76         06            push	6[bp]
28286                                           ! Debug: func () void = write_byte+0 (used reg = )
28287 8386           E8         8295            call	_write_byte
28288 8389           83C4                   06  add	sp,*6
28289                                           !BCC_EOS
28290                                           ! 4132         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
28291                                           ! Debug: list int = const 0 (used reg = )
28292 838C           31C0                       xor	ax,ax
28293 838E           50                         push	ax
28294                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
28295 838F           8B46         0C            mov	ax,$C[bp]
28296                                           ! Debug: list unsigned int = ax+$22 (used reg = )
28297 8392           05                   0022  add	ax,*$22
28298 8395           50                         push	ax
28299                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28300 8396           FF76         06            push	6[bp]
28301                                           ! Debug: func () void = write_word+0 (used reg = )
28302 8399           E8         829A            call	_write_word
28303 839C           83C4                   06  add	sp,*6
28304                                           !BCC_EOS
28305                                           ! 4133         if (iface==0x00) {
28306                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28307 839F           8A46         DE            mov	al,-$22[bp]
28308 83A2           84C0                       test	al,al
28309 83A4           75           51            jne 	.5E5
28310                       000083A6            .5E6:
28311                                           ! 4134           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
28312                                           ! Debug: list int = const $49 (used reg = )
28313 83A6           B8                   0049  mov	ax,*$49
28314 83A9           50                         push	ax
28315                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
28316 83AA           8B46         0C            mov	ax,$C[bp]
28317                                           ! Debug: list unsigned int = ax+$24 (used reg = )
28318 83AD           05                   0024  add	ax,*$24
28319 83B0           50                         push	ax
28320                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28321 83B1           FF76         06            push	6[bp]
28322                                           ! Debug: func () void = write_byte+0 (used reg = )
28323 83B4           E8         8267            call	_write_byte
28324 83B7           83C4                   06  add	sp,*6
28325                                           !BCC_EOS
28326                                           ! 4135           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
28327                                           ! Debug: list int = const $53 (used reg = )
28328 83BA           B8                   0053  mov	ax,*$53
28329 83BD           50                         push	ax
28330                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
28331 83BE           8B46         0C            mov	ax,$C[bp]
28332                                           ! Debug: list unsigned int = ax+$25 (used reg = )
28333 83C1           05                   0025  add	ax,*$25
28334 83C4           50                         push	ax
28335                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28336 83C5           FF76         06            push	6[bp]
28337                                           ! Debug: func () void = write_byte+0 (used reg = )
28338 83C8           E8         8253            call	_write_byte
28339 83CB           83C4                   06  add	sp,*6
28340                                           !BCC_EOS
28341                                           ! 4136           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
28342                                           ! Debug: list int = const $41 (used reg = )
28343 83CE           B8                   0041  mov	ax,*$41
28344 83D1           50                         push	ax
28345                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
28346 83D2           8B46         0C            mov	ax,$C[bp]
28347                                           ! Debug: list unsigned int = ax+$26 (used reg = )
28348 83D5           05                   0026  add	ax,*$26
28349 83D8           50                         push	ax
28350                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28351 83D9           FF76         06            push	6[bp]
28352                                           ! Debug: func () void = write_byte+0 (used reg = )
28353 83DC           E8         823F            call	_write_byte
28354 83DF           83C4                   06  add	sp,*6
28355                                           !BCC_EOS
28356                                           ! 4137           write_byte(DS, SI+(Bit16u
28357                                           ! 4137 )&((dpt_t *) 0)->host_bus[3], 0);
28358                                           ! Debug: list int = const 0 (used reg = )
28359 83E2           31C0                       xor	ax,ax
28360 83E4           50                         push	ax
28361                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
28362 83E5           8B46         0C            mov	ax,$C[bp]
28363                                           ! Debug: list unsigned int = ax+$27 (used reg = )
28364 83E8           05                   0027  add	ax,*$27
28365 83EB           50                         push	ax
28366                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28367 83EC           FF76         06            push	6[bp]
28368                                           ! Debug: func () void = write_byte+0 (used reg = )
28369 83EF           E8         822C            call	_write_byte
28370 83F2           83C4                   06  add	sp,*6
28371                                           !BCC_EOS
28372                                           ! 4138         }
28373                                           ! 4139         else {
28374 83F5           EB           00            jmp .5E7
28375                       000083F7            .5E5:
28376                                           ! 4140         }
28377                                           ! 4141         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
28378                       000083F7            .5E7:
28379                                           ! Debug: list int = const $41 (used reg = )
28380 83F7           B8                   0041  mov	ax,*$41
28381 83FA           50                         push	ax
28382                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
28383 83FB           8B46         0C            mov	ax,$C[bp]
28384                                           ! Debug: list unsigned int = ax+$28 (used reg = )
28385 83FE           05                   0028  add	ax,*$28
28386 8401           50                         push	ax
28387                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28388 8402           FF76         06            push	6[bp]
28389                                           ! Debug: func () void = write_byte+0 (used reg = )
28390 8405           E8         8216            call	_write_byte
28391 8408           83C4                   06  add	sp,*6
28392                                           !BCC_EOS
28393                                           ! 4142         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
28394                                           ! Debug: list int = const $54 (used reg = )
28395 840B           B8                   0054  mov	ax,*$54
28396 840E           50                         push	ax
28397                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
28398 840F           8B46         0C            mov	ax,$C[bp]
28399                                           ! Debug: list unsigned int = ax+$29 (used reg = )
28400 8412           05                   0029  add	ax,*$29
28401 8415           50                         push	ax
28402                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28403 8416           FF76         06            push	6[bp]
28404                                           ! Debug: func () void = write_byte+0 (used reg = )
28405 8419           E8         8202            call	_write_byte
28406 841C           83C4                   06  add	sp,*6
28407                                           !BCC_EOS
28408                                           ! 4143         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
28409                                           ! Debug: list int = const $41 (used reg = )
28410 841F           B8                   0041  mov	ax,*$41
28411 8422           50                         push	ax
28412                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
28413 8423           8B46         0C            mov	ax,$C[bp]
28414                                           ! Debug: list unsigned int = ax+$2A (used reg = )
28415 8426           05                   002A  add	ax,*$2A
28416 8429           50                         push	ax
28417                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28418 842A           FF76         06            push	6[bp]
28419                                           ! Debug: func () void = write_byte+0 (used reg = )
28420 842D           E8         81EE            call	_write_byte
28421 8430           83C4                   06  add	sp,*6
28422                                           !BCC_EOS
28423                                           ! 4144         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
28424                                           ! Debug: list int = const 0 (used reg = )
28425 8433           31C0                       xor	ax,ax
28426 8435           50                         push	ax
28427                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
28428 8436           8B46         0C            mov	ax,$C[bp]
28429                                           ! Debug: list unsigned int = ax+$2B (used reg = )
28430 8439           05                   002B  add	ax,*$2B
28431 843C           50                         push	ax
28432                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28433 843D           FF76         06            push	6[bp]
28434                                           ! Debug: func () void = write_byte+0 (used reg = )
28435 8440           E8         81DB            call	_write_byte
28436 8443           83C4                   06  add	sp,*6
28437                                           !BCC_EOS
28438                                           ! 4145         if (iface==0x00) {
28439                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28440 8446           8A46         DE            mov	al,-$22[bp]
28441 8449           84C0                       test	al,al
28442 844B           75           3E            jne 	.5E8
28443                       0000844D            .5E9:
28444                                           ! 4146           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
28445                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
28446 844D           FF76         DA            push	-$26[bp]
28447                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
28448 8450           8B46         0C            mov	ax,$C[bp]
28449                                           ! Debug: list unsigned int = ax+$30 (used reg = )
28450 8453           05                   0030  add	ax,*$30
28451 8456           50                         push	ax
28452                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28453 8457           FF76         06            push	6[bp]
28454                                           ! Debug: func () void = write_word+0 (used reg = )
28455 845A           E8         81D9            call	_write_word
28456 845D           83C4                   06  add	sp,*6
28457                                           !BCC_EOS
28458                                           ! 4147           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
28459                                           ! Debug: list int = const 0 (used reg = )
28460 8460           31C0                       xor	ax,ax
28461 8462           50                         push	ax
28462                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
28463 8463           8B46         0C            mov	ax,$C[bp]
28464                                           ! Debug: list unsigned int = ax+$32 (used reg = )
28465 8466           05                   0032  add	ax,*$32
28466 8469           50                         push	ax
28467                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28468 846A           FF76         06            push	6[bp]
28469                                           ! Debug: func () void = write_word+0 (used reg = )
28470 846D           E8         81C6            call	_write_word
28471 8470           83C4                   06  add	sp,*6
28472                                           !BCC_EOS
28473                                           ! 4148           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
28474                                           ! Debug: list long = const 0 (used reg = )
28475 8473           31C0                       xor	ax,ax
28476 8475           31DB                       xor	bx,bx
28477 8477           53                         push	bx
28478 8478           50                         push	ax
28479                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
28480 8479           8B46         0C            mov	ax,$C[bp]
28481                                           ! Debug: list unsigned int = ax+$34 (used reg = )
28482 847C           05                   0034  add	ax,*$34
28483 847F           50                         push	ax
28484                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28485 8480           FF76         06            push	6[bp]
28486                                           ! Debug: func () void = write_dword+0 (used reg = )
28487 8483           E8         7C15            call	_write_dword
28488 8486           83C4                   08  add	sp,*8
28489                                           !BCC_EOS
28490                                           ! 4149         }
28491                                           ! 4150         else {
28492 8489           EB           00            jmp .5EA
28493                       0000848B            .5E8:
28494                                           ! 4151         }
28495                                           ! 4152         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
28496                       0000848B            .5EA:
28497                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28498 848B           8A46         FD            mov	al,-3[bp]
28499 848E           30E4                       xor	ah,ah
28500 8490           24                     01  and	al,*1
28501                                           ! Debug: list unsigned char = al+0 (used reg = )
28502 8492           30E4                       xor	ah,ah
28503 8494           50                         push	ax
28504                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
28505 8495           8B46         0C            mov	ax,$C[bp]
28506                                           ! Debug: list unsigned int = ax+$38 (used reg = )
28507 8498           05                   0038  add	ax,*$38
28508 849B           50                         push	ax
28509                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28510 849C           FF76         06            push	6[bp]
28511                                           ! Debug: func () void = write_byte+0 (used reg = )
28512 849F           E8         817C            call	_write_byte
28513 84A2           83C4                   06  add	sp,*6
28514                                           !BCC_EOS
28515                                           ! 4153         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
28516                                           ! Debug: list int = const 0 (used reg = )
28517 84A5           31C0                       xor	ax,ax
28518 84A7           50                         push	ax
28519                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
28520 84A8           8B46         0C            mov	ax,$C[bp]
28521                                           ! Debug: list unsigned int = ax+$39 (used reg = )
28522 84AB           05                   0039  add	ax,*$39
28523 84AE           50                         push	ax
28524                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28525 84AF           FF76         06            push	6[bp]
28526                                           ! Debug: func () void = write_byte+0 (used reg = )
28527 84B2           E8         8169            call	_write_byte
28528 84B5           83C4                   06  add	sp,*6
28529                                           !BCC_EOS
28530                                           ! 4154         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
28531                                           ! Debug: list int = const 0 (used reg = )
28532 84B8           31C0                       xor	ax,ax
28533 84BA           50                         push	ax
28534                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
28535 84BB           8B46         0C            mov	ax,$C[bp]
28536                                           ! Debug: list unsigned int = ax+$3A (used reg = )
28537 84BE           05                   003A  add	ax,*$3A
28538 84C1           50                         push	ax
28539                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28540 84C2           FF76         06            push	6[bp]
28541                                           ! Debug: func () void = write_word+0 (used reg = )
28542 84C5           E8         816E            call	_write_word
28543 84C8           83C4                   06  add	sp,*6
28544                                           !BCC_EOS
28545                                           ! 4155         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
28546                                           ! Debug: list long = const 0 (used reg = )
28547 84CB           31C0                       xor	ax,ax
28548 84CD           31DB                       xor	bx,bx
28549 84CF           53                         push	bx
28550 84D0           50                         push	ax
28551                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
28552 84D1           8B46         0C            mov	ax,$C[bp]
28553                                           ! Debug: list unsigned int = ax+$3C (used reg = )
28554 84D4           05                   003C  add	ax,*$3C
28555 84D7           50                         push	ax
28556                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28557 84D8           FF76         06            push	6[bp]
28558                                           ! Debug: func () void = write_dword+0 (used reg = )
28559 84DB           E8         7BBD            call	_write_dword
28560 84DE           83C4                   08  add	sp,*8
28561                                           !BCC_EOS
28562                                           ! 4156         checksum=0;
28563                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
28564 84E1           30C0                       xor	al,al
28565 84E3           8846         DD            mov	-$23[bp],al
28566                                           !BCC_EOS
28567                                           ! 4157         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
28568                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
28569 84E6           B0                     1E  mov	al,*$1E
28570 84E8           8846         DC            mov	-$24[bp],al
28571                                           !BCC_EOS
28572                                           !BCC_EOS
28573 84EB           EB           25            jmp .5ED
28574                       000084ED            .5EE:
28575                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
28576 84ED           8B46         0C            mov	ax,$C[bp]
28577 84F0           0246         DC            add	al,-$24[bp]
28578 84F3           80D4                   00  adc	ah,*0
28579                                           ! Debug: list unsigned int = ax+0 (used reg = )
28580 84F6           50                         push	ax
28581                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
28582 84F7           FF76         06            push	6[bp]
28583                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28584 84FA           E8         80FB            call	_read_byte
28585 84FD           83C4                   04  add	sp,*4
28586                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28587 8500           30E4                       xor	ah,ah
28588 8502           0246         DD            add	al,-$23[bp]
28589 8505           80D4                   00  adc	ah,*0
28590 8508           8846         DD            mov	-$23[bp],al
28591                                           !BCC_EOS
28592                                           ! 4158         checksum = ~checksum;
28593                       0000850B            .5EC:
28594                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
28595 850B           8A46         DC            mov	al,-$24[bp]
28596 850E           40                         inc	ax
28597 850F           8846         DC            mov	-$24[bp],al
28598                       00008512            .5ED:
28599                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
28600 8512           8A46         DC            mov	al,-$24[bp]
28601 8515           3C                     40  cmp	al,*$40
28602 8517           72           D4            jb 	.5EE
28603                       00008519            .5EF:
28604                       00008519            .5EB:
28605                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
28606 8519           8A46         DD            mov	al,-$23[bp]
28607 851C           30E4                       xor	ah,ah
28608 851E           F7D0                       not	ax
28609                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28610 8520           8846         DD            mov	-$23[bp],al
28611                                           !BCC_EOS
28612                                           ! 4159         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
28613                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
28614 8523           8A46         DD            mov	al,-$23[bp]
28615 8526           30E4                       xor	ah,ah
28616 8528           50                         push	ax
28617                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
28618 8529           8B46         0C            mov	ax,$C[bp]
28619                                           ! Debug: list unsigned int = ax+$41 (used reg = )
28620 852C           05                   0041  add	ax,*$41
28621 852F           50                         push	ax
28622                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28623 8530           FF76         06            push	6[bp]
28624                                           ! Debug: func () void = write_byte+0 (used reg = )
28625 8533           E8         80E8            call	_write_byte
28626 8536           83C4                   06  add	sp,*6
28627                                           !BCC_EOS
28628                                           ! 4160       }
28629                                           ! 4161       goto int13_success;
28630                       00008539            .5E3:
28631 8539           83C4                   0C  add	sp,#..FFE9-..FFEA
28632 853C           E9         0110            br 	.FFE9
28633                                           !BCC_EOS
28634                                           ! 4162       break;
28635 853F           E9         00DD            br 	.59C
28636                                           !BCC_EOS
28637                                           ! 4163     case 0x49:
28638                                           ! 4164       AX = ((AX & 0x00ff) | ((06) << 8));
28639                       00008542            .5F0:
28640                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28641 8542           8A46         18            mov	al,$18[bp]
28642                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
28643 8545           30E4                       xor	ah,ah
28644 8547           0D                   0600  or	ax,#$600
28645                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28646 854A           8946         18            mov	$18[bp],ax
28647                                           !BCC_EOS
28648                                           ! 4165       goto int13_fail_nostatus;
28649 854D           83C4                   0C  add	sp,#..FFE7-..FFEA
28650 8550           E9         00F0            br 	.FFE7
28651                                           !BCC_EOS
28652                                           ! 4166       break;
28653 8553           E9         00C9            br 	.59C
28654                                           !BCC_EOS
28655                                           ! 4167     case 0x4e:
28656                                           ! 4168       switch (( AX & 0x00ff )) {
28657                       00008556            .5F1:
28658                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28659 8556           8A46         18            mov	al,$18[bp]
28660 8559           EB           10            jmp .5F4
28661                                           ! 4169         case 0x01:
28662                                           ! 4170         case 0x03:
28663                       0000855B            .5F5:
28664                                           ! 4171         case 0x04:
28665                       0000855B            .5F6:
28666                                           ! 4172         case 0x06:
28667                       0000855B            .5F7:
28668                                           ! 4173           goto int13_success;
28669                       0000855B            .5F8:
28670 855B           83C4                   0C  add	sp,#..FFE9-..FFEA
28671 855E           E9         00EE            br 	.FFE9
28672                                           !BCC_EOS
28673                                           ! 4174           break;
28674 8561           EB           1A            jmp .5F2
28675                                           !BCC_EOS
28676                                           ! 4175         default:
28677                                           ! 4176           goto int13_fail;
28678                       00008563            .5F9:
28679 8563           83C4                   0C  add	sp,#..FFEB-..FFEA
28680 8566           E9         00B9            br 	.FFEB
28681                                           !BCC_EOS
28682                                           ! 4177       }
28683                                           ! 4178       break;
28684 8569           EB           12            jmp .5F2
28685                       0000856B            .5F4:
28686 856B           2C                     01  sub	al,*1
28687 856D           74           EC            je 	.5F5
28688 856F           2C                     02  sub	al,*2
28689 8571           74           E8            je 	.5F6
28690 8573           2C                     01  sub	al,*1
28691 8575           74           E4            je 	.5F7
28692 8577           2C                     02  sub	al,*2
28693 8579           74           E0            je 	.5F8
28694 857B           EB           E6            jmp	.5F9
28695                       0000857D            .5F2:
28696 857D           E9         009F            br 	.59C
28697                                           !BCC_EOS
28698                                           ! 4179     case 0x02:
28699                                           ! 4180     case 0x04:
28700                       00008580            .5FA:
28701                                           ! 4181     case 0x08:
28702                       00008580            .5FB:
28703                                           ! 4182     case 0x0a:
28704                       00008580            .5FC:
28705                                           ! 4183     case 0x0b:
28706                       00008580            .5FD:
28707                                           ! 4184     case 0x18:
28708                       00008580            .5FE:
28709                                           ! 4185     case 0x50:
28710                       00008580            .5FF:
28711                                           ! 4186     default:
28712                       00008580            .600:
28713                                           ! 4187       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
28714                       00008580            .601:
28715                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28716 8580           8B46         18            mov	ax,$18[bp]
28717 8583           88E0                       mov	al,ah
28718 8585           30E4                       xor	ah,ah
28719                                           ! Debug: list unsigned int = ax+0 (used reg = )
28720 8587           50                         push	ax
28721                                           ! Debug: list * char = .602+0 (used reg = )
28722 8588           BB                   CF4F  mov	bx,#.602
28723 858B           53                         push	bx
28724                                           ! Debug: list int = const 4 (used reg = )
28725 858C           B8                   0004  mov	ax,*4
28726 858F           50                         push	ax
28727                                           ! Debug: func () void = bios_printf+0 (used reg = )
28728 8590           E8         8414            call	_bios_printf
28729 8593           83C4                   06  add	sp,*6
28730                                           !BCC_EOS
28731                                           ! 4188       goto int13_fail;
28732 8596           83C4                   0C  add	sp,#..FFEB-..FFEA
28733 8599           E9         0086            br 	.FFEB
28734                                           !BCC_EOS
28735                                           ! 4189       break;
28736 859C           E9         0080            br 	.59C
28737                                           !BCC_EOS
28738                                           ! 4190   }
28739                                           ! 4191 int13_fail:
28740 859F           EB           7E            jmp .59C
28741                       000085A1            .59E:
28742 85A1           83C4                   F4  add	sp,*-$C
28743 85A4           2D                   0000  sub	ax,*0
28744 85A7           7C           D7            jl 	.601
28745 85A9           3D                   0018  cmp	ax,*$18
28746 85AC           77           3B            ja  	.603
28747 85AE           D1E0                       shl	ax,*1
28748 85B0           89C3                       mov	bx,ax
28749 85B2           2E                         seg	cs
28750 85B3           FFA7       85B7            br	.604[bx]
28751                       000085B7            .604:
28752 85B7                      7BEF            .word	.59F
28753 85B9                      7C0C            .word	.5AA
28754 85BB                      8580            .word	.5FA
28755 85BD                      7BF8            .word	.5A7
28756 85BF                      8580            .word	.5FB
28757 85C1                      7BF8            .word	.5A8
28758 85C3                      8580            .word	.601
28759 85C5                      8580            .word	.601
28760 85C7                      8580            .word	.5FC
28761 85C9                      7BEF            .word	.5A0
28762 85CB                      8580            .word	.5FD
28763 85CD                      8580            .word	.5FE
28764 85CF                      7BEF            .word	.5A1
28765 85D1                      7BEF            .word	.5A2
28766 85D3                      8580            .word	.601
28767 85D5                      8580            .word	.601
28768 85D7                      7BEF            .word	.5A3
28769 85D9                      7BEF            .word	.5A4
28770 85DB                      8580            .word	.601
28771 85DD                      8580            .word	.601
28772 85DF                      7BEF            .word	.5A5
28773 85E1                      7C5D            .word	.5AE
28774 85E3                      7BEF            .word	.5A6
28775 85E5                      8580            .word	.601
28776 85E7                      8580            .word	.5FF
28777                       000085E9            .603:
28778 85E9           2D                   0041  sub	ax,*$41
28779 85EC           72           92            jb 	.601
28780 85EE           3D                   000F  cmp	ax,*$F
28781 85F1           77           29            ja  	.605
28782 85F3           D1E0                       shl	ax,*1
28783 85F5           89C3                       mov	bx,ax
28784 85F7           2E                         seg	cs
28785 85F8           FFA7       85FC            br	.606[bx]
28786                       000085FC            .606:
28787 85FC                      7C71            .word	.5AF
28788 85FE                      7C91            .word	.5B0
28789 8600                      7BF8            .word	.5A9
28790 8602                      7C91            .word	.5B1
28791 8604                      7E76            .word	.5BC
28792 8606                      7F94            .word	.5CF
28793 8608                      7C91            .word	.5B2
28794 860A                      7FFD            .word	.5D4
28795 860C                      8542            .word	.5F0
28796 860E                      8580            .word	.601
28797 8610                      8580            .word	.601
28798 8612                      8580            .word	.601
28799 8614                      8580            .word	.601
28800 8616                      8556            .word	.5F1
28801 8618                      8580            .word	.601
28802 861A                      8580            .word	.600
28803                       0000861C            .605:
28804 861C           E9         FF61            br 	.601
28805                       0000861F            .59C:
28806                       FFFFFFD2            ..FFEA	=	-$2E
28807 861F           83C4                   0C  add	sp,*$C
28808                       00008622            .FFEB:
28809                       FFFFFFDE            ..FFEB	=	-$22
28810                                           ! 4192   AX = ((AX & 0x00ff) | ((0x01) << 8));
28811                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28812 8622           8A46         18            mov	al,$18[bp]
28813                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28814 8625           30E4                       xor	ah,ah
28815 8627           0D                   0100  or	ax,#$100
28816                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28817 862A           8946         18            mov	$18[bp],ax
28818                                           !BCC_EOS
28819                                           ! 4193 int13_fail_noah:
28820                       0000862D            .FFE8:
28821                       FFFFFFDE            ..FFE8	=	-$22
28822                                           ! 4194   write_byte(0x0040, 0x0074, ( AX >> 8 ));
28823                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28824 862D           8B46         18            mov	ax,$18[bp]
28825 8630           88E0                       mov	al,ah
28826 8632           30E4                       xor	ah,ah
28827                                           ! Debug: list unsigned int = ax+0 (used reg = )
28828 8634           50                         push	ax
28829                                           ! Debug: list int = const $74 (used reg = )
28830 8635           B8                   0074  mov	ax,*$74
28831 8638           50                         push	ax
28832                                           ! Debug: list int = const $40 (used reg = )
28833 8639           B8                   0040  mov	ax,*$40
28834 863C           50                         push	ax
28835                                           ! Debug: func () void = write_byte+0 (used reg = )
28836 863D           E8         7FDE            call	_write_byte
28837 8640           83C4                   06  add	sp,*6
28838                                           !BCC_EOS
28839                                           ! 4195 int13_fail_nostatus:
28840                       00008643            .FFE7:
28841                       FFFFFFDE            ..FFE7	=	-$22
28842                                           ! 4196   FLAGS |= 0x0001;
28843                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28844 8643           8B46         1E            mov	ax,$1E[bp]
28845 8646           0C                     01  or	al,*1
28846 8648           8946         1E            mov	$1E[bp],ax
28847                                           !BCC_EOS
28848                                           ! 4197   return;
28849 864B           89EC                       mov	sp,bp
28850 864D           5D                         pop	bp
28851 864E           C3                         ret
28852                                           !BCC_EOS
28853                                           ! 4198 int13_success:
28854                       0000864F            .FFE9:
28855                       FFFFFFDE            ..FFE9	=	-$22
28856                                           ! 4199   AX = ((AX & 0x00ff) | ((0x00) << 8));
28857                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28858 864F           8A46         18            mov	al,$18[bp]
28859                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28860 8652           0C                     00  or	al,*0
28861                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
28862 8654           30E4                       xor	ah,ah
28863 8656           8946         18            mov	$18[bp],ax
28864                                           !BCC_EOS
28865                                           ! 4200 int13_success_noah:
28866                       00008659            .FFE6:
28867                       FFFFFFDE            ..FFE6	=	-$22
28868                                           ! 4201   write_byte(0x0040, 0x0074, 0x00);
28869                                           ! Debug: list int = const 0 (used reg = )
28870 8659           31C0                       xor	ax,ax
28871 865B           50                         push	ax
28872                                           ! Debug: list int = const $74 (used reg = )
28873 865C           B8                   0074  mov	ax,*$74
28874 865F           50                         push	ax
28875                                           ! Debug: list int = const $40 (used reg = )
28876 8660           B8                   0040  mov	ax,*$40
28877 8663           50                         push	ax
28878                                           ! Debug: func () void = write_byte+0 (used reg = )
28879 8664           E8         7FB7            call	_write_byte
28880 8667           83C4                   06  add	sp,*6
28881                                           !BCC_EOS
28882                                           ! 4202   FLAGS &= 0xfffe;
28883                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28884 866A           8B46         1E            mov	ax,$1E[bp]
28885 866D           24                     FE  and	al,#$FE
28886 866F           8946         1E            mov	$1E[bp],ax
28887                                           !BCC_EOS
28888                                           ! 4203 }
28889 8672           89EC                       mov	sp,bp
28890 8674           5D                         pop	bp
28891 8675           C3                         ret
28892                                           ! 4204   void
28893                                           ! Register BX used in function int13_cdrom
28894                                           ! 4205 int13_eltorito(DS, ES, D
28895                                           ! 4205 I, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28896                                           ! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28897                                           export	_int13_eltorito
28898                       00008676            _int13_eltorito:
28899                                           !BCC_EOS
28900                                           ! 4207 {
28901                                           ! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
28902 8676           55                         push	bp
28903 8677           89E5                       mov	bp,sp
28904 8679           4C                         dec	sp
28905 867A           4C                         dec	sp
28906                                           ! Debug: list int = const $E (used reg = )
28907 867B           B8                   000E  mov	ax,*$E
28908 867E           50                         push	ax
28909                                           ! Debug: list int = const $40 (used reg = )
28910 867F           B8                   0040  mov	ax,*$40
28911 8682           50                         push	ax
28912                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28913 8683           E8         7F85            call	_read_word
28914 8686           83C4                   04  add	sp,*4
28915                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28916 8689           8946         FE            mov	-2[bp],ax
28917                                           !BCC_EOS
28918                                           ! 4209   ;
28919                                           !BCC_EOS
28920                                           ! 4210   switch (( AX >> 8 )) {
28921                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28922 868C           8B46         16            mov	ax,$16[bp]
28923 868F           88E0                       mov	al,ah
28924 8691           30E4                       xor	ah,ah
28925 8693           E9         01BE            br 	.609
28926                                           ! 4211     case 0x4a:
28927                                           ! 4212     case 0x4c:
28928                       00008696            .60A:
28929                                           ! 4213     case 0x4d:
28930                       00008696            .60B:
28931                                           ! 4214       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
28932                       00008696            .60C:
28933                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
28934 8696           FF76         16            push	$16[bp]
28935                                           ! Debug: list * char = .60D+0 (used reg = )
28936 8699           BB                   CF1E  mov	bx,#.60D
28937 869C           53                         push	bx
28938                                           ! Debug: list int = const 7 (used reg = )
28939 869D           B8                   0007  mov	ax,*7
28940 86A0           50                         push	ax
28941                                           ! Debug: func () void = bios_printf+0 (used reg = )
28942 86A1           E8         8303            call	_bios_printf
28943 86A4           83C4                   06  add	sp,*6
28944                                           !BCC_EOS
28945                                           ! 4215       goto int13_fail;
28946 86A7           83C4                   00  add	sp,#..FFE4-..FFE5
28947 86AA           E9         01C5            br 	.FFE4
28948                                           !BCC_EOS
28949                                           ! 4216       break;
28950 86AD           E9         01C2            br 	.607
28951                                           !BCC_EOS
28952                                           ! 4217     case 0x4b:
28953                                           ! 4218       write_byte(DS,SI+0x00,0x13);
28954                       000086B0            .60E:
28955                                           ! Debug: list int = const $13 (used reg = )
28956 86B0           B8                   0013  mov	ax,*$13
28957 86B3           50                         push	ax
28958                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28959 86B4           8B46         0A            mov	ax,$A[bp]
28960                                           ! Debug: list unsigned int = ax+0 (used reg = )
28961 86B7           50                         push	ax
28962                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28963 86B8           FF76         04            push	4[bp]
28964                                           ! Debug: func () void = write_byte+0 (used reg = )
28965 86BB           E8         7F60            call	_write_byte
28966 86BE           83C4                   06  add	sp,*6
28967                                           !BCC_EOS
28968                                           ! 4219       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28969                                           ! Debug: list * unsigned char = const $25B (used reg = )
28970 86C1           B8                   025B  mov	ax,#$25B
28971 86C4           50                         push	ax
28972                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28973 86C5           FF76         FE            push	-2[bp]
28974                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28975 86C8           E8         7F2D            call	_read_byte
28976 86CB           83C4                   04  add	sp,*4
28977                                           ! Debug: list unsigned char = al+0 (used reg = )
28978 86CE           30E4                       xor	ah,ah
28979 86D0           50                         push	ax
28980                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28981 86D1           8B46         0A            mov	ax,$A[bp]
28982                                           ! Debug: list unsigned int = ax+1 (used reg = )
28983 86D4           40                         inc	ax
28984 86D5           50                         push	ax
28985                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28986 86D6           FF76         04            push	4[bp]
28987                                           ! Debug: func () void = write_byte+0 (used reg = )
28988 86D9           E8         7F42            call	_write_byte
28989 86DC           83C4                   06  add	sp,*6
28990                                           !BCC_EOS
28991                                           ! 4220       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
28992                                           ! Debug: list * unsigned char = const $25C (used reg = )
28993 86DF           B8                   025C  mov	ax,#$25C
28994 86E2           50                         push	ax
28995                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28996 86E3           FF76         FE            push	-2[bp]
28997                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28998 86E6           E8         7F0F            call	_read_byte
28999 86E9           83C4                   04  add	sp,*4
29000                                           ! Debug: list unsigned char = al+0 (used reg = )
29001 86EC           30E4                       xor	ah,ah
29002 86EE           50                         push	ax
29003                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
29004 86EF           8B46         0A            mov	ax,$A[bp]
29005                                           ! Debug: list unsigned int = ax+2 (used reg = )
29006 86F2           40                         inc	ax
29007 86F3           40                         inc	ax
29008 86F4           50                         push	ax
29009                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29010 86F5           FF76         04            push	4[bp]
29011                                           ! Debug: func () void = write_byte+0 (used reg = )
29012 86F8           E8         7F23            call	_write_byte
29013 86FB           83C4                   06  add	sp,*6
29014                                           !BCC_EOS
29015                                           ! 4221       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
29016                                           ! Debug: list * unsigned char = const $25D (used reg = )
29017 86FE           B8                   025D  mov	ax,#$25D
29018 8701           50                         push	ax
29019                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29020 8702           FF76         FE            push	-2[bp]
29021                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29022 8705           E8         7EF0            call	_read_byte
29023 8708           83C4                   04  add	sp,*4
29024                                           ! Debug: list unsigned char = al+0 (used reg = )
29025 870B           30E4                       xor	ah,ah
29026 870D           50                         push	ax
29027                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
29028 870E           8B46         0A            mov	ax,$A[bp]
29029                                           ! Debug: list unsigned int = ax+3 (used reg = )
29030 8711           05                   0003  add	ax,*3
29031 8714           50                         push	ax
29032                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29033 8715           FF76         04            push	4[bp]
29034                                           ! Debug: func () void = write_byte+0 (used reg = )
29035 8718           E8         7F03            call	_write_byte
29036 871B           83C4                   06  add	sp,*6
29037                                           !BCC_EOS
29038                                           ! 4222       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
29039                                           ! Debug: list * unsigned long = const $260 (used reg = )
29040 871E           B8                   0260  mov	ax,#$260
29041 8721           50                         push	ax
29042                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29043 8722           FF76         FE            push	-2[bp]
29044                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
29045 8725           E8         795B            call	_read_dword
29046 8728           89D3                       mov	bx,dx
29047 872A           83C4                   04  add	sp,*4
29048                                           ! Debug: list unsigned long = bx+0 (used reg = )
29049 872D           53                         push	bx
29050 872E           50                         push	ax
29051                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
29052 872F           8B46         0A            mov	ax,$A[bp]
29053                                           ! Debug: list unsigned int = ax+4 (used reg = )
29054 8732           05                   0004  add	ax,*4
29055 8735           50                         push	ax
29056                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
29057 8736           FF76         04            push	4[bp]
29058                                           ! Debug: func () void = write_dword+0 (used reg = )
29059 8739           E8         795F            call	_write_dword
29060 873C           83C4                   08  add	sp,*8
29061                                           !BCC_EOS
29062                                           ! 4223       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
29063                                           ! Debug: list * unsigned short = const $25E (used reg = )
29064 873F           B8                   025E  mov	ax,#$25E
29065 8742           50                         push	ax
29066                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29067 8743           FF76         FE            push	-2[bp]
29068                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29069 8746           E8         7EC2            call	_read_word
29070 8749           83C4                   04  add	sp,*4
29071                                           ! Debug: list unsigned short = ax+0 (used reg = )
29072 874C           50                         push	ax
29073                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
29074 874D           8B46         0A            mov	ax,$A[bp]
29075                                           ! Debug: list unsigned int = ax+8 (used reg = )
29076 8750           05                   0008  add	ax,*8
29077 8753           50                         push	ax
29078                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29079 8754           FF76         04            push	4[bp]
29080                                           ! Debug: func () void = write_word+0 (used reg = )
29081 8757           E8         7EDC            call	_write_word
29082 875A           83C4                   06  add	sp,*6
29083                                           !BCC_EOS
29084                                           ! 4224       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
29085                                           ! Debug: list * unsigned short = const $264 (used reg = )
29086 875D           B8                   0264  mov	ax,#$264
29087 8760           50                         push	ax
29088                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29089 8761           FF76         FE            push	-2[bp]
29090                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29091 8764           E8         7EA4            call	_read_word
29092 8767           83C4                   04  add	sp,*4
29093                                           ! Debug: list unsigned short = ax+0 (used reg = )
29094 876A           50                         push	ax
29095                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
29096 876B           8B46         0A            mov	ax,$A[bp]
29097                                           ! Debug: list unsigned int = ax+$A (used reg = )
29098 876E           05                   000A  add	ax,*$A
29099 8771           50                         push	ax
29100                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29101 8772           FF76         04            push	4[bp]
29102                                           ! Debug: func () void = write_word+0 (used reg = )
29103 8775           E8         7EBE            call	_write_word
29104 8778           83C4                   06  add	sp,*6
29105                                           !BCC_EOS
29106                                           ! 4225       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
29107                                           ! Debug: list * unsigned short = const $266 (used reg = )
29108 877B           B8                   0266  mov	ax,#$266
29109 877E           50                         push	ax
29110                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29111 877F           FF76         FE            push	-2[bp]
29112                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29113 8782           E8         7E86            call	_read_word
29114 8785           83C4                   04  add	sp,*4
29115                                           ! Debug: list unsigned short = ax+0 (used reg = )
29116 8788           50                         push	ax
29117                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
29118 8789           8B46         0A            mov	ax,$A[bp]
29119                                           ! Debug: list unsigned int = ax+$C (used reg = )
29120 878C           05                   000C  add	ax,*$C
29121 878F           50                         push	ax
29122                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29123 8790           FF76         04            push	4[bp]
29124                                           ! Debug: func () void = write_word+0 (used reg = )
29125 8793           E8         7EA0            call	_write_word
29126 8796           83C4                   06  add	sp,*6
29127                                           !BCC_EOS
29128                                           ! 4226       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
29129                                           ! Debug: list * unsigned short = const $268 (used reg = )
29130 8799           B8                   0268  mov	ax,#$268
29131 879C           50                         push	ax
29132                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29133 879D           FF76         FE            push	-2[bp]
29134                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29135 87A0           E8         7E68            call	_read_word
29136 87A3           83C4                   04  add	sp,*4
29137                                           ! Debug: list unsigned short = ax+0 (used reg = )
29138 87A6           50                         push	ax
29139                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
29140 87A7           8B46         0A            mov	ax,$A[bp]
29141                                           ! Debug: list unsigned int = ax+$E (used reg = )
29142 87AA           05                   000E  add	ax,*$E
29143 87AD           50                         push	ax
29144                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29145 87AE           FF76         04            push	4[bp]
29146                                           ! Debug: func () void = write_word+0 (used reg = )
29147 87B1           E8         7E82            call	_write_word
29148 87B4           83C4                   06  add	sp,*6
29149                                           !BCC_EOS
29150                                           ! 4227       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
29151                                           ! Debug: list * unsigned short = const $26C (used reg = )
29152 87B7           B8                   026C  mov	ax,#$26C
29153 87BA           50                         push	ax
29154                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29155 87BB           FF76         FE            push	-2[bp]
29156                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29157 87BE           E8         7E37            call	_read_byte
29158 87C1           83C4                   04  add	sp,*4
29159                                           ! Debug: list unsigned char = al+0 (used reg = )
29160 87C4           30E4                       xor	ah,ah
29161 87C6           50                         push	ax
29162                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
29163 87C7           8B46         0A            mov	ax,$A[bp]
29164                                           ! Debug: list unsigned int = ax+$10 (used reg = )
29165 87CA           05                   0010  add	ax,*$10
29166 87CD           50                         push	ax
29167                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29168 87CE           FF76         04            push	4[bp]
29169                                           ! Debug: func () void = write_byte+0 (used reg = )
29170 87D1           E8         7E4A            call	_write_byte
29171 87D4           83C4                   06  add	sp,*6
29172                                           !BCC_EOS
29173                                           ! 4228       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
29174                                           ! Debug: list * unsigned short = const $26E (used reg = )
29175 87D7           B8                   026E  mov	ax,#$26E
29176 87DA           50                         push	ax
29177                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29178 87DB           FF76         FE            push	-2[bp]
29179                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29180 87DE           E8         7E17            call	_read_byte
29181 87E1           83C4                   04  add	sp,*4
29182                                           ! Debug: list unsigned char = al+0 (used reg = )
29183 87E4           30E4                       xor	ah,ah
29184 87E6           50                         push	ax
29185                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
29186 87E7           8B46         0A            mov	ax,$A[bp]
29187                                           ! Debug: list unsigned int = ax+$11 (used reg = )
29188 87EA           05                   0011  add	ax,*$11
29189 87ED           50                         push	ax
29190                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29191 87EE           FF76         04            push	4[bp]
29192                                           ! Debug: func () void = write_byte+0 (used reg = )
29193 87F1           E8         7E2A            call	_write_byte
29194 87F4           83C4                   06  add	sp,*6
29195                                           !BCC_EOS
29196                                           ! 4229       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
29197                                           ! Debug: list * unsigned short = const $26A (used reg = )
29198 87F7           B8                   026A  mov	ax,#$26A
29199 87FA           50                         push	ax
29200                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29201 87FB           FF76         FE            push	-2[bp]
29202                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29203 87FE           E8         7DF7            call	_read_byte
29204 8801           83C4                   04  add	sp,*4
29205                                           ! Debug: list unsigned char = al+0 (used reg = )
29206 8804           30E4                       xor	ah,ah
29207 8806           50                         push	ax
29208                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
29209 8807           8B46         0A            mov	ax,$A[bp]
29210                                           ! Debug: list unsigned int = ax+$12 (used reg = )
29211 880A           05                   0012  add	ax,*$12
29212 880D           50                         push	ax
29213                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29214 880E           FF76         04            push	4[bp]
29215                                           ! Debug: func () void = write_byte+0 (used reg = )
29216 8811           E8         7E0A            call	_write_byte
29217 8814           83C4                   06  add	sp,*6
29218                                           !BCC_EOS
29219                                           ! 4230       if(( AX & 0x00ff ) == 0x00) {
29220                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29221 8817           8A46         16            mov	al,$16[bp]
29222                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29223 881A           84C0                       test	al,al
29224 881C           75           10            jne 	.60F
29225                       0000881E            .610:
29226                                           ! 4231         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
29227                                           ! Debug: list int = const 0 (used reg = )
29228 881E           31C0                       xor	ax,ax
29229 8820           50                         push	ax
29230                                           ! Debug: list * unsigned char = const $25A (used reg = )
29231 8821           B8                   025A  mov	ax,#$25A
29232 8824           50                         push	ax
29233                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
29234 8825           FF76         FE            push	-2[bp]
29235                                           ! Debug: func () void = write_byte+0 (used reg = )
29236 8828           E8         7DF3            call	_write_byte
29237 882B           83C4                   06  add	sp,*6
29238                                           !BCC_EOS
29239                                           ! 4232       }
29240                                           ! 4233       goto int13_success;
29241                       0000882E            .60F:
29242 882E           83C4                   00  add	sp,#..FFE3-..FFE5
29243 8831           EB           6C            jmp .FFE3
29244                                           !BCC_EOS
29245                                           ! 4234       break;
29246 8833           EB           3D            jmp .607
29247                                           !BCC_EOS
29248                                           ! 4235     default:
29249                                           ! 4236       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
29250                       00008835            .611:
29251                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29252 8835           8B46         16            mov	ax,$16[bp]
29253 8838           88E0                       mov	al,ah
29254 883A           30E4                       xor	ah,ah
29255                                           ! Debug: list unsigned int = ax+0 (used reg = )
29256 883C           50                         push	ax
29257                                           ! Debug: list * char = .612+0 (used reg = )
29258 883D           BB                   CEF9  mov	bx,#.612
29259 8840           53                         push	bx
29260                                           ! Debug: list int = const 4 (used reg = )
29261 8841           B8                   0004  mov	ax,*4
29262 8844           50                         push	ax
29263                                           ! Debug: func () void = bios_printf+0 (used reg = )
29264 8845           E8         815F            call	_bios_printf
29265 8848           83C4                   06  add	sp,*6
29266                                           !BCC_EOS
29267                                           ! 4237       goto int13_fail;
29268 884B           83C4                   00  add	sp,#..FFE4-..FFE5
29269 884E           EB           22            jmp .FFE4
29270                                           !BCC_EOS
29271                                           ! 4238       break;
29272 8850           EB           20            jmp .607
29273                                           !BCC_EOS
29274                                           ! 4239   }
29275                                           ! 4240 int13_fail:
29276 8852           EB           1E            jmp .607
29277                       00008854            .609:
29278 8854           2D                   004A  sub	ax,*$4A
29279 8857         0F84         FE3B            beq 	.60A
29280 885B           2D                   0001  sub	ax,*1
29281 885E         0F84         FE4E            beq 	.60E
29282 8862           2D                   0001  sub	ax,*1
29283 8865         0F84         FE2D            beq 	.60B
29284 8869           2D                   0001  sub	ax,*1
29285 886C         0F84         FE26            beq 	.60C
29286 8870           EB           C3            jmp	.611
29287                       00008872            .607:
29288                       FFFFFFFC            ..FFE5	=	-4
29289                       00008872            .FFE4:
29290                       FFFFFFFC            ..FFE4	=	-4
29291                                           ! 4241   AX = ((AX & 0x00ff) | ((0x01) << 8));
29292                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29293 8872           8A46         16            mov	al,$16[bp]
29294                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29295 8875           30E4                       xor	ah,ah
29296 8877           0D                   0100  or	ax,#$100
29297                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
29298 887A           8946         16            mov	$16[bp],ax
29299                                           !BCC_EOS
29300                                           ! 4242   write_byte(0x0040, 0x0074, ( AX >> 8 ));
29301                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29302 887D           8B46         16            mov	ax,$16[bp]
29303 8880           88E0                       mov	al,ah
29304 8882           30E4                       xor	ah,ah
29305                                           ! Debug: list unsigned int = ax+0 (used reg = )
29306 8884           50                         push	ax
29307                                           ! Debug: list int = const $74 (used reg = )
29308 8885           B8                   0074  mov	ax,*$74
29309 8888           50                         push	ax
29310                                           ! Debug: list int = const $40 (used reg = )
29311 8889           B8                   0040  mov	ax,*$40
29312 888C           50                         push	ax
29313                                           ! Debug: func () void = write_byte+0 (used reg = )
29314 888D           E8         7D8E            call	_write_byte
29315 8890           83C4                   06  add	sp,*6
29316                                           !BCC_EOS
29317                                           ! 4243   FLAGS |= 0x0001;
29318                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
29319 8893           8B46         1C            mov	ax,$1C[bp]
29320 8896           0C                     01  or	al,*1
29321 8898           8946         1C            mov	$1C[bp],ax
29322                                           !BCC_EOS
29323                                           ! 4244   return;
29324 889B           89EC                       mov	sp,bp
29325 889D           5D                         pop	bp
29326 889E           C3                         ret
29327                                           !BCC_EOS
29328                                           ! 4245 int13_success:
29329                       0000889F            .FFE3:
29330                       FFFFFFFC            ..FFE3	=	-4
29331                                           ! 4246   AX = ((AX & 0x00ff) | ((0x00) << 8));
29332                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29333 889F           8A46         16            mov	al,$16[bp]
29334                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29335 88A2           0C                     00  or	al,*0
29336                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
29337 88A4           30E4                       xor	ah,ah
29338 88A6           8946         16            mov	$16[bp],ax
29339                                           !BCC_EOS
29340                                           ! 4247   write_byte(0x0040, 0x0074, 0x00);
29341                                           ! Debug: list int = const 0 (used reg = )
29342 88A9           31C0                       xor	ax,ax
29343 88AB           50                         push	ax
29344                                           ! Debug: list int = const $74 (used reg = )
29345 88AC           B8                   0074  mov	ax,*$74
29346 88AF           50                         push	ax
29347                                           ! Debug: list int = const $40 (used reg = )
29348 88B0           B8                   0040  mov	ax,*$40
29349 88B3           50                         push	ax
29350                                           ! Debug: func () void = write_byte+0 (used reg = )
29351 88B4           E8         7D67            call	_write_byte
29352 88B7           83C4                   06  add	sp,*6
29353                                           !BCC_EOS
29354                                           ! 4248   FLAGS &= 0xfffe;
29355                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
29356 88BA           8B46         1C            mov	ax,$1C[bp]
29357 88BD           24                     FE  and	al,#$FE
29358 88BF           8946         1C            mov	$1C[bp],ax
29359                                           !BCC_EOS
29360                                           ! 4249 }
29361 88C2           89EC                       mov	sp,bp
29362 88C4           5D                         pop	bp
29363 88C5           C3                         ret
29364                                           ! 4250   void
29365                                           ! Register BX used in function int13_eltorito
29366                                           ! 4251 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
29367                                           ! 4252   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP
29368                                           export	_int13_cdemu
29369                       000088C6            _int13_cdemu:
29370                                           ! 4252 , CS, FLAGS;
29371                                           !BCC_EOS
29372                                           ! 4253 {
29373                                           ! 4254   Bit16u ebda_seg=read_word(0x0040,0x000E);
29374 88C6           55                         push	bp
29375 88C7           89E5                       mov	bp,sp
29376 88C9           4C                         dec	sp
29377 88CA           4C                         dec	sp
29378                                           ! Debug: list int = const $E (used reg = )
29379 88CB           B8                   000E  mov	ax,*$E
29380 88CE           50                         push	ax
29381                                           ! Debug: list int = const $40 (used reg = )
29382 88CF           B8                   0040  mov	ax,*$40
29383 88D2           50                         push	ax
29384                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29385 88D3           E8         7D35            call	_read_word
29386 88D6           83C4                   04  add	sp,*4
29387                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
29388 88D9           8946         FE            mov	-2[bp],ax
29389                                           !BCC_EOS
29390                                           ! 4255   Bit8u device, status;
29391                                           !BCC_EOS
29392                                           ! 4256   Bit16u vheads, vspt, vcylinders;
29393                                           !BCC_EOS
29394                                           ! 4257   Bit16u head, sector, cylinder, nbsectors;
29395                                           !BCC_EOS
29396                                           ! 4258   Bit32u vlba, ilba, slba, elba;
29397                                           !BCC_EOS
29398                                           ! 4259   Bit16u before, segment, offset;
29399                                           !BCC_EOS
29400                                           ! 4260   Bit8u atacmd[12];
29401                                           !BCC_EOS
29402                                           ! 4261   ;
29403 88DC           83C4                   CE  add	sp,*-$32
29404                                           !BCC_EOS
29405                                           ! 4262   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
29406                                           ! Debug: list * unsigned char = const $25D (used reg = )
29407 88DF           B8                   025D  mov	ax,#$25D
29408 88E2           50                         push	ax
29409                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29410 88E3           FF76         FE            push	-2[bp]
29411                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29412 88E6           E8         7D0F            call	_read_byte
29413 88E9           83C4                   04  add	sp,*4
29414                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
29415 88EC           30E4                       xor	ah,ah
29416 88EE           D1E0                       shl	ax,*1
29417                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
29418 88F0           8846         FD            mov	-3[bp],al
29419                                           !BCC_EOS
29420                                           ! 4263   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
29421                                           ! Debug: list * unsigned short = const $25E (used reg = )
29422 88F3           B8                   025E  mov	ax,#$25E
29423 88F6           50                         push	ax
29424                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29425 88F7           FF76         FE            push	-2[bp]
29426                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29427 88FA           E8         7CFB            call	_read_byte
29428 88FD           83C4                   04  add	sp,*4
29429                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
29430 8900           30E4                       xor	ah,ah
29431 8902           0246         FD            add	al,-3[bp]
29432 8905           80D4                   00  adc	ah,*0
29433 8908           8846         FD            mov	-3[bp],al
29434                                           !BCC_EOS
29435                                           ! 4264   write_byte(0x0040, 0x0074, 0x00);
29436                                           ! Debug: list int = const 0 (used reg = )
29437 890B           31C0                       xor	ax,ax
29438 890D           50                         push	ax
29439                                           ! Debug: list int = const $74 (used reg = )
29440 890E           B8                   0074  mov	ax,*$74
29441 8911           50                         push	ax
29442                                           ! Debug: list int = const $40 (used reg = )
29443 8912           B8                   0040  mov	ax,*$40
29444 8915           50                         push	ax
29445                                           ! Debug: func () void = write_byte+0 (used reg = )
29446 8916           E8         7D05            call	_write_byte
29447 8919           83C4                   06  add	sp,*6
29448                                           !BCC_EOS
29449                                           ! 4265   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0) ||
29450                                           ! 4266       (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
29451                                           ! Debug: list * unsigned char = const $25A (used reg = )
29452 891C           B8                   025A  mov	ax,#$25A
29453 891F           50                         push	ax
29454                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29455 8920           FF76         FE            push	-2[bp]
29456                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29457 8923           E8         7CD2            call	_read_byte
29458 8926           83C4                   04  add	sp,*4
29459                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29460 8929           84C0                       test	al,al
29461 892B           74           19            je  	.614
29462                       0000892D            .615:
29463                                           ! Debug: expression subtree swapping
29464                                           ! Debug: list * unsigned char = const $25C (used reg = )
29465 892D           B8                   025C  mov	ax,#$25C
29466 8930           50                         push	ax
29467                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29468 8931           FF76         FE            push	-2[bp]
29469                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29470 8934           E8         7CC1            call	_read_byte
29471 8937           83C4                   04  add	sp,*4
29472 893A           50                         push	ax
29473                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29474 893B           8A46         12            mov	al,$12[bp]
29475                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29476 893E           3A46         CA            cmp	al,-$36[bp]
29477 8941           8D66         CC            lea	sp,-$34[bp]
29478 8944           74           22            je  	.613
29479                       00008946            .614:
29480                                           ! 4267     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
29481                                           ! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
29482 8946           8A46         12            mov	al,$12[bp]
29483                                           ! Debug: list unsigned char = al+0 (used reg = )
29484 8949           30E4                       xor	ah,ah
29485 894B           50                         push	ax
29486                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
29487 894C           8B46         16            mov	ax,$16[bp]
29488 894F           88E0                       mov	al,ah
29489 8951           30E4                       xor	ah,ah
29490                                           ! Debug: list unsigned int = ax+0 (used reg = )
29491 8953           50                         push	ax
29492                                           ! Debug: list * char = .616+0 (used reg = )
29493 8954           BB                   CEBA  mov	bx,#.616
29494 8957           53                         push	bx
29495                                           ! Debug: list int = const 4 (used reg = )
29496 8958           B8                   0004  mov	ax,*4
29497 895B           50                         push	ax
29498                                           ! Debug: func () void = bios_printf+0 (used reg = )
29499 895C           E8         8048            call	_bios_printf
29500 895F           83C4                   08  add	sp,*8
29501                                           !BCC_EOS
29502                                           ! 4268     goto int13_fail;
29503 8962           83C4                   00  add	sp,#..FFE2+$36
29504 8965           E9         0563            br 	.FFE2
29505                                           !BCC_EOS
29506                                           ! 4269   }
29507                                           ! 4270   switch (( AX >> 8 )) {
29508                       00008968            .613:
29509                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29510 8968           8B46         16            mov	ax,$16[bp]
29511 896B           88E0                       mov	al,ah
29512 896D           30E4                       xor	ah,ah
29513 896F           E9         04DE            br 	.619
29514                                           ! 4271     case 0x00:
29515                                           ! 4272     case 0x09:
29516                       00008972            .61A:
29517                                           ! 4273     case 0x0c:
29518                       00008972            .61B:
29519                                           ! 4274     case 0x0d:
29520                       00008972            .61C:
29521                                           ! 4275     case 0x10:
29522                       00008972            .61D:
29523                                           ! 4276     case 0x11:
29524                       00008972            .61E:
29525                                           ! 4277     case 0x14:
29526                       00008972            .61F:
29527                                           ! 4278     case 0x16:
29528                       00008972            .620:
29529                                           ! 4279       goto int13_success;
29530                       00008972            .621:
29531 8972           83C4                   00  add	sp,#..FFE0-..FFE1
29532 8975           E9         0580            br 	.FFE0
29533                                           !BCC_EOS
29534                                           ! 4280       break;
29535 8978           E9         0550            br 	.617
29536                                           !BCC_EOS
29537                                           ! 4281     case 0x03:
29538                                           ! 4282     case 0x05:
29539                       0000897B            .622:
29540                                           ! 4283       AX = ((AX & 0x00ff) | ((0x03) << 8));
29541                       0000897B            .623:
29542                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29543 897B           8A46         16            mov	al,$16[bp]
29544                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29545 897E           30E4                       xor	ah,ah
29546 8980           0D                   0300  or	ax,#$300
29547                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29548 8983           8946         16            mov	$16[bp],ax
29549                                           !BCC_EOS
29550                                           ! 4284       goto int13_fail_noah;
29551 8986           83C4                   00  add	sp,#..FFDF-..FFE1
29552 8989           E9         054A            br 	.FFDF
29553                                           !BCC_EOS
29554                                           ! 4285       break;
29555 898C           E9         053C            br 	.617
29556                                           !BCC_EOS
29557                                           ! 4286     case 0x01:
29558                                           ! 4287       status=read_byte(0x0040, 0x0074);
29559                       0000898F            .624:
29560                                           ! Debug: list int = const $74 (used reg = )
29561 898F           B8                   0074  mov	ax,*$74
29562 8992           50                         push	ax
29563                                           ! Debug: list int = const $40 (used reg = )
29564 8993           B8                   0040  mov	ax,*$40
29565 8996           50                         push	ax
29566                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29567 8997           E8         7C5E            call	_read_byte
29568 899A           83C4                   04  add	sp,*4
29569                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
29570 899D           8846         FC            mov	-4[bp],al
29571                                           !BCC_EOS
29572                                           ! 4288       AX = ((AX & 0x00ff) | ((status) << 8));
29573                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
29574 89A0           8A46         FC            mov	al,-4[bp]
29575 89A3           30E4                       xor	ah,ah
29576 89A5           88C4                       mov	ah,al
29577 89A7           30C0                       xor	al,al
29578 89A9           50                         push	ax
29579                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
29580 89AA           8A46         16            mov	al,$16[bp]
29581                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29582 89AD           30E4                       xor	ah,ah
29583 89AF           0B46         CA            or	ax,0+..FFE1[bp]
29584 89B2           44                         inc	sp
29585 89B3           44                         inc	sp
29586                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29587 89B4           8946         16            mov	$16[bp],ax
29588                                           !BCC_EOS
29589                                           ! 4289       write_byte(0x0040, 0x0074, 0);
29590                                           ! Debug: list int = const 0 (used reg = )
29591 89B7           31C0                       xor	ax,ax
29592 89B9           50                         push	ax
29593                                           ! Debug: list int = const $74 (used reg = )
29594 89BA           B8                   0074  mov	ax,*$74
29595 89BD           50                         push	ax
29596                                           ! Debug: list int = const $40 (used reg = )
29597 89BE           B8                   0040  mov	ax,*$40
29598 89C1           50                         push	ax
29599                                           ! Debug: func () void = write_byte+0 (used reg = )
29600 89C2           E8         7C59            call	_write_byte
29601 89C5           83C4                   06  add	sp,*6
29602                                           !BCC_EOS
29603                                           ! 4290       if (status) goto int13_fail_nostatus;
29604 89C8           8A46         FC            mov	al,-4[bp]
29605 89CB           84C0                       test	al,al
29606 89CD           74           08            je  	.625
29607                       000089CF            .626:
29608 89CF           83C4                   00  add	sp,#..FFDE-..FFE1
29609 89D2           E9         0517            br 	.FFDE
29610                                           !BCC_EOS
29611                                           ! 4291       else goto int13_success_noah;
29612 89D5           EB           06            jmp .627
29613                       000089D7            .625:
29614 89D7           83C4                   00  add	sp,#..FFDD-..FFE1
29615 89DA           E9         0525            br 	.FFDD
29616                                           !BCC_EOS
29617                                           ! 4292       break;
29618                       000089DD            .627:
29619 89DD           E9         04EB            br 	.617
29620                                           !BCC_EOS
29621                                           ! 4293     case 0x02:
29622                                           ! 4294     case 0x04:
29623                       000089E0            .628:
29624                                           ! 4295       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29625                       000089E0            .629:
29626                                           ! Debug: list * unsigned short = const $26E (used reg = )
29627 89E0           B8                   026E  mov	ax,#$26E
29628 89E3           50                         push	ax
29629                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29630 89E4           FF76         FE            push	-2[bp]
29631                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29632 89E7           E8         7C21            call	_read_word
29633 89EA           83C4                   04  add	sp,*4
29634                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29635 89ED           8946         F8            mov	-8[bp],ax
29636                                           !BCC_EOS
29637                                           ! 4296       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
29638                                           ! Debug: list * unsigned short = const $26C (used reg = )
29639 89F0           B8                   026C  mov	ax,#$26C
29640 89F3           50                         push	ax
29641                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29642 89F4           FF76         FE            push	-2[bp]
29643                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29644 89F7           E8         7C11            call	_read_word
29645 89FA           83C4                   04  add	sp,*4
29646                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29647 89FD           8946         F6            mov	-$A[bp],ax
29648                                           !BCC_EOS
29649                                           ! 4297       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
29650                                           ! Debug: list * unsigned short = const $26A (used reg = )
29651 8A00           B8                   026A  mov	ax,#$26A
29652 8A03           50                         push	ax
29653                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29654 8A04           FF76         FE            push	-2[bp]
29655                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29656 8A07           E8         7C01            call	_read_word
29657 8A0A           83C4                   04  add	sp,*4
29658                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
29659 8A0D           8946         FA            mov	-6[bp],ax
29660                                           !BCC_EOS
29661                                           ! 4298       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
29662                                           ! Debug: list * unsigned long = const $260 (used reg = )
29663 8A10           B8                   0260  mov	ax,#$260
29664 8A13           50                         push	ax
29665                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29666 8A14           FF76         FE            push	-2[bp]
29667                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
29668 8A17           E8         7669            call	_read_dword
29669 8A1A           89D3                       mov	bx,dx
29670 8A1C           83C4                   04  add	sp,*4
29671                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
29672 8A1F           8946         E6            mov	-$1A[bp],ax
29673 8A22           895E         E8            mov	-$18[bp],bx
29674                                           !BCC_EOS
29675                                           ! 4299       sector = ( CX & 0x00ff ) & 0x003f;
29676                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
29677 8A25           8A46         14            mov	al,$14[bp]
29678                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
29679 8A28           24                     3F  and	al,*$3F
29680                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
29681 8A2A           30E4                       xor	ah,ah
29682 8A2C           8946         F2            mov	-$E[bp],ax
29683                                           !BCC_EOS
29684                                           ! 4300       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
29685                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
29686 8A2F           8B46         14            mov	ax,$14[bp]
29687 8A32           88E0                       mov	al,ah
29688 8A34           30E4                       xor	ah,ah
29689 8A36           50                         push	ax
29690                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29691 8A37           8A46         14            mov	al,$14[bp]
29692                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
29693 8A3A           24                     C0  and	al,#$C0
29694                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
29695 8A3C           30E4                       xor	ah,ah
29696 8A3E           D1E0                       shl	ax,*1
29697 8A40           D1E0                       shl	ax,*1
29698                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29699 8A42           0B46         CA            or	ax,0+..FFE1[bp]
29700 8A45           44                         inc	sp
29701 8A46           44                         inc	sp
29702                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
29703 8A47           8946         F0            mov	-$10[bp],ax
29704                                           !BCC_EOS
29705                                           ! 4301       head = ( DX >> 8 );
29706                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
29707 8A4A           8B46         12            mov	ax,$12[bp]
29708 8A4D           88E0                       mov	al,ah
29709 8A4F           30E4                       xor	ah,ah
29710                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
29711 8A51           8946         F4            mov	-$C[bp],ax
29712                                           !BCC_EOS
29713                                           ! 4302       nbsectors = ( AX & 0x00ff );
29714                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29715 8A54           8A46         16            mov	al,$16[bp]
29716                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29717 8A57           30E4                       xor	ah,ah
29718 8A59           8946         EE            mov	-$12[bp],ax
29719                                           !BCC_EOS
29720                                           ! 4303       segment = ES;
29721                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
29722 8A5C           8B46         06            mov	ax,6[bp]
29723 8A5F           8946         DA            mov	-$26[bp],ax
29724                                           !BCC_EOS
29725                                           ! 4304       offset = BX;
29726                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
29727 8A62           8B46         10            mov	ax,$10[bp]
29728 8A65           8946         D8            mov	-$28[bp],ax
29729                                           !BCC_EOS
29730                                           ! 4305       if(nbsectors==0) goto int13_success;
29731                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29732 8A68           8B46         EE            mov	ax,-$12[bp]
29733 8A6B           85C0                       test	ax,ax
29734 8A6D           75           06            jne 	.62A
29735                       00008A6F            .62B:
29736 8A6F           83C4                   00  add	sp,#..FFE0-..FFE1
29737 8A72           E9         0483            br 	.FFE0
29738                                           !BCC_EOS
29739                                           ! 4306       if ((sector > vspt)
29740                       00008A75            .62A:
29741                                           ! 4307        || (cylinder >= vcylinders)
29742                                           ! 4308        || (head >= vheads)) {
29743                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
29744 8A75           8B46         F2            mov	ax,-$E[bp]
29745 8A78           3B46         F8            cmp	ax,-8[bp]
29746 8A7B           77           10            ja  	.62D
29747                       00008A7D            .62F:
29748                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
29749 8A7D           8B46         F0            mov	ax,-$10[bp]
29750 8A80           3B46         F6            cmp	ax,-$A[bp]
29751 8A83           73           08            jae 	.62D
29752                       00008A85            .62E:
29753                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
29754 8A85           8B46         F4            mov	ax,-$C[bp]
29755 8A88           3B46         FA            cmp	ax,-6[bp]
29756 8A8B           72           06            jb  	.62C
29757                       00008A8D            .62D:
29758                                           ! 4309         goto int13_fail;
29759 8A8D           83C4                   00  add	sp,#..FFE2-..FFE1
29760 8A90           E9         0438            br 	.FFE2
29761                                           !BCC_EOS
29762                                           ! 4310       }
29763                                           ! 4311       if (( AX >> 8 ) == 0x04) goto int13_success;
29764                       00008A93            .62C:
29765                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29766 8A93           8B46         16            mov	ax,$16[bp]
29767 8A96           88E0                       mov	al,ah
29768 8A98           30E4                       xor	ah,ah
29769                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
29770 8A9A           3D                   0004  cmp	ax,*4
29771 8A9D           75           06            jne 	.630
29772                       00008A9F            .631:
29773 8A9F           83C4                   00  add	sp,#..FFE0-..FFE1
29774 8AA2           E9         0453            br 	.FFE0
29775                                           !BCC_EOS
29776                                           ! 4312       segm
29777                                           ! 4312 ent = ES+(BX / 16);
29778                       00008AA5            .630:
29779                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29780 8AA5           8B46         10            mov	ax,$10[bp]
29781 8AA8           B1                     04  mov	cl,*4
29782 8AAA           D3E8                       shr	ax,cl
29783                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
29784                                           ! Debug: expression subtree swapping
29785 8AAC           0346         06            add	ax,6[bp]
29786                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
29787 8AAF           8946         DA            mov	-$26[bp],ax
29788                                           !BCC_EOS
29789                                           ! 4313       offset = BX % 16;
29790                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29791 8AB2           8B46         10            mov	ax,$10[bp]
29792 8AB5           24                     0F  and	al,*$F
29793                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
29794 8AB7           30E4                       xor	ah,ah
29795 8AB9           8946         D8            mov	-$28[bp],ax
29796                                           !BCC_EOS
29797                                           ! 4314       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
29798                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
29799 8ABC           8B46         F2            mov	ax,-$E[bp]
29800                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
29801 8ABF           48                         dec	ax
29802 8AC0           31DB                       xor	bx,bx
29803 8AC2           53                         push	bx
29804 8AC3           50                         push	ax
29805                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
29806 8AC4           8B46         F8            mov	ax,-8[bp]
29807 8AC7           31DB                       xor	bx,bx
29808 8AC9           53                         push	bx
29809 8ACA           50                         push	ax
29810                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
29811 8ACB           8B46         F4            mov	ax,-$C[bp]
29812 8ACE           31DB                       xor	bx,bx
29813 8AD0           53                         push	bx
29814 8AD1           50                         push	ax
29815                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
29816 8AD2           8B46         FA            mov	ax,-6[bp]
29817 8AD5           31DB                       xor	bx,bx
29818 8AD7           53                         push	bx
29819 8AD8           50                         push	ax
29820                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
29821 8AD9           8B46         F0            mov	ax,-$10[bp]
29822 8ADC           31DB                       xor	bx,bx
29823                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
29824 8ADE           8D7E         BC            lea	di,-$E+..FFE1[bp]
29825 8AE1           E8         7605            call	lmulul
29826 8AE4           83C4                   04  add	sp,*4
29827                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
29828 8AE7           8D7E         C0            lea	di,-$A+..FFE1[bp]
29829 8AEA           E8         75D6            call	laddul
29830 8AED           83C4                   04  add	sp,*4
29831                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
29832 8AF0           8D7E         C4            lea	di,-6+..FFE1[bp]
29833 8AF3           E8         75F3            call	lmulul
29834 8AF6           83C4                   04  add	sp,*4
29835                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
29836 8AF9           8D7E         C8            lea	di,-2+..FFE1[bp]
29837 8AFC           E8         75C4            call	laddul
29838 8AFF           83C4                   04  add	sp,*4
29839                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29840 8B02           8946         EA            mov	-$16[bp],ax
29841 8B05           895E         EC            mov	-$14[bp],bx
29842                                           !BCC_EOS
29843                                           ! 4315       AX = ((AX & 0xff00) | (nbsectors));
29844                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29845 8B08           8B46         16            mov	ax,$16[bp]
29846 8B0B           30C0                       xor	al,al
29847                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
29848 8B0D           0B46         EE            or	ax,-$12[bp]
29849                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29850 8B10           8946         16            mov	$16[bp],ax
29851                                           !BCC_EOS
29852                                           ! 4316       slba = (Bit32u)vlba/4;
29853                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
29854 8B13           B8                   0004  mov	ax,*4
29855 8B16           31DB                       xor	bx,bx
29856 8B18           53                         push	bx
29857 8B19           50                         push	ax
29858 8B1A           8B46         EA            mov	ax,-$16[bp]
29859 8B1D           8B5E         EC            mov	bx,-$14[bp]
29860 8B20           8D7E         C8            lea	di,-2+..FFE1[bp]
29861 8B23           E8         7648            call	ldivul
29862 8B26           83C4                   04  add	sp,*4
29863                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
29864 8B29           8946         E2            mov	-$1E[bp],ax
29865 8B2C           895E         E4            mov	-$1C[bp],bx
29866                                           !BCC_EOS
29867                                           ! 4317       before= (Bit16u)vlba%4;
29868                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
29869 8B2F           8B46         EA            mov	ax,-$16[bp]
29870 8B32           24                     03  and	al,*3
29871                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
29872 8B34           30E4                       xor	ah,ah
29873 8B36           8946         DC            mov	-$24[bp],ax
29874                                           !BCC_EOS
29875                                           ! 4318       elba = (Bit32u)(vlba+nbsectors-1)/4;
29876                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29877 8B39           8B46         EE            mov	ax,-$12[bp]
29878 8B3C           31DB                       xor	bx,bx
29879                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29880                                           ! Debug: expression subtree swapping
29881 8B3E           8D7E         EA            lea	di,-$16[bp]
29882 8B41           E8         757F            call	laddul
29883                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29884 8B44           53                         push	bx
29885 8B45           50                         push	ax
29886 8B46           B8                   0001  mov	ax,*1
29887 8B49           31DB                       xor	bx,bx
29888 8B4B           53                         push	bx
29889 8B4C           50                         push	ax
29890 8B4D           8B46         C8            mov	ax,-2+..FFE1[bp]
29891 8B50           8B5E         CA            mov	bx,0+..FFE1[bp]
29892 8B53           8D7E         C4            lea	di,-6+..FFE1[bp]
29893 8B56           E8         7588            call	lsubul
29894 8B59           83C4                   08  add	sp,*8
29895                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
29896                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
29897 8B5C           53                         push	bx
29898 8B5D           50                         push	ax
29899 8B5E           B8                   0004  mov	ax,*4
29900 8B61           31DB                       xor	bx,bx
29901 8B63           53                         push	bx
29902 8B64           50                         push	ax
29903 8B65           8B46         C8            mov	ax,-2+..FFE1[bp]
29904 8B68           8B5E         CA            mov	bx,0+..FFE1[bp]
29905 8B6B           8D7E         C4            lea	di,-6+..FFE1[bp]
29906 8B6E           E8         75FD            call	ldivul
29907 8B71           83C4                   08  add	sp,*8
29908                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
29909 8B74           8946         DE            mov	-$22[bp],ax
29910 8B77           895E         E0            mov	-$20[bp],bx
29911                                           !BCC_EOS
29912                                           ! 4319       memsetb(get_SS(),atacmd,0,12);
29913                                           ! Debug: list int = const $C (used reg = )
29914 8B7A           B8                   000C  mov	ax,*$C
29915 8B7D           50                         push	ax
29916                                           ! Debug: list int = const 0 (used reg = )
29917 8B7E           31C0                       xor	ax,ax
29918 8B80           50                         push	ax
29919                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
29920 8B81           8D5E         CC            lea	bx,-$34[bp]
29921 8B84           53                         push	bx
29922                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29923 8B85           E8         7AC9            call	_get_SS
29924                                           ! Debug: list unsigned short = ax+0 (used reg = )
29925 8B88           50                         push	ax
29926                                           ! Debug: func () void = memsetb+0 (used reg = )
29927 8B89           E8         7474            call	_memsetb
29928 8B8C           83C4                   08  add	sp,*8
29929                                           !BCC_EOS
29930                                           ! 4320       atacmd[0]=0x28;
29931                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
29932 8B8F           B0                     28  mov	al,*$28
29933 8B91           8846         CC            mov	-$34[bp],al
29934                                           !BCC_EOS
29935                                           ! 4321       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
29936                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29937 8B94           8B46         DE            mov	ax,-$22[bp]
29938 8B97           8B5E         E0            mov	bx,-$20[bp]
29939 8B9A           8D7E         E2            lea	di,-$1E[bp]
29940 8B9D           E8         7541            call	lsubul
29941                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29942 8BA0           53                         push	bx
29943 8BA1           50                         push	ax
29944 8BA2           B8                   0001  mov	ax,*1
29945 8BA5           31DB                       xor	bx,bx
29946 8BA7           53                         push	bx
29947 8BA8           50                         push	ax
29948 8BA9           8B46         C8            mov	ax,-2+..FFE1[bp]
29949 8BAC           8B5E         CA            mov	bx,0+..FFE1[bp]
29950 8BAF           8D7E         C4            lea	di,-6+..FFE1[bp]
29951 8BB2           E8         750E            call	laddul
29952 8BB5           83C4                   08  add	sp,*8
29953                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29954                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
29955 8BB8           30C0                       xor	al,al
29956                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
29957 8BBA           88E0                       mov	al,ah
29958 8BBC           30E4                       xor	ah,ah
29959                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
29960 8BBE           8846         D3            mov	-$2D[bp],al
29961                                           !BCC_EOS
29962                                           ! 4322       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
29963                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29964 8BC1           8B46         DE            mov	ax,-$22[bp]
29965 8BC4           8B5E         E0            mov	bx,-$20[bp]
29966 8BC7           8D7E         E2            lea	di,-$1E[bp]
29967 8BCA           E8         7514            call	lsubul
29968                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29969 8BCD           53                         push	bx
29970 8BCE           50                         push	ax
29971 8BCF           B8                   0001  mov	ax,*1
29972 8BD2           31DB                       xor	bx,bx
29973 8BD4           53                         push	bx
29974 8BD5           50                         push	ax
29975 8BD6           8B46         C8            mov	ax,-2+..FFE1[bp]
29976 8BD9           8B5E         CA            mov	bx,0+..FFE1[bp]
29977 8BDC           8D7E         C4            lea	di,-6+..FFE1[bp]
29978 8BDF           E8         74E1            call	laddul
29979 8BE2           83C4                   08  add	sp,*8
29980                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29981                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
29982                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
29983 8BE5           8846         D4            mov	-$2C[bp],al
29984                                           !BCC_EOS
29985                                           ! 4323       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
29986                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29987 8BE8           8B46         E6            mov	ax,-$1A[bp]
29988 8BEB           8B5E         E8            mov	bx,-$18[bp]
29989 8BEE           8D7E         E2            lea	di,-$1E[bp]
29990 8BF1           E8         74CF            call	laddul
29991                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
29992 8BF4           53                         push	bx
29993 8BF5           50                         push	ax
29994 8BF6           31C0                       xor	ax,ax
29995 8BF8           BB                   FF00  mov	bx,#$FF00
29996 8BFB           53                         push	bx
29997 8BFC           50                         push	ax
29998 8BFD           8B46         C8            mov	ax,-2+..FFE1[bp]
29999 8C00           8B5E         CA            mov	bx,0+..FFE1[bp]
30000 8C03           8D7E         C4            lea	di,-6+..FFE1[bp]
30001 8C06           E8         74B2            call	landul
30002 8C09           83C4                   08  add	sp,*8
30003                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
30004 8C0C           93                         xchg	bx,ax
30005 8C0D           88E0                       mov	al,ah
30006 8C0F           30E4                       xor	ah,ah
30007 8C11           31DB                       xor	bx,bx
30008                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
30009 8C13           8846         CE            mov	-$32[bp],al
30010                                           !BCC_EOS
30011                                           ! 4324       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
30012                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30013 8C16           8B46         E6            mov	ax,-$1A[bp]
30014 8C19           8B5E         E8            mov	bx,-$18[bp]
30015 8C1C           8D7E         E2            lea	di,-$1E[bp]
30016 8C1F           E8         74A1            call	laddul
30017                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
30018 8C22           53                         push	bx
30019 8C23           50                         push	ax
30020 8C24           31C0                       xor	ax,ax
30021 8C26           BB                   00FF  mov	bx,#$FF
30022 8C29           53                         push	bx
30023 8C2A           50                         push	ax
30024 8C2B           8B46         C8            mov	ax,-2+..FFE1[bp]
30025 8C2E           8B5E         CA            mov	bx,0+..FFE1[bp]
30026 8C31           8D7E         C4            lea	di,-6+..FFE1[bp]
30027 8C34           E8         7484            call	landul
30028 8C37           83C4                   08  add	sp,*8
30029                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
30030 8C3A           93                         xchg	bx,ax
30031 8C3B           31DB                       xor	bx,bx
30032                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
30033 8C3D           8846         CF            mov	-$31[bp],al
30034                                           !BCC_EOS
30035                                           ! 4325       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
30036                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30037 8C40           8B46         E6            mov	ax,-$1A[bp]
30038 8C43           8B5E         E8            mov	bx,-$18[bp]
30039 8C46           8D7E         E2            lea	di,-$1E[bp]
30040 8C49           E8         7477            call	laddul
30041                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
30042 8C4C           53                         push	bx
30043 8C4D           50                         push	ax
30044 8C4E           B8                   FF00  mov	ax,#$FF00
30045 8C51           31DB                       xor	bx,bx
30046 8C53           53                         push	bx
30047 8C54           50                         push	ax
30048 8C55           8B46         C8            mov	ax,-2+..FFE1[bp]
30049 8C58           8B5E         CA            mov	bx,0+..FFE1[bp]
30050 8C5B           8D7E         C4            lea	di,-6+..FFE1[bp]
30051 8C5E           E8         745A            call	landul
30052 8C61           83C4                   08  add	sp,*8
30053                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
30054 8C64           88E0                       mov	al,ah
30055 8C66           88DC                       mov	ah,bl
30056 8C68           88FB                       mov	bl,bh
30057 8C6A           28FF                       sub	bh,bh
30058                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
30059 8C6C           8846         D0            mov	-$30[bp],al
30060                                           !BCC_EOS
30061                                           ! 4326       atacmd[5]=(ilba+slba & 0x000000ff);
30062                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
30063 8C6F           8B46         E6            mov	ax,-$1A[bp]
30064 8C72           8B5E         E8            mov	bx,-$18[bp]
30065 8C75           8D7E         E2            lea	di,-$1E[bp]
30066 8C78           E8         7448            call	laddul
30067                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
30068 8C7B           53                         push	bx
30069 8C7C           50                         push	ax
30070 8C7D           B8                   00FF  mov	ax,#$FF
30071 8C80           31DB                       xor	bx,bx
30072 8C82           53                         push	bx
30073 8C83           50                         push	ax
30074 8C84           8B46         C8            mov	ax,-2+..FFE1[bp]
30075 8C87           8B5E         CA            mov	bx,0+..FFE1[bp]
30076 8C8A           8D7E         C4            lea	di,-6+..FFE1[bp]
30077 8C8D           E8         742B            call	landul
30078 8C90           83C4                   08  add	sp,*8
30079                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
30080 8C93           8846         D1            mov	-$2F[bp],al
30081                                           !BCC_EOS
30082                                           ! 4327       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
30083                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
30084 8C96           FF76         D8            push	-$28[bp]
30085                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
30086 8C99           FF76         DA            push	-$26[bp]
30087                                           ! Debug: list int = const 1 (used reg = )
30088 8C9C           B8                   0001  mov	ax,*1
30089 8C9F           50                         push	ax
30090                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
30091 8CA0           8B46         EE            mov	ax,-$12[bp]
30092 8CA3           31DB                       xor	bx,bx
30093                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
30094 8CA5           53                         push	bx
30095 8CA6           50                         push	ax
30096 8CA7           B8                   0200  mov	ax,#$200
30097 8CAA           31DB                       xor	bx,bx
30098 8CAC           53                         push	bx
30099 8CAD           50                         push	ax
30100 8CAE           8B46         C2            mov	ax,-8+..FFE1[bp]
30101 8CB1           8B5E         C4            mov	bx,-6+..FFE1[bp]
30102 8CB4           8D7E         BE            lea	di,-$C+..FFE1[bp]
30103 8CB7           E8         742F            call	lmulul
30104 8CBA           83C4                   08  add	sp,*8
30105                                           ! Debug: list unsigned long = bx+0 (used reg = )
30106 8CBD           53                         push	bx
30107 8CBE           50                         push	ax
30108                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
30109 8CBF           8B46         DC            mov	ax,-$24[bp]
30110 8CC2           B9                   0200  mov	cx,#$200
30111 8CC5           F7E9                       imul	cx
30112                                           ! Debug: list unsigned int = ax+0 (used reg = )
30113 8CC7           50                         push	ax
30114                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
30115 8CC8           8D5E         CC            lea	bx,-$34[bp]
30116 8CCB           53                         push	bx
30117                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
30118 8CCC           E8         7982            call	_get_SS
30119                                           ! Debug: list unsigned short = ax+0 (used reg = )
30120 8CCF           50                         push	ax
30121                                           ! Debug: list int = const $C (used reg = )
30122 8CD0           B8                   000C  mov	ax,*$C
30123 8CD3           50                         push	ax
30124                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
30125 8CD4           8A46         FD            mov	al,-3[bp]
30126 8CD7           30E4                       xor	ah,ah
30127 8CD9           50                         push	ax
30128                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
30129 8CDA           E8         A90A            call	_ata_cmd_packet
30130 8CDD           83C4                   14  add	sp,*$14
30131                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
30132 8CE0           8846         FC            mov	-4[bp],al
30133                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
30134 8CE3           84C0                       test	al,al
30135 8CE5           74           37            je  	.632
30136                       00008CE7            .633:
30137                                           ! 4328         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
30138                                           ! Debug: list unsigned char status = [S+$36-6] (used reg = )
30139 8CE7           8A46         FC            mov	al,-4[bp]
30140 8CEA           30E4                       xor	ah,ah
30141 8CEC           50                         push	ax
30142                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
30143 8CED           8B46         16            mov	ax,$16[bp]
30144 8CF0           88E0                       mov	al,ah
30145 8CF2           30E4                       xor	ah,ah
30146                                           ! Debug: list unsigned int = ax+0 (used reg = )
30147 8CF4           50                         push	ax
30148                                           ! Debug: list * char = .634+0 (used reg = )
30149 8CF5           BB                   CE90  mov	bx,#.634
30150 8CF8           53                         push	bx
30151                                           ! Debug: list int = const 4 (used reg = )
30152 8CF9           B8                   0004  mov	ax,*4
30153 8CFC           50                         push	ax
30154                                           ! Debug: func () void = bios_printf+0 (used reg = )
30155 8CFD           E8         7CA7            call	_bios_printf
30156 8D00           83C4                   08  add	sp,*8
30157                                           !BCC_EOS
30158                                           ! 4329         AX = ((AX & 0x00ff) | ((0x02) << 8));
30159                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30160 8D03           8A46         16            mov	al,$16[bp]
30161                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
30162 8D06           30E4                       xor	ah,ah
30163 8D08           0D                   0200  or	ax,#$200
30164                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30165 8D0B           8946         16            mov	$16[bp],ax
30166                                           !BCC_EOS
30167                                           ! 4330         AX = ((AX & 0xff00) | (0));
30168                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
30169 8D0E           8B46         16            mov	ax,$16[bp]
30170 8D11           30C0                       xor	al,al
30171                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30172 8D13           0C                     00  or	al,*0
30173                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30174 8D15           8946         16            mov	$16[bp],ax
30175                                           !BCC_EOS
30176                                           ! 4331         goto int13_fail_noah;
30177 8D18           83C4                   00  add	sp,#..FFDF-..FFE1
30178 8D1B           E9         01B8            br 	.FFDF
30179                                           !BCC_EOS
30180                                           ! 4332       }
30181                                           ! 4333       goto int13_success;
30182                       00008D1E            .632:
30183 8D1E           83C4                   00  add	sp,#..FFE0-..FFE1
30184 8D21           E9         01D4            br 	.FFE0
30185                                           !BCC_EOS
30186                                           ! 4334       break;
30187 8D24           E9         01A4            br 	.617
30188                                           !BCC_EOS
30189                                           ! 4335     case 0x08:
30190                                           ! 4336       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
30191                       00008D27            .635:
30192                                           ! Debug: list * unsigned short = const $26E (used reg = )
30193 8D27           B8                   026E  mov	ax,#$26E
30194 8D2A           50                         push	ax
30195                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30196 8D2B           FF76         FE            push	-2[bp]
30197                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30198 8D2E           E8         78DA            call	_read_word
30199 8D31           83C4                   04  add	sp,*4
30200                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
30201 8D34           8946         F8            mov	-8[bp],ax
30202                                           !BCC_EOS
30203                                           ! 4337       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
30204                                           ! Debug: list * unsigned short = const $26C (used reg = )
30205 8D37           B8                   026C  mov	ax,#$26C
30206 8D3A           50                         push	ax
30207                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30208 8D3B           FF76         FE            push	-2[bp]
30209                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30210 8D3E           E8         78CA            call	_read_word
30211 8D41           83C4                   04  add	sp,*4
30212                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30213                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
30214 8D44           48                         dec	ax
30215 8D45           8946         F6            mov	-$A[bp],ax
30216                                           !BCC_EOS
30217                                           ! 4338       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
30218                                           ! Debug: list * unsigned short = const $26A (used reg = )
30219 8D48           B8                   026A  mov	ax,#$26A
30220 8D4B           50                         push	ax
30221                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30222 8D4C           FF76         FE            push	-2[bp]
30223                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30224 8D4F           E8         78B9            call	_read_word
30225 8D52           83C4                   04  add	sp,*4
30226                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30227                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
30228 8D55           48                         dec	ax
30229 8D56           8946         FA            mov	-6[bp],ax
30230                                           !BCC_EOS
30231                                           ! 4339       AX = ((AX & 0xff00) | (0x00));
30232                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
30233 8D59           8B46         16            mov	ax,$16[bp]
30234 8D5C           30C0                       xor	al,al
30235                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30236 8D5E           0C                     00  or	al,*0
30237                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30238 8D60           8946         16            mov	$16[bp],ax
30239                                           !BCC_EOS
30240                                           ! 4340       BX = ((BX & 0xff00) | (0x00));
30241                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30242 8D63           8B46         10            mov	ax,$10[bp]
30243 8D66           30C0                       xor	al,al
30244                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30245 8D68           0C                     00  or	al,*0
30246                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30247 8D6A           8946         10            mov	$10[bp],ax
30248                                           !BCC_EOS
30249                                           ! 4341       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
30250                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
30251 8D6D           8A46         F6            mov	al,-$A[bp]
30252                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
30253 8D70           30E4                       xor	ah,ah
30254 8D72           88C4                       mov	ah,al
30255 8D74           30C0                       xor	al,al
30256 8D76           50                         push	ax
30257                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
30258 8D77           8A46         14            mov	al,$14[bp]
30259                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30260 8D7A           30E4                       xor	ah,ah
30261 8D7C           0B46         CA            or	ax,0+..FFE1[bp]
30262 8D7F           44                         inc	sp
30263 8D80           44                         inc	sp
30264                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30265 8D81           8946         14            mov	$14[bp],ax
30266                                           !BCC_EOS
30267                                           ! 4342       CX = ((CX & 0xff00) | (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f)));
30268                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
30269 8D84           8A46         F8            mov	al,-8[bp]
30270 8D87           24                     3F  and	al,*$3F
30271 8D89           50                         push	ax
30272                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
30273 8D8A           8B46         F6            mov	ax,-$A[bp]
30274 8D8D           D1E8                       shr	ax,*1
30275 8D8F           D1E8                       shr	ax,*1
30276                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
30277 8D91           24                     C0  and	al,#$C0
30278                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30279 8D93           0A46         CA            or	al,0+..FFE1[bp]
30280 8D96           44                         inc	sp
30281 8D97           44                         inc	sp
30282 8D98           50                         push	ax
30283                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
30284 8D99           8B46         14            mov	ax,$14[bp]
30285 8D9C           30C0                       xor	al,al
30286                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
30287 8D9E           0A46         CA            or	al,0+..FFE1[bp]
30288 8DA1           44                         inc	sp
30289 8DA2           44                         inc	sp
30290                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30291 8DA3           8946         14            mov	$14[bp],ax
30292                                           !BCC_EOS
30293                                           ! 4343       DX = ((DX & 0x00ff) | ((vheads) << 8));
30294                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
30295 8DA6           8B46         FA            mov	ax,-6[bp]
30296 8DA9           88C4                       mov	ah,al
30297 8DAB           30C0                       xor	al,al
30298 8DAD           50                         push	ax
30299                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
30300 8DAE           8A46         12            mov	al,$12[bp]
30301                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30302 8DB1           30E4                       xor	ah,ah
30303 8DB3           0B46         CA            or	ax,0+..FFE1[bp]
30304 8DB6           44                         inc	sp
30305 8DB7           44                         inc	sp
30306                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30307 8DB8           8946         12            mov	$12[bp],ax
30308                                           !BCC_EOS
30309                                           ! 4344       DX = ((DX & 0xff00) | (0x02));
30310                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
30311 8DBB           8B46         12            mov	ax,$12[bp]
30312 8DBE           30C0                       xor	al,al
30313                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30314 8DC0           0C                     02  or	al,*2
30315                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30316 8DC2           8946         12            mov	$12[bp],ax
30317                                           !BCC_EOS
30318                                           ! 4345       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
30319                                           ! Debug: list * unsigned char = const $25B (used reg = )
30320 8DC5           B8                   025B  mov	ax,#$25B
30321 8DC8           50                         push	ax
30322                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30323 8DC9           FF76         FE            push	-2[bp]
30324                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30325 8DCC           E8         7829            call	_read_byte
30326 8DCF           83C4                   04  add	sp,*4
30327 8DD2           EB           26            jmp .638
30328                                           ! 4346         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
30329                       00008DD4            .639:
30330                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30331 8DD4           8B46         10            mov	ax,$10[bp]
30332 8DD7           30C0                       xor	al,al
30333                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30334 8DD9           0C                     02  or	al,*2
30335                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30336 8DDB           8946         10            mov	$10[bp],ax
30337                                           !BCC_EOS
30338 8DDE           EB           26            jmp .636
30339                                           !BCC_EOS
30340                                           ! 4347         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
30341                       00008DE0            .63A:
30342                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30343 8DE0           8B46         10            mov	ax,$10[bp]
30344 8DE3           30C0                       xor	al,al
30345                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
30346 8DE5           0C                     04  or	al,*4
30347                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30348 8DE7           8946         10            mov	$10[bp],ax
30349                                           !BCC_EOS
30350 8DEA           EB           1A            jmp .636
30351                                           !BCC_EOS
30352                                           ! 4348         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
30353                       00008DEC            .63B:
30354                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30355 8DEC           8B46         10            mov	ax,$10[bp]
30356 8DEF           30C0                       xor	al,al
30357                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
30358 8DF1           0C                     06  or	al,*6
30359                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30360 8DF3           8946         10            mov	$10[bp],ax
30361                                           !BCC_EOS
30362 8DF6           EB           0E            jmp .636
30363                                           !BCC_EOS
30364                                           ! 4349     }
30365                                           ! 4350 #asm
30366 8DF8           EB           0C            jmp .636
30367                       00008DFA            .638:
30368 8DFA           2C                     01  sub	al,*1
30369 8DFC           74           D6            je 	.639
30370 8DFE           2C                     01  sub	al,*1
30371 8E00           74           DE            je 	.63A
30372 8E02           2C                     01  sub	al,*1
30373 8E04           74           E6            je 	.63B
30374                       00008E06            .636:
30375                                           !BCC_EOS
30376                                           !BCC_ASM
30377                       00000040            _int13_cdemu.BP	set	$40
30378                       0000000C            .int13_cdemu.BP	set	$C
30379                       0000004E            _int13_cdemu.CS	set	$4E
30380                       0000001A            .int13_cdemu.CS	set	$1A
30381                       00000022            _int13_cdemu.nbsectors	set	$22
30382                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
30383                       00000048            _int13_cdemu.CX	set	$48
30384                       00000014            .int13_cdemu.CX	set	$14
30385                       00000012            _int13_cdemu.elba	set	$12
30386                       FFFFFFDE            .int13_cdemu.elba	set	-$22
30387                       0000000E            _int13_cdemu.segment	set	$E
30388                       FFFFFFDA            .int13_cdemu.segment	set	-$26
30389                       0000003C            _int13_cdemu.DI	set	$3C
30390                       00000008            .int13_cdemu.DI	set	8
30391                       00000050            _int13_cdemu.FLAGS	set	$50
30392                       0000001C            .int13_cdemu.FLAGS	set	$1C
30393                       0000002A            _int13_cdemu.vcylinders	set	$2A
30394                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
30395                       00000026            _int13_cdemu.sector	set	$26
30396                       FFFFFFF2            .int13_cdemu.sector	set	-$E
30397                       00000038            _int13_cdemu.DS	set	$38
30398                       00000004            .int13_cdemu.DS	set	4
30399                       00000028            _int13_cdemu.head	set	$28
30400                       FFFFFFF4            .int13_cdemu.head	set	-$C
30401                       00000024            _int13_cdemu.cylinder	set	$24
30402                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
30403                       00000046            _int13_cdemu.DX	set	$46
30404                       00000012            .int13_cdemu.DX	set	$12
30405                       00000031            _int13_cdemu.device	set	$31
30406                       FFFFFFFD            .int13_cdemu.device	set	-3
30407                       0000003A            _int13_cdemu.ES	set	$3A
30408                       00000006            .int13_cdemu.ES	set	6
30409                       0000002C            _int13_cdemu.vspt	set	$2C
30410                       FFFFFFF8            .int13_cdemu.vspt	set	-8
30411                       0000001E            _int13_cdemu.vlba	set	$1E
30412                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
30413                       00000032            _int13_cdemu.ebda_seg	set	$32
30414                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
30415                       0000003E            _int13_cdemu.SI	set	$3E
30416                       0000000A            .int13_cdemu.SI	set	$A
30417                       0000004C            _int13_cdemu.IP	set	$4C
30418                       00000018            .int13_cdemu.IP	set	$18
30419                       00000030            _int13_cdemu.status	set	$30
30420                       FFFFFFFC            .int13_cdemu.status	set	-4
30421                       00000000            _int13_cdemu.atacmd	set	0
30422                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
30423                       0000004A            _int13_cdemu.AX	set	$4A
30424                       00000016            .int13_cdemu.AX	set	$16
30425                       0000001A            _int13_cdemu.ilba	set	$1A
30426                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
30427                       00000010            _int13_cdemu.before	set	$10
30428                       FFFFFFDC            .int13_cdemu.before	set	-$24
30429                       0000000C            _int13_cdemu.offset	set	$C
30430                       FFFFFFD8            .int13_cdemu.offset	set	-$28
30431                       00000016            _int13_cdemu.slba	set	$16
30432                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
30433                       00000042            _int13_cdemu.SP	set	$42
30434                       0000000E            .int13_cdemu.SP	set	$E
30435                       0000002E            _int13_cdemu.vheads	set	$2E
30436                       FFFFFFFA            .int13_cdemu.vheads	set	-6
30437                       00000044            _int13_cdemu.BX	set	$44
30438                       00000010            .int13_cdemu.BX	set	$10
30439 8E06           55                               push bp
30440 8E07           89E5                             mov bp, sp
30441 8E09           B8                   EFDE        mov ax, #diskette_param_table2
30442 8E0C           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
30443 8E0F           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
30444 8E12           5D                               pop bp
30445                                           ! 4357 endasm
30446                                           !BCC_ENDASM
30447                                           !BCC_EOS
30448                                           ! 4358       goto int13_success;
30449 8E13           83C4                   00  add	sp,#..FFE0-..FFE1
30450 8E16           E9         00DF            br 	.FFE0
30451                                           !BCC_EOS
30452                                           ! 4359       break;
30453 8E19           E9         00AF            br 	.617
30454                                           !BCC_EOS
30455                                           ! 4360     case 0x15:
30456                                           ! 4361       AX = ((AX & 0x00ff) | ((0x
30457                       00008E1C            .63C:
30458                                           ! 4361 03) << 8));
30459                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30460 8E1C           8A46         16            mov	al,$16[bp]
30461                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
30462 8E1F           30E4                       xor	ah,ah
30463 8E21           0D                   0300  or	ax,#$300
30464                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30465 8E24           8946         16            mov	$16[bp],ax
30466                                           !BCC_EOS
30467                                           ! 4362       goto int13_success_noah;
30468 8E27           83C4                   00  add	sp,#..FFDD-..FFE1
30469 8E2A           E9         00D5            br 	.FFDD
30470                                           !BCC_EOS
30471                                           ! 4363       break;
30472 8E2D           E9         009B            br 	.617
30473                                           !BCC_EOS
30474                                           ! 4364     case 0x0a:
30475                                           ! 4365     case 0x0b:
30476                       00008E30            .63D:
30477                                           ! 4366     case 0x18:
30478                       00008E30            .63E:
30479                                           ! 4367     case 0x41:
30480                       00008E30            .63F:
30481                                           ! 4368     case 0x42:
30482                       00008E30            .640:
30483                                           ! 4369     case 0x43:
30484                       00008E30            .641:
30485                                           ! 4370     case 0x44:
30486                       00008E30            .642:
30487                                           ! 4371     case 0x45:
30488                       00008E30            .643:
30489                                           ! 4372     case 0x46:
30490                       00008E30            .644:
30491                                           ! 4373     case 0x47:
30492                       00008E30            .645:
30493                                           ! 4374     case 0x48:
30494                       00008E30            .646:
30495                                           ! 4375     case 0x49:
30496                       00008E30            .647:
30497                                           ! 4376     case 0x4e:
30498                       00008E30            .648:
30499                                           ! 4377     case 0x50:
30500                       00008E30            .649:
30501                                           ! 4378     default:
30502                       00008E30            .64A:
30503                                           ! 4379       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
30504                       00008E30            .64B:
30505                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30506 8E30           8B46         16            mov	ax,$16[bp]
30507 8E33           88E0                       mov	al,ah
30508 8E35           30E4                       xor	ah,ah
30509                                           ! Debug: list unsigned int = ax+0 (used reg = )
30510 8E37           50                         push	ax
30511                                           ! Debug: list * char = .64C+0 (used reg = )
30512 8E38           BB                   CE58  mov	bx,#.64C
30513 8E3B           53                         push	bx
30514                                           ! Debug: list int = const 4 (used reg = )
30515 8E3C           B8                   0004  mov	ax,*4
30516 8E3F           50                         push	ax
30517                                           ! Debug: func () void = bios_printf+0 (used reg = )
30518 8E40           E8         7B64            call	_bios_printf
30519 8E43           83C4                   06  add	sp,*6
30520                                           !BCC_EOS
30521                                           ! 4380       goto int13_fail;
30522 8E46           83C4                   00  add	sp,#..FFE2-..FFE1
30523 8E49           E9         007F            jmp .FFE2
30524                                           !BCC_EOS
30525                                           ! 4381       break;
30526 8E4C           EB           7D            jmp .617
30527                                           !BCC_EOS
30528                                           ! 4382   }
30529                                           ! 4383 int13_fail:
30530 8E4E           EB           7B            jmp .617
30531                       00008E50            .619:
30532 8E50           2D                   0000  sub	ax,*0
30533 8E53           7C           DB            jl 	.64B
30534 8E55           3D                   0018  cmp	ax,*$18
30535 8E58           77           3B            ja  	.64D
30536 8E5A           D1E0                       shl	ax,*1
30537 8E5C           89C3                       mov	bx,ax
30538 8E5E           2E                         seg	cs
30539 8E5F           FFA7       8E63            br	.64E[bx]
30540                       00008E63            .64E:
30541 8E63                      8972            .word	.61A
30542 8E65                      898F            .word	.624
30543 8E67                      89E0            .word	.628
30544 8E69                      897B            .word	.622
30545 8E6B                      89E0            .word	.629
30546 8E6D                      897B            .word	.623
30547 8E6F                      8E30            .word	.64B
30548 8E71                      8E30            .word	.64B
30549 8E73                      8D27            .word	.635
30550 8E75                      8972            .word	.61B
30551 8E77                      8E30            .word	.63D
30552 8E79                      8E30            .word	.63E
30553 8E7B                      8972            .word	.61C
30554 8E7D                      8972            .word	.61D
30555 8E7F                      8E30            .word	.64B
30556 8E81                      8E30            .word	.64B
30557 8E83                      8972            .word	.61E
30558 8E85                      8972            .word	.61F
30559 8E87                      8E30            .word	.64B
30560 8E89                      8E30            .word	.64B
30561 8E8B                      8972            .word	.620
30562 8E8D                      8E1C            .word	.63C
30563 8E8F                      8972            .word	.621
30564 8E91                      8E30            .word	.64B
30565 8E93                      8E30            .word	.63F
30566                       00008E95            .64D:
30567 8E95           2D                   0041  sub	ax,*$41
30568 8E98           72           96            jb 	.64B
30569 8E9A           3D                   000F  cmp	ax,*$F
30570 8E9D           77           29            ja  	.64F
30571 8E9F           D1E0                       shl	ax,*1
30572 8EA1           89C3                       mov	bx,ax
30573 8EA3           2E                         seg	cs
30574 8EA4           FFA7       8EA8            br	.650[bx]
30575                       00008EA8            .650:
30576 8EA8                      8E30            .word	.640
30577 8EAA                      8E30            .word	.641
30578 8EAC                      8E30            .word	.642
30579 8EAE                      8E30            .word	.643
30580 8EB0                      8E30            .word	.644
30581 8EB2                      8E30            .word	.645
30582 8EB4                      8E30            .word	.646
30583 8EB6                      8E30            .word	.647
30584 8EB8                      8E30            .word	.648
30585 8EBA                      8E30            .word	.64B
30586 8EBC                      8E30            .word	.64B
30587 8EBE                      8E30            .word	.64B
30588 8EC0                      8E30            .word	.64B
30589 8EC2                      8E30            .word	.649
30590 8EC4                      8E30            .word	.64B
30591 8EC6                      8E30            .word	.64A
30592                       00008EC8            .64F:
30593 8EC8           E9         FF65            br 	.64B
30594                       00008ECB            .617:
30595                       FFFFFFCA            ..FFE1	=	-$36
30596                       00008ECB            .FFE2:
30597                       FFFFFFCA            ..FFE2	=	-$36
30598                                           ! 4384   AX = ((AX & 0x00ff) | ((0x01) << 8));
30599                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30600 8ECB           8A46         16            mov	al,$16[bp]
30601                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30602 8ECE           30E4                       xor	ah,ah
30603 8ED0           0D                   0100  or	ax,#$100
30604                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30605 8ED3           8946         16            mov	$16[bp],ax
30606                                           !BCC_EOS
30607                                           ! 4385 int13_fail_noah:
30608                       00008ED6            .FFDF:
30609                       FFFFFFCA            ..FFDF	=	-$36
30610                                           ! 4386   write_byte(0x0040, 0x0074, ( AX >> 8 ));
30611                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30612 8ED6           8B46         16            mov	ax,$16[bp]
30613 8ED9           88E0                       mov	al,ah
30614 8EDB           30E4                       xor	ah,ah
30615                                           ! Debug: list unsigned int = ax+0 (used reg = )
30616 8EDD           50                         push	ax
30617                                           ! Debug: list int = const $74 (used reg = )
30618 8EDE           B8                   0074  mov	ax,*$74
30619 8EE1           50                         push	ax
30620                                           ! Debug: list int = const $40 (used reg = )
30621 8EE2           B8                   0040  mov	ax,*$40
30622 8EE5           50                         push	ax
30623                                           ! Debug: func () void = write_byte+0 (used reg = )
30624 8EE6           E8         7735            call	_write_byte
30625 8EE9           83C4                   06  add	sp,*6
30626                                           !BCC_EOS
30627                                           ! 4387 int13_fail_nostatus:
30628                       00008EEC            .FFDE:
30629                       FFFFFFCA            ..FFDE	=	-$36
30630                                           ! 4388   FLAGS |= 0x0001;
30631                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30632 8EEC           8B46         1C            mov	ax,$1C[bp]
30633 8EEF           0C                     01  or	al,*1
30634 8EF1           8946         1C            mov	$1C[bp],ax
30635                                           !BCC_EOS
30636                                           ! 4389   return;
30637 8EF4           89EC                       mov	sp,bp
30638 8EF6           5D                         pop	bp
30639 8EF7           C3                         ret
30640                                           !BCC_EOS
30641                                           ! 4390 int13_success:
30642                       00008EF8            .FFE0:
30643                       FFFFFFCA            ..FFE0	=	-$36
30644                                           ! 4391   AX = ((AX & 0x00ff) | ((0x00) << 8));
30645                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30646 8EF8           8A46         16            mov	al,$16[bp]
30647                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
30648 8EFB           0C                     00  or	al,*0
30649                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
30650 8EFD           30E4                       xor	ah,ah
30651 8EFF           8946         16            mov	$16[bp],ax
30652                                           !BCC_EOS
30653                                           ! 4392 int13_success_noah:
30654                       00008F02            .FFDD:
30655                       FFFFFFCA            ..FFDD	=	-$36
30656                                           ! 4393   write_byte(0x0040, 0x0074, 0x00);
30657                                           ! Debug: list int = const 0 (used reg = )
30658 8F02           31C0                       xor	ax,ax
30659 8F04           50                         push	ax
30660                                           ! Debug: list int = const $74 (used reg = )
30661 8F05           B8                   0074  mov	ax,*$74
30662 8F08           50                         push	ax
30663                                           ! Debug: list int = const $40 (used reg = )
30664 8F09           B8                   0040  mov	ax,*$40
30665 8F0C           50                         push	ax
30666                                           ! Debug: func () void = write_byte+0 (used reg = )
30667 8F0D           E8         770E            call	_write_byte
30668 8F10           83C4                   06  add	sp,*6
30669                                           !BCC_EOS
30670                                           ! 4394   FLAGS &= 0xfffe;
30671                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30672 8F13           8B46         1C            mov	ax,$1C[bp]
30673 8F16           24                     FE  and	al,#$FE
30674 8F18           8946         1C            mov	$1C[bp],ax
30675                                           !BCC_EOS
30676                                           ! 4395 }
30677 8F1B           89EC                       mov	sp,bp
30678 8F1D           5D                         pop	bp
30679 8F1E           C3                         ret
30680                                           ! 4396 void floppy_reset_controller()
30681                                           ! Register BX used in function int13_cdemu
30682                                           ! 4397 {
30683                                           export	_floppy_reset_controller
30684                       00008F1F            _floppy_reset_controller:
30685                                           ! 4398   Bit8u val8;
30686                                           !BCC_EOS
30687                                           ! 4399   val8 = inb(0x03f2);
30688 8F1F           55                         push	bp
30689 8F20           89E5                       mov	bp,sp
30690 8F22           4C                         dec	sp
30691 8F23           4C                         dec	sp
30692                                           ! Debug: list int = const $3F2 (used reg = )
30693 8F24           B8                   03F2  mov	ax,#$3F2
30694 8F27           50                         push	ax
30695                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30696 8F28           E8         7617            call	_inb
30697 8F2B           44                         inc	sp
30698 8F2C           44                         inc	sp
30699                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30700 8F2D           8846         FF            mov	-1[bp],al
30701                                           !BCC_EOS
30702                                           ! 4400   outb(0x03f2, val8 & ~0x04);
30703                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
30704 8F30           8A46         FF            mov	al,-1[bp]
30705 8F33           24                     FB  and	al,#$FB
30706                                           ! Debug: list unsigned char = al+0 (used reg = )
30707 8F35           30E4                       xor	ah,ah
30708 8F37           50                         push	ax
30709                                           ! Debug: list int = const $3F2 (used reg = )
30710 8F38           B8                   03F2  mov	ax,#$3F2
30711 8F3B           50                         push	ax
30712                                           ! Debug: func () void = outb+0 (used reg = )
30713 8F3C           E8         7619            call	_outb
30714 8F3F           83C4                   04  add	sp,*4
30715                                           !BCC_EOS
30716                                           ! 4401   outb(0x03f2, val8 | 0x04);
30717                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
30718 8F42           8A46         FF            mov	al,-1[bp]
30719 8F45           0C                     04  or	al,*4
30720                                           ! Debug: list unsigned char = al+0 (used reg = )
30721 8F47           30E4                       xor	ah,ah
30722 8F49           50                         push	ax
30723                                           ! Debug: list int = const $3F2 (used reg = )
30724 8F4A           B8                   03F2  mov	ax,#$3F2
30725 8F4D           50                         push	ax
30726                                           ! Debug: func () void = outb+0 (used reg = )
30727 8F4E           E8         7607            call	_outb
30728 8F51           83C4                   04  add	sp,*4
30729                                           !BCC_EOS
30730                                           ! 4402   do {
30731                       00008F54            .653:
30732                                           ! 4403     val8 = inb(0x3f4);
30733                                           ! Debug: list int = const $3F4 (used reg = )
30734 8F54           B8                   03F4  mov	ax,#$3F4
30735 8F57           50                         push	ax
30736                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30737 8F58           E8         75E7            call	_inb
30738 8F5B           44                         inc	sp
30739 8F5C           44                         inc	sp
30740                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30741 8F5D           8846         FF            mov	-1[bp],al
30742                                           !BCC_EOS
30743                                           ! 4404   } while ((val8 & 0xc0) != 0x80);
30744                       00008F60            .652:
30745                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
30746 8F60           8A46         FF            mov	al,-1[bp]
30747 8F63           24                     C0  and	al,#$C0
30748                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30749 8F65           3C                     80  cmp	al,#$80
30750 8F67           75           EB            jne	.653
30751                       00008F69            .654:
30752                                           !BCC_EOS
30753                                           ! 4405 }
30754                       00008F69            .651:
30755 8F69           89EC                       mov	sp,bp
30756 8F6B           5D                         pop	bp
30757 8F6C           C3                         ret
30758                                           ! 4406 void floppy_prepare_controller(drive)
30759                                           ! 4407   Bit16u drive;
30760                                           export	_floppy_prepare_controller
30761                       00008F6D            _floppy_prepare_controller:
30762                                           !BCC_EOS
30763                                           ! 4408 {
30764                                           ! 4409   Bit8u val8, dor, prev_reset;
30765                                           !BCC_EOS
30766                                           ! 4410   val8 = read_byte(0x0040, 0x003e);
30767 8F6D           55                         push	bp
30768 8F6E           89E5                       mov	bp,sp
30769 8F70           83C4                   FC  add	sp,*-4
30770                                           ! Debug: list int = const $3E (used reg = )
30771 8F73           B8                   003E  mov	ax,*$3E
30772 8F76           50                         push	ax
30773                                           ! Debug: list int = const $40 (used reg = )
30774 8F77           B8                   0040  mov	ax,*$40
30775 8F7A           50                         push	ax
30776                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30777 8F7B           E8         767A            call	_read_byte
30778 8F7E           83C4                   04  add	sp,*4
30779                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30780 8F81           8846         FF            mov	-1[bp],al
30781                                           !BCC_EOS
30782                                           ! 4411   val8 &= 0x7f;
30783                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30784 8F84           8A46         FF            mov	al,-1[bp]
30785 8F87           24                     7F  and	al,*$7F
30786 8F89           8846         FF            mov	-1[bp],al
30787                                           !BCC_EOS
30788                                           ! 4412   write_byte(0x0040, 0x003e, val8);
30789                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30790 8F8C           8A46         FF            mov	al,-1[bp]
30791 8F8F           30E4                       xor	ah,ah
30792 8F91           50                         push	ax
30793                                           ! Debug: list int = const $3E (used reg = )
30794 8F92           B8                   003E  mov	ax,*$3E
30795 8F95           50                         push	ax
30796                                           ! Debug: list int = const $40 (used reg = )
30797 8F96           B8                   0040  mov	ax,*$40
30798 8F99           50                         push	ax
30799                                           ! Debug: func () void = write_byte+0 (used reg = )
30800 8F9A           E8         7681            call	_write_byte
30801 8F9D           83C4                   06  add	sp,*6
30802                                           !BCC_EOS
30803                                           ! 4413   prev_reset = inb(0x03f2) & 0x04;
30804                                           ! Debug: list int = const $3F2 (used reg = )
30805 8FA0           B8                   03F2  mov	ax,#$3F2
30806 8FA3           50                         push	ax
30807                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30808 8FA4           E8         759B            call	_inb
30809 8FA7           44                         inc	sp
30810 8FA8           44                         inc	sp
30811                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
30812 8FA9           24                     04  and	al,*4
30813                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
30814 8FAB           8846         FD            mov	-3[bp],al
30815                                           !BCC_EOS
30816                                           ! 4414   if (drive)
30817 8FAE           8B46         04            mov	ax,4[bp]
30818 8FB1           85C0                       test	ax,ax
30819 8FB3           74           07            je  	.655
30820                       00008FB5            .656:
30821                                           ! 4415     dor = 0x20;
30822                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
30823 8FB5           B0                     20  mov	al,*$20
30824 8FB7           8846         FE            mov	-2[bp],al
30825                                           !BCC_EOS
30826                                           ! 4416   else
30827                                           ! 4417     dor = 0x10;
30828 8FBA           EB           05            jmp .657
30829                       00008FBC            .655:
30830                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
30831 8FBC           B0                     10  mov	al,*$10
30832 8FBE           8846         FE            mov	-2[bp],al
30833                                           !BCC_EOS
30834                                           ! 4418   dor |= 0x0c;
30835                       00008FC1            .657:
30836                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
30837 8FC1           8A46         FE            mov	al,-2[bp]
30838 8FC4           0C                     0C  or	al,*$C
30839 8FC6           8846         FE            mov	-2[bp],al
30840                                           !BCC_EOS
30841                                           ! 4419   dor |= drive;
30842                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
30843 8FC9           8B46         04            mov	ax,4[bp]
30844 8FCC           0A46         FE            or	al,-2[bp]
30845 8FCF           8846         FE            mov	-2[bp],al
30846                                           !BCC_EOS
30847                                           ! 4420   outb(0x03f2, dor);
30848                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
30849 8FD2           8A46         FE            mov	al,-2[bp]
30850 8FD5           30E4                       xor	ah,ah
30851 8FD7           50                         push	ax
30852                                           ! Debug: list int = const $3F2 (used reg = )
30853 8FD8           B8                   03F2  mov	ax,#$3F2
30854 8FDB           50                         push	ax
30855                                           ! Debug: func () void = outb+0 (used reg = )
30856 8FDC           E8         7579            call	_outb
30857 8FDF           83C4                   04  add	sp,*4
30858                                           !BCC_EOS
30859                                           ! 4421   write_byte(0x40,0x40, 37);
30860                                           ! Debug: list int = const $25 (used reg = )
30861 8FE2           B8                   0025  mov	ax,*$25
30862 8FE5           50                         push	ax
30863                                           ! Debug: list int = const $40 (used reg = )
30864 8FE6           B8                   0040  mov	ax,*$40
30865 8FE9           50                         push	ax
30866                                           ! Debug: list int = const $40 (used reg = )
30867 8FEA           B8                   0040  mov	ax,*$40
30868 8FED           50                         push	ax
30869                                           ! Debug: func () void = write_byte+0 (used reg = )
30870 8FEE           E8         762D            call	_write_byte
30871 8FF1           83C4                   06  add	sp,*6
30872                                           !BCC_EOS
30873                                           ! 4422   do {
30874                       00008FF4            .65A:
30875                                           ! 4423     val8 = inb(0x3f4);
30876                                           ! Debug: list int = const $3F4 (used reg = )
30877 8FF4           B8                   03F4  mov	ax,#$3F4
30878 8FF7           50                         push	ax
30879                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30880 8FF8           E8         7547            call	_inb
30881 8FFB           44                         inc	sp
30882 8FFC           44                         inc	sp
30883                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30884 8FFD           8846         FF            mov	-1[bp],al
30885                                           !BCC_EOS
30886                                           ! 4424   } while ( (val8 & 0xc0) != 0x80 );
30887                       00009000            .659:
30888                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
30889 9000           8A46         FF            mov	al,-1[bp]
30890 9003           24                     C0  and	al,#$C0
30891                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30892 9005           3C                     80  cmp	al,#$80
30893 9007           75           EB            jne	.65A
30894                       00009009            .65B:
30895                                           !BCC_EOS
30896                                           ! 4425   if (prev_reset == 0) {
30897                       00009009            .658:
30898                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
30899 9009           8A46         FD            mov	al,-3[bp]
30900 900C           84C0                       test	al,al
30901 900E           75           38            jne 	.65C
30902                       00009010            .65D:
30903                                           ! 4426 #asm
30904                                           !BCC_EOS
30905                                           !BCC_ASM
30906                       00000002            _floppy_prepare_controller.dor	set	2
30907                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30908                       00000001            _floppy_prepare_controller.prev_reset	set	1
30909                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30910                       00000003            _floppy_prepare_controller.val8	set	3
30911                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30912                       00000008            _floppy_prepare_controller.drive	set	8
30913                       00000004            .floppy_prepare_controller.drive	set	4
30914 9010           FB                             sti
30915                                           ! 4428 endasm
30916                                           !BCC_ENDASM
30917                                           !BCC_EOS
30918                                           ! 4429     do {
30919                       00009011            .660:
30920                                           ! 4430       val8 = read_byte(0x0040, 0x003e);
30921                                           ! Debug: list int = const $3E (used reg = )
30922 9011           B8                   003E  mov	ax,*$3E
30923 9014           50                         push	ax
30924                                           ! Debug: list int = const $40 (used reg = )
30925 9015           B8                   0040  mov	ax,*$40
30926 9018           50                         push	ax
30927                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30928 9019           E8         75DC            call	_read_byte
30929 901C           83C4                   04  add	sp,*4
30930                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30931 901F           8846         FF            mov	-1[bp],al
30932                                           !BCC_EOS
30933                                           ! 4431     } while ( (val8 & 0x80) == 0 );
30934                       00009022            .65F:
30935                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
30936 9022           8A46         FF            mov	al,-1[bp]
30937 9025           24                     80  and	al,#$80
30938                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
30939 9027           84C0                       test	al,al
30940 9029           74           E6            je 	.660
30941                       0000902B            .661:
30942                                           !BCC_EOS
30943                                           ! 4432     val8 &= 0x7f;
30944                       0000902B            .65E:
30945                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30946 902B           8A46         FF            mov	al,-1[bp]
30947 902E           24                     7F  and	al,*$7F
30948 9030           8846         FF            mov	-1[bp],al
30949                                           !BCC_EOS
30950                                           ! 4433 #asm
30951                                           !BCC_EOS
30952                                           !BCC_ASM
30953                       00000002            _floppy_prepare_controller.dor	set	2
30954                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30955                       00000001            _floppy_prepare_controller.prev_reset	set	1
30956                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30957                       00000003            _floppy_prepare_controller.val8	set	3
30958                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30959                       00000008            _floppy_prepare_controller.drive	set	8
30960                       00000004            .floppy_prepare_controller.drive	set	4
30961 9033           FA                             cli
30962                                           ! 4435 endasm
30963                                           !BCC_ENDASM
30964                                           !BCC_EOS
30965                                           ! 4436     write_byte(0x0040, 0x003e, val8);
30966                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30967 9034           8A46         FF            mov	al,-1[bp]
30968 9037           30E4                       xor	ah,ah
30969 9039           50                         push	ax
30970                                           ! Debug: list int = const $3E (used reg = )
30971 903A           B8                   003E  mov	ax,*$3E
30972 903D           50                         push	ax
30973                                           ! Debug: list int = const $40 (used reg = )
30974 903E           B8                   0040  mov	ax,*$40
30975 9041           50                         push	ax
30976                                           ! Debug: func () void = write_byte+0 (used reg = )
30977 9042           E8         75D9            call	_write_byte
30978 9045           83C4                   06  add	sp,*6
30979                                           !BCC_EOS
30980                                           ! 4437   }
30981                                           ! 4438 }
30982                       00009048            .65C:
30983 9048           89EC                       mov	sp,bp
30984 904A           5D                         pop	bp
30985 904B           C3                         ret
30986                                           ! 4439   bx_bool
30987                                           ! 4440 floppy_media_known(drive)
30988                                           ! 4441   Bit16u drive;
30989                                           export	_floppy_media_known
30990                       0000904C            _floppy_media_known:
30991                                           !BCC_EOS
30992                                           ! 4442 {
30993                                           ! 4443   Bit8u val8;
30994                                           !BCC_EOS
30995                                           ! 4444   Bit16u media_state_offset;
30996                                           !BCC_EOS
30997                                           ! 4445   val8 = read_byte(0x0040, 0x003e);
30998 904C           55                         push	bp
30999 904D           89E5                       mov	bp,sp
31000 904F           83C4                   FC  add	sp,*-4
31001                                           ! Debug: list int = const $3E (used reg = )
31002 9052           B8                   003E  mov	ax,*$3E
31003 9055           50                         push	ax
31004                                           ! Debug: list int = const $40 (used reg = )
31005 9056           B8                   0040  mov	ax,*$40
31006 9059           50                         push	ax
31007                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31008 905A           E8         759B            call	_read_byte
31009 905D           83C4                   04  add	sp,*4
31010                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31011 9060           8846         FF            mov	-1[bp],al
31012                                           !BCC_EOS
31013                                           ! 4446   if (drive)
31014 9063           8B46         04            mov	ax,4[bp]
31015 9066           85C0                       test	ax,ax
31016 9068           74           0A            je  	.662
31017                       0000906A            .663:
31018                                           ! 4447     val8 >>= 1;
31019                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31020 906A           8A46         FF            mov	al,-1[bp]
31021 906D           30E4                       xor	ah,ah
31022 906F           D1E8                       shr	ax,*1
31023 9071           8846         FF            mov	-1[bp],al
31024                                           !BCC_EOS
31025                                           ! 4448   val8 &= 0x01;
31026                       00009074            .662:
31027                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31028 9074           8A46         FF            mov	al,-1[bp]
31029 9077           24                     01  and	al,*1
31030 9079           8846         FF            mov	-1[bp],al
31031                                           !BCC_EOS
31032                                           ! 4449   if (val8 == 0)
31033                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31034 907C           8A46         FF            mov	al,-1[bp]
31035 907F           84C0                       test	al,al
31036 9081           75           06            jne 	.664
31037                       00009083            .665:
31038                                           ! 4450     return(0);
31039 9083           31C0                       xor	ax,ax
31040 9085           89EC                       mov	sp,bp
31041 9087           5D                         pop	bp
31042 9088           C3                         ret
31043                                           !BCC_EOS
31044                                           ! 4451   media_state_offset = 0x0090;
31045                       00009089            .664:
31046                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
31047 9089           B8                   0090  mov	ax,#$90
31048 908C           8946         FC            mov	-4[bp],ax
31049                                           !BCC_EOS
31050                                           ! 4452   if (drive)
31051 908F           8B46         04            mov	ax,4[bp]
31052 9092           85C0                       test	ax,ax
31053 9094           74           07            je  	.666
31054                       00009096            .667:
31055                                           ! 4453     media_state_offset += 1;
31056                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
31057 9096           8B46         FC            mov	ax,-4[bp]
31058 9099           40                         inc	ax
31059 909A           8946         FC            mov	-4[bp],ax
31060                                           !BCC_EOS
31061                                           ! 4454   val8 = read_byte(0x0040, media_state_offset);
31062                       0000909D            .666:
31063                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
31064 909D           FF76         FC            push	-4[bp]
31065                                           ! Debug: list int = const $40 (used reg = )
31066 90A0           B8                   0040  mov	ax,*$40
31067 90A3           50                         push	ax
31068                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31069 90A4           E8         7551            call	_read_byte
31070 90A7           83C4                   04  add	sp,*4
31071                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31072 90AA           8846         FF            mov	-1[bp],al
31073                                           !BCC_EOS
31074                                           ! 4455   val8 = (val8 >> 4) & 0x01;
31075                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
31076 90AD           8A46         FF            mov	al,-1[bp]
31077 90B0           30E4                       xor	ah,ah
31078 90B2           B1                     04  mov	cl,*4
31079 90B4           D3E8                       shr	ax,cl
31080                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
31081 90B6           24                     01  and	al,*1
31082                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31083 90B8           8846         FF            mov	-1[bp],al
31084                                           !BCC_EOS
31085                                           ! 4456   if (val8 == 0)
31086                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31087 90BB           8A46         FF            mov	al,-1[bp]
31088 90BE           84C0                       test	al,al
31089 90C0           75           06            jne 	.668
31090                       000090C2            .669:
31091                                           ! 4457     return(0);
31092 90C2           31C0                       xor	ax,ax
31093 90C4           89EC                       mov	sp,bp
31094 90C6           5D                         pop	bp
31095 90C7           C3                         ret
31096                                           !BCC_EOS
31097                                           ! 4458   return(1);
31098                       000090C8            .668:
31099 90C8           B8                   0001  mov	ax,*1
31100 90CB           89EC                       mov	sp,bp
31101 90CD           5D                         pop	bp
31102 90CE           C3                         ret
31103                                           !BCC_EOS
31104                                           ! 4459 }
31105                                           ! 4460   bx_bool
31106                                           ! 4461 floppy_media_sense(drive)
31107                                           ! 4462   Bit16u drive;
31108                                           export	_floppy_media_sense
31109                       000090CF            _floppy_media_sense:
31110                                           !BCC_EOS
31111                                           ! 4463 {
31112                                           ! 4464   bx_bool retval;
31113                                           !BCC_EOS
31114                                           ! 4465   Bit16u media_state_offset;
31115                                           !BCC_EOS
31116                                           ! 4466   Bit8u drive
31117                                           ! 4466 _type, config_data, media_state;
31118                                           !BCC_EOS
31119                                           ! 4467   if (floppy_drive_recal(drive) == 0) {
31120 90CF           55                         push	bp
31121 90D0           89E5                       mov	bp,sp
31122 90D2           83C4                   F8  add	sp,*-8
31123                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
31124 90D5           FF76         04            push	4[bp]
31125                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
31126 90D8           E8         0153            call	_floppy_drive_recal
31127 90DB           44                         inc	sp
31128 90DC           44                         inc	sp
31129                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31130 90DD           85C0                       test	ax,ax
31131 90DF           75           06            jne 	.66A
31132                       000090E1            .66B:
31133                                           ! 4468     return(0);
31134 90E1           31C0                       xor	ax,ax
31135 90E3           89EC                       mov	sp,bp
31136 90E5           5D                         pop	bp
31137 90E6           C3                         ret
31138                                           !BCC_EOS
31139                                           ! 4469   }
31140                                           ! 4470   drive_type = inb_cmos(0x10);
31141                       000090E7            .66A:
31142                                           ! Debug: list int = const $10 (used reg = )
31143 90E7           B8                   0010  mov	ax,*$10
31144 90EA           50                         push	ax
31145                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31146 90EB           E8         7499            call	_inb_cmos
31147 90EE           44                         inc	sp
31148 90EF           44                         inc	sp
31149                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
31150 90F0           8846         FB            mov	-5[bp],al
31151                                           !BCC_EOS
31152                                           ! 4471   if (drive == 0)
31153                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
31154 90F3           8B46         04            mov	ax,4[bp]
31155 90F6           85C0                       test	ax,ax
31156 90F8           75           0E            jne 	.66C
31157                       000090FA            .66D:
31158                                           ! 4472     drive_type >>= 4;
31159                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
31160 90FA           8A46         FB            mov	al,-5[bp]
31161 90FD           30E4                       xor	ah,ah
31162 90FF           B1                     04  mov	cl,*4
31163 9101           D3E8                       shr	ax,cl
31164 9103           8846         FB            mov	-5[bp],al
31165                                           !BCC_EOS
31166                                           ! 4473   else
31167                                           ! 4474     drive_type &= 0x0f;
31168 9106           EB           08            jmp .66E
31169                       00009108            .66C:
31170                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
31171 9108           8A46         FB            mov	al,-5[bp]
31172 910B           24                     0F  and	al,*$F
31173 910D           8846         FB            mov	-5[bp],al
31174                                           !BCC_EOS
31175                                           ! 4475   if (drive_type == 1) {
31176                       00009110            .66E:
31177                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
31178 9110           8A46         FB            mov	al,-5[bp]
31179 9113           3C                     01  cmp	al,*1
31180 9115           75           13            jne 	.66F
31181                       00009117            .670:
31182                                           ! 4476     config_data = 0x00;
31183                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31184 9117           30C0                       xor	al,al
31185 9119           8846         FA            mov	-6[bp],al
31186                                           !BCC_EOS
31187                                           ! 4477     media_state = 0x25;
31188                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31189 911C           B0                     25  mov	al,*$25
31190 911E           8846         F9            mov	-7[bp],al
31191                                           !BCC_EOS
31192                                           ! 4478     retval = 1;
31193                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31194 9121           B8                   0001  mov	ax,*1
31195 9124           8946         FE            mov	-2[bp],ax
31196                                           !BCC_EOS
31197                                           ! 4479   }
31198                                           ! 4480   else if (drive_type == 2) {
31199 9127           E9         00C1            br 	.671
31200                       0000912A            .66F:
31201                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
31202 912A           8A46         FB            mov	al,-5[bp]
31203 912D           3C                     02  cmp	al,*2
31204 912F           75           13            jne 	.672
31205                       00009131            .673:
31206                                           ! 4481     config_data = 0x00;
31207                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31208 9131           30C0                       xor	al,al
31209 9133           8846         FA            mov	-6[bp],al
31210                                           !BCC_EOS
31211                                           ! 4482     media_state = 0x25;
31212                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31213 9136           B0                     25  mov	al,*$25
31214 9138           8846         F9            mov	-7[bp],al
31215                                           !BCC_EOS
31216                                           ! 4483     retval = 1;
31217                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31218 913B           B8                   0001  mov	ax,*1
31219 913E           8946         FE            mov	-2[bp],ax
31220                                           !BCC_EOS
31221                                           ! 4484   }
31222                                           ! 4485   else if (drive_type == 3) {
31223 9141           E9         00A7            br 	.674
31224                       00009144            .672:
31225                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
31226 9144           8A46         FB            mov	al,-5[bp]
31227 9147           3C                     03  cmp	al,*3
31228 9149           75           13            jne 	.675
31229                       0000914B            .676:
31230                                           ! 4486     config_data = 0x00;
31231                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31232 914B           30C0                       xor	al,al
31233 914D           8846         FA            mov	-6[bp],al
31234                                           !BCC_EOS
31235                                           ! 4487     media_state = 0x17;
31236                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31237 9150           B0                     17  mov	al,*$17
31238 9152           8846         F9            mov	-7[bp],al
31239                                           !BCC_EOS
31240                                           ! 4488     retval = 1;
31241                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31242 9155           B8                   0001  mov	ax,*1
31243 9158           8946         FE            mov	-2[bp],ax
31244                                           !BCC_EOS
31245                                           ! 4489   }
31246                                           ! 4490   else if (drive_type == 4) {
31247 915B           E9         008D            br 	.677
31248                       0000915E            .675:
31249                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
31250 915E           8A46         FB            mov	al,-5[bp]
31251 9161           3C                     04  cmp	al,*4
31252 9163           75           13            jne 	.678
31253                       00009165            .679:
31254                                           ! 4491     config_data = 0x00;
31255                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31256 9165           30C0                       xor	al,al
31257 9167           8846         FA            mov	-6[bp],al
31258                                           !BCC_EOS
31259                                           ! 4492     media_state = 0x17;
31260                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31261 916A           B0                     17  mov	al,*$17
31262 916C           8846         F9            mov	-7[bp],al
31263                                           !BCC_EOS
31264                                           ! 4493     retval = 1;
31265                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31266 916F           B8                   0001  mov	ax,*1
31267 9172           8946         FE            mov	-2[bp],ax
31268                                           !BCC_EOS
31269                                           ! 4494   }
31270                                           ! 4495   else if (drive_type == 5) {
31271 9175           E9         0073            br 	.67A
31272                       00009178            .678:
31273                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
31274 9178           8A46         FB            mov	al,-5[bp]
31275 917B           3C                     05  cmp	al,*5
31276 917D           75           12            jne 	.67B
31277                       0000917F            .67C:
31278                                           ! 4496     config_data = 0xCC;
31279                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
31280 917F           B0                     CC  mov	al,#$CC
31281 9181           8846         FA            mov	-6[bp],al
31282                                           !BCC_EOS
31283                                           ! 4497     media_state = 0xD7;
31284                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
31285 9184           B0                     D7  mov	al,#$D7
31286 9186           8846         F9            mov	-7[bp],al
31287                                           !BCC_EOS
31288                                           ! 4498     retval = 1;
31289                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31290 9189           B8                   0001  mov	ax,*1
31291 918C           8946         FE            mov	-2[bp],ax
31292                                           !BCC_EOS
31293                                           ! 4499   }
31294                                           ! 4500   else if (drive_type == 6) {
31295 918F           EB           5A            jmp .67D
31296                       00009191            .67B:
31297                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
31298 9191           8A46         FB            mov	al,-5[bp]
31299 9194           3C                     06  cmp	al,*6
31300 9196           75           12            jne 	.67E
31301                       00009198            .67F:
31302                                           ! 4501     config_data = 0x00;
31303                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31304 9198           30C0                       xor	al,al
31305 919A           8846         FA            mov	-6[bp],al
31306                                           !BCC_EOS
31307                                           ! 4502     media_state = 0x27;
31308                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31309 919D           B0                     27  mov	al,*$27
31310 919F           8846         F9            mov	-7[bp],al
31311                                           !BCC_EOS
31312                                           ! 4503     retval = 1;
31313                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31314 91A2           B8                   0001  mov	ax,*1
31315 91A5           8946         FE            mov	-2[bp],ax
31316                                           !BCC_EOS
31317                                           ! 4504   }
31318                                           ! 4505   else if (drive_type == 7) {
31319 91A8           EB           41            jmp .680
31320                       000091AA            .67E:
31321                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
31322 91AA           8A46         FB            mov	al,-5[bp]
31323 91AD           3C                     07  cmp	al,*7
31324 91AF           75           12            jne 	.681
31325                       000091B1            .682:
31326                                           ! 4506     config_data = 0x00;
31327                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31328 91B1           30C0                       xor	al,al
31329 91B3           8846         FA            mov	-6[bp],al
31330                                           !BCC_EOS
31331                                           ! 4507     media_state = 0x27;
31332                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31333 91B6           B0                     27  mov	al,*$27
31334 91B8           8846         F9            mov	-7[bp],al
31335                                           !BCC_EOS
31336                                           ! 4508     retval = 1;
31337                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31338 91BB           B8                   0001  mov	ax,*1
31339 91BE           8946         FE            mov	-2[bp],ax
31340                                           !BCC_EOS
31341                                           ! 4509   }
31342                                           ! 4510   else if (drive_type == 8) {
31343 91C1           EB           28            jmp .683
31344                       000091C3            .681:
31345                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
31346 91C3           8A46         FB            mov	al,-5[bp]
31347 91C6           3C                     08  cmp	al,*8
31348 91C8           75           12            jne 	.684
31349                       000091CA            .685:
31350                                           ! 4511     config_data = 0x00;
31351                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31352 91CA           30C0                       xor	al,al
31353 91CC           8846         FA            mov	-6[bp],al
31354                                           !BCC_EOS
31355                                           ! 4512     media_state = 0x27;
31356                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31357 91CF           B0                     27  mov	al,*$27
31358 91D1           8846         F9            mov	-7[bp],al
31359                                           !BCC_EOS
31360                                           ! 4513     retval = 1;
31361                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31362 91D4           B8                   0001  mov	ax,*1
31363 91D7           8946         FE            mov	-2[bp],ax
31364                                           !BCC_EOS
31365                                           ! 4514   }
31366                                           ! 4515   else {
31367 91DA           EB           0F            jmp .686
31368                       000091DC            .684:
31369                                           ! 4516     config_data = 0x00;
31370                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31371 91DC           30C0                       xor	al,al
31372 91DE           8846         FA            mov	-6[bp],al
31373                                           !BCC_EOS
31374                                           ! 4517     media_state = 0x00;
31375                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
31376 91E1           30C0                       xor	al,al
31377 91E3           8846         F9            mov	-7[bp],al
31378                                           !BCC_EOS
31379                                           ! 4518     retval = 0;
31380                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
31381 91E6           31C0                       xor	ax,ax
31382 91E8           8946         FE            mov	-2[bp],ax
31383                                           !BCC_EOS
31384                                           ! 4519   }
31385                                           ! 4520   if (drive == 0)
31386                       000091EB            .686:
31387                       000091EB            .683:
31388                       000091EB            .680:
31389                       000091EB            .67D:
31390                       000091EB            .67A:
31391                       000091EB            .677:
31392                       000091EB            .674:
31393                       000091EB            .671:
31394                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
31395 91EB           8B46         04            mov	ax,4[bp]
31396 91EE           85C0                       test	ax,ax
31397 91F0           75           08            jne 	.687
31398                       000091F2            .688:
31399                                           ! 4521     media_state_offset = 0x90;
31400                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31401 91F2           B8                   0090  mov	ax,#$90
31402 91F5           8946         FC            mov	-4[bp],ax
31403                                           !BCC_EOS
31404                                           ! 4522   else
31405                                           ! 4523     media_state_offset = 0x91;
31406 91F8           EB           06            jmp .689
31407                       000091FA            .687:
31408                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31409 91FA           B8                   0091  mov	ax,#$91
31410 91FD           8946         FC            mov	-4[bp],ax
31411                                           !BCC_EOS
31412                                           ! 4524   write_byte(0x0040, 0x008B, config_data);
31413                       00009200            .689:
31414                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
31415 9200           8A46         FA            mov	al,-6[bp]
31416 9203           30E4                       xor	ah,ah
31417 9205           50                         push	ax
31418                                           ! Debug: list int = const $8B (used reg = )
31419 9206           B8                   008B  mov	ax,#$8B
31420 9209           50                         push	ax
31421                                           ! Debug: list int = const $40 (used reg = )
31422 920A           B8                   0040  mov	ax,*$40
31423 920D           50                         push	ax
31424                                           ! Debug: func () void = write_byte+0 (used reg = )
31425 920E           E8         740D            call	_write_byte
31426 9211           83C4                   06  add	sp,*6
31427                                           !BCC_EOS
31428                                           ! 4525   write_byte(0x0040, media_state_offset, media_state);
31429                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
31430 9214           8A46         F9            mov	al,-7[bp]
31431 9217           30E4                       xor	ah,ah
31432 9219           50                         push	ax
31433                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
31434 921A           FF76         FC            push	-4[bp]
31435                                           ! Debug: list int = const $40 (used reg = )
31436 921D           B8                   0040  mov	ax,*$40
31437 9220           50                         push	ax
31438                                           ! Debug: func () void = write_byte+0 (used reg = )
31439 9221           E8         73FA            call	_write_byte
31440 9224           83C4                   06  add	sp,*6
31441                                           !BCC_EOS
31442                                           ! 4526   return(retval);
31443 9227           8B46         FE            mov	ax,-2[bp]
31444 922A           89EC                       mov	sp,bp
31445 922C           5D                         pop	bp
31446 922D           C3                         ret
31447                                           !BCC_EOS
31448                                           ! 4527 }
31449                                           ! 4528   bx_bool
31450                                           ! 4529 floppy_drive_recal(drive)
31451                                           ! 4530   Bit16u drive;
31452                                           export	_floppy_drive_recal
31453                       0000922E            _floppy_drive_recal:
31454                                           !BCC_EOS
31455                                           ! 4531 {
31456                                           ! 4532   Bit8u val8;
31457                                           !BCC_EOS
31458                                           ! 4533   Bit16u curr_cyl_offset;
31459                                           !BCC_EOS
31460                                           ! 4534   floppy_prepare_controller(drive);
31461 922E           55                         push	bp
31462 922F           89E5                       mov	bp,sp
31463 9231           83C4                   FC  add	sp,*-4
31464                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31465 9234           FF76         04            push	4[bp]
31466                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31467 9237           E8         FD33            call	_floppy_prepare_controller
31468 923A           44                         inc	sp
31469 923B           44                         inc	sp
31470                                           !BCC_EOS
31471                                           ! 4535   outb(0x03f5, 0x07);
31472                                           ! Debug: list int = const 7 (used reg = )
31473 923C           B8                   0007  mov	ax,*7
31474 923F           50                         push	ax
31475                                           ! Debug: list int = const $3F5 (used reg = )
31476 9240           B8                   03F5  mov	ax,#$3F5
31477 9243           50                         push	ax
31478                                           ! Debug: func () void = outb+0 (used reg = )
31479 9244           E8         7311            call	_outb
31480 9247           83C4                   04  add	sp,*4
31481                                           !BCC_EOS
31482                                           ! 4536   outb(0x03f5, drive);
31483                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31484 924A           FF76         04            push	4[bp]
31485                                           ! Debug: list int = const $3F5 (used reg = )
31486 924D           B8                   03F5  mov	ax,#$3F5
31487 9250           50                         push	ax
31488                                           ! Debug: func () void = outb+0 (used reg = )
31489 9251           E8         7304            call	_outb
31490 9254           83C4                   04  add	sp,*4
31491                                           !BCC_EOS
31492                                           ! 4537 #asm
31493                                           !BCC_EOS
31494                                           !BCC_ASM
31495                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31496                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31497                       00000003            _floppy_drive_recal.val8	set	3
31498                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31499                       00000008            _floppy_drive_recal.drive	set	8
31500                       00000004            .floppy_drive_recal.drive	set	4
31501 9257           FB                           sti
31502                                           ! 4539 endasm
31503                                           !BCC_ENDASM
31504                                           !BCC_EOS
31505                                           ! 4540   do {
31506                       00009258            .68C:
31507                                           ! 4541     val8 = (read_byte(0x0040, 0x003e) & 0x80);
31508                                           ! Debug: list int = const $3E (used reg = )
31509 9258           B8                   003E  mov	ax,*$3E
31510 925B           50                         push	ax
31511                                           ! Debug: list int = const $40 (used reg = )
31512 925C           B8                   0040  mov	ax,*$40
31513 925F           50                         push	ax
31514                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31515 9260           E8         7395            call	_read_byte
31516 9263           83C4                   04  add	sp,*4
31517                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31518 9266           24                     80  and	al,#$80
31519                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31520 9268           8846         FF            mov	-1[bp],al
31521                                           !BCC_EOS
31522                                           ! 4542   } while ( val8 == 0 );
31523                       0000926B            .68B:
31524                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31525 926B           8A46         FF            mov	al,-1[bp]
31526 926E           84C0                       test	al,al
31527 9270           74           E6            je 	.68C
31528                       00009272            .68D:
31529                                           !BCC_EOS
31530                                           ! 4543   val8 = 0;
31531                       00009272            .68A:
31532                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31533 9272           30C0                       xor	al,al
31534 9274           8846         FF            mov	-1[bp],al
31535                                           !BCC_EOS
31536                                           ! 4544 #asm
31537                                           !BCC_EOS
31538                                           !BCC_ASM
31539                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31540                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31541                       00000003            _floppy_drive_recal.val8	set	3
31542                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31543                       00000008            _floppy_drive_recal.drive	set	8
31544                       00000004            .floppy_drive_recal.drive	set	4
31545 9277           FA                           cli
31546                                           ! 4546 endasm
31547                                           !BCC_ENDASM
31548                                           !BCC_EOS
31549                                           ! 4547   val8 = read_byte(0x0040, 0x003e);
31550                                           ! Debug: list int = const $3E (used reg = )
31551 9278           B8                   003E  mov	ax,*$3E
31552 927B           50                         push	ax
31553                                           ! Debug: list int = const $40 (used reg = )
31554 927C           B8                   0040  mov	ax,*$40
31555 927F           50                         push	ax
31556                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31557 9280           E8         7375            call	_read_byte
31558 9283           83C4                   04  add	sp,*4
31559                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31560 9286           8846         FF            mov	-1[bp],al
31561                                           !BCC_EOS
31562                                           ! 4548   val8 &= 0x7f;
31563                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
31564 9289           8A46         FF            mov	al,-1[bp]
31565 928C           24                     7F  and	al,*$7F
31566 928E           8846         FF            mov	-1[bp],al
31567                                           !BCC_EOS
31568                                           ! 4549   if (drive) {
31569 9291           8B46         04            mov	ax,4[bp]
31570 9294           85C0                       test	ax,ax
31571 9296           74           10            je  	.68E
31572                       00009298            .68F:
31573                                           ! 4550     val8 |= 0x02;
31574                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
31575 9298           8A46         FF            mov	al,-1[bp]
31576 929B           0C                     02  or	al,*2
31577 929D           8846         FF            mov	-1[bp],al
31578                                           !BCC_EOS
31579                                           ! 4551     curr_cyl_offset = 0x0095;
31580                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31581 92A0           B8                   0095  mov	ax,#$95
31582 92A3           8946         FC            mov	-4[bp],ax
31583                                           !BCC_EOS
31584                                           ! 4552   } else {
31585 92A6           EB           0E            jmp .690
31586                       000092A8            .68E:
31587                                           ! 4553     val8 |= 0x01;
31588                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31589 92A8           8A46         FF            mov	al,-1[bp]
31590 92AB           0C                     01  or	al,*1
31591 92AD           8846         FF            mov	-1[bp],al
31592                                           !BCC_EOS
31593                                           ! 4554     curr_cyl_offset = 0x0094;
31594                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31595 92B0           B8                   0094  mov	ax,#$94
31596 92B3           8946         FC            mov	-4[bp],ax
31597                                           !BCC_EOS
31598                                           ! 4555   }
31599                                           ! 4556   write_byte(0x0040, 0x003e, val8);
31600                       000092B6            .690:
31601                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
31602 92B6           8A46         FF            mov	al,-1[bp]
31603 92B9           30E4                       xor	ah,ah
31604 92BB           50                         push	ax
31605                                           ! Debug: list int = const $3E (used reg = )
31606 92BC           B8                   003E  mov	ax,*$3E
31607 92BF           50                         push	ax
31608                                           ! Debug: list int = const $40 (used reg = )
31609 92C0           B8                   0040  mov	ax,*$40
31610 92C3           50                         push	ax
31611                                           ! Debug: func () void = write_byte+0 (used reg = )
31612 92C4           E8         7357            call	_write_byte
31613 92C7           83C4                   06  add	sp,*6
31614                                           !BCC_EOS
31615                                           ! 4557   write_byte(0x0040, curr_cyl_offset, 0);
31616                                           ! Debug: list int = const 0 (used reg = )
31617 92CA           31C0                       xor	ax,ax
31618 92CC           50                         push	ax
31619                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
31620 92CD           FF76         FC            push	-4[bp]
31621                                           ! Debug: list int = const $40 (used reg = )
31622 92D0           B8                   0040  mov	ax,*$40
31623 92D3           50                         push	ax
31624                                           ! Debug: func () void = write_byte+0 (used reg = )
31625 92D4           E8         7347            call	_write_byte
31626 92D7           83C4                   06  add	sp,*6
31627                                           !BCC_EOS
31628                                           ! 4558   return(1);
31629 92DA           B8                   0001  mov	ax,*1
31630 92DD           89EC                       mov	sp,bp
31631 92DF           5D                         pop	bp
31632 92E0           C3                         ret
31633                                           !BCC_EOS
31634                                           ! 4559 }
31635                                           ! 4560   bx_bool
31636                                           ! 4561 floppy_drive_exists(drive)
31637                                           ! 4562   Bit16u drive;
31638                                           export	_floppy_drive_exists
31639                       000092E1            _floppy_drive_exists:
31640                                           !BCC_EOS
31641                                           ! 4563 {
31642                                           ! 4564   Bit8u drive_type;
31643                                           !BCC_EOS
31644                                           ! 4565   drive_type = inb_cmos(0x10);
31645 92E1           55                         push	bp
31646 92E2           89E5                       mov	bp,sp
31647 92E4           4C                         dec	sp
31648 92E5           4C                         dec	sp
31649                                           ! Debug: list int = const $10 (used reg = )
31650 92E6           B8                   0010  mov	ax,*$10
31651 92E9           50                         push	ax
31652                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31653 92EA           E8         729A            call	_inb_cmos
31654 92ED           44                         inc	sp
31655 92EE           44                         inc	sp
31656                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
31657 92EF           8846         FF            mov	-1[bp],al
31658                                           !BCC_EOS
31659                                           ! 4566   if (drive == 0)
31660                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
31661 92F2           8B46         04            mov	ax,4[bp]
31662 92F5           85C0                       test	ax,ax
31663 92F7           75           0E            jne 	.691
31664                       000092F9            .692:
31665                                           ! 4567     drive_type >>= 4;
31666                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
31667 92F9           8A46         FF            mov	al,-1[bp]
31668 92FC           30E4                       xor	ah,ah
31669 92FE           B1                     04  mov	cl,*4
31670 9300           D3E8                       shr	ax,cl
31671 9302           8846         FF            mov	-1[bp],al
31672                                           !BCC_EOS
31673                                           ! 4568   else
31674                                           ! 4569     drive_type &= 0x0f;
31675 9305           EB           08            jmp .693
31676                       00009307            .691:
31677                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
31678 9307           8A46         FF            mov	al,-1[bp]
31679 930A           24                     0F  and	al,*$F
31680 930C           8846         FF            mov	-1[bp],al
31681                                           !BCC_EOS
31682                                           ! 4570   if ( drive_type == 0 )
31683                       0000930F            .693:
31684                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
31685 930F           8A46         FF            mov	al,-1[bp]
31686 9312           84C0                       test	al,al
31687 9314           75           08            jne 	.694
31688                       00009316            .695:
31689                                           ! 4571     return(0);
31690 9316           31C0                       xor	ax,ax
31691 9318           89EC                       mov	sp,bp
31692 931A           5D                         pop	bp
31693 931B           C3                         ret
31694                                           !BCC_EOS
31695                                           ! 4572  
31696                                           ! 4572  else
31697                                           ! 4573     return(1);
31698 931C           EB           07            jmp .696
31699                       0000931E            .694:
31700 931E           B8                   0001  mov	ax,*1
31701 9321           89EC                       mov	sp,bp
31702 9323           5D                         pop	bp
31703 9324           C3                         ret
31704                                           !BCC_EOS
31705                                           ! 4574 }
31706                       00009325            .696:
31707 9325           89EC                       mov	sp,bp
31708 9327           5D                         pop	bp
31709 9328           C3                         ret
31710                                           ! 4575   void
31711                                           ! 4576 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
31712                                           ! 4577   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
31713                                           export	_int13_diskette_function
31714                       00009329            _int13_diskette_function:
31715                                           !BCC_EOS
31716                                           ! 4578 {
31717                                           ! 4579   Bit8u drive, num_sectors, track, sector, head, status;
31718                                           !BCC_EOS
31719                                           ! 4580   Bit16u base_address, base_count, base_es;
31720                                           !BCC_EOS
31721                                           ! 4581   Bit8u page, mode_register, val8, dor;
31722                                           !BCC_EOS
31723                                           ! 4582   Bit8u return_status[7];
31724                                           !BCC_EOS
31725                                           ! 4583   Bit8u drive_type, num_floppies, ah;
31726                                           !BCC_EOS
31727                                           ! 4584   Bit16u es, last_addr;
31728                                           !BCC_EOS
31729                                           ! 4585   ;
31730 9329           55                         push	bp
31731 932A           89E5                       mov	bp,sp
31732 932C           83C4                   E2  add	sp,*-$1E
31733                                           !BCC_EOS
31734                                           ! 4586   ah = ( AX >> 8 );
31735                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
31736 932F           8B46         16            mov	ax,$16[bp]
31737 9332           88E0                       mov	al,ah
31738 9334           30E4                       xor	ah,ah
31739                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
31740 9336           8846         E6            mov	-$1A[bp],al
31741                                           !BCC_EOS
31742                                           ! 4587   switch ( ah ) {
31743 9339           8A46         E6            mov	al,-$1A[bp]
31744 933C           E9         10C3            br 	.699
31745                                           ! 4588     case 0x00:
31746                                           ! 4589 ;
31747                       0000933F            .69A:
31748                                           !BCC_EOS
31749                                           ! 4590       drive = ( ELDX & 0x00ff );
31750                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31751 933F           8A46         0E            mov	al,$E[bp]
31752                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31753 9342           8846         FF            mov	-1[bp],al
31754                                           !BCC_EOS
31755                                           ! 4591       if (drive > 1) {
31756                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31757 9345           8A46         FF            mov	al,-1[bp]
31758 9348           3C                     01  cmp	al,*1
31759 934A           76           20            jbe 	.69B
31760                       0000934C            .69C:
31761                                           ! 4592         AX = ((AX & 0x00ff) | ((1) << 8));
31762                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31763 934C           8A46         16            mov	al,$16[bp]
31764                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31765 934F           30E4                       xor	ah,ah
31766 9351           0D                   0100  or	ax,#$100
31767                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31768 9354           8946         16            mov	$16[bp],ax
31769                                           !BCC_EOS
31770                                           ! 4593         set_diskette_ret_status(1);
31771                                           ! Debug: list int = const 1 (used reg = )
31772 9357           B8                   0001  mov	ax,*1
31773 935A           50                         push	ax
31774                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31775 935B           E8         10E7            call	_set_diskette_ret_status
31776 935E           44                         inc	sp
31777 935F           44                         inc	sp
31778                                           !BCC_EOS
31779                                           ! 4594         FLAGS |= 0x0001;
31780                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31781 9360           8B46         1C            mov	ax,$1C[bp]
31782 9363           0C                     01  or	al,*1
31783 9365           8946         1C            mov	$1C[bp],ax
31784                                           !BCC_EOS
31785                                           ! 4595         return;
31786 9368           89EC                       mov	sp,bp
31787 936A           5D                         pop	bp
31788 936B           C3                         ret
31789                                           !BCC_EOS
31790                                           ! 4596       }
31791                                           ! 4597       drive_type = inb_cmos(0x10);
31792                       0000936C            .69B:
31793                                           ! Debug: list int = const $10 (used reg = )
31794 936C           B8                   0010  mov	ax,*$10
31795 936F           50                         push	ax
31796                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31797 9370           E8         7214            call	_inb_cmos
31798 9373           44                         inc	sp
31799 9374           44                         inc	sp
31800                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31801 9375           8846         E8            mov	-$18[bp],al
31802                                           !BCC_EOS
31803                                           ! 4598       if (drive == 0)
31804                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
31805 9378           8A46         FF            mov	al,-1[bp]
31806 937B           84C0                       test	al,al
31807 937D           75           0E            jne 	.69D
31808                       0000937F            .69E:
31809                                           ! 4599         drive_type >>= 4;
31810                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31811 937F           8A46         E8            mov	al,-$18[bp]
31812 9382           30E4                       xor	ah,ah
31813 9384           B1                     04  mov	cl,*4
31814 9386           D3E8                       shr	ax,cl
31815 9388           8846         E8            mov	-$18[bp],al
31816                                           !BCC_EOS
31817                                           ! 4600       else
31818                                           ! 4601         drive_type &= 0x0f;
31819 938B           EB           08            jmp .69F
31820                       0000938D            .69D:
31821                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
31822 938D           8A46         E8            mov	al,-$18[bp]
31823 9390           24                     0F  and	al,*$F
31824 9392           8846         E8            mov	-$18[bp],al
31825                                           !BCC_EOS
31826                                           ! 4602       if (drive_type == 0) {
31827                       00009395            .69F:
31828                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31829 9395           8A46         E8            mov	al,-$18[bp]
31830 9398           84C0                       test	al,al
31831 939A           75           20            jne 	.6A0
31832                       0000939C            .6A1:
31833                                           ! 4603         AX = ((AX & 0x00ff) | ((0x80) << 8));
31834                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31835 939C           8A46         16            mov	al,$16[bp]
31836                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31837 939F           30E4                       xor	ah,ah
31838 93A1           0D                   8000  or	ax,#-$8000
31839                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31840 93A4           8946         16            mov	$16[bp],ax
31841                                           !BCC_EOS
31842                                           ! 4604         set_diskette_ret_status(0x80);
31843                                           ! Debug: list int = const $80 (used reg = )
31844 93A7           B8                   0080  mov	ax,#$80
31845 93AA           50                         push	ax
31846                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31847 93AB           E8         1097            call	_set_diskette_ret_status
31848 93AE           44                         inc	sp
31849 93AF           44                         inc	sp
31850                                           !BCC_EOS
31851                                           ! 4605         FLAGS |= 0x0001;
31852                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31853 93B0           8B46         1C            mov	ax,$1C[bp]
31854 93B3           0C                     01  or	al,*1
31855 93B5           8946         1C            mov	$1C[bp],ax
31856                                           !BCC_EOS
31857                                           ! 4606         return;
31858 93B8           89EC                       mov	sp,bp
31859 93BA           5D                         pop	bp
31860 93BB           C3                         ret
31861                                           !BCC_EOS
31862                                           ! 4607       }
31863                                           ! 4608       AX = ((AX & 0x00ff) | ((0) << 8));
31864                       000093BC            .6A0:
31865                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31866 93BC           8A46         16            mov	al,$16[bp]
31867                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31868 93BF           0C                     00  or	al,*0
31869                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31870 93C1           30E4                       xor	ah,ah
31871 93C3           8946         16            mov	$16[bp],ax
31872                                           !BCC_EOS
31873                                           ! 4609       set_diskette_ret_status(0);
31874                                           ! Debug: list int = const 0 (used reg = )
31875 93C6           31C0                       xor	ax,ax
31876 93C8           50                         push	ax
31877                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31878 93C9           E8         1079            call	_set_diskette_ret_status
31879 93CC           44                         inc	sp
31880 93CD           44                         inc	sp
31881                                           !BCC_EOS
31882                                           ! 4610       FLAGS &= 0xfffe;
31883                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31884 93CE           8B46         1C            mov	ax,$1C[bp]
31885 93D1           24                     FE  and	al,#$FE
31886 93D3           8946         1C            mov	$1C[bp],ax
31887                                           !BCC_EOS
31888                                           ! 4611       set_diskette_current_cyl(drive, 0);
31889                                           ! Debug: list int = const 0 (used reg = )
31890 93D6           31C0                       xor	ax,ax
31891 93D8           50                         push	ax
31892                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31893 93D9           8A46         FF            mov	al,-1[bp]
31894 93DC           30E4                       xor	ah,ah
31895 93DE           50                         push	ax
31896                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31897 93DF           E8         107B            call	_set_diskette_current_cyl
31898 93E2           83C4                   04  add	sp,*4
31899                                           !BCC_EOS
31900                                           ! 4612       return;
31901 93E5           89EC                       mov	sp,bp
31902 93E7           5D                         pop	bp
31903 93E8           C3                         ret
31904                                           !BCC_EOS
31905                                           ! 4613     case 0x01:
31906                                           ! 4614       FLAGS &= 0xfffe;
31907                       000093E9            .6A2:
31908                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31909 93E9           8B46         1C            mov	ax,$1C[bp]
31910 93EC           24                     FE  and	al,#$FE
31911 93EE           8946         1C            mov	$1C[bp],ax
31912                                           !BCC_EOS
31913                                           ! 4615       val8 = read_byte(0x0000, 0x0441);
31914                                           ! Debug: list int = const $441 (used reg = )
31915 93F1           B8                   0441  mov	ax,#$441
31916 93F4           50                         push	ax
31917                                           ! Debug: list int = const 0 (used reg = )
31918 93F5           31C0                       xor	ax,ax
31919 93F7           50                         push	ax
31920                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31921 93F8           E8         71FD            call	_read_byte
31922 93FB           83C4                   04  add	sp,*4
31923                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31924 93FE           8846         F1            mov	-$F[bp],al
31925                                           !BCC_EOS
31926                                           ! 4616       AX = ((AX & 0x00ff) | ((val8) << 8));
31927                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
31928 9401           8A46         F1            mov	al,-$F[bp]
31929 9404           30E4                       xor	ah,ah
31930 9406           88C4                       mov	ah,al
31931 9408           30C0                       xor	al,al
31932 940A           50                         push	ax
31933                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
31934 940B           8A46         16            mov	al,$16[bp]
31935                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
31936 940E           30E4                       xor	ah,ah
31937 9410           0B46         E0            or	ax,0+..FFDC[bp]
31938 9413           44                         inc	sp
31939 9414           44                         inc	sp
31940                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31941 9415           8946         16            mov	$16[bp],ax
31942                                           !BCC_EOS
31943                                           ! 4617       if (val8) {
31944 9418           8A46         F1            mov	al,-$F[bp]
31945 941B           84C0                       test	al,al
31946 941D           74           08            je  	.6A3
31947                       0000941F            .6A4:
31948                                           ! 4618         FLAGS |= 0x0001;
31949                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31950 941F           8B46         1C            mov	ax,$1C[bp]
31951 9422           0C                     01  or	al,*1
31952 9424           8946         1C            mov	$1C[bp],ax
31953                                           !BCC_EOS
31954                                           ! 4619       }
31955                                           ! 4620       return;
31956                       00009427            .6A3:
31957 9427           89EC                       mov	sp,bp
31958 9429           5D                         pop	bp
31959 942A           C3                         ret
31960                                           !BCC_EOS
31961                                           ! 4621     case 0x02:
31962                                           ! 4622     case 0x03:
31963                       0000942B            .6A5:
31964                                           ! 4623     case 0x04:
31965                       0000942B            .6A6:
31966                                           ! 4624       num_sectors = ( AX & 0x00ff );
31967                       0000942B            .6A7:
31968                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31969 942B           8A46         16            mov	al,$16[bp]
31970                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31971 942E           8846         FE            mov	-2[bp],al
31972                                           !BCC_EOS
31973                                           ! 4625       track = ( CX >> 8 );
31974                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31975 9431           8B46         14            mov	ax,$14[bp]
31976 9434           88E0                       mov	al,ah
31977 9436           30E4                       xor	ah,ah
31978                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31979 9438           8846         FD            mov	-3[bp],al
31980                                           !BCC_EOS
31981                                           ! 4626       sector = ( CX & 0x00ff );
31982                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
31983 943B           8A46         14            mov	al,$14[bp]
31984                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
31985 943E           8846         FC            mov	-4[bp],al
31986                                           !BCC_EOS
31987                                           ! 4627       head = ( DX >> 8 );
31988                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
31989 9441           8B46         12            mov	ax,$12[bp]
31990 9444           88E0                       mov	al,ah
31991 9446           30E4                       xor	ah,ah
31992                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
31993 9448           8846         FB            mov	-5[bp],al
31994                                           !BCC_EOS
31995                                           ! 4628       drive = ( ELDX & 0x00ff );
31996                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31997 944B           8A46         0E            mov	al,$E[bp]
31998                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31999 944E           8846         FF            mov	-1[bp],al
32000                                           !BCC_EOS
32001                                           ! 4629       if ((drive > 1) || (head > 1) || (sector == 0) ||
32002                                           ! 4630           (num_sectors == 0) || (num_sectors > 72)) {
32003                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
32004 9451           8A46         FF            mov	al,-1[bp]
32005 9454           3C                     01  cmp	al,*1
32006 9456           77           1C            ja  	.6A9
32007                       00009458            .6AD:
32008                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
32009 9458           8A46         FB            mov	al,-5[bp]
32010 945B           3C                     01  cmp	al,*1
32011 945D           77           15            ja  	.6A9
32012                       0000945F            .6AC:
32013                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
32014 945F           8A46         FC            mov	al,-4[bp]
32015 9462           84C0                       test	al,al
32016 9464           74           0E            je  	.6A9
32017                       00009466            .6AB:
32018                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
32019 9466           8A46         FE            mov	al,-2[bp]
32020 9469           84C0                       test	al,al
32021 946B           74           07            je  	.6A9
32022                       0000946D            .6AA:
32023                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
32024 946D           8A46         FE            mov	al,-2[bp]
32025 9470           3C                     48  cmp	al,*$48
32026 9472           76           38            jbe 	.6A8
32027                       00009474            .6A9:
32028                                           ! 4631         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
32029                                           ! Debug: list * char = .6AE+0 (used reg = )
32030 9474           BB                   CE1D  mov	bx,#.6AE
32031 9477           53                         push	bx
32032                                           ! Debug: list int = const 4 (used reg = )
32033 9478           B8                   0004  mov	ax,*4
32034 947B           50                         push	ax
32035                                           ! Debug: func () void = bios_printf+0 (used reg = )
32036 947C           E8         7528            call	_bios_printf
32037 947F           83C4                   04  add	sp,*4
32038                                           !BCC_EOS
32039                                           ! 4632         AX = ((AX & 0x00ff) | ((1) << 8));
32040                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32041 9482           8A46         16            mov	al,$16[bp]
32042                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32043 9485           30E4                       xor	ah,ah
32044 9487           0D                   0100  or	ax,#$100
32045                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32046 948A           8946         16            mov	$16[bp],ax
32047                                           !BCC_EOS
32048                                           ! 4633         set_diskette_ret_status(1);
32049                                           ! Debug: list int = const 1 (used reg = )
32050 948D           B8                   0001  mov	ax,*1
32051 9490           50                         push	ax
32052                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32053 9491           E8         0FB1            call	_set_diskette_ret_status
32054 9494           44                         inc	sp
32055 9495           44                         inc	sp
32056                                           !BCC_EOS
32057                                           ! 4634         AX = ((AX & 0xff00) | (0));
32058                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32059 9496           8B46         16            mov	ax,$16[bp]
32060 9499           30C0                       xor	al,al
32061                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32062 949B           0C                     00  or	al,*0
32063                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32064 949D           8946         16            mov	$16[bp],ax
32065                                           !BCC_EOS
32066                                           ! 4635         FLAGS |= 0x0001;
32067                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32068 94A0           8B46         1C            mov	ax,$1C[bp]
32069 94A3           0C                     01  or	al,*1
32070 94A5           8946         1C            mov	$1C[bp],ax
32071                                           !BCC_EOS
32072                                           ! 4636         return;
32073 94A8           89EC                       mov	sp,bp
32074 94AA           5D                         pop	bp
32075 94AB           C3                         ret
32076                                           !BCC_EOS
32077                                           ! 4637       }
32078                                           ! 4638       if (floppy_drive_exists(drive) == 0) {
32079                       000094AC            .6A8:
32080                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32081 94AC           8A46         FF            mov	al,-1[bp]
32082 94AF           30E4                       xor	ah,ah
32083 94B1           50                         push	ax
32084                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
32085 94B2           E8         FE2C            call	_floppy_drive_exists
32086 94B5           44                         inc	sp
32087 94B6           44                         inc	sp
32088                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32089 94B7           85C0                       test	ax,ax
32090 94B9           75           2A            jne 	.6AF
32091                       000094BB            .6B0:
32092                                           ! 4639         AX = ((AX & 0x00ff) | ((0x80) << 8));
32093                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32094 94BB           8A46         16            mov	al,$16[bp]
32095                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32096 94BE           30E4                       xor	ah,ah
32097 94C0           0D                   8000  or	ax,#-$8000
32098                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32099 94C3           8946         16            mov	$16[bp],ax
32100                                           !BCC_EOS
32101                                           ! 4640         set_diskette_ret_status(0x80);
32102                                           ! Debug: list int = const $80 (used reg = )
32103 94C6           B8                   0080  mov	ax,#$80
32104 94C9           50                         push	ax
32105                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32106 94CA           E8         0F78            call	_set_diskette_ret_status
32107 94CD           44                         inc	sp
32108 94CE           44                         inc	sp
32109                                           !BCC_EOS
32110                                           ! 4641         AX = ((AX & 0xff00) | (0));
32111                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32112 94CF           8B46         16            mov	ax,$16[bp]
32113 94D2           30C0                       xor	al,al
32114                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32115 94D4           0C                     00  or	al,*0
32116                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32117 94D6           8946         16            mov	$16[bp],ax
32118                                           !BCC_EOS
32119                                           ! 4642         FLAGS |= 0x0001;
32120                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32121 94D9           8B46         1C            mov	ax,$1C[bp]
32122 94DC           0C                     01  or	al,*1
32123 94DE           8946         1C            mov	$1C[bp],ax
32124                                           !BCC_EOS
32125                                           ! 4643         return;
32126 94E1           89EC                       mov	sp,bp
32127 94E3           5D                         pop	bp
32128 94E4           C3                         ret
32129                                           !BCC_EOS
32130                                           ! 4644    
32131                                           ! 4644    }
32132                                           ! 4645       if (floppy_media_known(drive) == 0) {
32133                       000094E5            .6AF:
32134                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32135 94E5           8A46         FF            mov	al,-1[bp]
32136 94E8           30E4                       xor	ah,ah
32137 94EA           50                         push	ax
32138                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
32139 94EB           E8         FB5E            call	_floppy_media_known
32140 94EE           44                         inc	sp
32141 94EF           44                         inc	sp
32142                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32143 94F0           85C0                       test	ax,ax
32144 94F2           75           39            jne 	.6B1
32145                       000094F4            .6B2:
32146                                           ! 4646         if (floppy_media_sense(drive) == 0) {
32147                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32148 94F4           8A46         FF            mov	al,-1[bp]
32149 94F7           30E4                       xor	ah,ah
32150 94F9           50                         push	ax
32151                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
32152 94FA           E8         FBD2            call	_floppy_media_sense
32153 94FD           44                         inc	sp
32154 94FE           44                         inc	sp
32155                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
32156 94FF           85C0                       test	ax,ax
32157 9501           75           2A            jne 	.6B3
32158                       00009503            .6B4:
32159                                           ! 4647           AX = ((AX & 0x00ff) | ((0x0C) << 8));
32160                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32161 9503           8A46         16            mov	al,$16[bp]
32162                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
32163 9506           30E4                       xor	ah,ah
32164 9508           0D                   0C00  or	ax,#$C00
32165                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32166 950B           8946         16            mov	$16[bp],ax
32167                                           !BCC_EOS
32168                                           ! 4648           set_diskette_ret_status(0x0C);
32169                                           ! Debug: list int = const $C (used reg = )
32170 950E           B8                   000C  mov	ax,*$C
32171 9511           50                         push	ax
32172                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32173 9512           E8         0F30            call	_set_diskette_ret_status
32174 9515           44                         inc	sp
32175 9516           44                         inc	sp
32176                                           !BCC_EOS
32177                                           ! 4649           AX = ((AX & 0xff00) | (0));
32178                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32179 9517           8B46         16            mov	ax,$16[bp]
32180 951A           30C0                       xor	al,al
32181                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32182 951C           0C                     00  or	al,*0
32183                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32184 951E           8946         16            mov	$16[bp],ax
32185                                           !BCC_EOS
32186                                           ! 4650           FLAGS |= 0x0001;
32187                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32188 9521           8B46         1C            mov	ax,$1C[bp]
32189 9524           0C                     01  or	al,*1
32190 9526           8946         1C            mov	$1C[bp],ax
32191                                           !BCC_EOS
32192                                           ! 4651           return;
32193 9529           89EC                       mov	sp,bp
32194 952B           5D                         pop	bp
32195 952C           C3                         ret
32196                                           !BCC_EOS
32197                                           ! 4652         }
32198                                           ! 4653       }
32199                       0000952D            .6B3:
32200                                           ! 4654       if (ah == 0x02) {
32201                       0000952D            .6B1:
32202                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
32203 952D           8A46         E6            mov	al,-$1A[bp]
32204 9530           3C                     02  cmp	al,*2
32205 9532         0F85         03B4            bne 	.6B5
32206                       00009536            .6B6:
32207                                           ! 4655         page = (ES >> 12);
32208                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32209 9536           8B46         06            mov	ax,6[bp]
32210 9539           88E0                       mov	al,ah
32211 953B           30E4                       xor	ah,ah
32212 953D           B1                     04  mov	cl,*4
32213 953F           D3E8                       shr	ax,cl
32214                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32215 9541           8846         F3            mov	-$D[bp],al
32216                                           !BCC_EOS
32217                                           ! 4656         base_es = (ES << 4);
32218                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32219 9544           8B46         06            mov	ax,6[bp]
32220 9547           B1                     04  mov	cl,*4
32221 9549           D3E0                       shl	ax,cl
32222                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32223 954B           8946         F4            mov	-$C[bp],ax
32224                                           !BCC_EOS
32225                                           ! 4657         base_address = base_es + BX;
32226                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32227 954E           8B46         F4            mov	ax,-$C[bp]
32228 9551           0346         10            add	ax,$10[bp]
32229                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32230 9554           8946         F8            mov	-8[bp],ax
32231                                           !BCC_EOS
32232                                           ! 4658         if ( base_address < base_es ) {
32233                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32234 9557           8B46         F8            mov	ax,-8[bp]
32235 955A           3B46         F4            cmp	ax,-$C[bp]
32236 955D           73           07            jae 	.6B7
32237                       0000955F            .6B8:
32238                                           ! 4659           page++;
32239                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32240 955F           8A46         F3            mov	al,-$D[bp]
32241 9562           40                         inc	ax
32242 9563           8846         F3            mov	-$D[bp],al
32243                                           !BCC_EOS
32244                                           ! 4660         }
32245                                           ! 4661         base_count = (num_sectors * 512) - 1;
32246                       00009566            .6B7:
32247                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32248 9566           8A46         FE            mov	al,-2[bp]
32249 9569           30E4                       xor	ah,ah
32250 956B           B9                   0200  mov	cx,#$200
32251 956E           F7E9                       imul	cx
32252                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32253                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32254 9570           48                         dec	ax
32255 9571           8946         F6            mov	-$A[bp],ax
32256                                           !BCC_EOS
32257                                           ! 4662         last_addr = base_address + base_count;
32258                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32259 9574           8B46         F8            mov	ax,-8[bp]
32260 9577           0346         F6            add	ax,-$A[bp]
32261                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32262 957A           8946         E2            mov	-$1E[bp],ax
32263                                           !BCC_EOS
32264                                           ! 4663         if (last_addr < base_address) {
32265                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32266 957D           8B46         E2            mov	ax,-$1E[bp]
32267 9580           3B46         F8            cmp	ax,-8[bp]
32268 9583           73           2A            jae 	.6B9
32269                       00009585            .6BA:
32270                                           ! 4664           AX = ((AX & 0x00ff) | ((0x09) << 8));
32271                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32272 9585           8A46         16            mov	al,$16[bp]
32273                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32274 9588           30E4                       xor	ah,ah
32275 958A           0D                   0900  or	ax,#$900
32276                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32277 958D           8946         16            mov	$16[bp],ax
32278                                           !BCC_EOS
32279                                           ! 4665           set_diskette_ret_status(0x09);
32280                                           ! Debug: list int = const 9 (used reg = )
32281 9590           B8                   0009  mov	ax,*9
32282 9593           50                         push	ax
32283                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32284 9594           E8         0EAE            call	_set_diskette_ret_status
32285 9597           44                         inc	sp
32286 9598           44                         inc	sp
32287                                           !BCC_EOS
32288                                           ! 4666           AX = ((AX & 0xff00) | (0));
32289                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32290 9599           8B46         16            mov	ax,$16[bp]
32291 959C           30C0                       xor	al,al
32292                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32293 959E           0C                     00  or	al,*0
32294                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32295 95A0           8946         16            mov	$16[bp],ax
32296                                           !BCC_EOS
32297                                           ! 4667           FLAGS |= 0x0001;
32298                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32299 95A3           8B46         1C            mov	ax,$1C[bp]
32300 95A6           0C                     01  or	al,*1
32301 95A8           8946         1C            mov	$1C[bp],ax
32302                                           !BCC_EOS
32303                                           ! 4668           return;
32304 95AB           89EC                       mov	sp,bp
32305 95AD           5D                         pop	bp
32306 95AE           C3                         ret
32307                                           !BCC_EOS
32308                                           ! 4669         }
32309                                           ! 4670         ;
32310                       000095AF            .6B9:
32311                                           !BCC_EOS
32312                                           ! 4671         outb(0x000a, 0x06);
32313                                           ! Debug: list int = const 6 (used reg = )
32314 95AF           B8                   0006  mov	ax,*6
32315 95B2           50                         push	ax
32316                                           ! Debug: list int = const $A (used reg = )
32317 95B3           B8                   000A  mov	ax,*$A
32318 95B6           50                         push	ax
32319                                           ! Debug: func () void = outb+0 (used reg = )
32320 95B7           E8         6F9E            call	_outb
32321 95BA           83C4                   04  add	sp,*4
32322                                           !BCC_EOS
32323                                           ! 4672   ;
32324                                           !BCC_EOS
32325                                           ! 4673         outb(0x000c, 0x00);
32326                                           ! Debug: list int = const 0 (used reg = )
32327 95BD           31C0                       xor	ax,ax
32328 95BF           50                         push	ax
32329                                           ! Debug: list int = const $C (used reg = )
32330 95C0           B8                   000C  mov	ax,*$C
32331 95C3           50                         push	ax
32332                                           ! Debug: func () void = outb+0 (used reg = )
32333 95C4           E8         6F91            call	_outb
32334 95C7           83C4                   04  add	sp,*4
32335                                           !BCC_EOS
32336                                           ! 4674         outb(0x0004, base_address);
32337                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32338 95CA           FF76         F8            push	-8[bp]
32339                                           ! Debug: list int = const 4 (used reg = )
32340 95CD           B8                   0004  mov	ax,*4
32341 95D0           50                         push	ax
32342                                           ! Debug: func () void = outb+0 (used reg = )
32343 95D1           E8         6F84            call	_outb
32344 95D4           83C4                   04  add	sp,*4
32345                                           !BCC_EOS
32346                                           ! 4675         outb(0x0004, base_address>>8);
32347                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32348 95D7           8B46         F8            mov	ax,-8[bp]
32349 95DA           88E0                       mov	al,ah
32350 95DC           30E4                       xor	ah,ah
32351                                           ! Debug: list unsigned int = ax+0 (used reg = )
32352 95DE           50                         push	ax
32353                                           ! Debug: list int = const 4 (used reg = )
32354 95DF           B8                   0004  mov	ax,*4
32355 95E2           50                         push	ax
32356                                           ! Debug: func () void = outb+0 (used reg = )
32357 95E3           E8         6F72            call	_outb
32358 95E6           83C4                   04  add	sp,*4
32359                                           !BCC_EOS
32360                                           ! 4676   ;
32361                                           !BCC_EOS
32362                                           ! 4677         outb(0x000c, 0x00);
32363                                           ! Debug: list int = const 0 (used reg = )
32364 95E9           31C0                       xor	ax,ax
32365 95EB           50                         push	ax
32366                                           ! Debug: list int = const $C (used reg = )
32367 95EC           B8                   000C  mov	ax,*$C
32368 95EF           50                         push	ax
32369                                           ! Debug: func () void = outb+0 (used reg = )
32370 95F0           E8         6F65            call	_outb
32371 95F3           83C4                   04  add	sp,*4
32372                                           !BCC_EOS
32373                                           ! 4678         outb(0x0005, base_count);
32374                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32375 95F6           FF76         F6            push	-$A[bp]
32376                                           ! Debug: list int = const 5 (used reg = )
32377 95F9           B8                   0005  mov	ax,*5
32378 95FC           50                         push	ax
32379                                           ! Debug: func () void = outb+0 (used reg = )
32380 95FD           E8         6F58            call	_outb
32381 9600           83C4                   04  add	sp,*4
32382                                           !BCC_EOS
32383                                           ! 4679         outb(0x0005, base_count>>8);
32384                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32385 9603           8B46         F6            mov	ax,-$A[bp]
32386 9606           88E0                       mov	al,ah
32387 9608           30E4                       xor	ah,ah
32388                                           ! Debug: list unsigned int = ax+0 (used reg = )
32389 960A           50                         push	ax
32390                                           ! Debug: list int = const 5 (used reg = )
32391 960B           B8                   0005  mov	ax,*5
32392 960E           50                         push	ax
32393                                           ! Debug: func () void = outb+0 (used reg = )
32394 960F           E8         6F46            call	_outb
32395 9612           83C4                   04  add	sp,*4
32396                                           !BCC_EOS
32397                                           ! 4680         mode_register = 0x46;
32398                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
32399 9615           B0                     46  mov	al,*$46
32400 9617           8846         F2            mov	-$E[bp],al
32401                                           !BCC_EOS
32402                                           ! 4681   ;
32403                                           !BCC_EOS
32404                                           ! 4682         outb(0x000b, mode_register);
32405                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32406 961A           8A46         F2            mov	al,-$E[bp]
32407 961D           30E4                       xor	ah,ah
32408 961F           50                         push	ax
32409                                           ! Debug: list int = const $B (used reg = )
32410 9620           B8                   000B  mov	ax,*$B
32411 9623           50                         push	ax
32412                                           ! Debug: func () void = outb+0 (used reg = )
32413 9624           E8         6F31            call	_outb
32414 9627           83C4                   04  add	sp,*4
32415                                           !BCC_EOS
32416                                           ! 4683   ;
32417                                           !BCC_EOS
32418                                           ! 4684         outb(0x0081, page);
32419                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32420 962A           8A46         F3            mov	al,-$D[bp]
32421 962D           30E4                       xor	ah,ah
32422 962F           50                         push	ax
32423                                           ! Debug: list int = const $81 (used reg = )
32424 9630           B8                   0081  mov	ax,#$81
32425 9633           50                         push	ax
32426                                           ! Debug: func () void = outb+0 (used reg = )
32427 9634           E8         6F21            call	_outb
32428 9637           83C4                   04  add	sp,*4
32429                                           !BCC_EOS
32430                                           ! 4685   ;
32431                                           !BCC_EOS
32432                                           ! 4686         outb(0x000a, 0x02);
32433                                           ! Debug: list int = const 2 (used reg = )
32434 963A           B8                   0002  mov	ax,*2
32435 963D           50                         push	ax
32436                                           ! Debug: list int = const $A (used reg = )
32437 963E           B8                   000A  mov	ax,*$A
32438 9641           50                         push	ax
32439                                           ! Debug: func () void = outb+0 (used reg = )
32440 9642           E8         6F13            call	_outb
32441 9645           83C4                   04  add	sp,*4
32442                                           !BCC_EOS
32443                                           ! 4687         ;
32444                                           !BCC_EOS
32445                                           ! 4688         outb(0x000a, 0x02);
32446                                           ! Debug: list int = const 2 (used reg = )
32447 9648           B8                   0002  mov	ax,*2
32448 964B           50                         push	ax
32449                                           ! Debug: list int = const $A (used reg = )
32450 964C           B8                   000A  mov	ax,*$A
32451 964F           50                         push	ax
32452                                           ! Debug: func () void = outb+0 (used reg = )
32453 9650           E8         6F05            call	_outb
32454 9653           83C4                   04  add	sp,*4
32455                                           !BCC_EOS
32456                                           ! 4689         floppy_prepare_controller(drive);
32457                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32458 9656           8A46         FF            mov	al,-1[bp]
32459 9659           30E4                       xor	ah,ah
32460 965B           50                         push	ax
32461                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32462 965C           E8         F90E            call	_floppy_prepare_controller
32463 965F           44                         inc	sp
32464 9660           44                         inc	sp
32465                                           !BCC_EOS
32466                                           ! 4690         outb(0x03f5, 0xe6);
32467                                           ! Debug: list int = const $E6 (used reg = )
32468 9661           B8                   00E6  mov	ax,#$E6
32469 9664           50                         push	ax
32470                                           ! Debug: list int = const $3F5 (used reg = )
32471 9665           B8                   03F5  mov	ax,#$3F5
32472 9668           50                         push	ax
32473                                           ! Debug: func () void = outb+0 (used reg = )
32474 9669           E8         6EEC            call	_outb
32475 966C           83C4                   04  add	sp,*4
32476                                           !BCC_EOS
32477                                           ! 4691         outb(0x03f5, (head << 2) | drive);
32478                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32479 966F           8A46         FB            mov	al,-5[bp]
32480 9672           30E4                       xor	ah,ah
32481 9674           D1E0                       shl	ax,*1
32482 9676           D1E0                       shl	ax,*1
32483                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32484 9678           0A46         FF            or	al,-1[bp]
32485                                           ! Debug: list unsigned int = ax+0 (used reg = )
32486 967B           50                         push	ax
32487                                           ! Debug: list int = const $3F5 (used reg = )
32488 967C           B8                   03F5  mov	ax,#$3F5
32489 967F           50                         push	ax
32490                                           ! Debug: func () void = outb+0 (used reg = )
32491 9680           E8         6ED5            call	_outb
32492 9683           83C4                   04  add	sp,*4
32493                                           !BCC_EOS
32494                                           ! 4692         outb(0x03f5, track);
32495                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32496 9686           8A46         FD            mov	al,-3[bp]
32497 9689           30E4                       xor	ah,ah
32498 968B           50                         push	ax
32499                                           ! Debug: list int = const $3F5 (used reg = )
32500 968C           B8                   03F5  mov	ax,#$3F5
32501 968F           50                         push	ax
32502                                           ! Debug: func () void = outb+0 (used reg = )
32503 9690           E8         6EC5            call	_outb
32504 9693           83C4                   04  add	sp,*4
32505                                           !BCC_EOS
32506                                           ! 4693         outb(0x03f5, head);
32507                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32508 9696           8A46         FB            mov	al,-5[bp]
32509 9699           30E4                       xor	ah,ah
32510 969B           50                         push	ax
32511                                           ! Debug: list int = const $3F5 (used reg = )
32512 969C           B8                   03F5  mov	ax,#$3F5
32513 969F           50                         push	ax
32514                                           ! Debug: func () void = outb+0 (used reg = )
32515 96A0           E8         6EB5            call	_outb
32516 96A3           83C4                   04  add	sp,*4
32517                                           !BCC_EOS
32518                                           ! 4694         outb(0x03f5, sector);
32519                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32520 96A6           8A46         FC            mov	al,-4[bp]
32521 96A9           30E4                       xor	ah,ah
32522 96AB           50                         push	ax
32523                                           ! Debug: list int = const $3F5 (used reg = )
32524 96AC           B8                   03F5  mov	ax,#$3F5
32525 96AF           50                         push	ax
32526                                           ! Debug: func () void = outb+0 (used reg = )
32527 96B0           E8         6EA5            call	_outb
32528 96B3           83C4                   04  add	sp,*4
32529                                           !BCC_EOS
32530                                           ! 4695         outb(0x03f5, 2);
32531                                           ! Debug: list int = const 2 (used reg = )
32532 96B6           B8                   0002  mov	ax,*2
32533 96B9           50                         push	ax
32534                                           ! Debug: list int = const $3F5 (used reg = )
32535 96BA           B8                   03F5  mov	ax,#$3F5
32536 96BD           50                         push	ax
32537                                           ! Debug: func () void = outb+0 (used reg = )
32538 96BE           E8         6E97            call	_outb
32539 96C1           83C4                   04  add	sp,*4
32540                                           !BCC_EOS
32541                                           ! 4696         outb(0x03f5, sector + num_sectors - 1);
32542                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32543 96C4           8A46         FC            mov	al,-4[bp]
32544 96C7           30E4                       xor	ah,ah
32545 96C9           0246         FE            add	al,-2[bp]
32546 96CC           80D4                   00  adc	ah,*0
32547                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32548                                           ! Debug: list unsigned int = ax-1 (used reg = )
32549 96CF           48                         dec	ax
32550 96D0           50                         push	ax
32551                                           ! Debug: list int = const $3F5 (used reg = )
32552 96D1           B8                   03F5  mov	ax,#$3F5
32553 96D4           50                         push	ax
32554                                           ! Debug: func () void = outb+0 (used reg = )
32555 96D5           E8         6E80            call	_outb
32556 96D8           83C4                   04  add	sp,*4
32557                                           !BCC_EOS
32558                                           ! 4697         outb(0x03f5, 0);
32559                                           ! Debug: list int = const 0 (used reg = )
32560 96DB           31C0                       xor	ax,ax
32561 96DD           50                         push	ax
32562                                           ! Debug: list int = const $3F5 (used reg = )
32563 96DE           B8                   03F5  mov	ax,#$3F5
32564 96E1           50                         push	ax
32565                                           ! Debug: func () void = outb+0 (used reg = )
32566 96E2           E8         6E73            call	_outb
32567 96E5           83C4                   04  add	sp,*4
32568                                           !BCC_EOS
32569                                           ! 4698         outb(0x03f5, 0xff);
32570                                           ! Debug: list int = const $FF (used reg = )
32571 96E8           B8                   00FF  mov	ax,#$FF
32572 96EB           50                         push	ax
32573                                           ! Debug: list int = const $3F5 (used reg = )
32574 96EC           B8                   03F5  mov	ax,#$3F5
32575 96EF           50                         push	ax
32576                                           ! Debug: func () void = outb+0 (used reg = )
32577 96F0           E8         6E65            call	_outb
32578 96F3           83C4                   04  add	sp,*4
32579                                           !BCC_EOS
32580                                           ! 4699 #asm
32581                                           !BCC_EOS
32582                                           !BCC_ASM
32583                       0000002A            _int13_diskette_function.BP	set	$2A
32584                       0000000C            .int13_diskette_function.BP	set	$C
32585                       00000038            _int13_diskette_function.CS	set	$38
32586                       0000001A            .int13_diskette_function.CS	set	$1A
32587                       00000032            _int13_diskette_function.CX	set	$32
32588                       00000014            .int13_diskette_function.CX	set	$14
32589                       00000016            _int13_diskette_function.base_address	set	$16
32590                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32591                       00000026            _int13_diskette_function.DI	set	$26
32592                       00000008            .int13_diskette_function.DI	set	8
32593                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32594                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32595                       00000014            _int13_diskette_function.base_count	set	$14
32596                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32597                       0000001A            _int13_diskette_function.sector	set	$1A
32598                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32599                       00000022            _int13_diskette_function.DS	set	$22
32600                       00000004            .int13_diskette_function.DS	set	4
32601                       00000019            _int13_diskette_function.head	set	$19
32602                       FFFFFFFB            .int13_diskette_function.head	set	-5
32603                       0000002C            _int13_diskette_function.ELDX	set	$2C
32604                       0000000E            .int13_diskette_function.ELDX	set	$E
32605                       0000000E            _int13_diskette_function.dor	set	$E
32606                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32607                       00000030            _int13_diskette_function.DX	set	$30
32608                       00000012            .int13_diskette_function.DX	set	$12
32609                       00000007            _int13_diskette_function.return_status	set	7
32610                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32611                       00000002            _int13_diskette_function.es	set	2
32612                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32613                       00000010            _int13_diskette_function.mode_register	set	$10
32614                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32615                       00000024            _int13_diskette_function.ES	set	$24
32616                       00000006            .int13_diskette_function.ES	set	6
32617                       00000012            _int13_diskette_function.base_es	set	$12
32618                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32619                       0000001B            _int13_diskette_function.track	set	$1B
32620                       FFFFFFFD            .int13_diskette_function.track	set	-3
32621                       00000028            _int13_diskette_function.SI	set	$28
32622                       0000000A            .int13_diskette_function.SI	set	$A
32623                       00000006            _int13_diskette_function.drive_type	set	6
32624                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32625                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32626                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32627                       00000036            _int13_diskette_function.IP	set	$36
32628                       00000018            .int13_diskette_function.IP	set	$18
32629                       00000018            _int13_diskette_function.status	set	$18
32630                       FFFFFFFA            .int13_diskette_function.status	set	-6
32631                       00000034            _int13_diskette_function.AX	set	$34
32632                       00000016            .int13_diskette_function.AX	set	$16
32633                       0000000F            _int13_diskette_function.val8	set	$F
32634                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32635                       00000000            _int13_diskette_function.last_addr	set	0
32636                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32637                       00000011            _int13_diskette_function.page	set	$11
32638                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32639                       00000004            _int13_diskette_function.ah	set	4
32640                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32641                       0000001D            _int13_diskette_function.drive	set	$1D
32642                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32643                       00000005            _int13_diskette_function.num_floppies	set	5
32644                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32645                       0000002E            _int13_diskette_function.BX	set	$2E
32646                       00000010            .int13_diskette_function.BX	set	$10
32647 96F6           FB                                 sti
32648                                           ! 4701 endasm
32649                                           !BCC_ENDASM
32650                                           !BCC_EOS
32651                                           ! 4702         do {
32652                       000096F7            .6BD:
32653                                           ! 4703           val8 = read_byte(0x0040, 0x0040);
32654                                           ! Debug: list int = const $40 (used reg = )
32655 96F7           B8                   0040  mov	ax,*$40
32656 96FA           50                         push	ax
32657                                           ! Debug: list int = const $40 (used reg = )
32658 96FB           B8                   0040  mov	ax,*$40
32659 96FE           50                         push	ax
32660                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32661 96FF           E8         6EF6            call	_read_byte
32662 9702           83C4                   04  add	sp,*4
32663                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32664 9705           8846         F1            mov	-$F[bp],al
32665                                           !BCC_EOS
32666                                           ! 4704           if (val8 == 0) {
32667                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32668 9708           8A46         F1            mov	al,-$F[bp]
32669 970B           84C0                       test	al,al
32670 970D           75           2D            jne 	.6BE
32671                       0000970F            .6BF:
32672                                           ! 4705             floppy_reset_controller();
32673                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32674 970F           E8         F80D            call	_floppy_reset_controller
32675                                           !BCC_EOS
32676                                           ! 4706             AX = ((AX & 0x00ff) | ((0x80) << 8));
32677                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32678 9712           8A46         16            mov	al,$16[bp]
32679                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32680 9715           30E4                       xor	ah,ah
32681 9717           0D                   8000  or	ax,#-$8000
32682                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32683 971A           8946         16            mov	$16[bp],ax
32684                                           !BCC_EOS
32685                                           ! 4707             set_diskette_ret_status(0x80);
32686                                           ! Debug: list int = const $80 (used reg = )
32687 971D           B8                   0080  mov	ax,#$80
32688 9720           50                         push	ax
32689                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32690 9721           E8         0D21            call	_set_diskette_ret_status
32691 9724           44                         inc	sp
32692 9725           44                         inc	sp
32693                                           !BCC_EOS
32694                                           ! 4708             AX = ((AX & 0xff00) | (0));
32695                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32696 9726           8B46         16            mov	ax,$16[bp]
32697 9729           30C0                       xor	al,al
32698                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32699 972B           0C                     00  or	al,*0
32700                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32701 972D           8946         16            mov	$16[bp],ax
32702                                           !BCC_EOS
32703                                           ! 4709             FLAGS |= 0x0001;
32704                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32705 9730           8B46         1C            mov	ax,$1C[bp]
32706 9733           0C                     01  or	al,*1
32707 9735           8946         1C            mov	$1C[bp],ax
32708                                           !BCC_EOS
32709                                           ! 4710             return;
32710 9738           89EC                       mov	sp,bp
32711 973A           5D                         pop	bp
32712 973B           C3                         ret
32713                                           !BCC_EOS
32714                                           ! 4711           }
32715                                           ! 4712           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32716                       0000973C            .6BE:
32717                                           ! Debug: list int = const $3E (used reg = )
32718 973C           B8                   003E  mov	ax,*$3E
32719 973F           50                         push	ax
32720                                           ! Debug: list int = const $40 (used reg = )
32721 9740           B8                   0040  mov	ax,*$40
32722 9743           50                         push	ax
32723                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32724 9744           E8         6EB1            call	_read_byte
32725 9747           83C4                   04  add	sp,*4
32726                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32727 974A           24                     80  and	al,#$80
32728                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32729 974C           8846         F1            mov	-$F[bp],al
32730                                           !BCC_EOS
32731                                           ! 4713         } while ( val8 == 0 );
32732                       0000974F            .6BC:
32733                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32734 974F           8A46         F1            mov	al,-$F[bp]
32735 9752           84C0                       test	al,al
32736 9754           74           A1            je 	.6BD
32737                       00009756            .6C0:
32738                                           !BCC_EOS
32739                                           ! 4714         val8 = 0;
32740                       00009756            .6BB:
32741                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32742 9756           30C0                       xor	al,al
32743 9758           8846         F1            mov	-$F[bp],al
32744                                           !BCC_EOS
32745                                           ! 4715 #asm
32746                                           !BCC_EOS
32747                                           !BCC_ASM
32748                       0000002A            _int13_diskette_function.BP	set	$2A
32749                       0000000C            .int13_diskette_function.BP	set	$C
32750                       00000038            _int13_diskette_function.CS	set	$38
32751                       0000001A            .int13_diskette_function.CS	set	$1A
32752                       00000032            _int13_diskette_function.CX	set	$32
32753                       00000014            .int13_diskette_function.CX	set	$14
32754                       00000016            _int13_diskette_function.base_address	set	$16
32755                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32756                       00000026            _int13_diskette_function.DI	set	$26
32757                       00000008            .int13_diskette_function.DI	set	8
32758                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32759                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32760                       00000014            _int13_diskette_function.base_count	set	$14
32761                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32762                       0000001A            _int13_diskette_function.sector	set	$1A
32763                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32764                       00000022            _int13_diskette_function.DS	set	$22
32765                       00000004            .int13_diskette_function.DS	set	4
32766                       00000019            _int13_diskette_function.head	set	$19
32767                       FFFFFFFB            .int13_diskette_function.head	set	-5
32768                       0000002C            _int13_diskette_function.ELDX	set	$2C
32769                       0000000E            .int13_diskette_function.ELDX	set	$E
32770                       0000000E            _int13_diskette_function.dor	set	$E
32771                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32772                       00000030            _int13_diskette_function.DX	set	$30
32773                       00000012            .int13_diskette_function.DX	set	$12
32774                       00000007            _int13_diskette_function.return_status	set	7
32775                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32776                       00000002            _int13_diskette_function.es	set	2
32777                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32778                       00000010            _int13_diskette_function.mode_register	set	$10
32779                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32780                       00000024            _int13_diskette_function.ES	set	$24
32781                       00000006            .int13_diskette_function.ES	set	6
32782                       00000012            _int13_diskette_function.base_es	set	$12
32783                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32784                       0000001B            _int13_diskette_function.track	set	$1B
32785                       FFFFFFFD            .int13_diskette_function.track	set	-3
32786                       00000028            _int13_diskette_function.SI	set	$28
32787                       0000000A            .int13_diskette_function.SI	set	$A
32788                       00000006            _int13_diskette_function.drive_type	set	6
32789                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32790                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32791                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32792                       00000036            _int13_diskette_function.IP	set	$36
32793                       00000018            .int13_diskette_function.IP	set	$18
32794                       00000018            _int13_diskette_function.status	set	$18
32795                       FFFFFFFA            .int13_diskette_function.status	set	-6
32796                       00000034            _int13_diskette_function.AX	set	$34
32797                       00000016            .int13_diskette_function.AX	set	$16
32798                       0000000F            _int13_diskette_function.val8	set	$F
32799                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32800                       00000000            _int13_diskette_function.last_addr	set	0
32801                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32802                       00000011            _int13_diskette_function.page	set	$11
32803                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32804                       00000004            _int13_diskette_function.ah	set	4
32805                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32806                       0000001D            _int13_diskette_function.drive	set	$1D
32807                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32808                       00000005            _int13_diskette_function.num_floppies	set	5
32809                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32810                       0000002E            _int13_diskette_function.BX	set	$2E
32811                       00000010            .int13_diskette_function.BX	set	$10
32812 975B           FA                                 cli
32813                                           ! 4717 endasm
32814                                           !BCC_ENDASM
32815                                           !BCC_EOS
32816                                           ! 4718         val8 = read_byte(0x0040, 0x003e);
32817                                           ! Debug: list int = const $3E (used reg = )
32818 975C           B8                   003E  mov	ax,*$3E
32819 975F           50                         push	ax
32820                                           ! Debug: list int = const $40 (used reg = )
32821 9760           B8                   0040  mov	ax,*$40
32822 9763           50                         push	ax
32823                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32824 9764           E8         6E91            call	_read_byte
32825 9767           83C4                   04  add	sp,*4
32826                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32827 976A           8846         F1            mov	-$F[bp],al
32828                                           !BCC_EOS
32829                                           ! 4719      
32830                                           ! 4719    val8 &= 0x7f;
32831                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32832 976D           8A46         F1            mov	al,-$F[bp]
32833 9770           24                     7F  and	al,*$7F
32834 9772           8846         F1            mov	-$F[bp],al
32835                                           !BCC_EOS
32836                                           ! 4720         write_byte(0x0040, 0x003e, val8);
32837                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32838 9775           8A46         F1            mov	al,-$F[bp]
32839 9778           30E4                       xor	ah,ah
32840 977A           50                         push	ax
32841                                           ! Debug: list int = const $3E (used reg = )
32842 977B           B8                   003E  mov	ax,*$3E
32843 977E           50                         push	ax
32844                                           ! Debug: list int = const $40 (used reg = )
32845 977F           B8                   0040  mov	ax,*$40
32846 9782           50                         push	ax
32847                                           ! Debug: func () void = write_byte+0 (used reg = )
32848 9783           E8         6E98            call	_write_byte
32849 9786           83C4                   06  add	sp,*6
32850                                           !BCC_EOS
32851                                           ! 4721         val8 = inb(0x3f4);
32852                                           ! Debug: list int = const $3F4 (used reg = )
32853 9789           B8                   03F4  mov	ax,#$3F4
32854 978C           50                         push	ax
32855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32856 978D           E8         6DB2            call	_inb
32857 9790           44                         inc	sp
32858 9791           44                         inc	sp
32859                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32860 9792           8846         F1            mov	-$F[bp],al
32861                                           !BCC_EOS
32862                                           ! 4722         if ( (val8 & 0xc0) != 0xc0 )
32863                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32864 9795           8A46         F1            mov	al,-$F[bp]
32865 9798           24                     C0  and	al,#$C0
32866                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32867 979A           3C                     C0  cmp	al,#$C0
32868 979C           74           0E            je  	.6C1
32869                       0000979E            .6C2:
32870                                           ! 4723           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32871                                           ! Debug: list * char = .6C3+0 (used reg = )
32872 979E           BB                   CDFD  mov	bx,#.6C3
32873 97A1           53                         push	bx
32874                                           ! Debug: list int = const 7 (used reg = )
32875 97A2           B8                   0007  mov	ax,*7
32876 97A5           50                         push	ax
32877                                           ! Debug: func () void = bios_printf+0 (used reg = )
32878 97A6           E8         71FE            call	_bios_printf
32879 97A9           83C4                   04  add	sp,*4
32880                                           !BCC_EOS
32881                                           ! 4724         return_status[0] = inb(0x3f5);
32882                       000097AC            .6C1:
32883                                           ! Debug: list int = const $3F5 (used reg = )
32884 97AC           B8                   03F5  mov	ax,#$3F5
32885 97AF           50                         push	ax
32886                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32887 97B0           E8         6D8F            call	_inb
32888 97B3           44                         inc	sp
32889 97B4           44                         inc	sp
32890                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32891 97B5           8846         E9            mov	-$17[bp],al
32892                                           !BCC_EOS
32893                                           ! 4725         return_status[1] = inb(0x3f5);
32894                                           ! Debug: list int = const $3F5 (used reg = )
32895 97B8           B8                   03F5  mov	ax,#$3F5
32896 97BB           50                         push	ax
32897                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32898 97BC           E8         6D83            call	_inb
32899 97BF           44                         inc	sp
32900 97C0           44                         inc	sp
32901                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32902 97C1           8846         EA            mov	-$16[bp],al
32903                                           !BCC_EOS
32904                                           ! 4726         return_status[2] = inb(0x3f5);
32905                                           ! Debug: list int = const $3F5 (used reg = )
32906 97C4           B8                   03F5  mov	ax,#$3F5
32907 97C7           50                         push	ax
32908                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32909 97C8           E8         6D77            call	_inb
32910 97CB           44                         inc	sp
32911 97CC           44                         inc	sp
32912                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32913 97CD           8846         EB            mov	-$15[bp],al
32914                                           !BCC_EOS
32915                                           ! 4727         return_status[3] = inb(0x3f5);
32916                                           ! Debug: list int = const $3F5 (used reg = )
32917 97D0           B8                   03F5  mov	ax,#$3F5
32918 97D3           50                         push	ax
32919                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32920 97D4           E8         6D6B            call	_inb
32921 97D7           44                         inc	sp
32922 97D8           44                         inc	sp
32923                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32924 97D9           8846         EC            mov	-$14[bp],al
32925                                           !BCC_EOS
32926                                           ! 4728         return_status[4] = inb(0x3f5);
32927                                           ! Debug: list int = const $3F5 (used reg = )
32928 97DC           B8                   03F5  mov	ax,#$3F5
32929 97DF           50                         push	ax
32930                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32931 97E0           E8         6D5F            call	_inb
32932 97E3           44                         inc	sp
32933 97E4           44                         inc	sp
32934                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32935 97E5           8846         ED            mov	-$13[bp],al
32936                                           !BCC_EOS
32937                                           ! 4729         return_status[5] = inb(0x3f5);
32938                                           ! Debug: list int = const $3F5 (used reg = )
32939 97E8           B8                   03F5  mov	ax,#$3F5
32940 97EB           50                         push	ax
32941                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32942 97EC           E8         6D53            call	_inb
32943 97EF           44                         inc	sp
32944 97F0           44                         inc	sp
32945                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32946 97F1           8846         EE            mov	-$12[bp],al
32947                                           !BCC_EOS
32948                                           ! 4730         return_status[6] = inb(0x3f5);
32949                                           ! Debug: list int = const $3F5 (used reg = )
32950 97F4           B8                   03F5  mov	ax,#$3F5
32951 97F7           50                         push	ax
32952                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32953 97F8           E8         6D47            call	_inb
32954 97FB           44                         inc	sp
32955 97FC           44                         inc	sp
32956                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32957 97FD           8846         EF            mov	-$11[bp],al
32958                                           !BCC_EOS
32959                                           ! 4731         write_byte(0x0040, 0x0042, return_status[0]);
32960                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32961 9800           8A46         E9            mov	al,-$17[bp]
32962 9803           30E4                       xor	ah,ah
32963 9805           50                         push	ax
32964                                           ! Debug: list int = const $42 (used reg = )
32965 9806           B8                   0042  mov	ax,*$42
32966 9809           50                         push	ax
32967                                           ! Debug: list int = const $40 (used reg = )
32968 980A           B8                   0040  mov	ax,*$40
32969 980D           50                         push	ax
32970                                           ! Debug: func () void = write_byte+0 (used reg = )
32971 980E           E8         6E0D            call	_write_byte
32972 9811           83C4                   06  add	sp,*6
32973                                           !BCC_EOS
32974                                           ! 4732         write_byte(0x0040, 0x0043, return_status[1]);
32975                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32976 9814           8A46         EA            mov	al,-$16[bp]
32977 9817           30E4                       xor	ah,ah
32978 9819           50                         push	ax
32979                                           ! Debug: list int = const $43 (used reg = )
32980 981A           B8                   0043  mov	ax,*$43
32981 981D           50                         push	ax
32982                                           ! Debug: list int = const $40 (used reg = )
32983 981E           B8                   0040  mov	ax,*$40
32984 9821           50                         push	ax
32985                                           ! Debug: func () void = write_byte+0 (used reg = )
32986 9822           E8         6DF9            call	_write_byte
32987 9825           83C4                   06  add	sp,*6
32988                                           !BCC_EOS
32989                                           ! 4733         write_byte(0x0040, 0x0044, return_status[2]);
32990                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32991 9828           8A46         EB            mov	al,-$15[bp]
32992 982B           30E4                       xor	ah,ah
32993 982D           50                         push	ax
32994                                           ! Debug: list int = const $44 (used reg = )
32995 982E           B8                   0044  mov	ax,*$44
32996 9831           50                         push	ax
32997                                           ! Debug: list int = const $40 (used reg = )
32998 9832           B8                   0040  mov	ax,*$40
32999 9835           50                         push	ax
33000                                           ! Debug: func () void = write_byte+0 (used reg = )
33001 9836           E8         6DE5            call	_write_byte
33002 9839           83C4                   06  add	sp,*6
33003                                           !BCC_EOS
33004                                           ! 4734         write_byte(0x0040, 0x0045, return_status[3]);
33005                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33006 983C           8A46         EC            mov	al,-$14[bp]
33007 983F           30E4                       xor	ah,ah
33008 9841           50                         push	ax
33009                                           ! Debug: list int = const $45 (used reg = )
33010 9842           B8                   0045  mov	ax,*$45
33011 9845           50                         push	ax
33012                                           ! Debug: list int = const $40 (used reg = )
33013 9846           B8                   0040  mov	ax,*$40
33014 9849           50                         push	ax
33015                                           ! Debug: func () void = write_byte+0 (used reg = )
33016 984A           E8         6DD1            call	_write_byte
33017 984D           83C4                   06  add	sp,*6
33018                                           !BCC_EOS
33019                                           ! 4735         write_byte(0x0040, 0x0046, return_status[4]);
33020                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33021 9850           8A46         ED            mov	al,-$13[bp]
33022 9853           30E4                       xor	ah,ah
33023 9855           50                         push	ax
33024                                           ! Debug: list int = const $46 (used reg = )
33025 9856           B8                   0046  mov	ax,*$46
33026 9859           50                         push	ax
33027                                           ! Debug: list int = const $40 (used reg = )
33028 985A           B8                   0040  mov	ax,*$40
33029 985D           50                         push	ax
33030                                           ! Debug: func () void = write_byte+0 (used reg = )
33031 985E           E8         6DBD            call	_write_byte
33032 9861           83C4                   06  add	sp,*6
33033                                           !BCC_EOS
33034                                           ! 4736         write_byte(0x0040, 0x0047, return_status[5]);
33035                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33036 9864           8A46         EE            mov	al,-$12[bp]
33037 9867           30E4                       xor	ah,ah
33038 9869           50                         push	ax
33039                                           ! Debug: list int = const $47 (used reg = )
33040 986A           B8                   0047  mov	ax,*$47
33041 986D           50                         push	ax
33042                                           ! Debug: list int = const $40 (used reg = )
33043 986E           B8                   0040  mov	ax,*$40
33044 9871           50                         push	ax
33045                                           ! Debug: func () void = write_byte+0 (used reg = )
33046 9872           E8         6DA9            call	_write_byte
33047 9875           83C4                   06  add	sp,*6
33048                                           !BCC_EOS
33049                                           ! 4737         write_byte(0x0040, 0x0048, return_status[6]);
33050                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33051 9878           8A46         EF            mov	al,-$11[bp]
33052 987B           30E4                       xor	ah,ah
33053 987D           50                         push	ax
33054                                           ! Debug: list int = const $48 (used reg = )
33055 987E           B8                   0048  mov	ax,*$48
33056 9881           50                         push	ax
33057                                           ! Debug: list int = const $40 (used reg = )
33058 9882           B8                   0040  mov	ax,*$40
33059 9885           50                         push	ax
33060                                           ! Debug: func () void = write_byte+0 (used reg = )
33061 9886           E8         6D95            call	_write_byte
33062 9889           83C4                   06  add	sp,*6
33063                                           !BCC_EOS
33064                                           ! 4738         if ( (return_status[0] & 0xc0) != 0 ) {
33065                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33066 988C           8A46         E9            mov	al,-$17[bp]
33067 988F           24                     C0  and	al,#$C0
33068                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33069 9891           84C0                       test	al,al
33070 9893           74           2A            je  	.6C4
33071                       00009895            .6C5:
33072                                           ! 4739           AX = ((AX & 0x00ff) | ((0x20) << 8));
33073                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33074 9895           8A46         16            mov	al,$16[bp]
33075                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
33076 9898           30E4                       xor	ah,ah
33077 989A           0D                   2000  or	ax,#$2000
33078                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33079 989D           8946         16            mov	$16[bp],ax
33080                                           !BCC_EOS
33081                                           ! 4740           set_diskette_ret_status(0x20);
33082                                           ! Debug: list int = const $20 (used reg = )
33083 98A0           B8                   0020  mov	ax,*$20
33084 98A3           50                         push	ax
33085                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33086 98A4           E8         0B9E            call	_set_diskette_ret_status
33087 98A7           44                         inc	sp
33088 98A8           44                         inc	sp
33089                                           !BCC_EOS
33090                                           ! 4741           AX = ((AX & 0xff00) | (0));
33091                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33092 98A9           8B46         16            mov	ax,$16[bp]
33093 98AC           30C0                       xor	al,al
33094                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33095 98AE           0C                     00  or	al,*0
33096                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33097 98B0           8946         16            mov	$16[bp],ax
33098                                           !BCC_EOS
33099                                           ! 4742           FLAGS |= 0x0001;
33100                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33101 98B3           8B46         1C            mov	ax,$1C[bp]
33102 98B6           0C                     01  or	al,*1
33103 98B8           8946         1C            mov	$1C[bp],ax
33104                                           !BCC_EOS
33105                                           ! 4743           return;
33106 98BB           89EC                       mov	sp,bp
33107 98BD           5D                         pop	bp
33108 98BE           C3                         ret
33109                                           !BCC_EOS
33110                                           ! 4744         }
33111                                           ! 4745         set_diskette_current_cyl(drive, track);
33112                       000098BF            .6C4:
33113                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33114 98BF           8A46         FD            mov	al,-3[bp]
33115 98C2           30E4                       xor	ah,ah
33116 98C4           50                         push	ax
33117                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33118 98C5           8A46         FF            mov	al,-1[bp]
33119 98C8           30E4                       xor	ah,ah
33120 98CA           50                         push	ax
33121                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33122 98CB           E8         0B8F            call	_set_diskette_current_cyl
33123 98CE           83C4                   04  add	sp,*4
33124                                           !BCC_EOS
33125                                           ! 4746         AX = ((AX & 0x00ff) | ((0x00) << 8));
33126                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33127 98D1           8A46         16            mov	al,$16[bp]
33128                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33129 98D4           0C                     00  or	al,*0
33130                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33131 98D6           30E4                       xor	ah,ah
33132 98D8           8946         16            mov	$16[bp],ax
33133                                           !BCC_EOS
33134                                           ! 4747         FLAGS &= 0xfffe;
33135                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33136 98DB           8B46         1C            mov	ax,$1C[bp]
33137 98DE           24                     FE  and	al,#$FE
33138 98E0           8946         1C            mov	$1C[bp],ax
33139                                           !BCC_EOS
33140                                           ! 4748         return;
33141 98E3           89EC                       mov	sp,bp
33142 98E5           5D                         pop	bp
33143 98E6           C3                         ret
33144                                           !BCC_EOS
33145                                           ! 4749       } else if (ah == 0x03) {
33146 98E7           E9         03D7            br 	.6C6
33147                       000098EA            .6B5:
33148                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
33149 98EA           8A46         E6            mov	al,-$1A[bp]
33150 98ED           3C                     03  cmp	al,*3
33151 98EF         0F85         03A6            bne 	.6C7
33152                       000098F3            .6C8:
33153                                           ! 4750         page = (ES >> 12);
33154                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
33155 98F3           8B46         06            mov	ax,6[bp]
33156 98F6           88E0                       mov	al,ah
33157 98F8           30E4                       xor	ah,ah
33158 98FA           B1                     04  mov	cl,*4
33159 98FC           D3E8                       shr	ax,cl
33160                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
33161 98FE           8846         F3            mov	-$D[bp],al
33162                                           !BCC_EOS
33163                                           ! 4751         base_es = (ES << 4);
33164                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
33165 9901           8B46         06            mov	ax,6[bp]
33166 9904           B1                     04  mov	cl,*4
33167 9906           D3E0                       shl	ax,cl
33168                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
33169 9908           8946         F4            mov	-$C[bp],ax
33170                                           !BCC_EOS
33171                                           ! 4752         base_address = base_es + BX;
33172                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
33173 990B           8B46         F4            mov	ax,-$C[bp]
33174 990E           0346         10            add	ax,$10[bp]
33175                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33176 9911           8946         F8            mov	-8[bp],ax
33177                                           !BCC_EOS
33178                                           ! 4753         if ( base_address < base_es ) {
33179                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33180 9914           8B46         F8            mov	ax,-8[bp]
33181 9917           3B46         F4            cmp	ax,-$C[bp]
33182 991A           73           07            jae 	.6C9
33183                       0000991C            .6CA:
33184                                           ! 4754           page++;
33185                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33186 991C           8A46         F3            mov	al,-$D[bp]
33187 991F           40                         inc	ax
33188 9920           8846         F3            mov	-$D[bp],al
33189                                           !BCC_EOS
33190                                           ! 4755         }
33191                                           ! 4756         base_count = (num_sectors * 512) - 1;
33192                       00009923            .6C9:
33193                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
33194 9923           8A46         FE            mov	al,-2[bp]
33195 9926           30E4                       xor	ah,ah
33196 9928           B9                   0200  mov	cx,#$200
33197 992B           F7E9                       imul	cx
33198                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33199                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33200 992D           48                         dec	ax
33201 992E           8946         F6            mov	-$A[bp],ax
33202                                           !BCC_EOS
33203                                           ! 4757         last_addr = base_address + base_count;
33204                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33205 9931           8B46         F8            mov	ax,-8[bp]
33206 9934           0346         F6            add	ax,-$A[bp]
33207                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33208 9937           8946         E2            mov	-$1E[bp],ax
33209                                           !BCC_EOS
33210                                           ! 4758         if (last_addr < base_address) {
33211                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33212 993A           8B46         E2            mov	ax,-$1E[bp]
33213 993D           3B46         F8            cmp	ax,-8[bp]
33214 9940           73           2A            jae 	.6CB
33215                       00009942            .6CC:
33216                                           ! 4759           AX = ((AX & 0x00ff) | ((0x09) << 8));
33217                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33218 9942           8A46         16            mov	al,$16[bp]
33219                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33220 9945           30E4                       xor	ah,ah
33221 9947           0D                   0900  or	ax,#$900
33222                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33223 994A           8946         16            mov	$16[bp],ax
33224                                           !BCC_EOS
33225                                           ! 4760           set_diskette_ret_status(0x09);
33226                                           ! Debug: list int = const 9 (used reg = )
33227 994D           B8                   0009  mov	ax,*9
33228 9950           50                         push	ax
33229                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33230 9951           E8         0AF1            call	_set_diskette_ret_status
33231 9954           44                         inc	sp
33232 9955           44                         inc	sp
33233                                           !BCC_EOS
33234                                           ! 4761           AX = ((AX & 0xff00) | (0));
33235                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33236 9956           8B46         16            mov	ax,$16[bp]
33237 9959           30C0                       xor	al,al
33238                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33239 995B           0C                     00  or	al,*0
33240                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33241 995D           8946         16            mov	$16[bp],ax
33242                                           !BCC_EOS
33243                                           ! 4762           FLAGS |= 0x0001;
33244                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33245 9960           8B46         1C            mov	ax,$1C[bp]
33246 9963           0C                     01  or	al,*1
33247 9965           8946         1C            mov	$1C[bp],ax
33248                                           !BCC_EOS
33249                                           ! 4763           return;
33250 9968           89EC                       mov	sp,bp
33251 996A           5D                         pop	bp
33252 996B           C3                         ret
33253                                           !BCC_EOS
33254                                           ! 4764         }
33255                                           ! 4765         ;
33256                       0000996C            .6CB:
33257                                           !BCC_EOS
33258                                           ! 4766         outb(0x000a, 0x06);
33259                                           ! Debug: list int = const 6 (used reg = )
33260 996C           B8                   0006  mov	ax,*6
33261 996F           50                         push	ax
33262                                           ! Debug: list int = const $A (used reg = )
33263 9970           B8                   000A  mov	ax,*$A
33264 9973           50                         push	ax
33265                                           ! Debug: func () void = outb+0 (used reg = )
33266 9974           E8         6BE1            call	_outb
33267 9977           83C4                   04  add	sp,*4
33268                                           !BCC_EOS
33269                                           ! 4767         outb(0x000c, 0x00);
33270                                           ! Debug: list int = const 0 (used reg = )
33271 997A           31C0                       xor	ax,ax
33272 997C           50                         push	ax
33273                                           ! Debug: list int = const $C (used reg = )
33274 997D           B8                   000C  mov	ax,*$C
33275 9980           50                         push	ax
33276                                           ! Debug: func () void = outb+0 (used reg = )
33277 9981           E8         6BD4            call	_outb
33278 9984           83C4                   04  add	sp,*4
33279                                           !BCC_EOS
33280                                           ! 4768         outb(0x0004, base_address);
33281                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33282 9987           FF76         F8            push	-8[bp]
33283                                           ! Debug: list int = const 4 (used reg = )
33284 998A           B8                   0004  mov	ax,*4
33285 998D           50                         push	ax
33286                                           ! Debug: func () void = outb+0 (used reg = )
33287 998E           E8         6BC7            call	_outb
33288 9991           83C4                   04  add	sp,*4
33289                                           !BCC_EOS
33290                                           ! 4769         outb(0x0004, base_address>>8);
33291                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33292 9994           8B46         F8            mov	ax,-8[bp]
33293 9997           88E0                       mov	al,ah
33294 9999           30E4                       xor	ah,ah
33295                                           ! Debug: list unsigned int = ax+0 (used reg = )
33296 999B           50                         push	ax
33297                                           ! Debug: list int = const 4 (used reg = )
33298 999C           B8                   0004  mov	ax,*4
33299 999F           50                         push	ax
33300                                           ! Debug: func () void = outb+0 (used reg = )
33301 99A0           E8         6BB5            call	_outb
33302 99A3           83C4                   04  add	sp,*4
33303                                           !BCC_EOS
33304                                           ! 4770         outb(0x000c, 0x00);
33305                                           ! Debug: list int = const 0 (used reg = )
33306 99A6           31C0                       xor	ax,ax
33307 99A8           50                         push	ax
33308                                           ! Debug: list int = const $C (used reg = )
33309 99A9           B8                   000C  mov	ax,*$C
33310 99AC           50                         push	ax
33311                                           ! Debug: func () void = outb+0 (used reg = )
33312 99AD           E8         6BA8            call	_outb
33313 99B0           83C4                   04  add	sp,*4
33314                                           !BCC_EOS
33315                                           ! 4771         outb(0x0005, base_count);
33316                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33317 99B3           FF76         F6            push	-$A[bp]
33318                                           ! Debug: list int = const 5 (used reg = )
33319 99B6           B8                   0005  mov	ax,*5
33320 99B9           50                         push	ax
33321                                           ! Debug: func () void = outb+0 (used reg = )
33322 99BA           E8         6B9B            call	_outb
33323 99BD           83C4                   04  add	sp,*4
33324                                           !BCC_EOS
33325                                           ! 4772         outb(0x0005, base_count>>8);
33326                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33327 99C0           8B46         F6            mov	ax,-$A[bp]
33328 99C3           88E0                       mov	al,ah
33329 99C5           30E4                       xor	ah,ah
33330                                           ! Debug: list unsigned int = ax+0 (used reg = )
33331 99C7           50                         push	ax
33332                                           ! Debug: list int = const 5 (used reg = )
33333 99C8           B8                   0005  mov	ax,*5
33334 99CB           50                         push	ax
33335                                           ! Debug: func () void = outb+0 (used reg = )
33336 99CC           E8         6B89            call	_outb
33337 99CF           83C4                   04  add	sp,*4
33338                                           !BCC_EOS
33339                                           ! 4773         mode_register = 0x4a;
33340                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33341 99D2           B0                     4A  mov	al,*$4A
33342 99D4           8846         F2            mov	-$E[bp],al
33343                                           !BCC_EOS
33344                                           ! 4774         outb(0x000b, mode_register);
33345                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33346 99D7           8A46         F2            mov	al,-$E[bp]
33347 99DA           30E4                       xor	ah,ah
33348 99DC           50                         push	ax
33349                                           ! Debug: list int = const $B (used reg = )
33350 99DD           B8                   000B  mov	ax,*$B
33351 99E0           50                         push	ax
33352                                           ! Debug: func () void = outb+0 (used reg = )
33353 99E1           E8         6B74            call	_outb
33354 99E4           83C4                   04  add	sp,*4
33355                                           !BCC_EOS
33356                                           ! 4775         outb(0x0081, pa
33357                                           ! 4775 ge);
33358                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33359 99E7           8A46         F3            mov	al,-$D[bp]
33360 99EA           30E4                       xor	ah,ah
33361 99EC           50                         push	ax
33362                                           ! Debug: list int = const $81 (used reg = )
33363 99ED           B8                   0081  mov	ax,#$81
33364 99F0           50                         push	ax
33365                                           ! Debug: func () void = outb+0 (used reg = )
33366 99F1           E8         6B64            call	_outb
33367 99F4           83C4                   04  add	sp,*4
33368                                           !BCC_EOS
33369                                           ! 4776         ;
33370                                           !BCC_EOS
33371                                           ! 4777         outb(0x000a, 0x02);
33372                                           ! Debug: list int = const 2 (used reg = )
33373 99F7           B8                   0002  mov	ax,*2
33374 99FA           50                         push	ax
33375                                           ! Debug: list int = const $A (used reg = )
33376 99FB           B8                   000A  mov	ax,*$A
33377 99FE           50                         push	ax
33378                                           ! Debug: func () void = outb+0 (used reg = )
33379 99FF           E8         6B56            call	_outb
33380 9A02           83C4                   04  add	sp,*4
33381                                           !BCC_EOS
33382                                           ! 4778         floppy_prepare_controller(drive);
33383                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33384 9A05           8A46         FF            mov	al,-1[bp]
33385 9A08           30E4                       xor	ah,ah
33386 9A0A           50                         push	ax
33387                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33388 9A0B           E8         F55F            call	_floppy_prepare_controller
33389 9A0E           44                         inc	sp
33390 9A0F           44                         inc	sp
33391                                           !BCC_EOS
33392                                           ! 4779         outb(0x03f5, 0xc5);
33393                                           ! Debug: list int = const $C5 (used reg = )
33394 9A10           B8                   00C5  mov	ax,#$C5
33395 9A13           50                         push	ax
33396                                           ! Debug: list int = const $3F5 (used reg = )
33397 9A14           B8                   03F5  mov	ax,#$3F5
33398 9A17           50                         push	ax
33399                                           ! Debug: func () void = outb+0 (used reg = )
33400 9A18           E8         6B3D            call	_outb
33401 9A1B           83C4                   04  add	sp,*4
33402                                           !BCC_EOS
33403                                           ! 4780         outb(0x03f5, (head << 2) | drive);
33404                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33405 9A1E           8A46         FB            mov	al,-5[bp]
33406 9A21           30E4                       xor	ah,ah
33407 9A23           D1E0                       shl	ax,*1
33408 9A25           D1E0                       shl	ax,*1
33409                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33410 9A27           0A46         FF            or	al,-1[bp]
33411                                           ! Debug: list unsigned int = ax+0 (used reg = )
33412 9A2A           50                         push	ax
33413                                           ! Debug: list int = const $3F5 (used reg = )
33414 9A2B           B8                   03F5  mov	ax,#$3F5
33415 9A2E           50                         push	ax
33416                                           ! Debug: func () void = outb+0 (used reg = )
33417 9A2F           E8         6B26            call	_outb
33418 9A32           83C4                   04  add	sp,*4
33419                                           !BCC_EOS
33420                                           ! 4781         outb(0x03f5, track);
33421                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33422 9A35           8A46         FD            mov	al,-3[bp]
33423 9A38           30E4                       xor	ah,ah
33424 9A3A           50                         push	ax
33425                                           ! Debug: list int = const $3F5 (used reg = )
33426 9A3B           B8                   03F5  mov	ax,#$3F5
33427 9A3E           50                         push	ax
33428                                           ! Debug: func () void = outb+0 (used reg = )
33429 9A3F           E8         6B16            call	_outb
33430 9A42           83C4                   04  add	sp,*4
33431                                           !BCC_EOS
33432                                           ! 4782         outb(0x03f5, head);
33433                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
33434 9A45           8A46         FB            mov	al,-5[bp]
33435 9A48           30E4                       xor	ah,ah
33436 9A4A           50                         push	ax
33437                                           ! Debug: list int = const $3F5 (used reg = )
33438 9A4B           B8                   03F5  mov	ax,#$3F5
33439 9A4E           50                         push	ax
33440                                           ! Debug: func () void = outb+0 (used reg = )
33441 9A4F           E8         6B06            call	_outb
33442 9A52           83C4                   04  add	sp,*4
33443                                           !BCC_EOS
33444                                           ! 4783         outb(0x03f5, sector);
33445                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
33446 9A55           8A46         FC            mov	al,-4[bp]
33447 9A58           30E4                       xor	ah,ah
33448 9A5A           50                         push	ax
33449                                           ! Debug: list int = const $3F5 (used reg = )
33450 9A5B           B8                   03F5  mov	ax,#$3F5
33451 9A5E           50                         push	ax
33452                                           ! Debug: func () void = outb+0 (used reg = )
33453 9A5F           E8         6AF6            call	_outb
33454 9A62           83C4                   04  add	sp,*4
33455                                           !BCC_EOS
33456                                           ! 4784         outb(0x03f5, 2);
33457                                           ! Debug: list int = const 2 (used reg = )
33458 9A65           B8                   0002  mov	ax,*2
33459 9A68           50                         push	ax
33460                                           ! Debug: list int = const $3F5 (used reg = )
33461 9A69           B8                   03F5  mov	ax,#$3F5
33462 9A6C           50                         push	ax
33463                                           ! Debug: func () void = outb+0 (used reg = )
33464 9A6D           E8         6AE8            call	_outb
33465 9A70           83C4                   04  add	sp,*4
33466                                           !BCC_EOS
33467                                           ! 4785         outb(0x03f5, sector + num_sectors - 1);
33468                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
33469 9A73           8A46         FC            mov	al,-4[bp]
33470 9A76           30E4                       xor	ah,ah
33471 9A78           0246         FE            add	al,-2[bp]
33472 9A7B           80D4                   00  adc	ah,*0
33473                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33474                                           ! Debug: list unsigned int = ax-1 (used reg = )
33475 9A7E           48                         dec	ax
33476 9A7F           50                         push	ax
33477                                           ! Debug: list int = const $3F5 (used reg = )
33478 9A80           B8                   03F5  mov	ax,#$3F5
33479 9A83           50                         push	ax
33480                                           ! Debug: func () void = outb+0 (used reg = )
33481 9A84           E8         6AD1            call	_outb
33482 9A87           83C4                   04  add	sp,*4
33483                                           !BCC_EOS
33484                                           ! 4786         outb(0x03f5, 0);
33485                                           ! Debug: list int = const 0 (used reg = )
33486 9A8A           31C0                       xor	ax,ax
33487 9A8C           50                         push	ax
33488                                           ! Debug: list int = const $3F5 (used reg = )
33489 9A8D           B8                   03F5  mov	ax,#$3F5
33490 9A90           50                         push	ax
33491                                           ! Debug: func () void = outb+0 (used reg = )
33492 9A91           E8         6AC4            call	_outb
33493 9A94           83C4                   04  add	sp,*4
33494                                           !BCC_EOS
33495                                           ! 4787         outb(0x03f5, 0xff);
33496                                           ! Debug: list int = const $FF (used reg = )
33497 9A97           B8                   00FF  mov	ax,#$FF
33498 9A9A           50                         push	ax
33499                                           ! Debug: list int = const $3F5 (used reg = )
33500 9A9B           B8                   03F5  mov	ax,#$3F5
33501 9A9E           50                         push	ax
33502                                           ! Debug: func () void = outb+0 (used reg = )
33503 9A9F           E8         6AB6            call	_outb
33504 9AA2           83C4                   04  add	sp,*4
33505                                           !BCC_EOS
33506                                           ! 4788 #asm
33507                                           !BCC_EOS
33508                                           !BCC_ASM
33509                       0000002A            _int13_diskette_function.BP	set	$2A
33510                       0000000C            .int13_diskette_function.BP	set	$C
33511                       00000038            _int13_diskette_function.CS	set	$38
33512                       0000001A            .int13_diskette_function.CS	set	$1A
33513                       00000032            _int13_diskette_function.CX	set	$32
33514                       00000014            .int13_diskette_function.CX	set	$14
33515                       00000016            _int13_diskette_function.base_address	set	$16
33516                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33517                       00000026            _int13_diskette_function.DI	set	$26
33518                       00000008            .int13_diskette_function.DI	set	8
33519                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33520                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33521                       00000014            _int13_diskette_function.base_count	set	$14
33522                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33523                       0000001A            _int13_diskette_function.sector	set	$1A
33524                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33525                       00000022            _int13_diskette_function.DS	set	$22
33526                       00000004            .int13_diskette_function.DS	set	4
33527                       00000019            _int13_diskette_function.head	set	$19
33528                       FFFFFFFB            .int13_diskette_function.head	set	-5
33529                       0000002C            _int13_diskette_function.ELDX	set	$2C
33530                       0000000E            .int13_diskette_function.ELDX	set	$E
33531                       0000000E            _int13_diskette_function.dor	set	$E
33532                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33533                       00000030            _int13_diskette_function.DX	set	$30
33534                       00000012            .int13_diskette_function.DX	set	$12
33535                       00000007            _int13_diskette_function.return_status	set	7
33536                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33537                       00000002            _int13_diskette_function.es	set	2
33538                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33539                       00000010            _int13_diskette_function.mode_register	set	$10
33540                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33541                       00000024            _int13_diskette_function.ES	set	$24
33542                       00000006            .int13_diskette_function.ES	set	6
33543                       00000012            _int13_diskette_function.base_es	set	$12
33544                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33545                       0000001B            _int13_diskette_function.track	set	$1B
33546                       FFFFFFFD            .int13_diskette_function.track	set	-3
33547                       00000028            _int13_diskette_function.SI	set	$28
33548                       0000000A            .int13_diskette_function.SI	set	$A
33549                       00000006            _int13_diskette_function.drive_type	set	6
33550                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33551                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33552                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33553                       00000036            _int13_diskette_function.IP	set	$36
33554                       00000018            .int13_diskette_function.IP	set	$18
33555                       00000018            _int13_diskette_function.status	set	$18
33556                       FFFFFFFA            .int13_diskette_function.status	set	-6
33557                       00000034            _int13_diskette_function.AX	set	$34
33558                       00000016            .int13_diskette_function.AX	set	$16
33559                       0000000F            _int13_diskette_function.val8	set	$F
33560                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33561                       00000000            _int13_diskette_function.last_addr	set	0
33562                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33563                       00000011            _int13_diskette_function.page	set	$11
33564                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33565                       00000004            _int13_diskette_function.ah	set	4
33566                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33567                       0000001D            _int13_diskette_function.drive	set	$1D
33568                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33569                       00000005            _int13_diskette_function.num_floppies	set	5
33570                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33571                       0000002E            _int13_diskette_function.BX	set	$2E
33572                       00000010            .int13_diskette_function.BX	set	$10
33573 9AA5           FB                                 sti
33574                                           ! 4790 endasm
33575                                           !BCC_ENDASM
33576                                           !BCC_EOS
33577                                           ! 4791         do {
33578                       00009AA6            .6CF:
33579                                           ! 4792           val8 = read_byte(0x0040, 0x0040);
33580                                           ! Debug: list int = const $40 (used reg = )
33581 9AA6           B8                   0040  mov	ax,*$40
33582 9AA9           50                         push	ax
33583                                           ! Debug: list int = const $40 (used reg = )
33584 9AAA           B8                   0040  mov	ax,*$40
33585 9AAD           50                         push	ax
33586                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33587 9AAE           E8         6B47            call	_read_byte
33588 9AB1           83C4                   04  add	sp,*4
33589                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33590 9AB4           8846         F1            mov	-$F[bp],al
33591                                           !BCC_EOS
33592                                           ! 4793           if (val8 == 0) {
33593                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33594 9AB7           8A46         F1            mov	al,-$F[bp]
33595 9ABA           84C0                       test	al,al
33596 9ABC           75           2D            jne 	.6D0
33597                       00009ABE            .6D1:
33598                                           ! 4794             floppy_reset_controller();
33599                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33600 9ABE           E8         F45E            call	_floppy_reset_controller
33601                                           !BCC_EOS
33602                                           ! 4795             AX = ((AX & 0x00ff) | ((0x80) << 8));
33603                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33604 9AC1           8A46         16            mov	al,$16[bp]
33605                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33606 9AC4           30E4                       xor	ah,ah
33607 9AC6           0D                   8000  or	ax,#-$8000
33608                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33609 9AC9           8946         16            mov	$16[bp],ax
33610                                           !BCC_EOS
33611                                           ! 4796             set_diskette_ret_status(0x80);
33612                                           ! Debug: list int = const $80 (used reg = )
33613 9ACC           B8                   0080  mov	ax,#$80
33614 9ACF           50                         push	ax
33615                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33616 9AD0           E8         0972            call	_set_diskette_ret_status
33617 9AD3           44                         inc	sp
33618 9AD4           44                         inc	sp
33619                                           !BCC_EOS
33620                                           ! 4797             AX = ((AX & 0xff00) | (0));
33621                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33622 9AD5           8B46         16            mov	ax,$16[bp]
33623 9AD8           30C0                       xor	al,al
33624                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33625 9ADA           0C                     00  or	al,*0
33626                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33627 9ADC           8946         16            mov	$16[bp],ax
33628                                           !BCC_EOS
33629                                           ! 4798             FLAGS |= 0x0001;
33630                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33631 9ADF           8B46         1C            mov	ax,$1C[bp]
33632 9AE2           0C                     01  or	al,*1
33633 9AE4           8946         1C            mov	$1C[bp],ax
33634                                           !BCC_EOS
33635                                           ! 4799             return;
33636 9AE7           89EC                       mov	sp,bp
33637 9AE9           5D                         pop	bp
33638 9AEA           C3                         ret
33639                                           !BCC_EOS
33640                                           ! 4800           }
33641                                           ! 4801           val8 = (read_byte(0x0040, 0x003e) & 0x80);
33642                       00009AEB            .6D0:
33643                                           ! Debug: list int = const $3E (used reg = )
33644 9AEB           B8                   003E  mov	ax,*$3E
33645 9AEE           50                         push	ax
33646                                           ! Debug: list int = const $40 (used reg = )
33647 9AEF           B8                   0040  mov	ax,*$40
33648 9AF2           50                         push	ax
33649                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33650 9AF3           E8         6B02            call	_read_byte
33651 9AF6           83C4                   04  add	sp,*4
33652                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33653 9AF9           24                     80  and	al,#$80
33654                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33655 9AFB           8846         F1            mov	-$F[bp],al
33656                                           !BCC_EOS
33657                                           ! 4802         } while ( val8 == 0 );
33658                       00009AFE            .6CE:
33659                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33660 9AFE           8A46         F1            mov	al,-$F[bp]
33661 9B01           84C0                       test	al,al
33662 9B03           74           A1            je 	.6CF
33663                       00009B05            .6D2:
33664                                           !BCC_EOS
33665                                           ! 4803         val8 = 0;
33666                       00009B05            .6CD:
33667                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33668 9B05           30C0                       xor	al,al
33669 9B07           8846         F1            mov	-$F[bp],al
33670                                           !BCC_EOS
33671                                           ! 4804 #asm
33672                                           !BCC_EOS
33673                                           !BCC_ASM
33674                       0000002A            _int13_diskette_function.BP	set	$2A
33675                       0000000C            .int13_diskette_function.BP	set	$C
33676                       00000038            _int13_diskette_function.CS	set	$38
33677                       0000001A            .int13_diskette_function.CS	set	$1A
33678                       00000032            _int13_diskette_function.CX	set	$32
33679                       00000014            .int13_diskette_function.CX	set	$14
33680                       00000016            _int13_diskette_function.base_address	set	$16
33681                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33682                       00000026            _int13_diskette_function.DI	set	$26
33683                       00000008            .int13_diskette_function.DI	set	8
33684                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33685                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33686                       00000014            _int13_diskette_function.base_count	set	$14
33687                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33688                       0000001A            _int13_diskette_function.sector	set	$1A
33689                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33690                       00000022            _int13_diskette_function.DS	set	$22
33691                       00000004            .int13_diskette_function.DS	set	4
33692                       00000019            _int13_diskette_function.head	set	$19
33693                       FFFFFFFB            .int13_diskette_function.head	set	-5
33694                       0000002C            _int13_diskette_function.ELDX	set	$2C
33695                       0000000E            .int13_diskette_function.ELDX	set	$E
33696                       0000000E            _int13_diskette_function.dor	set	$E
33697                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33698                       00000030            _int13_diskette_function.DX	set	$30
33699                       00000012            .int13_diskette_function.DX	set	$12
33700                       00000007            _int13_diskette_function.return_status	set	7
33701                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33702                       00000002            _int13_diskette_function.es	set	2
33703                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33704                       00000010            _int13_diskette_function.mode_register	set	$10
33705                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33706                       00000024            _int13_diskette_function.ES	set	$24
33707                       00000006            .int13_diskette_function.ES	set	6
33708                       00000012            _int13_diskette_function.base_es	set	$12
33709                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33710                       0000001B            _int13_diskette_function.track	set	$1B
33711                       FFFFFFFD            .int13_diskette_function.track	set	-3
33712                       00000028            _int13_diskette_function.SI	set	$28
33713                       0000000A            .int13_diskette_function.SI	set	$A
33714                       00000006            _int13_diskette_function.drive_type	set	6
33715                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33716                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33717                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33718                       00000036            _int13_diskette_function.IP	set	$36
33719                       00000018            .int13_diskette_function.IP	set	$18
33720                       00000018            _int13_diskette_function.status	set	$18
33721                       FFFFFFFA            .int13_diskette_function.status	set	-6
33722                       00000034            _int13_diskette_function.AX	set	$34
33723                       00000016            .int13_diskette_function.AX	set	$16
33724                       0000000F            _int13_diskette_function.val8	set	$F
33725                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33726                       00000000            _int13_diskette_function.last_addr	set	0
33727                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33728                       00000011            _int13_diskette_function.page	set	$11
33729                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33730                       00000004            _int13_diskette_function.ah	set	4
33731                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33732                       0000001D            _int13_diskette_function.drive	set	$1D
33733                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33734                       00000005            _int13_diskette_function.num_floppies	set	5
33735                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33736                       0000002E            _int13_diskette_function.BX	set	$2E
33737                       00000010            .int13_diskette_function.BX	set	$10
33738 9B0A           FA                                 cli
33739                                           ! 4806 endasm
33740                                           !BCC_ENDASM
33741                                           !BCC_EOS
33742                                           ! 4807         val8 = read_byte(0x0040, 0x003e);
33743                                           ! Debug: list int = const $3E (used reg = )
33744 9B0B           B8                   003E  mov	ax,*$3E
33745 9B0E           50                         push	ax
33746                                           ! Debug: list int = const $40 (used reg = )
33747 9B0F           B8                   0040  mov	ax,*$40
33748 9B12           50                         push	ax
33749                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33750 9B13           E8         6AE2            call	_read_byte
33751 9B16           83C4                   04  add	sp,*4
33752                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33753 9B19           8846         F1            mov	-$F[bp],al
33754                                           !BCC_EOS
33755                                           ! 4808         val8 &= 0x7f;
33756                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33757 9B1C           8A46         F1            mov	al,-$F[bp]
33758 9B1F           24                     7F  and	al,*$7F
33759 9B21           8846         F1            mov	-$F[bp],al
33760                                           !BCC_EOS
33761                                           ! 4809         write_byte(0x0040, 0x003e, val8);
33762                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33763 9B24           8A46         F1            mov	al,-$F[bp]
33764 9B27           30E4                       xor	ah,ah
33765 9B29           50                         push	ax
33766                                           ! Debug: list int = const $3E (used reg = )
33767 9B2A           B8                   003E  mov	ax,*$3E
33768 9B2D           50                         push	ax
33769                                           ! Debug: list int = const $40 (used reg = )
33770 9B2E           B8                   0040  mov	ax,*$40
33771 9B31           50                         push	ax
33772                                           ! Debug: func () void = write_byte+0 (used reg = )
33773 9B32           E8         6AE9            call	_write_byte
33774 9B35           83C4                   06  add	sp,*6
33775                                           !BCC_EOS
33776                                           ! 4810         val8 = inb(0x3f4);
33777                                           ! Debug: list int = const $3F4 (used reg = )
33778 9B38           B8                   03F4  mov	ax,#$3F4
33779 9B3B           50                         push	ax
33780                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33781 9B3C           E8         6A03            call	_inb
33782 9B3F           44                         inc	sp
33783 9B40           44                         inc	sp
33784                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33785 9B41           8846         F1            mov	-$F[bp],al
33786                                           !BCC_EOS
33787                                           ! 4811         if ( (val8 & 0xc0) != 0xc0 )
33788                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
33789 9B44           8A46         F1            mov	al,-$F[bp]
33790 9B47           24                     C0  and	al,#$C0
33791                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
33792 9B49           3C                     C0  cmp	al,#$C0
33793 9B4B           74           0E            je  	.6D3
33794                       00009B4D            .6D4:
33795                                           ! 4812           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
33796                                           ! Debug: list * char = .6D5+0 (used reg = )
33797 9B4D           BB                   CDDD  mov	bx,#.6D5
33798 9B50           53                         push	bx
33799                                           ! Debug: list int = const 7 (used reg = )
33800 9B51           B8                   0007  mov	ax,*7
33801 9B54           50                         push	ax
33802                                           ! Debug: func () void = bios_printf+0 (used reg = )
33803 9B55           E8         6E4F            call	_bios_printf
33804 9B58           83C4                   04  add	sp,*4
33805                                           !BCC_EOS
33806                                           ! 4813         return_status[0] = inb(0x3f5);
33807                       00009B5B            .6D3:
33808                                           ! Debug: list int = const $3F5 (used reg = )
33809 9B5B           B8                   03F5  mov	ax,#$3F5
33810 9B5E           50                         push	ax
33811                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33812 9B5F           E8         69E0            call	_inb
33813 9B62           44                         inc	sp
33814 9B63           44                         inc	sp
33815                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
33816 9B64           8846         E9            mov	-$17[bp],al
33817                                           !BCC_EOS
33818                                           ! 4814         return_status[1] = inb(0x3f5);
33819                                           ! Debug: list int = const $3F5 (used reg = )
33820 9B67           B8                   03F5  mov	ax,#$3F5
33821 9B6A           50                         push	ax
33822                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33823 9B6B           E8         69D4            call	_inb
33824 9B6E           44                         inc	sp
33825 9B6F           44                         inc	sp
33826                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
33827 9B70           8846         EA            mov	-$16[bp],al
33828                                           !BCC_EOS
33829                                           ! 4815         return_status[2] = inb(0x3f5);
33830                                           ! Debug: list int = const $3F5 (used reg = )
33831 9B73           B8                   03F5  mov	ax,#$3F5
33832 9B76           50                         push	ax
33833                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33834 9B77           E8         69C8            call	_inb
33835 9B7A           44                         inc	sp
33836 9B7B           44                         inc	sp
33837                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
33838 9B7C           8846         EB            mov	-$15[bp],al
33839                                           !BCC_EOS
33840                                           ! 4816         return_status[3] = inb(0x3f5);
33841                                           ! Debug: list int = const $3F5 (used reg = )
33842 9B7F           B8                   03F5  mov	ax,#$3F5
33843 9B82           50                         push	ax
33844                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33845 9B83           E8         69BC            call	_inb
33846 9B86           44                         inc	sp
33847 9B87           44                         inc	sp
33848                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
33849 9B88           8846         EC            mov	-$14[bp],al
33850                                           !BCC_EOS
33851                                           ! 4817         return_status[4] = inb(0x3f5);
33852                                           ! Debug: list int = const $3F5 (used reg = )
33853 9B8B           B8                   03F5  mov	ax,#$3F5
33854 9B8E           50                         push	ax
33855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33856 9B8F           E8         69B0            call	_inb
33857 9B92           44                         inc	sp
33858 9B93           44                         inc	sp
33859                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
33860 9B94           8846         ED            mov	-$13[bp],al
33861                                           !BCC_EOS
33862                                           ! 4818         return_status[5] = inb(0x3f5);
33863                                           ! Debug: list int = const $3F5 (used reg = )
33864 9B97           B8                   03F5  mov	ax,#$3F5
33865 9B9A           50                         push	ax
33866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33867 9B9B           E8         69A4            call	_inb
33868 9B9E           44                         inc	sp
33869 9B9F           44                         inc	sp
33870                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33871 9BA0           8846         EE            mov	-$12[bp],al
33872                                           !BCC_EOS
33873                                           ! 4819         return_status[6] = inb(0x3f5);
33874                                           ! Debug: list int = const $3F5 (used reg = )
33875 9BA3           B8                   03F5  mov	ax,#$3F5
33876 9BA6           50                         push	ax
33877                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33878 9BA7           E8         6998            call	_inb
33879 9BAA           44                         inc	sp
33880 9BAB           44                         inc	sp
33881                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33882 9BAC           8846         EF            mov	-$11[bp],al
33883                                           !BCC_EOS
33884                                           ! 4820         write_byte(0x0040, 0x0042, return_status[0]);
33885                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33886 9BAF           8A46         E9            mov	al,-$17[bp]
33887 9BB2           30E4                       xor	ah,ah
33888 9BB4           50                         push	ax
33889                                           ! Debug: list int = const $42 (used reg = )
33890 9BB5           B8                   0042  mov	ax,*$42
33891 9BB8           50                         push	ax
33892                                           ! Debug: list int = const $40 (used reg = )
33893 9BB9           B8                   0040  mov	ax,*$40
33894 9BBC           50                         push	ax
33895                                           ! Debug: func () void = write_byte+0 (used reg = )
33896 9BBD           E8         6A5E            call	_write_byte
33897 9BC0           83C4                   06  add	sp,*6
33898                                           !BCC_EOS
33899                                           ! 4821         write_byte(0x0040, 0x0043, return_status[1]);
33900                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33901 9BC3           8A46         EA            mov	al,-$16[bp]
33902 9BC6           30E4                       xor	ah,ah
33903 9BC8           50                         push	ax
33904                                           ! Debug: list int = const $43 (used reg = )
33905 9BC9           B8                   0043  mov	ax,*$43
33906 9BCC           50                         push	ax
33907                                           ! Debug: list int = const $40 (used reg = )
33908 9BCD           B8                   0040  mov	ax,*$40
33909 9BD0           50                         push	ax
33910                                           ! Debug: func () void = write_byte+0 (used reg = )
33911 9BD1           E8         6A4A            call	_write_byte
33912 9BD4           83C4                   06  add	sp,*6
33913                                           !BCC_EOS
33914                                           ! 4822         write_byte(0x0040, 0x0044, return_status[2]);
33915                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33916 9BD7           8A46         EB            mov	al,-$15[bp]
33917 9BDA           30E4                       xor	ah,ah
33918 9BDC           50                         push	ax
33919                                           ! Debug: list int = const $44 (used reg = )
33920 9BDD           B8                   0044  mov	ax,*$44
33921 9BE0           50                         push	ax
33922                                           ! Debug: list int = const $40 (used reg = )
33923 9BE1           B8                   0040  mov	ax,*$40
33924 9BE4           50                         push	ax
33925                                           ! Debug: func () void = write_byte+0 (used reg = )
33926 9BE5           E8         6A36            call	_write_byte
33927 9BE8           83C4                   06  add	sp,*6
33928                                           !BCC_EOS
33929                                           ! 4823         write_byte(0x0040, 0x0045, return_status[3]);
33930                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33931 9BEB           8A46         EC            mov	al,-$14[bp]
33932 9BEE           30E4                       xor	ah,ah
33933 9BF0           50                         push	ax
33934                                           ! Debug: list int = const $45 (used reg = )
33935 9BF1           B8                   0045  mov	ax,*$45
33936 9BF4           50                         push	ax
33937                                           ! Debug: list int = const $40 (used reg = )
33938 9BF5           B8                   0040  mov	ax,*$40
33939 9BF8           50                         push	ax
33940                                           ! Debug: func () void = write_byte+0 (used reg = )
33941 9BF9           E8         6A22            call	_write_byte
33942 9BFC           83C4                   06  add	sp,*6
33943                                           !BCC_EOS
33944                                           ! 4824         write_byte(0x0040, 0x0046, return_status[4]);
33945                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33946 9BFF           8A46         ED            mov	al,-$13[bp]
33947 9C02           30E4                       xor	ah,ah
33948 9C04           50                         push	ax
33949                                           ! Debug: list int = const $46 (used reg = )
33950 9C05           B8                   0046  mov	ax,*$46
33951 9C08           50                         push	ax
33952                                           ! Debug: list int = const $40 (used reg = )
33953 9C09           B8                   0040  mov	ax,*$40
33954 9C0C           50                         push	ax
33955                                           ! Debug: func () void = write_byte+0 (used reg = )
33956 9C0D           E8         6A0E            call	_write_byte
33957 9C10           83C4                   06  add	sp,*6
33958                                           !BCC_EOS
33959                                           ! 4825         write_byte(0x0040, 0x0047, return_status[5]);
33960                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33961 9C13           8A46         EE            mov	al,-$12[bp]
33962 9C16           30E4                       xor	ah,ah
33963 9C18           50                         push	ax
33964                                           ! Debug: list int = const $47 (used reg = )
33965 9C19           B8                   0047  mov	ax,*$47
33966 9C1C           50                         push	ax
33967                                           ! Debug: list int = const $40 (used reg = )
33968 9C1D           B8                   0040  mov	ax,*$40
33969 9C20           50                         push	ax
33970                                           ! Debug: func () void = write_byte+0 (used reg = )
33971 9C21           E8         69FA            call	_write_byte
33972 9C24           83C4                   06  add	sp,*6
33973                                           !BCC_EOS
33974                                           ! 4826         write_byte(0x0040, 0x0048, return_status[6]);
33975                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33976 9C27           8A46         EF            mov	al,-$11[bp]
33977 9C2A           30E4                       xor	ah,ah
33978 9C2C           50                         push	ax
33979                                           ! Debug: list int = const $48 (used reg = )
33980 9C2D           B8                   0048  mov	ax,*$48
33981 9C30           50                         push	ax
33982                                           ! Debug: list int = const $40 (used reg = )
33983 9C31           B8                   0040  mov	ax,*$40
33984 9C34           50                         push	ax
33985                                           ! Debug: func () void = write_byte+0 (used reg = )
33986 9C35           E8         69E6            call	_write_byte
33987 9C38           83C4                   06  add	sp,*6
33988                                           !BCC_EOS
33989                                           ! 4827         if ( (return_status[0] & 0xc0) != 0 ) {
33990                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33991 9C3B           8A46         E9            mov	al,-$17[bp]
33992 9C3E           24                     C0  and	al,#$C0
33993                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33994 9C40           84C0                       test	al,al
33995 9C42           74           2B            je  	.6D6
33996                       00009C44            .6D7:
33997                                           ! 4828           if ( (return_status[1] & 0x02) != 0 ) {
33998                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
33999 9C44           8A46         EA            mov	al,-$16[bp]
34000 9C47           24                     02  and	al,*2
34001                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34002 9C49           84C0                       test	al,al
34003 9C4B           74           14            je  	.6D8
34004                       00009C4D            .6D9:
34005                                           ! 4829             AX = 0x0300;
34006                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34007 9C4D           B8                   0300  mov	ax,#$300
34008 9C50           8946         16            mov	$16[bp],ax
34009                                           !BCC_EOS
34010                                           ! 4830             FLAGS |= 0x0001;
34011                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34012 9C53           8B46         1C            mov	ax,$1C[bp]
34013 9C56           0C                     01  or	al,*1
34014 9C58           8946         1C            mov	$1C[bp],ax
34015                                           !BCC_EOS
34016                                           ! 4831             return;
34017 9C5B           89EC                       mov	sp,bp
34018 9C5D           5D                         pop	bp
34019 9C5E           C3                         ret
34020                                           !BCC_EOS
34021                                           ! 4832           } else {
34022 9C5F           EB           0E            jmp .6DA
34023                       00009C61            .6D8:
34024                                           ! 4833             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
34025                                           ! Debug: list * char = .6DB+0 (used reg = )
34026 9C61           BB                   CDB8  mov	bx,#.6DB
34027 9C64           53                         push	bx
34028                                           ! Debug: list int = const 7 (used reg = )
34029 9C65           B8                   0007  mov	ax,*7
34030 9C68           50                         push	ax
34031                                           ! Debug: func () void = bios_printf+0 (used reg = )
34032 9C69           E8         6D3B            call	_bios_printf
34033 9C6C           83C4                   04  add	sp,*4
34034                                           !BCC_EOS
34035                                           ! 4834           }
34036                                           ! 4835         }
34037                       00009C6F            .6DA:
34038                                           ! 4836         set_diskette_curr
34039                                           ! 4836 ent_cyl(drive, track);
34040                       00009C6F            .6D6:
34041                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
34042 9C6F           8A46         FD            mov	al,-3[bp]
34043 9C72           30E4                       xor	ah,ah
34044 9C74           50                         push	ax
34045                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34046 9C75           8A46         FF            mov	al,-1[bp]
34047 9C78           30E4                       xor	ah,ah
34048 9C7A           50                         push	ax
34049                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34050 9C7B           E8         07DF            call	_set_diskette_current_cyl
34051 9C7E           83C4                   04  add	sp,*4
34052                                           !BCC_EOS
34053                                           ! 4837         AX = ((AX & 0x00ff) | ((0x00) << 8));
34054                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34055 9C81           8A46         16            mov	al,$16[bp]
34056                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34057 9C84           0C                     00  or	al,*0
34058                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34059 9C86           30E4                       xor	ah,ah
34060 9C88           8946         16            mov	$16[bp],ax
34061                                           !BCC_EOS
34062                                           ! 4838         FLAGS &= 0xfffe;
34063                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34064 9C8B           8B46         1C            mov	ax,$1C[bp]
34065 9C8E           24                     FE  and	al,#$FE
34066 9C90           8946         1C            mov	$1C[bp],ax
34067                                           !BCC_EOS
34068                                           ! 4839         return;
34069 9C93           89EC                       mov	sp,bp
34070 9C95           5D                         pop	bp
34071 9C96           C3                         ret
34072                                           !BCC_EOS
34073                                           ! 4840       } else {
34074 9C97           EB           28            jmp .6DC
34075                       00009C99            .6C7:
34076                                           ! 4841         set_diskette_current_cyl(drive, track);
34077                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
34078 9C99           8A46         FD            mov	al,-3[bp]
34079 9C9C           30E4                       xor	ah,ah
34080 9C9E           50                         push	ax
34081                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34082 9C9F           8A46         FF            mov	al,-1[bp]
34083 9CA2           30E4                       xor	ah,ah
34084 9CA4           50                         push	ax
34085                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34086 9CA5           E8         07B5            call	_set_diskette_current_cyl
34087 9CA8           83C4                   04  add	sp,*4
34088                                           !BCC_EOS
34089                                           ! 4842         FLAGS &= 0xfffe;
34090                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34091 9CAB           8B46         1C            mov	ax,$1C[bp]
34092 9CAE           24                     FE  and	al,#$FE
34093 9CB0           8946         1C            mov	$1C[bp],ax
34094                                           !BCC_EOS
34095                                           ! 4843         AX = ((AX & 0x00ff) | ((0x00) << 8));
34096                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34097 9CB3           8A46         16            mov	al,$16[bp]
34098                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34099 9CB6           0C                     00  or	al,*0
34100                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34101 9CB8           30E4                       xor	ah,ah
34102 9CBA           8946         16            mov	$16[bp],ax
34103                                           !BCC_EOS
34104                                           ! 4844         return;
34105 9CBD           89EC                       mov	sp,bp
34106 9CBF           5D                         pop	bp
34107 9CC0           C3                         ret
34108                                           !BCC_EOS
34109                                           ! 4845       }
34110                                           ! 4846       break;
34111                       00009CC1            .6DC:
34112                       00009CC1            .6C6:
34113 9CC1           E9         077D            br 	.697
34114                                           !BCC_EOS
34115                                           ! 4847     case 0x05:
34116                                           ! 4848 ;
34117                       00009CC4            .6DD:
34118                                           !BCC_EOS
34119                                           ! 4849       num_sectors = ( AX & 0x00ff );
34120                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34121 9CC4           8A46         16            mov	al,$16[bp]
34122                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
34123 9CC7           8846         FE            mov	-2[bp],al
34124                                           !BCC_EOS
34125                                           ! 4850       track = ( CX >> 8 );
34126                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
34127 9CCA           8B46         14            mov	ax,$14[bp]
34128 9CCD           88E0                       mov	al,ah
34129 9CCF           30E4                       xor	ah,ah
34130                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
34131 9CD1           8846         FD            mov	-3[bp],al
34132                                           !BCC_EOS
34133                                           ! 4851       head = ( DX >> 8 );
34134                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
34135 9CD4           8B46         12            mov	ax,$12[bp]
34136 9CD7           88E0                       mov	al,ah
34137 9CD9           30E4                       xor	ah,ah
34138                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
34139 9CDB           8846         FB            mov	-5[bp],al
34140                                           !BCC_EOS
34141                                           ! 4852       drive = ( ELDX & 0x00ff );
34142                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34143 9CDE           8A46         0E            mov	al,$E[bp]
34144                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34145 9CE1           8846         FF            mov	-1[bp],al
34146                                           !BCC_EOS
34147                                           ! 4853       if ((drive > 1) || (head > 1) || (track > 79) ||
34148                                           ! 4854           (num_sectors == 0) || (num_sectors > 18)) {
34149                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34150 9CE4           8A46         FF            mov	al,-1[bp]
34151 9CE7           3C                     01  cmp	al,*1
34152 9CE9           77           1C            ja  	.6DF
34153                       00009CEB            .6E3:
34154                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
34155 9CEB           8A46         FB            mov	al,-5[bp]
34156 9CEE           3C                     01  cmp	al,*1
34157 9CF0           77           15            ja  	.6DF
34158                       00009CF2            .6E2:
34159                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
34160 9CF2           8A46         FD            mov	al,-3[bp]
34161 9CF5           3C                     4F  cmp	al,*$4F
34162 9CF7           77           0E            ja  	.6DF
34163                       00009CF9            .6E1:
34164                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
34165 9CF9           8A46         FE            mov	al,-2[bp]
34166 9CFC           84C0                       test	al,al
34167 9CFE           74           07            je  	.6DF
34168                       00009D00            .6E0:
34169                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
34170 9D00           8A46         FE            mov	al,-2[bp]
34171 9D03           3C                     12  cmp	al,*$12
34172 9D05           76           1C            jbe 	.6DE
34173                       00009D07            .6DF:
34174                                           ! 4855         AX = ((AX & 0x00ff) | ((1) << 8));
34175                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34176 9D07           8A46         16            mov	al,$16[bp]
34177                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34178 9D0A           30E4                       xor	ah,ah
34179 9D0C           0D                   0100  or	ax,#$100
34180                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34181 9D0F           8946         16            mov	$16[bp],ax
34182                                           !BCC_EOS
34183                                           ! 4856         set_diskette_ret_status(1);
34184                                           ! Debug: list int = const 1 (used reg = )
34185 9D12           B8                   0001  mov	ax,*1
34186 9D15           50                         push	ax
34187                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34188 9D16           E8         072C            call	_set_diskette_ret_status
34189 9D19           44                         inc	sp
34190 9D1A           44                         inc	sp
34191                                           !BCC_EOS
34192                                           ! 4857         FLAGS |= 0x0001;
34193                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34194 9D1B           8B46         1C            mov	ax,$1C[bp]
34195 9D1E           0C                     01  or	al,*1
34196 9D20           8946         1C            mov	$1C[bp],ax
34197                                           !BCC_EOS
34198                                           ! 4858       }
34199                                           ! 4859       if (floppy_drive_exists(drive) == 0) {
34200                       00009D23            .6DE:
34201                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34202 9D23           8A46         FF            mov	al,-1[bp]
34203 9D26           30E4                       xor	ah,ah
34204 9D28           50                         push	ax
34205                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
34206 9D29           E8         F5B5            call	_floppy_drive_exists
34207 9D2C           44                         inc	sp
34208 9D2D           44                         inc	sp
34209                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34210 9D2E           85C0                       test	ax,ax
34211 9D30           75           20            jne 	.6E4
34212                       00009D32            .6E5:
34213                                           ! 4860         AX = ((AX & 0x00ff) | ((0x80) << 8));
34214                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34215 9D32           8A46         16            mov	al,$16[bp]
34216                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34217 9D35           30E4                       xor	ah,ah
34218 9D37           0D                   8000  or	ax,#-$8000
34219                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34220 9D3A           8946         16            mov	$16[bp],ax
34221                                           !BCC_EOS
34222                                           ! 4861         set_diskette_ret_status(0x80);
34223                                           ! Debug: list int = const $80 (used reg = )
34224 9D3D           B8                   0080  mov	ax,#$80
34225 9D40           50                         push	ax
34226                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34227 9D41           E8         0701            call	_set_diskette_ret_status
34228 9D44           44                         inc	sp
34229 9D45           44                         inc	sp
34230                                           !BCC_EOS
34231                                           ! 4862         FLAGS |= 0x0001;
34232                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34233 9D46           8B46         1C            mov	ax,$1C[bp]
34234 9D49           0C                     01  or	al,*1
34235 9D4B           8946         1C            mov	$1C[bp],ax
34236                                           !BCC_EOS
34237                                           ! 4863         return;
34238 9D4E           89EC                       mov	sp,bp
34239 9D50           5D                         pop	bp
34240 9D51           C3                         ret
34241                                           !BCC_EOS
34242                                           ! 4864       }
34243                                           ! 4865       if (floppy_media_known(drive) == 0) {
34244                       00009D52            .6E4:
34245                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34246 9D52           8A46         FF            mov	al,-1[bp]
34247 9D55           30E4                       xor	ah,ah
34248 9D57           50                         push	ax
34249                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
34250 9D58           E8         F2F1            call	_floppy_media_known
34251 9D5B           44                         inc	sp
34252 9D5C           44                         inc	sp
34253                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34254 9D5D           85C0                       test	ax,ax
34255 9D5F           75           39            jne 	.6E6
34256                       00009D61            .6E7:
34257                                           ! 4866         if (floppy_media_sense(drive) == 0) {
34258                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34259 9D61           8A46         FF            mov	al,-1[bp]
34260 9D64           30E4                       xor	ah,ah
34261 9D66           50                         push	ax
34262                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
34263 9D67           E8         F365            call	_floppy_media_sense
34264 9D6A           44                         inc	sp
34265 9D6B           44                         inc	sp
34266                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34267 9D6C           85C0                       test	ax,ax
34268 9D6E           75           2A            jne 	.6E8
34269                       00009D70            .6E9:
34270                                           ! 4867           AX = ((AX & 0x00ff) | ((0x0C) << 8));
34271                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34272 9D70           8A46         16            mov	al,$16[bp]
34273                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
34274 9D73           30E4                       xor	ah,ah
34275 9D75           0D                   0C00  or	ax,#$C00
34276                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34277 9D78           8946         16            mov	$16[bp],ax
34278                                           !BCC_EOS
34279                                           ! 4868           set_diskette_ret_status(0x0C);
34280                                           ! Debug: list int = const $C (used reg = )
34281 9D7B           B8                   000C  mov	ax,*$C
34282 9D7E           50                         push	ax
34283                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34284 9D7F           E8         06C3            call	_set_diskette_ret_status
34285 9D82           44                         inc	sp
34286 9D83           44                         inc	sp
34287                                           !BCC_EOS
34288                                           ! 4869           AX = ((AX & 0xff00) | (0));
34289                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34290 9D84           8B46         16            mov	ax,$16[bp]
34291 9D87           30C0                       xor	al,al
34292                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34293 9D89           0C                     00  or	al,*0
34294                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34295 9D8B           8946         16            mov	$16[bp],ax
34296                                           !BCC_EOS
34297                                           ! 4870           FLAGS |= 0x0001;
34298                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34299 9D8E           8B46         1C            mov	ax,$1C[bp]
34300 9D91           0C                     01  or	al,*1
34301 9D93           8946         1C            mov	$1C[bp],ax
34302                                           !BCC_EOS
34303                                           ! 4871           return;
34304 9D96           89EC                       mov	sp,bp
34305 9D98           5D                         pop	bp
34306 9D99           C3                         ret
34307                                           !BCC_EOS
34308                                           ! 4872         }
34309                                           ! 4873       }
34310                       00009D9A            .6E8:
34311                                           ! 4874       page = (ES >> 12);
34312                       00009D9A            .6E6:
34313                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
34314 9D9A           8B46         06            mov	ax,6[bp]
34315 9D9D           88E0                       mov	al,ah
34316 9D9F           30E4                       xor	ah,ah
34317 9DA1           B1                     04  mov	cl,*4
34318 9DA3           D3E8                       shr	ax,cl
34319                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
34320 9DA5           8846         F3            mov	-$D[bp],al
34321                                           !BCC_EOS
34322                                           ! 4875       base_es = (ES << 4);
34323                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
34324 9DA8           8B46         06            mov	ax,6[bp]
34325 9DAB           B1                     04  mov	cl,*4
34326 9DAD           D3E0                       shl	ax,cl
34327                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
34328 9DAF           8946         F4            mov	-$C[bp],ax
34329                                           !BCC_EOS
34330                                           ! 4876       base_address = base_es + BX;
34331                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
34332 9DB2           8B46         F4            mov	ax,-$C[bp]
34333 9DB5           0346         10            add	ax,$10[bp]
34334                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
34335 9DB8           8946         F8            mov	-8[bp],ax
34336                                           !BCC_EOS
34337                                           ! 4877       if ( base_address < base_es ) {
34338                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
34339 9DBB           8B46         F8            mov	ax,-8[bp]
34340 9DBE           3B46         F4            cmp	ax,-$C[bp]
34341 9DC1           73           07            jae 	.6EA
34342                       00009DC3            .6EB:
34343                                           ! 4878         page++;
34344                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
34345 9DC3           8A46         F3            mov	al,-$D[bp]
34346 9DC6           40                         inc	ax
34347 9DC7           8846         F3            mov	-$D[bp],al
34348                                           !BCC_EOS
34349                                           ! 4879       }
34350                                           ! 4880       base_count = (num_sectors * 4) - 1;
34351                       00009DCA            .6EA:
34352                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
34353 9DCA           8A46         FE            mov	al,-2[bp]
34354 9DCD           30E4                       xor	ah,ah
34355 9DCF           D1E0                       shl	ax,*1
34356 9DD1           D1E0                       shl	ax,*1
34357                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
34358                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
34359 9DD3           48                         dec	ax
34360 9DD4           8946         F6            mov	-$A[bp],ax
34361                                           !BCC_EOS
34362                                           ! 4881       last_addr = base_address + base_count;
34363                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
34364 9DD7           8B46         F8            mov	ax,-8[bp]
34365 9DDA           0346         F6            add	ax,-$A[bp]
34366                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
34367 9DDD           8946         E2            mov	-$1E[bp],ax
34368                                           !BCC_EOS
34369                                           ! 4882       if (last_addr < base_address) {
34370                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
34371 9DE0           8B46         E2            mov	ax,-$1E[bp]
34372 9DE3           3B46         F8            cmp	ax,-8[bp]
34373 9DE6           73           2A            jae 	.6EC
34374                       00009DE8            .6ED:
34375                                           ! 4883         AX = ((AX & 0x00ff) | ((0x09) << 8));
34376                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34377 9DE8           8A46         16            mov	al,$16[bp]
34378                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
34379 9DEB           30E4                       xor	ah,ah
34380 9DED           0D                   0900  or	ax,#$900
34381                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34382 9DF0           8946         16            mov	$16[bp],ax
34383                                           !BCC_EOS
34384                                           ! 4884         set_diskette_ret_status(0x09);
34385                                           ! Debug: list int = const 9 (used reg = )
34386 9DF3           B8                   0009  mov	ax,*9
34387 9DF6           50                         push	ax
34388                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34389 9DF7           E8         064B            call	_set_diskette_ret_status
34390 9DFA           44                         inc	sp
34391 9DFB           44                         inc	sp
34392                                           !BCC_EOS
34393                                           ! 4885         AX = ((AX & 0xff00) | (0));
34394                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34395 9DFC           8B46         16            mov	ax,$16[bp]
34396 9DFF           30C0                       xor	al,al
34397                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34398 9E01           0C                     00  or	al,*0
34399                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34400 9E03           8946         16            mov	$16[bp],ax
34401                                           !BCC_EOS
34402                                           ! 4886         FLAGS |= 0x0001;
34403                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34404 9E06           8B46         1C            mov	ax,$1C[bp]
34405 9E09           0C                     01  or	al,*1
34406 9E0B           8946         1C            mov	$1C[bp],ax
34407                                           !BCC_EOS
34408                                           ! 4887         return;
34409 9E0E           89EC                       mov	sp,bp
34410 9E10           5D                         pop	bp
34411 9E11           C3                         ret
34412                                           !BCC_EOS
34413                                           ! 4888       }
34414                                           ! 4889       outb(0x000a, 0x06);
34415                       00009E12            .6EC:
34416                                           ! Debug: list int = const 6 (used reg = )
34417 9E12           B8                   0006  mov	ax,*6
34418 9E15           50                         push	ax
34419                                           ! Debug: list int = const $A (used reg = )
34420 9E16           B8                   000A  mov	ax,*$A
34421 9E19           50                         push	ax
34422                                           ! Debug: func () void = outb+0 (used reg = )
34423 9E1A           E8         673B            call	_outb
34424 9E1D           83C4                   04  add	sp,*4
34425                                           !BCC_EOS
34426                                           ! 4890       outb(0x000c, 0x00);
34427                                           ! Debug: list int = const 0 (used reg = )
34428 9E20           31C0                       xor	ax,ax
34429 9E22           50                         push	ax
34430                                           ! Debug: list int = const $C (used reg = )
34431 9E23           B8                   000C  mov	ax,*$C
34432 9E26           50                         push	ax
34433                                           ! Debug: func () void = outb+0 (used reg = )
34434 9E27           E8         672E            call	_outb
34435 9E2A           83C4                   04  add	sp,*4
34436                                           !BCC_EOS
34437                                           ! 4891       outb(0x0004, base_address);
34438                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
34439 9E2D           FF76         F8            push	-8[bp]
34440                                           ! Debug: list int = const 4 (used reg = )
34441 9E30           B8                   0004  mov	ax,*4
34442 9E33           50                         push	ax
34443                                           ! Debug: func () void = outb+0 (used reg = )
34444 9E34           E8         6721            call	_outb
34445 9E37           83C4                   04  add	sp,*4
34446                                           !BCC_EOS
34447                                           ! 4892       outb(0x0004, base_address>>8);
34448                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
34449 9E3A           8B46         F8            mov	ax,-8[bp]
34450 9E3D           88E0                       mov	al,ah
34451 9E3F           30E4                       xor	ah,ah
34452                                           ! Debug: list unsigned int = ax+0 (used reg = )
34453 9E41           50                         push	ax
34454                                           ! Debug: list int = const 4 (used reg = )
34455 9E42           B8                   0004  mov	ax,*4
34456 9E45           50                         push	ax
34457                                           ! Debug: func () void = outb+0 (used reg = )
34458 9E46           E8         670F            call	_outb
34459 9E49           83C4                   04  add	sp,*4
34460                                           !BCC_EOS
34461                                           ! 4893       outb(0x000c, 0x00);
34462                                           ! Debug: list int = const 0 (used reg = )
34463 9E4C           31C0                       xor	ax,ax
34464 9E4E           50                         push	ax
34465                                           ! Debug: list int = const $C (used reg = )
34466 9E4F           B8                   000C  mov	ax,*$C
34467 9E52           50                         push	ax
34468                                           ! Debug: func () void = outb+0 (used reg = )
34469 9E53           E8         6702            call	_outb
34470 9E56           83C4                   04  add	sp,*4
34471                                           !BCC_EOS
34472                                           ! 4894       outb(0x0005, base_count);
34473                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
34474 9E59           FF76         F6            push	-$A[bp]
34475                                           ! Debug: list int = const 5 (used reg = )
34476 9E5C           B8                   0005  mov	ax,*5
34477 9E5F           50                         push	ax
34478                                           ! Debug: func () void = outb+0 (used reg = )
34479 9E60           E8         66F5            call	_outb
34480 9E63           83C4                   04  add	sp,*4
34481                                           !BCC_EOS
34482                                           ! 4895       outb(0x0005, base_count>>8);
34483                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
34484 9E66           8B46         F6            mov	ax,-$A[bp]
34485 9E69           88E0                       mov	al,ah
34486 9E6B           30E4                       xor	ah,ah
34487                                           ! Debug: list unsigned int = ax+0 (used reg = )
34488 9E6D           50                         push	ax
34489                                           ! Debug: list int = const 5 (used reg = )
34490 9E6E           B8                   0005  mov	ax,*5
34491 9E71           50                         push	ax
34492                                           ! Debug: func () void = outb+0 (used reg = )
34493 9E72           E8         66E3            call	_outb
34494 9E75           83C4                   04  add	sp,*4
34495                                           !BCC_EOS
34496                                           ! 4896       mode_register = 0x4a;
34497                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
34498 9E78           B0                     4A  mov	al,*$4A
34499 9E7A           8846         F2            mov	-$E[bp],al
34500                                           !BCC_EOS
34501                                           ! 4897       outb(0x000b, mode_register);
34502                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
34503 9E7D           8A46         F2            mov	al,-$E[bp]
34504 9E80           30E4                       xor	ah,ah
34505 9E82           50                         push	ax
34506                                           ! Debug: list int = const $B (used reg = )
34507 9E83           B8                   000B  mov	ax,*$B
34508 9E86           50                         push	ax
34509                                           ! Debug: func () void = outb+0 (used reg = )
34510 9E87           E8         66CE            call	_outb
34511 9E8A           83C4                   04  add	sp,*4
34512                                           !BCC_EOS
34513                                           ! 4898       outb(0x0081, page);
34514                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
34515 9E8D           8A46         F3            mov	al,-$D[bp]
34516 9E90           30E4                       xor	ah,ah
34517 9E92           50                         push	ax
34518                                           ! Debug: list int = const $81 (used reg = )
34519 9E93           B8                   0081  mov	ax,#$81
34520 9E96           50                         push	ax
34521                                           ! Debug: func () void = outb+0 (used reg = )
34522 9E97           E8         66BE            call	_outb
34523 9E9A           83C4                   04  add	sp,*4
34524                                           !BCC_EOS
34525                                           ! 4899       outb(0x000a, 0x02);
34526                                           ! Debug: list int = const 2 (used reg = )
34527 9E9D           B8                   0002  mov	ax,*2
34528 9EA0           50                         push	ax
34529                                           ! Debug: list int = const $A (used reg = )
34530 9EA1           B8                   000A  mov	ax,*$A
34531 9EA4           50                         push	ax
34532                                           ! Debug: func () void = outb+0 (used reg = )
34533 9EA5           E8         66B0            call	_outb
34534 9EA8           83C4                   04  add	sp,*4
34535                                           !BCC_EOS
34536                                           ! 4900       floppy_prepare_controller(drive);
34537                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34538 9EAB           8A46         FF            mov	al,-1[bp]
34539 9EAE           30E4                       xor	ah,ah
34540 9EB0           50                         push	ax
34541                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
34542 9EB1           E8         F0B9            call	_floppy_prepare_controller
34543 9EB4           44                         inc	sp
34544 9EB5           44                         inc	sp
34545                                           !BCC_EOS
34546                                           ! 4901       outb(0x03f5, 0x4d);
34547                                           ! Debug: list int = const $4D (used reg = )
34548 9EB6           B8                   004D  mov	ax,*$4D
34549 9EB9           50                         push	ax
34550                                           ! Debug: list int = const $3F5 (used reg = )
34551 9EBA           B8                   03F5  mov	ax,#$3F5
34552 9EBD           50                         push	ax
34553                                           ! Debug: func () void = outb+0 (used reg = )
34554 9EBE           E8         6697            call	_outb
34555 9EC1           83C4                   04  add	sp,*4
34556                                           !BCC_EOS
34557                                           ! 4902       outb(0x03f5, (head << 2) | drive);
34558                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
34559 9EC4           8A46         FB            mov	al,-5[bp]
34560 9EC7           30E4                       xor	ah,ah
34561 9EC9           D1E0                       shl	ax,*1
34562 9ECB           D1E0                       shl	ax,*1
34563                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
34564 9ECD           0A46         FF            or	al,-1[bp]
34565                                           ! Debug: list unsigned int = ax+0 (used reg = )
34566 9ED0           50                         push	ax
34567                                           ! Debug: list int = const $3F5 (used reg = )
34568 9ED1           B8                   03F5  mov	ax,#$3F5
34569 9ED4           50                         push	ax
34570                                           ! Debug: func () void = outb+0 (used reg = )
34571 9ED5           E8         6680            call	_outb
34572 9ED8           83C4                   04  add	sp,*4
34573                                           !BCC_EOS
34574                                           ! 4903       outb(0x03f5, 2);
34575                                           ! Debug: list int = const 2 (used reg = )
34576 9EDB           B8                   0002  mov	ax,*2
34577 9EDE           50                         push	ax
34578                                           ! Debug: list int = const $3F5 (used reg = )
34579 9EDF           B8                   03F5  mov	ax,#$3F5
34580 9EE2           50                         push	ax
34581                                           ! Debug: func () void = outb+0 (used reg = )
34582 9EE3           E8         6672            call	_outb
34583 9EE6           83C4                   04  add	sp,*4
34584                                           !BCC_EOS
34585                                           ! 4904       outb(0x03f5, num_sectors);
34586                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
34587 9EE9           8A46         FE            mov	al,-2[bp]
34588 9EEC           30E4                       xor	ah,ah
34589 9EEE           50                         push	ax
34590                                           ! Debug: list int = const $3F5 (used reg = )
34591 9EEF           B8                   03F5  mov	ax,#$3F5
34592 9EF2           50                         push	ax
34593                                           ! Debug: func () void = outb+0 (used reg = )
34594 9EF3           E8         6662            call	_outb
34595 9EF6           83C4                   04  add	sp,*4
34596                                           !BCC_EOS
34597                                           ! 4905       out
34598                                           ! 4905 b(0x03f5, 0);
34599                                           ! Debug: list int = const 0 (used reg = )
34600 9EF9           31C0                       xor	ax,ax
34601 9EFB           50                         push	ax
34602                                           ! Debug: list int = const $3F5 (used reg = )
34603 9EFC           B8                   03F5  mov	ax,#$3F5
34604 9EFF           50                         push	ax
34605                                           ! Debug: func () void = outb+0 (used reg = )
34606 9F00           E8         6655            call	_outb
34607 9F03           83C4                   04  add	sp,*4
34608                                           !BCC_EOS
34609                                           ! 4906       outb(0x03f5, 0xf6);
34610                                           ! Debug: list int = const $F6 (used reg = )
34611 9F06           B8                   00F6  mov	ax,#$F6
34612 9F09           50                         push	ax
34613                                           ! Debug: list int = const $3F5 (used reg = )
34614 9F0A           B8                   03F5  mov	ax,#$3F5
34615 9F0D           50                         push	ax
34616                                           ! Debug: func () void = outb+0 (used reg = )
34617 9F0E           E8         6647            call	_outb
34618 9F11           83C4                   04  add	sp,*4
34619                                           !BCC_EOS
34620                                           ! 4907 #asm
34621                                           !BCC_EOS
34622                                           !BCC_ASM
34623                       0000002A            _int13_diskette_function.BP	set	$2A
34624                       0000000C            .int13_diskette_function.BP	set	$C
34625                       00000038            _int13_diskette_function.CS	set	$38
34626                       0000001A            .int13_diskette_function.CS	set	$1A
34627                       00000032            _int13_diskette_function.CX	set	$32
34628                       00000014            .int13_diskette_function.CX	set	$14
34629                       00000016            _int13_diskette_function.base_address	set	$16
34630                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34631                       00000026            _int13_diskette_function.DI	set	$26
34632                       00000008            .int13_diskette_function.DI	set	8
34633                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34634                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34635                       00000014            _int13_diskette_function.base_count	set	$14
34636                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34637                       0000001A            _int13_diskette_function.sector	set	$1A
34638                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34639                       00000022            _int13_diskette_function.DS	set	$22
34640                       00000004            .int13_diskette_function.DS	set	4
34641                       00000019            _int13_diskette_function.head	set	$19
34642                       FFFFFFFB            .int13_diskette_function.head	set	-5
34643                       0000002C            _int13_diskette_function.ELDX	set	$2C
34644                       0000000E            .int13_diskette_function.ELDX	set	$E
34645                       0000000E            _int13_diskette_function.dor	set	$E
34646                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34647                       00000030            _int13_diskette_function.DX	set	$30
34648                       00000012            .int13_diskette_function.DX	set	$12
34649                       00000007            _int13_diskette_function.return_status	set	7
34650                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34651                       00000002            _int13_diskette_function.es	set	2
34652                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34653                       00000010            _int13_diskette_function.mode_register	set	$10
34654                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34655                       00000024            _int13_diskette_function.ES	set	$24
34656                       00000006            .int13_diskette_function.ES	set	6
34657                       00000012            _int13_diskette_function.base_es	set	$12
34658                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34659                       0000001B            _int13_diskette_function.track	set	$1B
34660                       FFFFFFFD            .int13_diskette_function.track	set	-3
34661                       00000028            _int13_diskette_function.SI	set	$28
34662                       0000000A            .int13_diskette_function.SI	set	$A
34663                       00000006            _int13_diskette_function.drive_type	set	6
34664                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34665                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34666                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34667                       00000036            _int13_diskette_function.IP	set	$36
34668                       00000018            .int13_diskette_function.IP	set	$18
34669                       00000018            _int13_diskette_function.status	set	$18
34670                       FFFFFFFA            .int13_diskette_function.status	set	-6
34671                       00000034            _int13_diskette_function.AX	set	$34
34672                       00000016            .int13_diskette_function.AX	set	$16
34673                       0000000F            _int13_diskette_function.val8	set	$F
34674                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34675                       00000000            _int13_diskette_function.last_addr	set	0
34676                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34677                       00000011            _int13_diskette_function.page	set	$11
34678                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34679                       00000004            _int13_diskette_function.ah	set	4
34680                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34681                       0000001D            _int13_diskette_function.drive	set	$1D
34682                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34683                       00000005            _int13_diskette_function.num_floppies	set	5
34684                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34685                       0000002E            _int13_diskette_function.BX	set	$2E
34686                       00000010            .int13_diskette_function.BX	set	$10
34687 9F14           FB                               sti
34688                                           ! 4909 endasm
34689                                           !BCC_ENDASM
34690                                           !BCC_EOS
34691                                           ! 4910       do {
34692                       00009F15            .6F0:
34693                                           ! 4911         val8 = read_byte(0x0040, 0x0040);
34694                                           ! Debug: list int = const $40 (used reg = )
34695 9F15           B8                   0040  mov	ax,*$40
34696 9F18           50                         push	ax
34697                                           ! Debug: list int = const $40 (used reg = )
34698 9F19           B8                   0040  mov	ax,*$40
34699 9F1C           50                         push	ax
34700                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34701 9F1D           E8         66D8            call	_read_byte
34702 9F20           83C4                   04  add	sp,*4
34703                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34704 9F23           8846         F1            mov	-$F[bp],al
34705                                           !BCC_EOS
34706                                           ! 4912         if (val8 == 0) {
34707                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34708 9F26           8A46         F1            mov	al,-$F[bp]
34709 9F29           84C0                       test	al,al
34710 9F2B           75           23            jne 	.6F1
34711                       00009F2D            .6F2:
34712                                           ! 4913           floppy_reset_controller();
34713                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
34714 9F2D           E8         EFEF            call	_floppy_reset_controller
34715                                           !BCC_EOS
34716                                           ! 4914           AX = ((AX & 0x00ff) | ((0x80) << 8));
34717                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34718 9F30           8A46         16            mov	al,$16[bp]
34719                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34720 9F33           30E4                       xor	ah,ah
34721 9F35           0D                   8000  or	ax,#-$8000
34722                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34723 9F38           8946         16            mov	$16[bp],ax
34724                                           !BCC_EOS
34725                                           ! 4915           set_diskette_ret_status(0x80);
34726                                           ! Debug: list int = const $80 (used reg = )
34727 9F3B           B8                   0080  mov	ax,#$80
34728 9F3E           50                         push	ax
34729                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34730 9F3F           E8         0503            call	_set_diskette_ret_status
34731 9F42           44                         inc	sp
34732 9F43           44                         inc	sp
34733                                           !BCC_EOS
34734                                           ! 4916           FLAGS |= 0x0001;
34735                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34736 9F44           8B46         1C            mov	ax,$1C[bp]
34737 9F47           0C                     01  or	al,*1
34738 9F49           8946         1C            mov	$1C[bp],ax
34739                                           !BCC_EOS
34740                                           ! 4917           return;
34741 9F4C           89EC                       mov	sp,bp
34742 9F4E           5D                         pop	bp
34743 9F4F           C3                         ret
34744                                           !BCC_EOS
34745                                           ! 4918         }
34746                                           ! 4919         val8 = (read_byte(0x0040, 0x003e) & 0x80);
34747                       00009F50            .6F1:
34748                                           ! Debug: list int = const $3E (used reg = )
34749 9F50           B8                   003E  mov	ax,*$3E
34750 9F53           50                         push	ax
34751                                           ! Debug: list int = const $40 (used reg = )
34752 9F54           B8                   0040  mov	ax,*$40
34753 9F57           50                         push	ax
34754                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34755 9F58           E8         669D            call	_read_byte
34756 9F5B           83C4                   04  add	sp,*4
34757                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
34758 9F5E           24                     80  and	al,#$80
34759                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34760 9F60           8846         F1            mov	-$F[bp],al
34761                                           !BCC_EOS
34762                                           ! 4920       } while ( val8 == 0 );
34763                       00009F63            .6EF:
34764                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34765 9F63           8A46         F1            mov	al,-$F[bp]
34766 9F66           84C0                       test	al,al
34767 9F68           74           AB            je 	.6F0
34768                       00009F6A            .6F3:
34769                                           !BCC_EOS
34770                                           ! 4921       val8 = 0;
34771                       00009F6A            .6EE:
34772                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34773 9F6A           30C0                       xor	al,al
34774 9F6C           8846         F1            mov	-$F[bp],al
34775                                           !BCC_EOS
34776                                           ! 4922 #asm
34777                                           !BCC_EOS
34778                                           !BCC_ASM
34779                       0000002A            _int13_diskette_function.BP	set	$2A
34780                       0000000C            .int13_diskette_function.BP	set	$C
34781                       00000038            _int13_diskette_function.CS	set	$38
34782                       0000001A            .int13_diskette_function.CS	set	$1A
34783                       00000032            _int13_diskette_function.CX	set	$32
34784                       00000014            .int13_diskette_function.CX	set	$14
34785                       00000016            _int13_diskette_function.base_address	set	$16
34786                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34787                       00000026            _int13_diskette_function.DI	set	$26
34788                       00000008            .int13_diskette_function.DI	set	8
34789                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34790                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34791                       00000014            _int13_diskette_function.base_count	set	$14
34792                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34793                       0000001A            _int13_diskette_function.sector	set	$1A
34794                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34795                       00000022            _int13_diskette_function.DS	set	$22
34796                       00000004            .int13_diskette_function.DS	set	4
34797                       00000019            _int13_diskette_function.head	set	$19
34798                       FFFFFFFB            .int13_diskette_function.head	set	-5
34799                       0000002C            _int13_diskette_function.ELDX	set	$2C
34800                       0000000E            .int13_diskette_function.ELDX	set	$E
34801                       0000000E            _int13_diskette_function.dor	set	$E
34802                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34803                       00000030            _int13_diskette_function.DX	set	$30
34804                       00000012            .int13_diskette_function.DX	set	$12
34805                       00000007            _int13_diskette_function.return_status	set	7
34806                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34807                       00000002            _int13_diskette_function.es	set	2
34808                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34809                       00000010            _int13_diskette_function.mode_register	set	$10
34810                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34811                       00000024            _int13_diskette_function.ES	set	$24
34812                       00000006            .int13_diskette_function.ES	set	6
34813                       00000012            _int13_diskette_function.base_es	set	$12
34814                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34815                       0000001B            _int13_diskette_function.track	set	$1B
34816                       FFFFFFFD            .int13_diskette_function.track	set	-3
34817                       00000028            _int13_diskette_function.SI	set	$28
34818                       0000000A            .int13_diskette_function.SI	set	$A
34819                       00000006            _int13_diskette_function.drive_type	set	6
34820                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34821                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34822                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34823                       00000036            _int13_diskette_function.IP	set	$36
34824                       00000018            .int13_diskette_function.IP	set	$18
34825                       00000018            _int13_diskette_function.status	set	$18
34826                       FFFFFFFA            .int13_diskette_function.status	set	-6
34827                       00000034            _int13_diskette_function.AX	set	$34
34828                       00000016            .int13_diskette_function.AX	set	$16
34829                       0000000F            _int13_diskette_function.val8	set	$F
34830                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34831                       00000000            _int13_diskette_function.last_addr	set	0
34832                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34833                       00000011            _int13_diskette_function.page	set	$11
34834                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34835                       00000004            _int13_diskette_function.ah	set	4
34836                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34837                       0000001D            _int13_diskette_function.drive	set	$1D
34838                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34839                       00000005            _int13_diskette_function.num_floppies	set	5
34840                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34841                       0000002E            _int13_diskette_function.BX	set	$2E
34842                       00000010            .int13_diskette_function.BX	set	$10
34843 9F6F           FA                               cli
34844                                           ! 4924 endasm
34845                                           !BCC_ENDASM
34846                                           !BCC_EOS
34847                                           ! 4925       val8 = read_byte(0x0040, 0x003e);
34848                                           ! Debug: list int = const $3E (used reg = )
34849 9F70           B8                   003E  mov	ax,*$3E
34850 9F73           50                         push	ax
34851                                           ! Debug: list int = const $40 (used reg = )
34852 9F74           B8                   0040  mov	ax,*$40
34853 9F77           50                         push	ax
34854                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34855 9F78           E8         667D            call	_read_byte
34856 9F7B           83C4                   04  add	sp,*4
34857                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34858 9F7E           8846         F1            mov	-$F[bp],al
34859                                           !BCC_EOS
34860                                           ! 4926       val8 &= 0x7f;
34861                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
34862 9F81           8A46         F1            mov	al,-$F[bp]
34863 9F84           24                     7F  and	al,*$7F
34864 9F86           8846         F1            mov	-$F[bp],al
34865                                           !BCC_EOS
34866                                           ! 4927       write_byte(0x0040, 0x003e, val8);
34867                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
34868 9F89           8A46         F1            mov	al,-$F[bp]
34869 9F8C           30E4                       xor	ah,ah
34870 9F8E           50                         push	ax
34871                                           ! Debug: list int = const $3E (used reg = )
34872 9F8F           B8                   003E  mov	ax,*$3E
34873 9F92           50                         push	ax
34874                                           ! Debug: list int = const $40 (used reg = )
34875 9F93           B8                   0040  mov	ax,*$40
34876 9F96           50                         push	ax
34877                                           ! Debug: func () void = write_byte+0 (used reg = )
34878 9F97           E8         6684            call	_write_byte
34879 9F9A           83C4                   06  add	sp,*6
34880                                           !BCC_EOS
34881                                           ! 4928       val8 = inb(0x3f4);
34882                                           ! Debug: list int = const $3F4 (used reg = )
34883 9F9D           B8                   03F4  mov	ax,#$3F4
34884 9FA0           50                         push	ax
34885                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34886 9FA1           E8         659E            call	_inb
34887 9FA4           44                         inc	sp
34888 9FA5           44                         inc	sp
34889                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34890 9FA6           8846         F1            mov	-$F[bp],al
34891                                           !BCC_EOS
34892                                           ! 4929       if ( (val8 & 0xc0) != 0xc0 )
34893                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
34894 9FA9           8A46         F1            mov	al,-$F[bp]
34895 9FAC           24                     C0  and	al,#$C0
34896                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
34897 9FAE           3C                     C0  cmp	al,#$C0
34898 9FB0           74           0E            je  	.6F4
34899                       00009FB2            .6F5:
34900                                           ! 4930         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
34901                                           ! Debug: list * char = .6F6+0 (used reg = )
34902 9FB2           BB                   CD98  mov	bx,#.6F6
34903 9FB5           53                         push	bx
34904                                           ! Debug: list int = const 7 (used reg = )
34905 9FB6           B8                   0007  mov	ax,*7
34906 9FB9           50                         push	ax
34907                                           ! Debug: func () void = bios_printf+0 (used reg = )
34908 9FBA           E8         69EA            call	_bios_printf
34909 9FBD           83C4                   04  add	sp,*4
34910                                           !BCC_EOS
34911                                           ! 4931       return_status[0] = inb(0x3f5);
34912                       00009FC0            .6F4:
34913                                           ! Debug: list int = const $3F5 (used reg = )
34914 9FC0           B8                   03F5  mov	ax,#$3F5
34915 9FC3           50                         push	ax
34916                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34917 9FC4           E8         657B            call	_inb
34918 9FC7           44                         inc	sp
34919 9FC8           44                         inc	sp
34920                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
34921 9FC9           8846         E9            mov	-$17[bp],al
34922                                           !BCC_EOS
34923                                           ! 4932       return_status[1] = inb(0x3f5);
34924                                           ! Debug: list int = const $3F5 (used reg = )
34925 9FCC           B8                   03F5  mov	ax,#$3F5
34926 9FCF           50                         push	ax
34927                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34928 9FD0           E8         656F            call	_inb
34929 9FD3           44                         inc	sp
34930 9FD4           44                         inc	sp
34931                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
34932 9FD5           8846         EA            mov	-$16[bp],al
34933                                           !BCC_EOS
34934                                           ! 4933       return_status[2] = inb(0x3f5);
34935                                           ! Debug: list int = const $3F5 (used reg = )
34936 9FD8           B8                   03F5  mov	ax,#$3F5
34937 9FDB           50                         push	ax
34938                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34939 9FDC           E8         6563            call	_inb
34940 9FDF           44                         inc	sp
34941 9FE0           44                         inc	sp
34942                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
34943 9FE1           8846         EB            mov	-$15[bp],al
34944                                           !BCC_EOS
34945                                           ! 4934       return_status[3] = inb(0x3f5);
34946                                           ! Debug: list int = const $3F5 (used reg = )
34947 9FE4           B8                   03F5  mov	ax,#$3F5
34948 9FE7           50                         push	ax
34949                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34950 9FE8           E8         6557            call	_inb
34951 9FEB           44                         inc	sp
34952 9FEC           44                         inc	sp
34953                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
34954 9FED           8846         EC            mov	-$14[bp],al
34955                                           !BCC_EOS
34956                                           ! 4935       return_status[4] = inb(0x3f5);
34957                                           ! Debug: list int = const $3F5 (used reg = )
34958 9FF0           B8                   03F5  mov	ax,#$3F5
34959 9FF3           50                         push	ax
34960                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34961 9FF4           E8         654B            call	_inb
34962 9FF7           44                         inc	sp
34963 9FF8           44                         inc	sp
34964                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
34965 9FF9           8846         ED            mov	-$13[bp],al
34966                                           !BCC_EOS
34967                                           ! 4936       return_status[5] = inb(0x3f5);
34968                                           ! Debug: list int = const $3F5 (used reg = )
34969 9FFC           B8                   03F5  mov	ax,#$3F5
34970 9FFF           50                         push	ax
34971                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34972 A000           E8         653F            call	_inb
34973 A003           44                         inc	sp
34974 A004           44                         inc	sp
34975                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
34976 A005           8846         EE            mov	-$12[bp],al
34977                                           !BCC_EOS
34978                                           ! 4937       return_status[6] = inb(0x3f5);
34979                                           ! Debug: list int = const $3F5 (used reg = )
34980 A008           B8                   03F5  mov	ax,#$3F5
34981 A00B           50                         push	ax
34982                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34983 A00C           E8         6533            call	_inb
34984 A00F           44                         inc	sp
34985 A010           44                         inc	sp
34986                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
34987 A011           8846         EF            mov	-$11[bp],al
34988                                           !BCC_EOS
34989                                           ! 4938       write_byte(0x0040, 0x0042, return_status[0]);
34990                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
34991 A014           8A46         E9            mov	al,-$17[bp]
34992 A017           30E4                       xor	ah,ah
34993 A019           50                         push	ax
34994                                           ! Debug: list int = const $42 (used reg = )
34995 A01A           B8                   0042  mov	ax,*$42
34996 A01D           50                         push	ax
34997                                           ! Debug: list int = const $40 (used reg = )
34998 A01E           B8                   0040  mov	ax,*$40
34999 A021           50                         push	ax
35000                                           ! Debug: func () void = write_byte+0 (used reg = )
35001 A022           E8         65F9            call	_write_byte
35002 A025           83C4                   06  add	sp,*6
35003                                           !BCC_EOS
35004                                           ! 4939       write_byte(0x0040, 0x0043, return_status[1]);
35005                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
35006 A028           8A46         EA            mov	al,-$16[bp]
35007 A02B           30E4                       xor	ah,ah
35008 A02D           50                         push	ax
35009                                           ! Debug: list int = const $43 (used reg = )
35010 A02E           B8                   0043  mov	ax,*$43
35011 A031           50                         push	ax
35012                                           ! Debug: list int = const $40 (used reg = )
35013 A032           B8                   0040  mov	ax,*$40
35014 A035           50                         push	ax
35015                                           ! Debug: func () void = write_byte+0 (used reg = )
35016 A036           E8         65E5            call	_write_byte
35017 A039           83C4                   06  add	sp,*6
35018                                           !BCC_EOS
35019                                           ! 4940       write_byte(0x0040, 0x0044, return_status[2]);
35020                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
35021 A03C           8A46         EB            mov	al,-$15[bp]
35022 A03F           30E4                       xor	ah,ah
35023 A041           50                         push	ax
35024                                           ! Debug: list int = const $44 (used reg = )
35025 A042           B8                   0044  mov	ax,*$44
35026 A045           50                         push	ax
35027                                           ! Debug: list int = const $40 (used reg = )
35028 A046           B8                   0040  mov	ax,*$40
35029 A049           50                         push	ax
35030                                           ! Debug: func () void = write_byte+0 (used reg = )
35031 A04A           E8         65D1            call	_write_byte
35032 A04D           83C4                   06  add	sp,*6
35033                                           !BCC_EOS
35034                                           ! 4941       write_byte(0x0040, 0x0045, return_status[3]);
35035                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
35036 A050           8A46         EC            mov	al,-$14[bp]
35037 A053           30E4                       xor	ah,ah
35038 A055           50                         push	ax
35039                                           ! Debug: list int = const $45 (used reg = )
35040 A056           B8                   0045  mov	ax,*$45
35041 A059           50                         push	ax
35042                                           ! Debug: list int = const $40 (used reg = )
35043 A05A           B8                   0040  mov	ax,*$40
35044 A05D           50                         push	ax
35045                                           ! Debug: func () void = write_byte+0 (used reg = )
35046 A05E           E8         65BD            call	_write_byte
35047 A061           83C4                   06  add	sp,*6
35048                                           !BCC_EOS
35049                                           ! 4942       write_byte(0x0040, 0x0046, return_status[4]);
35050                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
35051 A064           8A46         ED            mov	al,-$13[bp]
35052 A067           30E4                       xor	ah,ah
35053 A069           50                         push	ax
35054                                           ! Debug: list int = const $46 (used reg = )
35055 A06A           B8                   0046  mov	ax,*$46
35056 A06D           50                         push	ax
35057                                           ! Debug: list int = const $40 (used reg = )
35058 A06E           B8                   0040  mov	ax,*$40
35059 A071           50                         push	ax
35060                                           ! Debug: func () void = write_byte+0 (used reg = )
35061 A072           E8         65A9            call	_write_byte
35062 A075           83C4                   06  add	sp,*6
35063                                           !BCC_EOS
35064                                           ! 4943       write_byte(0x0040, 0x0047, return_status[5]);
35065                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
35066 A078           8A46         EE            mov	al,-$12[bp]
35067 A07B           30E4                       xor	ah,ah
35068 A07D           50                         push	ax
35069                                           ! Debug: list int = const $47 (used reg = )
35070 A07E           B8                   0047  mov	ax,*$47
35071 A081           50                         push	ax
35072                                           ! Debug: list int = const $40 (used reg = )
35073 A082           B8                   0040  mov	ax,*$40
35074 A085           50                         push	ax
35075                                           ! Debug: func () void = write_byte+0 (used reg = )
35076 A086           E8         6595            call	_write_byte
35077 A089           83C4                   06  add	sp,*6
35078                                           !BCC_EOS
35079                                           ! 4944       write_byte(0x0040, 0x0048, return_status[6]);
35080                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
35081 A08C           8A46         EF            mov	al,-$11[bp]
35082 A08F           30E4                       xor	ah,ah
35083 A091           50                         push	ax
35084                                           ! Debug: list int = const $48 (used reg = )
35085 A092           B8                   0048  mov	ax,*$48
35086 A095           50                         push	ax
35087                                           ! Debug: list int = const $40 (used reg = )
35088 A096           B8                   0040  mov	ax,*$40
35089 A099           50                         push	ax
35090                                           ! Debug: func () void = write_byte+0 (used reg = )
35091 A09A           E8         6581            call	_write_byte
35092 A09D           83C4                   06  add	sp,*6
35093                                           !BCC_EOS
35094                                           ! 4945       if ( (return_status[0] & 0xc0) != 0 ) {
35095                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
35096 A0A0           8A46         E9            mov	al,-$17[bp]
35097 A0A3           24                     C0  and	al,#$C0
35098                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35099 A0A5           84C0                       test	al,al
35100 A0A7           74           2B            je  	.6F7
35101                       0000A0A9            .6F8:
35102                                           ! 4946         if ( (return_status[1] & 0x02) != 0 ) {
35103                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
35104 A0A9           8A46         EA            mov	al,-$16[bp]
35105 A0AC           24                     02  and	al,*2
35106                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35107 A0AE           84C0                       test	al,al
35108 A0B0           74           14            je  	.6F9
35109                       0000A0B2            .6FA:
35110                                           ! 4947           AX = 0x0300;
35111                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
35112 A0B2           B8                   0300  mov	ax,#$300
35113 A0B5           8946         16            mov	$16[bp],ax
35114                                           !BCC_EOS
35115                                           ! 4948           FLAGS |= 0x0001;
35116                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35117 A0B8           8B46         1C            mov	ax,$1C[bp]
35118 A0BB           0C                     01  or	al,*1
35119 A0BD           8946         1C            mov	$1C[bp],ax
35120                                           !BCC_EOS
35121                                           ! 4949           return;
35122 A0C0           89EC                       mov	sp,bp
35123 A0C2           5D                         pop	bp
35124 A0C3           C3                         ret
35125                                           !BCC_EOS
35126                                           ! 4950         } else {
35127 A0C4           EB           0E            jmp .6FB
35128                       0000A0C6            .6F9:
35129                                           ! 4951           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
35130                                           ! Debug: list * char = .6FC+0 (used reg = )
35131 A0C6           BB                   CD72  mov	bx,#.6FC
35132 A0C9           53                         push	bx
35133                                           ! Debug: list int = const 7 (used reg = )
35134 A0CA           B8                   0007  mov	ax,*7
35135 A0CD           50                         push	ax
35136                                           ! Debug: func () void = bios_printf+0 (used reg = )
35137 A0CE           E8         68D6            call	_bios_printf
35138 A0D1           83C4                   04  add	sp,*4
35139                                           !BCC_EOS
35140                                           ! 4952         }
35141                                           ! 4953       }
35142                       0000A0D4            .6FB:
35143                                           ! 4954       AX = ((AX & 0x00ff) | ((0) << 8));
35144                       0000A0D4            .6F7:
35145                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35146 A0D4           8A46         16            mov	al,$16[bp]
35147                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35148 A0D7           0C                     00  or	al,*0
35149                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35150 A0D9           30E4                       xor	ah,ah
35151 A0DB           8946         16            mov	$16[bp],ax
35152                                           !BCC_EOS
35153                                           ! 4955       set_diskette_ret_status(0);
35154                                           ! Debug: list int = const 0 (used reg = )
35155 A0DE           31C0                       xor	ax,ax
35156 A0E0           50                         push	ax
35157                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35158 A0E1           E8         0361            call	_set_diskette_ret_status
35159 A0E4           44                         inc	sp
35160 A0E5           44                         inc	sp
35161                                           !BCC_EOS
35162                                           ! 4956       set_diskette_current_cyl(drive, 0);
35163                                           ! Debug: list int = const 0 (used reg = )
35164 A0E6           31C0                       xor	ax,ax
35165 A0E8           50                         push	ax
35166                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
35167 A0E9           8A46         FF            mov	al,-1[bp]
35168 A0EC           30E4                       xor	ah,ah
35169 A0EE           50                         push	ax
35170                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
35171 A0EF           E8         036B            call	_set_diskette_current_cyl
35172 A0F2           83C4                   04  add	sp,*4
35173                                           !BCC_EOS
35174                                           ! 4957       FLAGS &= 0xfffe;
35175                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35176 A0F5           8B46         1C            mov	ax,$1C[bp]
35177 A0F8           24                     FE  and	al,#$FE
35178 A0FA           8946         1C            mov	$1C[bp],ax
35179                                           !BCC_EOS
35180                                           ! 4958       return;
35181 A0FD           89EC                       mov	sp,bp
35182 A0FF           5D                         pop	bp
35183 A100           C3                         ret
35184                                           !BCC_EOS
35185                                           ! 4959     case 0x08:
35186                                           ! 4960 ;
35187                       0000A101            .6FD:
35188                                           !BCC_EOS
35189                                           ! 4961       drive = ( ELDX & 0x00ff );
35190                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35191 A101           8A46         0E            mov	al,$E[bp]
35192                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35193 A104           8846         FF            mov	-1[bp],al
35194                                           !BCC_EOS
35195                                           ! 4962       if (drive > 1) {
35196                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35197 A107           8A46         FF            mov	al,-1[bp]
35198 A10A           3C                     01  cmp	al,*1
35199 A10C           76           35            jbe 	.6FE
35200                       0000A10E            .6FF:
35201                                           ! 4963         AX = 0;
35202                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
35203 A10E           31C0                       xor	ax,ax
35204 A110           8946         16            mov	$16[bp],ax
35205                                           !BCC_EOS
35206                                           ! 4964         BX = 0;
35207                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
35208 A113           31C0                       xor	ax,ax
35209 A115           8946         10            mov	$10[bp],ax
35210                                           !BCC_EOS
35211                                           ! 4965         CX = 0;
35212                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35213 A118           31C0                       xor	ax,ax
35214 A11A           8946         14            mov	$14[bp],ax
35215                                           !BCC_EOS
35216                                           ! 4966         DX = 0;
35217                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
35218 A11D           31C0                       xor	ax,ax
35219 A11F           8946         12            mov	$12[bp],ax
35220                                           !BCC_EOS
35221                                           ! 4967         ES = 0;
35222                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
35223 A122           31C0                       xor	ax,ax
35224 A124           8946         06            mov	6[bp],ax
35225                                           !BCC_EOS
35226                                           ! 4968         DI = 0;
35227                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
35228 A127           31C0                       xor	ax,ax
35229 A129           8946         08            mov	8[bp],ax
35230                                           !BCC_EOS
35231                                           ! 4969         DX = ((DX & 0xff00) | (num_floppies));
35232                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35233 A12C           8B46         12            mov	ax,$12[bp]
35234 A12F           30C0                       xor	al,al
35235                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35236 A131           0A46         E7            or	al,-$19[bp]
35237                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35238 A134           8946         12            mov	$12[bp],ax
35239                                           !BCC_EOS
35240                                           ! 4970         FLAGS |= 0x0001;
35241                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35242 A137           8B46         1C            mov	ax,$1C[bp]
35243 A13A           0C                     01  or	al,*1
35244 A13C           8946         1C            mov	$1C[bp],ax
35245                                           !BCC_EOS
35246                                           ! 4971         return;
35247 A13F           89EC                       mov	sp,bp
35248 A141           5D                         pop	bp
35249 A142           C3                         ret
35250                                           !BCC_EOS
35251                                           ! 4972       }
35252                                           ! 4973       drive_type = inb_cmos(0x10);
35253                       0000A143            .6FE:
35254                                           ! Debug: list int = const $10 (used reg = )
35255 A143           B8                   0010  mov	ax,*$10
35256 A146           50                         push	ax
35257                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35258 A147           E8         643D            call	_inb_cmos
35259 A14A           44                         inc	sp
35260 A14B           44                         inc	sp
35261                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35262 A14C           8846         E8            mov	-$18[bp],al
35263                                           !BCC_EOS
35264                                           ! 4974       num_floppies = 0;
35265                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
35266 A14F           30C0                       xor	al,al
35267 A151           8846         E7            mov	-$19[bp],al
35268                                           !BCC_EOS
35269                                           ! 4975  
35270                                           ! 4975      if (drive_type & 0xf0)
35271                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35272 A154           8A46         E8            mov	al,-$18[bp]
35273 A157           24                     F0  and	al,#$F0
35274 A159           84C0                       test	al,al
35275 A15B           74           07            je  	.700
35276                       0000A15D            .701:
35277                                           ! 4976         num_floppies++;
35278                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35279 A15D           8A46         E7            mov	al,-$19[bp]
35280 A160           40                         inc	ax
35281 A161           8846         E7            mov	-$19[bp],al
35282                                           !BCC_EOS
35283                                           ! 4977       if (drive_type & 0x0f)
35284                       0000A164            .700:
35285                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35286 A164           8A46         E8            mov	al,-$18[bp]
35287 A167           24                     0F  and	al,*$F
35288 A169           84C0                       test	al,al
35289 A16B           74           07            je  	.702
35290                       0000A16D            .703:
35291                                           ! 4978         num_floppies++;
35292                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35293 A16D           8A46         E7            mov	al,-$19[bp]
35294 A170           40                         inc	ax
35295 A171           8846         E7            mov	-$19[bp],al
35296                                           !BCC_EOS
35297                                           ! 4979       if (drive == 0)
35298                       0000A174            .702:
35299                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35300 A174           8A46         FF            mov	al,-1[bp]
35301 A177           84C0                       test	al,al
35302 A179           75           0E            jne 	.704
35303                       0000A17B            .705:
35304                                           ! 4980         drive_type >>= 4;
35305                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35306 A17B           8A46         E8            mov	al,-$18[bp]
35307 A17E           30E4                       xor	ah,ah
35308 A180           B1                     04  mov	cl,*4
35309 A182           D3E8                       shr	ax,cl
35310 A184           8846         E8            mov	-$18[bp],al
35311                                           !BCC_EOS
35312                                           ! 4981       else
35313                                           ! 4982         drive_type &= 0x0f;
35314 A187           EB           08            jmp .706
35315                       0000A189            .704:
35316                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35317 A189           8A46         E8            mov	al,-$18[bp]
35318 A18C           24                     0F  and	al,*$F
35319 A18E           8846         E8            mov	-$18[bp],al
35320                                           !BCC_EOS
35321                                           ! 4983       BX = ((BX & 0x00ff) | ((0) << 8));
35322                       0000A191            .706:
35323                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
35324 A191           8A46         10            mov	al,$10[bp]
35325                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35326 A194           0C                     00  or	al,*0
35327                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
35328 A196           30E4                       xor	ah,ah
35329 A198           8946         10            mov	$10[bp],ax
35330                                           !BCC_EOS
35331                                           ! 4984       BX = ((BX & 0xff00) | (drive_type));
35332                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
35333 A19B           8B46         10            mov	ax,$10[bp]
35334 A19E           30C0                       xor	al,al
35335                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
35336 A1A0           0A46         E8            or	al,-$18[bp]
35337                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
35338 A1A3           8946         10            mov	$10[bp],ax
35339                                           !BCC_EOS
35340                                           ! 4985       AX = ((AX & 0x00ff) | ((0) << 8));
35341                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35342 A1A6           8A46         16            mov	al,$16[bp]
35343                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35344 A1A9           0C                     00  or	al,*0
35345                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35346 A1AB           30E4                       xor	ah,ah
35347 A1AD           8946         16            mov	$16[bp],ax
35348                                           !BCC_EOS
35349                                           ! 4986       AX = ((AX & 0xff00) | (0));
35350                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
35351 A1B0           8B46         16            mov	ax,$16[bp]
35352 A1B3           30C0                       xor	al,al
35353                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
35354 A1B5           0C                     00  or	al,*0
35355                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35356 A1B7           8946         16            mov	$16[bp],ax
35357                                           !BCC_EOS
35358                                           ! 4987       DX = ((DX & 0xff00) | (num_floppies));
35359                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35360 A1BA           8B46         12            mov	ax,$12[bp]
35361 A1BD           30C0                       xor	al,al
35362                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35363 A1BF           0A46         E7            or	al,-$19[bp]
35364                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35365 A1C2           8946         12            mov	$12[bp],ax
35366                                           !BCC_EOS
35367                                           ! 4988       switch (drive_type) {
35368 A1C5           8A46         E8            mov	al,-$18[bp]
35369 A1C8           E9         00BC            br 	.709
35370                                           ! 4989         case 0:
35371                                           ! 4990           CX = 0;
35372                       0000A1CB            .70A:
35373                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35374 A1CB           31C0                       xor	ax,ax
35375 A1CD           8946         14            mov	$14[bp],ax
35376                                           !BCC_EOS
35377                                           ! 4991           DX = ((DX & 0x00ff) | ((0) << 8));
35378                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35379 A1D0           8A46         12            mov	al,$12[bp]
35380                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35381 A1D3           0C                     00  or	al,*0
35382                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35383 A1D5           30E4                       xor	ah,ah
35384 A1D7           8946         12            mov	$12[bp],ax
35385                                           !BCC_EOS
35386                                           ! 4992           break;
35387 A1DA           E9         00D1            br 	.707
35388                                           !BCC_EOS
35389                                           ! 4993         case 1:
35390                                           ! 4994           CX = 0x2709;
35391                       0000A1DD            .70B:
35392                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35393 A1DD           B8                   2709  mov	ax,#$2709
35394 A1E0           8946         14            mov	$14[bp],ax
35395                                           !BCC_EOS
35396                                           ! 4995           DX = ((DX & 0x00ff) | ((1) << 8));
35397                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35398 A1E3           8A46         12            mov	al,$12[bp]
35399                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35400 A1E6           30E4                       xor	ah,ah
35401 A1E8           0D                   0100  or	ax,#$100
35402                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35403 A1EB           8946         12            mov	$12[bp],ax
35404                                           !BCC_EOS
35405                                           ! 4996           break;
35406 A1EE           E9         00BD            br 	.707
35407                                           !BCC_EOS
35408                                           ! 4997         case 2:
35409                                           ! 4998           CX = 0x4f0f;
35410                       0000A1F1            .70C:
35411                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
35412 A1F1           B8                   4F0F  mov	ax,#$4F0F
35413 A1F4           8946         14            mov	$14[bp],ax
35414                                           !BCC_EOS
35415                                           ! 4999           DX = ((DX & 0x00ff) | ((1) << 8));
35416                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35417 A1F7           8A46         12            mov	al,$12[bp]
35418                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35419 A1FA           30E4                       xor	ah,ah
35420 A1FC           0D                   0100  or	ax,#$100
35421                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35422 A1FF           8946         12            mov	$12[bp],ax
35423                                           !BCC_EOS
35424                                           ! 5000           break;
35425 A202           E9         00A9            br 	.707
35426                                           !BCC_EOS
35427                                           ! 5001         case 3:
35428                                           ! 5002           CX = 0x4f09;
35429                       0000A205            .70D:
35430                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
35431 A205           B8                   4F09  mov	ax,#$4F09
35432 A208           8946         14            mov	$14[bp],ax
35433                                           !BCC_EOS
35434                                           ! 5003           DX = ((DX & 0x00ff) | ((1) << 8));
35435                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35436 A20B           8A46         12            mov	al,$12[bp]
35437                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35438 A20E           30E4                       xor	ah,ah
35439 A210           0D                   0100  or	ax,#$100
35440                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35441 A213           8946         12            mov	$12[bp],ax
35442                                           !BCC_EOS
35443                                           ! 5004           break;
35444 A216           E9         0095            br 	.707
35445                                           !BCC_EOS
35446                                           ! 5005         case 4:
35447                                           ! 5006           CX = 0x4f12;
35448                       0000A219            .70E:
35449                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
35450 A219           B8                   4F12  mov	ax,#$4F12
35451 A21C           8946         14            mov	$14[bp],ax
35452                                           !BCC_EOS
35453                                           ! 5007           DX = ((DX & 0x00ff) | ((1) << 8));
35454                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35455 A21F           8A46         12            mov	al,$12[bp]
35456                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35457 A222           30E4                       xor	ah,ah
35458 A224           0D                   0100  or	ax,#$100
35459                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35460 A227           8946         12            mov	$12[bp],ax
35461                                           !BCC_EOS
35462                                           ! 5008           break;
35463 A22A           E9         0081            br 	.707
35464                                           !BCC_EOS
35465                                           ! 5009         case 5:
35466                                           ! 5010           CX = 0x4f24;
35467                       0000A22D            .70F:
35468                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
35469 A22D           B8                   4F24  mov	ax,#$4F24
35470 A230           8946         14            mov	$14[bp],ax
35471                                           !BCC_EOS
35472                                           ! 5011           DX = ((DX & 0x00ff) | ((1) << 8));
35473                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35474 A233           8A46         12            mov	al,$12[bp]
35475                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35476 A236           30E4                       xor	ah,ah
35477 A238           0D                   0100  or	ax,#$100
35478                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35479 A23B           8946         12            mov	$12[bp],ax
35480                                           !BCC_EOS
35481                                           ! 5012           break;
35482 A23E           EB           6E            jmp .707
35483                                           !BCC_EOS
35484                                           ! 5013         case 6:
35485                                           ! 5014           CX = 0x2708;
35486                       0000A240            .710:
35487                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35488 A240           B8                   2708  mov	ax,#$2708
35489 A243           8946         14            mov	$14[bp],ax
35490                                           !BCC_EOS
35491                                           ! 5015           DX = ((DX & 0x00ff) | ((0) << 8));
35492                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35493 A246           8A46         12            mov	al,$12[bp]
35494                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35495 A249           0C                     00  or	al,*0
35496                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35497 A24B           30E4                       xor	ah,ah
35498 A24D           8946         12            mov	$12[bp],ax
35499                                           !BCC_EOS
35500                                           ! 5016           break;
35501 A250           EB           5C            jmp .707
35502                                           !BCC_EOS
35503                                           ! 5017         case 7:
35504                                           ! 5018           CX = 0x2709;
35505                       0000A252            .711:
35506                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35507 A252           B8                   2709  mov	ax,#$2709
35508 A255           8946         14            mov	$14[bp],ax
35509                                           !BCC_EOS
35510                                           ! 5019           DX = ((DX & 0x00ff) | ((0) << 8));
35511                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35512 A258           8A46         12            mov	al,$12[bp]
35513                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35514 A25B           0C                     00  or	al,*0
35515                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35516 A25D           30E4                       xor	ah,ah
35517 A25F           8946         12            mov	$12[bp],ax
35518                                           !BCC_EOS
35519                                           ! 5020           break;
35520 A262           EB           4A            jmp .707
35521                                           !BCC_EOS
35522                                           ! 5021         case 8:
35523                                           ! 5022           CX = 0x2708;
35524                       0000A264            .712:
35525                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35526 A264           B8                   2708  mov	ax,#$2708
35527 A267           8946         14            mov	$14[bp],ax
35528                                           !BCC_EOS
35529                                           ! 5023           DX = ((DX & 0x00ff) | ((1) << 8));
35530                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35531 A26A           8A46         12            mov	al,$12[bp]
35532                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35533 A26D           30E4                       xor	ah,ah
35534 A26F           0D                   0100  or	ax,#$100
35535                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35536 A272           8946         12            mov	$12[bp],ax
35537                                           !BCC_EOS
35538                                           ! 5024           break;
35539 A275           EB           37            jmp .707
35540                                           !BCC_EOS
35541                                           ! 5025         default:
35542                                           ! 5026           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
35543                       0000A277            .713:
35544                                           ! Debug: list * char = .714+0 (used reg = )
35545 A277           BB                   CD52  mov	bx,#.714
35546 A27A           53                         push	bx
35547                                           ! Debug: list int = const 7 (used reg = )
35548 A27B           B8                   0007  mov	ax,*7
35549 A27E           50                         push	ax
35550                                           ! Debug: func () void = bios_printf+0 (used reg = )
35551 A27F           E8         6725            call	_bios_printf
35552 A282           83C4                   04  add	sp,*4
35553                                           !BCC_EOS
35554                                           ! 5027         }
35555                                           ! 5028 #asm
35556 A285           EB           27            jmp .707
35557                       0000A287            .709:
35558 A287           2C                     00  sub	al,*0
35559 A289           72           EC            jb 	.713
35560 A28B           3C                     08  cmp	al,*8
35561 A28D           77           1D            ja  	.715
35562 A28F           30E4                       xor	ah,ah
35563 A291           D1E0                       shl	ax,*1
35564 A293           89C3                       mov	bx,ax
35565 A295           2E                         seg	cs
35566 A296           FFA7       A29A            br	.716[bx]
35567                       0000A29A            .716:
35568 A29A                      A1CB            .word	.70A
35569 A29C                      A1DD            .word	.70B
35570 A29E                      A1F1            .word	.70C
35571 A2A0                      A205            .word	.70D
35572 A2A2                      A219            .word	.70E
35573 A2A4                      A22D            .word	.70F
35574 A2A6                      A240            .word	.710
35575 A2A8                      A252            .word	.711
35576 A2AA                      A264            .word	.712
35577                       0000A2AC            .715:
35578 A2AC           EB           C9            jmp	.713
35579                       0000A2AE            .707:
35580                                           !BCC_EOS
35581                                           !BCC_ASM
35582                       0000002A            _int13_diskette_function.BP	set	$2A
35583                       0000000C            .int13_diskette_function.BP	set	$C
35584                       00000038            _int13_diskette_function.CS	set	$38
35585                       0000001A            .int13_diskette_function.CS	set	$1A
35586                       00000032            _int13_diskette_function.CX	set	$32
35587                       00000014            .int13_diskette_function.CX	set	$14
35588                       00000016            _int13_diskette_function.base_address	set	$16
35589                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
35590                       00000026            _int13_diskette_function.DI	set	$26
35591                       00000008            .int13_diskette_function.DI	set	8
35592                       0000003A            _int13_diskette_function.FLAGS	set	$3A
35593                       0000001C            .int13_diskette_function.FLAGS	set	$1C
35594                       00000014            _int13_diskette_function.base_count	set	$14
35595                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
35596                       0000001A            _int13_diskette_function.sector	set	$1A
35597                       FFFFFFFC            .int13_diskette_function.sector	set	-4
35598                       00000022            _int13_diskette_function.DS	set	$22
35599                       00000004            .int13_diskette_function.DS	set	4
35600                       00000019            _int13_diskette_function.head	set	$19
35601                       FFFFFFFB            .int13_diskette_function.head	set	-5
35602                       0000002C            _int13_diskette_function.ELDX	set	$2C
35603                       0000000E            .int13_diskette_function.ELDX	set	$E
35604                       0000000E            _int13_diskette_function.dor	set	$E
35605                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
35606                       00000030            _int13_diskette_function.DX	set	$30
35607                       00000012            .int13_diskette_function.DX	set	$12
35608                       00000007            _int13_diskette_function.return_status	set	7
35609                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
35610                       00000002            _int13_diskette_function.es	set	2
35611                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
35612                       00000010            _int13_diskette_function.mode_register	set	$10
35613                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
35614                       00000024            _int13_diskette_function.ES	set	$24
35615                       00000006            .int13_diskette_function.ES	set	6
35616                       00000012            _int13_diskette_function.base_es	set	$12
35617                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
35618                       0000001B            _int13_diskette_function.track	set	$1B
35619                       FFFFFFFD            .int13_diskette_function.track	set	-3
35620                       00000028            _int13_diskette_function.SI	set	$28
35621                       0000000A            .int13_diskette_function.SI	set	$A
35622                       00000006            _int13_diskette_function.drive_type	set	6
35623                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
35624                       0000001C            _int13_diskette_function.num_sectors	set	$1C
35625                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
35626                       00000036            _int13_diskette_function.IP	set	$36
35627                       00000018            .int13_diskette_function.IP	set	$18
35628                       00000018            _int13_diskette_function.status	set	$18
35629                       FFFFFFFA            .int13_diskette_function.status	set	-6
35630                       00000034            _int13_diskette_function.AX	set	$34
35631                       00000016            .int13_diskette_function.AX	set	$16
35632                       0000000F            _int13_diskette_function.val8	set	$F
35633                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
35634                       00000000            _int13_diskette_function.last_addr	set	0
35635                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
35636                       00000011            _int13_diskette_function.page	set	$11
35637                       FFFFFFF3            .int13_diskette_function.page	set	-$D
35638                       00000004            _int13_diskette_function.ah	set	4
35639                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
35640                       0000001D            _int13_diskette_function.drive	set	$1D
35641                       FFFFFFFF            .int13_diskette_function.drive	set	-1
35642                       00000005            _int13_diskette_function.num_floppies	set	5
35643                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
35644                       0000002E            _int13_diskette_function.BX	set	$2E
35645                       00000010            .int13_diskette_function.BX	set	$10
35646 A2AE           55                               push bp
35647 A2AF           89E5                             mov bp, sp
35648 A2B1           B8                   EFDE        mov ax, #diskette_param_table2
35649 A2B4           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
35650 A2B7           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
35651 A2BA           5D                               pop bp
35652                                           ! 5035 endasm
35653                                           !BCC_ENDASM
35654                                           !BCC_EOS
35655                                           ! 5036       FLAGS &= 0xfffe;
35656                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35657 A2BB           8B46         1C            mov	ax,$1C[bp]
35658 A2BE           24                     FE  and	al,#$FE
35659 A2C0           8946         1C            mov	$1C[bp],ax
35660                                           !BCC_EOS
35661                                           ! 5037       return;
35662 A2C3           89EC                       mov	sp,bp
35663 A2C5           5D                         pop	bp
35664 A2C6           C3                         ret
35665                                           !BCC_EOS
35666                                           ! 5038     case 0x15:
35667                                           ! 5039 ;
35668                       0000A2C7            .717:
35669                                           !BCC_EOS
35670                                           ! 5040       drive = ( ELDX & 0x00ff );
35671                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35672 A2C7           8A46         0E            mov	al,$E[bp]
35673                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35674 A2CA           8846         FF            mov	-1[bp],al
35675                                           !BCC_EOS
35676                                           ! 5041       if (drive > 1) {
35677                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35678 A2CD           8A46         FF            mov	al,-1[bp]
35679 A2D0           3C                     01  cmp	al,*1
35680 A2D2           76           16            jbe 	.718
35681                       0000A2D4            .719:
35682                                           ! 5042         AX = ((AX & 0x00ff) | ((0) << 8));
35683                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35684 A2D4           8A46         16            mov	al,$16[bp]
35685                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35686 A2D7           0C                     00  or	al,*0
35687                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35688 A2D9           30E4                       xor	ah,ah
35689 A2DB           8946         16            mov	$16[bp],ax
35690                                           !BCC_EOS
35691                                           ! 5043         FLAGS |= 0x0001;
35692                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35693 A2DE           8B46         1C            mov	ax,$1C[bp]
35694 A2E1           0C                     01  or	al,*1
35695 A2E3           8946         1C            mov	$1C[bp],ax
35696                                           !BCC_EOS
35697                                           ! 5044         return;
35698 A2E6           89EC                       mov	sp,bp
35699 A2E8           5D                         pop	bp
35700 A2E9           C3                         ret
35701                                           !BCC_EOS
35702                                           ! 5045       }
35703                                           ! 5046       drive_type = inb_cmos(0x10);
35704                       0000A2EA            .718:
35705                                           ! Debug: list int = const $10 (used reg = )
35706 A2EA           B8                   0010  mov	ax,*$10
35707 A2ED           50                         push	ax
35708                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35709 A2EE           E8         6296            call	_inb_cmos
35710 A2F1           44                         inc	sp
35711 A2F2           44                         inc	sp
35712                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35713 A2F3           8846         E8            mov	-$18[bp],al
35714                                           !BCC_EOS
35715                                           ! 5047       if (drive == 0)
35716                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35717 A2F6           8A46         FF            mov	al,-1[bp]
35718 A2F9           84C0                       test	al,al
35719 A2FB           75           0E            jne 	.71A
35720                       0000A2FD            .71B:
35721                                           ! 5048         drive_type >>= 4;
35722                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35723 A2FD           8A46         E8            mov	al,-$18[bp]
35724 A300           30E4                       xor	ah,ah
35725 A302           B1                     04  mov	cl,*4
35726 A304           D3E8                       shr	ax,cl
35727 A306           8846         E8            mov	-$18[bp],al
35728                                           !BCC_EOS
35729                                           ! 5049       else
35730                                           ! 5050         drive_type &= 0x0f;
35731 A309           EB           08            jmp .71C
35732                       0000A30B            .71A:
35733                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35734 A30B           8A46         E8            mov	al,-$18[bp]
35735 A30E           24                     0F  and	al,*$F
35736 A310           8846         E8            mov	-$18[bp],al
35737                                           !BCC_EOS
35738                                           ! 5051       FLAGS &= 0xfffe;
35739                       0000A313            .71C:
35740                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35741 A313           8B46         1C            mov	ax,$1C[bp]
35742 A316           24                     FE  and	al,#$FE
35743 A318           8946         1C            mov	$1C[bp],ax
35744                                           !BCC_EOS
35745                                           ! 5052       if (drive_type==0) {
35746                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35747 A31B           8A46         E8            mov	al,-$18[bp]
35748 A31E           84C0                       test	al,al
35749 A320           75           0C            jne 	.71D
35750                       0000A322            .71E:
35751                                           ! 5053         AX = ((AX & 0x00ff) | ((0) << 8));
35752                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35753 A322           8A46         16            mov	al,$16[bp]
35754                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35755 A325           0C                     00  or	al,*0
35756                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35757 A327           30E4                       xor	ah,ah
35758 A329           8946         16            mov	$16[bp],ax
35759                                           !BCC_EOS
35760                                           ! 5054       }
35761                                           ! 5055       
35762                                           ! 5055 else {
35763 A32C           EB           0B            jmp .71F
35764                       0000A32E            .71D:
35765                                           ! 5056         AX = ((AX & 0x00ff) | ((1) << 8));
35766                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35767 A32E           8A46         16            mov	al,$16[bp]
35768                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35769 A331           30E4                       xor	ah,ah
35770 A333           0D                   0100  or	ax,#$100
35771                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35772 A336           8946         16            mov	$16[bp],ax
35773                                           !BCC_EOS
35774                                           ! 5057       }
35775                                           ! 5058       return;
35776                       0000A339            .71F:
35777 A339           89EC                       mov	sp,bp
35778 A33B           5D                         pop	bp
35779 A33C           C3                         ret
35780                                           !BCC_EOS
35781                                           ! 5059     case 0x16:
35782                                           ! 5060 ;
35783                       0000A33D            .720:
35784                                           !BCC_EOS
35785                                           ! 5061       drive = ( ELDX & 0x00ff );
35786                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35787 A33D           8A46         0E            mov	al,$E[bp]
35788                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35789 A340           8846         FF            mov	-1[bp],al
35790                                           !BCC_EOS
35791                                           ! 5062       if (drive > 1) {
35792                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35793 A343           8A46         FF            mov	al,-1[bp]
35794 A346           3C                     01  cmp	al,*1
35795 A348           76           20            jbe 	.721
35796                       0000A34A            .722:
35797                                           ! 5063         AX = ((AX & 0x00ff) | ((0x01) << 8));
35798                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35799 A34A           8A46         16            mov	al,$16[bp]
35800                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35801 A34D           30E4                       xor	ah,ah
35802 A34F           0D                   0100  or	ax,#$100
35803                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35804 A352           8946         16            mov	$16[bp],ax
35805                                           !BCC_EOS
35806                                           ! 5064         set_diskette_ret_status(0x01);
35807                                           ! Debug: list int = const 1 (used reg = )
35808 A355           B8                   0001  mov	ax,*1
35809 A358           50                         push	ax
35810                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35811 A359           E8         00E9            call	_set_diskette_ret_status
35812 A35C           44                         inc	sp
35813 A35D           44                         inc	sp
35814                                           !BCC_EOS
35815                                           ! 5065         FLAGS |= 0x0001;
35816                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35817 A35E           8B46         1C            mov	ax,$1C[bp]
35818 A361           0C                     01  or	al,*1
35819 A363           8946         1C            mov	$1C[bp],ax
35820                                           !BCC_EOS
35821                                           ! 5066         return;
35822 A366           89EC                       mov	sp,bp
35823 A368           5D                         pop	bp
35824 A369           C3                         ret
35825                                           !BCC_EOS
35826                                           ! 5067       }
35827                                           ! 5068       AX = ((AX & 0x00ff) | ((0x06) << 8));
35828                       0000A36A            .721:
35829                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35830 A36A           8A46         16            mov	al,$16[bp]
35831                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
35832 A36D           30E4                       xor	ah,ah
35833 A36F           0D                   0600  or	ax,#$600
35834                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35835 A372           8946         16            mov	$16[bp],ax
35836                                           !BCC_EOS
35837                                           ! 5069       set_diskette_ret_status(0x06);
35838                                           ! Debug: list int = const 6 (used reg = )
35839 A375           B8                   0006  mov	ax,*6
35840 A378           50                         push	ax
35841                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35842 A379           E8         00C9            call	_set_diskette_ret_status
35843 A37C           44                         inc	sp
35844 A37D           44                         inc	sp
35845                                           !BCC_EOS
35846                                           ! 5070       FLAGS |= 0x0001;
35847                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35848 A37E           8B46         1C            mov	ax,$1C[bp]
35849 A381           0C                     01  or	al,*1
35850 A383           8946         1C            mov	$1C[bp],ax
35851                                           !BCC_EOS
35852                                           ! 5071       return;
35853 A386           89EC                       mov	sp,bp
35854 A388           5D                         pop	bp
35855 A389           C3                         ret
35856                                           !BCC_EOS
35857                                           ! 5072     case 0x17:
35858                                           ! 5073 ;
35859                       0000A38A            .723:
35860                                           !BCC_EOS
35861                                           ! 5074       AX = ((AX & 0x00ff) | ((0x01) << 8));
35862                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35863 A38A           8A46         16            mov	al,$16[bp]
35864                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35865 A38D           30E4                       xor	ah,ah
35866 A38F           0D                   0100  or	ax,#$100
35867                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35868 A392           8946         16            mov	$16[bp],ax
35869                                           !BCC_EOS
35870                                           ! 5075       set_diskette_ret_status(1);
35871                                           ! Debug: list int = const 1 (used reg = )
35872 A395           B8                   0001  mov	ax,*1
35873 A398           50                         push	ax
35874                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35875 A399           E8         00A9            call	_set_diskette_ret_status
35876 A39C           44                         inc	sp
35877 A39D           44                         inc	sp
35878                                           !BCC_EOS
35879                                           ! 5076       FLAGS |= 0x0001;
35880                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35881 A39E           8B46         1C            mov	ax,$1C[bp]
35882 A3A1           0C                     01  or	al,*1
35883 A3A3           8946         1C            mov	$1C[bp],ax
35884                                           !BCC_EOS
35885                                           ! 5077       return;
35886 A3A6           89EC                       mov	sp,bp
35887 A3A8           5D                         pop	bp
35888 A3A9           C3                         ret
35889                                           !BCC_EOS
35890                                           ! 5078     case 0x18:
35891                                           ! 5079 ;
35892                       0000A3AA            .724:
35893                                           !BCC_EOS
35894                                           ! 5080       AX = ((AX & 0x00ff) | ((0x01) << 8));
35895                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35896 A3AA           8A46         16            mov	al,$16[bp]
35897                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35898 A3AD           30E4                       xor	ah,ah
35899 A3AF           0D                   0100  or	ax,#$100
35900                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35901 A3B2           8946         16            mov	$16[bp],ax
35902                                           !BCC_EOS
35903                                           ! 5081       set_diskette_ret_status(1);
35904                                           ! Debug: list int = const 1 (used reg = )
35905 A3B5           B8                   0001  mov	ax,*1
35906 A3B8           50                         push	ax
35907                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35908 A3B9           E8         0089            call	_set_diskette_ret_status
35909 A3BC           44                         inc	sp
35910 A3BD           44                         inc	sp
35911                                           !BCC_EOS
35912                                           ! 5082       FLAGS |= 0x0001;
35913                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35914 A3BE           8B46         1C            mov	ax,$1C[bp]
35915 A3C1           0C                     01  or	al,*1
35916 A3C3           8946         1C            mov	$1C[bp],ax
35917                                           !BCC_EOS
35918                                           ! 5083       return;
35919 A3C6           89EC                       mov	sp,bp
35920 A3C8           5D                         pop	bp
35921 A3C9           C3                         ret
35922                                           !BCC_EOS
35923                                           ! 5084     default:
35924                                           ! 5085         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
35925                       0000A3CA            .725:
35926                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
35927 A3CA           8B46         16            mov	ax,$16[bp]
35928 A3CD           88E0                       mov	al,ah
35929 A3CF           30E4                       xor	ah,ah
35930                                           ! Debug: list unsigned int = ax+0 (used reg = )
35931 A3D1           50                         push	ax
35932                                           ! Debug: list * char = .726+0 (used reg = )
35933 A3D2           BB                   CD2D  mov	bx,#.726
35934 A3D5           53                         push	bx
35935                                           ! Debug: list int = const 4 (used reg = )
35936 A3D6           B8                   0004  mov	ax,*4
35937 A3D9           50                         push	ax
35938                                           ! Debug: func () void = bios_printf+0 (used reg = )
35939 A3DA           E8         65CA            call	_bios_printf
35940 A3DD           83C4                   06  add	sp,*6
35941                                           !BCC_EOS
35942                                           ! 5086         AX = ((AX & 0x00ff) | ((0x01) << 8));
35943                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35944 A3E0           8A46         16            mov	al,$16[bp]
35945                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35946 A3E3           30E4                       xor	ah,ah
35947 A3E5           0D                   0100  or	ax,#$100
35948                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35949 A3E8           8946         16            mov	$16[bp],ax
35950                                           !BCC_EOS
35951                                           ! 5087         set_diskette_ret_status(1);
35952                                           ! Debug: list int = const 1 (used reg = )
35953 A3EB           B8                   0001  mov	ax,*1
35954 A3EE           50                         push	ax
35955                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35956 A3EF           E8         0053            call	_set_diskette_ret_status
35957 A3F2           44                         inc	sp
35958 A3F3           44                         inc	sp
35959                                           !BCC_EOS
35960                                           ! 5088         FLAGS |= 0x0001;
35961                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35962 A3F4           8B46         1C            mov	ax,$1C[bp]
35963 A3F7           0C                     01  or	al,*1
35964 A3F9           8946         1C            mov	$1C[bp],ax
35965                                           !BCC_EOS
35966                                           ! 5089         return;
35967 A3FC           89EC                       mov	sp,bp
35968 A3FE           5D                         pop	bp
35969 A3FF           C3                         ret
35970                                           !BCC_EOS
35971                                           ! 5090     }
35972                                           ! 5091 }
35973 A400           EB           3F            jmp .697
35974                       0000A402            .699:
35975 A402           2C                     00  sub	al,*0
35976 A404           72           C4            jb 	.725
35977 A406           3C                     08  cmp	al,*8
35978 A408           77           1D            ja  	.727
35979 A40A           30E4                       xor	ah,ah
35980 A40C           D1E0                       shl	ax,*1
35981 A40E           89C3                       mov	bx,ax
35982 A410           2E                         seg	cs
35983 A411           FFA7       A415            br	.728[bx]
35984                       0000A415            .728:
35985 A415                      933F            .word	.69A
35986 A417                      93E9            .word	.6A2
35987 A419                      942B            .word	.6A5
35988 A41B                      942B            .word	.6A6
35989 A41D                      942B            .word	.6A7
35990 A41F                      9CC4            .word	.6DD
35991 A421                      A3CA            .word	.725
35992 A423                      A3CA            .word	.725
35993 A425                      A101            .word	.6FD
35994                       0000A427            .727:
35995 A427           2C                     15  sub	al,*$15
35996 A429         0F84         FE9A            beq 	.717
35997 A42D           2C                     01  sub	al,*1
35998 A42F         0F84         FF0A            beq 	.720
35999 A433           2C                     01  sub	al,*1
36000 A435         0F84         FF51            beq 	.723
36001 A439           2C                     01  sub	al,*1
36002 A43B         0F84         FF6B            beq 	.724
36003 A43F           EB           89            jmp	.725
36004                       0000A441            .697:
36005                       FFFFFFE0            ..FFDC	=	-$20
36006 A441           89EC                       mov	sp,bp
36007 A443           5D                         pop	bp
36008 A444           C3                         ret
36009                                           ! 5092  void
36010                                           ! Register BX used in function int13_diskette_function
36011                                           ! 5093 set_diskette_ret_status(value)
36012                                           ! 5094   Bit8u value;
36013                                           export	_set_diskette_ret_status
36014                       0000A445            _set_diskette_ret_status:
36015                                           !BCC_EOS
36016                                           ! 5095 {
36017                                           ! 5096   write_byte(0x0040, 0x0041, value);
36018 A445           55                         push	bp
36019 A446           89E5                       mov	bp,sp
36020                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
36021 A448           8A46         04            mov	al,4[bp]
36022 A44B           30E4                       xor	ah,ah
36023 A44D           50                         push	ax
36024                                           ! Debug: list int = const $41 (used reg = )
36025 A44E           B8                   0041  mov	ax,*$41
36026 A451           50                         push	ax
36027                                           ! Debug: list int = const $40 (used reg = )
36028 A452           B8                   0040  mov	ax,*$40
36029 A455           50                         push	ax
36030                                           ! Debug: func () void = write_byte+0 (used reg = )
36031 A456           E8         61C5            call	_write_byte
36032 A459           89EC                       mov	sp,bp
36033                                           !BCC_EOS
36034                                           ! 5097 }
36035 A45B           5D                         pop	bp
36036 A45C           C3                         ret
36037                                           ! 5098   void
36038                                           ! 5099 set_diskette_current_cyl(drive, cyl)
36039                                           ! 5100   Bit8u drive;
36040                                           export	_set_diskette_current_cyl
36041                       0000A45D            _set_diskette_current_cyl:
36042                                           !BCC_EOS
36043                                           ! 5101   Bit8u cyl;
36044                                           !BCC_EOS
36045                                           ! 5102 {
36046                                           ! 5103   if (drive > 1)
36047 A45D           55                         push	bp
36048 A45E           89E5                       mov	bp,sp
36049                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
36050 A460           8A46         04            mov	al,4[bp]
36051 A463           3C                     01  cmp	al,*1
36052 A465           76           0D            jbe 	.729
36053                       0000A467            .72A:
36054                                           ! 5104     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
36055                                           ! Debug: list * char = .72B+0 (used reg = )
36056 A467           BB                   CD06  mov	bx,#.72B
36057 A46A           53                         push	bx
36058                                           ! Debug: list int = const 7 (used reg = )
36059 A46B           B8                   0007  mov	ax,*7
36060 A46E           50                         push	ax
36061                                           ! Debug: func () void = bios_printf+0 (used reg = )
36062 A46F           E8         6535            call	_bios_printf
36063 A472           89EC                       mov	sp,bp
36064                                           !BCC_EOS
36065                                           ! 5105   write_byte(0x0040, 0x0094+drive, cyl);
36066                       0000A474            .729:
36067                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
36068 A474           8A46         06            mov	al,6[bp]
36069 A477           30E4                       xor	ah,ah
36070 A479           50                         push	ax
36071                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
36072                                           ! Debug: expression subtree swapping
36073 A47A           8A46         04            mov	al,4[bp]
36074 A47D           30E4                       xor	ah,ah
36075                                           ! Debug: list unsigned int = ax+$94 (used reg = )
36076 A47F           05                   0094  add	ax,#$94
36077 A482           50                         push	ax
36078                                           ! Debug: list int = const $40 (used reg = )
36079 A483           B8                   0040  mov	ax,*$40
36080 A486           50                         push	ax
36081                                           ! Debug: func () void = write_byte+0 (used reg = )
36082 A487           E8         6194            call	_write_byte
36083 A48A           89EC                       mov	sp,bp
36084                                           !BCC_EOS
36085                                           ! 5106 }
36086 A48C           5D                         pop	bp
36087 A48D           C3                         ret
36088                                           ! 5107   void
36089                                           ! Register BX used in function set_diskette_current_cyl
36090                                           ! 5108 determine_floppy_media(drive)
36091                                           ! 5109   Bit16u drive;
36092                                           export	_determine_floppy_media
36093                       0000A48E            _determine_floppy_media:
36094                                           !BCC_EOS
36095                                           ! 5110 {
36096                                           ! 5111 }
36097 A48E           C3                         ret
36098                                           ! 5112   void
36099                                           ! 5113 int17_function(regs, ds, iret_addr)
36100                                           ! 5114   pusha_regs_t regs;
36101                                           export	_int17_function
36102                       0000A48F            _int17_function:
36103                                           !BCC_EOS
36104                                           ! 5115   Bit16u ds;
36105                                           !BCC_EOS
36106                                           ! 5116   iret_addr_t iret_addr;
36107                                           !BCC_EOS
36108                                           ! 5117 {
36109                                           ! 5118   Bit16u addr,timeout;
36110                                           !BCC_EOS
36111                                           ! 5119   Bit8u val8;
36112                                           !BCC_EOS
36113                                           ! 5120 #asm
36114 A48F           55                         push	bp
36115 A490           89E5                       mov	bp,sp
36116 A492           83C4                   FA  add	sp,*-6
36117                                           !BCC_EOS
36118                                           !BCC_ASM
36119                       0000001A            _int17_function.ds	set	$1A
36120                       00000014            .int17_function.ds	set	$14
36121                       00000002            _int17_function.timeout	set	2
36122                       FFFFFFFC            .int17_function.timeout	set	-4
36123                       00000001            _int17_function.val8	set	1
36124                       FFFFFFFB            .int17_function.val8	set	-5
36125                       0000001C            _int17_function.iret_addr	set	$1C
36126                       00000016            .int17_function.iret_addr	set	$16
36127                       00000004            _int17_function.addr	set	4
36128                       FFFFFFFE            .int17_function.addr	set	-2
36129                       0000000A            _int17_function.regs	set	$A
36130                       00000004            .int17_function.regs	set	4
36131 A495           FB                           sti
36132                                           ! 5122 endasm
36133                                           !BCC_ENDASM
36134                                           !BCC_EOS
36135                                           ! 5123   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
36136                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
36137 A496           8B46         0E            mov	ax,$E[bp]
36138 A499           D1E0                       shl	ax,*1
36139                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
36140                                           ! Debug: list unsigned int = ax+8 (used reg = )
36141 A49B           05                   0008  add	ax,*8
36142 A49E           50                         push	ax
36143                                           ! Debug: list int = const $40 (used reg = )
36144 A49F           B8                   0040  mov	ax,*$40
36145 A4A2           50                         push	ax
36146                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36147 A4A3           E8         6165            call	_read_word
36148 A4A6           83C4                   04  add	sp,*4
36149                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
36150 A4A9           8946         FE            mov	-2[bp],ax
36151                                           !BCC_EOS
36152                                           ! 5124   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
36153                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
36154 A4AC           8A46         13            mov	al,$13[bp]
36155 A4AF           3C                     03  cmp	al,*3
36156 A4B1         0F83         0106            bhis	.72C
36157                       0000A4B5            .72F:
36158                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
36159 A4B5           8B46         0E            mov	ax,$E[bp]
36160 A4B8           3D                   0003  cmp	ax,*3
36161 A4BB         0F83         00FC            bhis	.72C
36162                       0000A4BF            .72E:
36163                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
36164 A4BF           8B46         FE            mov	ax,-2[bp]
36165 A4C2           85C0                       test	ax,ax
36166 A4C4         0F84         00F3            beq 	.72C
36167                       0000A4C8            .72D:
36168                                           ! 5125     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
36169                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
36170                                           ! Debug: expression subtree swapping
36171 A4C8           8B46         0E            mov	ax,$E[bp]
36172                                           ! Debug: list unsigned int = ax+$78 (used reg = )
36173 A4CB           05                   0078  add	ax,*$78
36174 A4CE           50                         push	ax
36175                                           ! Debug: list int = const $40 (used reg = )
36176 A4CF           B8                   0040  mov	ax,*$40
36177 A4D2           50                         push	ax
36178                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
36179 A4D3           E8         6122            call	_read_byte
36180 A4D6           83C4                   04  add	sp,*4
36181                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
36182 A4D9           30E4                       xor	ah,ah
36183 A4DB           88C4                       mov	ah,al
36184 A4DD           30C0                       xor	al,al
36185                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
36186 A4DF           8946         FC            mov	-4[bp],ax
36187                                           !BCC_EOS
36188                                           ! 5126     if (regs.u.r8.ah == 0) {
36189                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
36190 A4E2           8A46         13            mov	al,$13[bp]
36191 A4E5           84C0                       test	al,al
36192 A4E7           75           66            jne 	.730
36193                       0000A4E9            .731:
36194                                           ! 5127       outb(addr, regs.u.r8.al);
36195                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
36196 A4E9           8A46         12            mov	al,$12[bp]
36197 A4EC           30E4                       xor	ah,ah
36198 A4EE           50                         push	ax
36199                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
36200 A4EF           FF76         FE            push	-2[bp]
36201                                           ! Debug: func () void = outb+0 (used reg = )
36202 A4F2           E8         6063            call	_outb
36203 A4F5           83C4                   04  add	sp,*4
36204                                           !BCC_EOS
36205                                           ! 5128       val8 = inb(addr+2);
36206                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36207 A4F8           8B46         FE            mov	ax,-2[bp]
36208                                           ! Debug: list unsigned int = ax+2 (used reg = )
36209 A4FB           40                         inc	ax
36210 A4FC           40                         inc	ax
36211 A4FD           50                         push	ax
36212                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36213 A4FE           E8         6041            call	_inb
36214 A501           44                         inc	sp
36215 A502           44                         inc	sp
36216                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36217 A503           8846         FB            mov	-5[bp],al
36218                                           !BCC_EOS
36219                                           ! 5129       outb(addr+2, val8 | 0x01);
36220                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
36221 A506           8A46         FB            mov	al,-5[bp]
36222 A509           0C                     01  or	al,*1
36223                                           ! Debug: list unsigned char = al+0 (used reg = )
36224 A50B           30E4                       xor	ah,ah
36225 A50D           50                         push	ax
36226                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36227 A50E           8B46         FE            mov	ax,-2[bp]
36228                                           ! Debug: list unsigned int = ax+2 (used reg = )
36229 A511           40                         inc	ax
36230 A512           40                         inc	ax
36231 A513           50                         push	ax
36232                                           ! Debug: func () void = outb+0 (used reg = )
36233 A514           E8         6041            call	_outb
36234 A517           83C4                   04  add	sp,*4
36235                                           !BCC_EOS
36236                                           ! 5130 #asm
36237                                           !BCC_EOS
36238                                           !BCC_ASM
36239                       0000001A            _int17_function.ds	set	$1A
36240                       00000014            .int17_function.ds	set	$14
36241                       00000002            _int17_function.timeout	set	2
36242                       FFFFFFFC            .int17_function.timeout	set	-4
36243                       00000001            _int17_function.val8	set	1
36244                       FFFFFFFB            .int17_function.val8	set	-5
36245                       0000001C            _int17_function.iret_addr	set	$1C
36246                       00000016            .int17_function.iret_addr	set	$16
36247                       00000004            _int17_function.addr	set	4
36248                       FFFFFFFE            .int17_function.addr	set	-2
36249                       0000000A            _int17_function.regs	set	$A
36250                       00000004            .int17_function.regs	set	4
36251 A51A           90                               nop
36252                                           ! 5132 endasm
36253                                           !BCC_ENDASM
36254                                           !BCC_EOS
36255                                           ! 5133       outb(addr+2, val8 & ~0x01);
36256                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
36257 A51B           8A46         FB            mov	al,-5[bp]
36258 A51E           24                     FE  and	al,#$FE
36259                                           ! Debug: list unsigned char = al+0 (used reg = )
36260 A520           30E4                       xor	ah,ah
36261 A522           50                         push	ax
36262                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36263 A523           8B46         FE            mov	ax,-2[bp]
36264                                           ! Debug: list unsigned int = ax+2 (used reg = )
36265 A526           40                         inc	ax
36266 A527           40                         inc	ax
36267 A528           50                         push	ax
36268                                           ! Debug: func () void = outb+0 (used reg = )
36269 A529           E8         602C            call	_outb
36270 A52C           83C4                   04  add	sp,*4
36271                                           !BCC_EOS
36272                                           ! 5134       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
36273 A52F           EB           07            jmp .733
36274                       0000A531            .734:
36275                                           ! 5135         timeout--;
36276                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
36277 A531           8B46         FC            mov	ax,-4[bp]
36278 A534           48                         dec	ax
36279 A535           8946         FC            mov	-4[bp],ax
36280                                           !BCC_EOS
36281                                           ! 5136       }
36282                                           ! 5137     }
36283                       0000A538            .733:
36284                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36285 A538           8B46         FE            mov	ax,-2[bp]
36286                                           ! Debug: list unsigned int = ax+1 (used reg = )
36287 A53B           40                         inc	ax
36288 A53C           50                         push	ax
36289                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36290 A53D           E8         6002            call	_inb
36291 A540           44                         inc	sp
36292 A541           44                         inc	sp
36293                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
36294 A542           24                     40  and	al,*$40
36295                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
36296 A544           3C                     40  cmp	al,*$40
36297 A546           75           07            jne 	.735
36298                       0000A548            .736:
36299 A548           8B46         FC            mov	ax,-4[bp]
36300 A54B           85C0                       test	ax,ax
36301 A54D           75           E2            jne	.734
36302                       0000A54F            .735:
36303                       0000A54F            .732:
36304                                           ! 5138     if (regs.u.r8.ah == 1) {
36305                       0000A54F            .730:
36306                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36307 A54F           8A46         13            mov	al,$13[bp]
36308 A552           3C                     01  cmp	al,*1
36309 A554           75           37            jne 	.737
36310                       0000A556            .738:
36311                                           ! 5139       val8 = inb(addr+2);
36312                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36313 A556           8B46         FE            mov	ax,-2[bp]
36314                                           ! Debug: list unsigned int = ax+2 (used reg = )
36315 A559           40                         inc	ax
36316 A55A           40                         inc	ax
36317 A55B           50                         push	ax
36318                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36319 A55C           E8         5FE3            call	_inb
36320 A55F           44                         inc	sp
36321 A560           44                         inc	sp
36322                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36323 A561           8846         FB            mov	-5[bp],al
36324                                           !BCC_EOS
36325                                           ! 5140       outb(addr+2, val8 & ~0x04);
36326                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
36327 A564           8A46         FB            mov	al,-5[bp]
36328 A567           24                     FB  and	al,#$FB
36329                                           ! Debug: list unsigned char = al+0 (used reg = )
36330 A569           30E4                       xor	ah,ah
36331 A56B           50                         push	ax
36332                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36333 A56C           8B46         FE            mov	ax,-2[bp]
36334                                           ! Debug: list unsigned int = ax+2 (used reg = )
36335 A56F           40                         inc	ax
36336 A570           40                         inc	ax
36337 A571           50                         push	ax
36338                                           ! Debug: func () void = outb+0 (used reg = )
36339 A572           E8         5FE3            call	_outb
36340 A575           83C4                   04  add	sp,*4
36341                                           !BCC_EOS
36342                                           ! 5141 #asm
36343                                           !BCC_EOS
36344                                           !BCC_ASM
36345                       0000001A            _int17_function.ds	set	$1A
36346                       00000014            .int17_function.ds	set	$14
36347                       00000002            _int17_function.timeout	set	2
36348                       FFFFFFFC            .int17_function.timeout	set	-4
36349                       00000001            _int17_function.val8	set	1
36350                       FFFFFFFB            .int17_function.val8	set	-5
36351                       0000001C            _int17_function.iret_addr	set	$1C
36352                       00000016            .int17_function.iret_addr	set	$16
36353                       00000004            _int17_function.addr	set	4
36354                       FFFFFFFE            .int17_function.addr	set	-2
36355                       0000000A            _int17_function.regs	set	$A
36356                       00000004            .int17_function.regs	set	4
36357 A578           90                               nop
36358                                           ! 5143 endasm
36359                                           !BCC_ENDASM
36360                                           !BCC_EOS
36361                                           ! 5144       outb(addr+2, val8 | 0x04);
36362                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
36363 A579           8A46         FB            mov	al,-5[bp]
36364 A57C           0C                     04  or	al,*4
36365                                           ! Debug: list unsigned char = al+0 (used reg = )
36366 A57E           30E4                       xor	ah,ah
36367 A580           50                         push	ax
36368                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36369 A581           8B46         FE            mov	ax,-2[bp]
36370                                           ! Debug: list unsigned int = ax+2 (used reg = )
36371 A584           40                         inc	ax
36372 A585           40                         inc	ax
36373 A586           50                         push	ax
36374                                           ! Debug: func () void = outb+0 (used reg = )
36375 A587           E8         5FCE            call	_outb
36376 A58A           83C4                   04  add	sp,*4
36377                                           !BCC_EOS
36378                                           ! 5145     }
36379                                           ! 5146     val8 = inb(addr+1);
36380                       0000A58D            .737:
36381                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36382 A58D           8B46         FE            mov	ax,-2[bp]
36383                                           ! Debug: list unsigned int = ax+1 (used reg = )
36384 A590           40                         inc	ax
36385 A591           50                         push	ax
36386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36387 A592           E8         5FAD            call	_inb
36388 A595           44                         inc	sp
36389 A596           44                         inc	sp
36390                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36391 A597           8846         FB            mov	-5[bp],al
36392                                           !BCC_EOS
36393                                           ! 5147     regs.u.r8.ah = (va
36394                                           ! 5147 l8 ^ 0x48);
36395                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
36396 A59A           8A46         FB            mov	al,-5[bp]
36397 A59D           34                     48  xor	al,*$48
36398                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
36399 A59F           8846         13            mov	$13[bp],al
36400                                           !BCC_EOS
36401                                           ! 5148     if (!timeout) regs.u.r8.ah |= 0x01;
36402 A5A2           8B46         FC            mov	ax,-4[bp]
36403 A5A5           85C0                       test	ax,ax
36404 A5A7           75           08            jne 	.739
36405                       0000A5A9            .73A:
36406                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36407 A5A9           8A46         13            mov	al,$13[bp]
36408 A5AC           0C                     01  or	al,*1
36409 A5AE           8846         13            mov	$13[bp],al
36410                                           !BCC_EOS
36411                                           ! 5149     iret_addr.flags.u.r8.flagsl &= 0xfe;
36412                       0000A5B1            .739:
36413                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
36414 A5B1           8A46         1A            mov	al,$1A[bp]
36415 A5B4           24                     FE  and	al,#$FE
36416 A5B6           8846         1A            mov	$1A[bp],al
36417                                           !BCC_EOS
36418                                           ! 5150   } else {
36419 A5B9           EB           08            jmp .73B
36420                       0000A5BB            .72C:
36421                                           ! 5151     iret_addr.flags.u.r8.flagsl |= 0x01;
36422                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
36423 A5BB           8A46         1A            mov	al,$1A[bp]
36424 A5BE           0C                     01  or	al,*1
36425 A5C0           8846         1A            mov	$1A[bp],al
36426                                           !BCC_EOS
36427                                           ! 5152   }
36428                                           ! 5153 }
36429                       0000A5C3            .73B:
36430 A5C3           89EC                       mov	sp,bp
36431 A5C5           5D                         pop	bp
36432 A5C6           C3                         ret
36433                                           ! 5154 void
36434                                           ! 5155 int19_function(seq_nr)
36435                                           ! 5156 Bit16u seq_nr;
36436                                           export	_int19_function
36437                       0000A5C7            _int19_function:
36438                                           !BCC_EOS
36439                                           ! 5157 {
36440                                           ! 5158   Bit16u ebda_seg=read_word(0x0040,0x000E);
36441 A5C7           55                         push	bp
36442 A5C8           89E5                       mov	bp,sp
36443 A5CA           4C                         dec	sp
36444 A5CB           4C                         dec	sp
36445                                           ! Debug: list int = const $E (used reg = )
36446 A5CC           B8                   000E  mov	ax,*$E
36447 A5CF           50                         push	ax
36448                                           ! Debug: list int = const $40 (used reg = )
36449 A5D0           B8                   0040  mov	ax,*$40
36450 A5D3           50                         push	ax
36451                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36452 A5D4           E8         6034            call	_read_word
36453 A5D7           83C4                   04  add	sp,*4
36454                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36455 A5DA           8946         FE            mov	-2[bp],ax
36456                                           !BCC_EOS
36457                                           ! 5159   Bit16u bootdev;
36458                                           !BCC_EOS
36459                                           ! 5160   Bit8u bootdrv;
36460                                           !BCC_EOS
36461                                           ! 5161   Bit8u bootchk;
36462                                           !BCC_EOS
36463                                           ! 5162   Bit16u bootseg;
36464                                           !BCC_EOS
36465                                           ! 5163   Bit16u bootip;
36466                                           !BCC_EOS
36467                                           ! 5164   Bit16u status;
36468                                           !BCC_EOS
36469                                           ! 5165   Bit16u bootfirst;
36470                                           !BCC_EOS
36471                                           ! 5166   ipl_entry_t e;
36472                                           !BCC_EOS
36473                                           ! 5167   bootdev = inb_cmos(0x3d);
36474 A5DD           83C4                   E4  add	sp,*-$1C
36475                                           ! Debug: list int = const $3D (used reg = )
36476 A5E0           B8                   003D  mov	ax,*$3D
36477 A5E3           50                         push	ax
36478                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36479 A5E4           E8         5FA0            call	_inb_cmos
36480 A5E7           44                         inc	sp
36481 A5E8           44                         inc	sp
36482                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36483 A5E9           30E4                       xor	ah,ah
36484 A5EB           8946         FC            mov	-4[bp],ax
36485                                           !BCC_EOS
36486                                           ! 5168   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
36487                                           ! Debug: list int = const $38 (used reg = )
36488 A5EE           B8                   0038  mov	ax,*$38
36489 A5F1           50                         push	ax
36490                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36491 A5F2           E8         5F92            call	_inb_cmos
36492 A5F5           44                         inc	sp
36493 A5F6           44                         inc	sp
36494                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
36495 A5F7           24                     F0  and	al,#$F0
36496                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
36497 A5F9           30E4                       xor	ah,ah
36498 A5FB           B1                     04  mov	cl,*4
36499 A5FD           D3E0                       shl	ax,cl
36500                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36501 A5FF           0B46         FC            or	ax,-4[bp]
36502 A602           8946         FC            mov	-4[bp],ax
36503                                           !BCC_EOS
36504                                           ! 5169   bootdev >>= 4 * seq_nr;
36505                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
36506                                           ! Debug: expression subtree swapping
36507 A605           8B46         04            mov	ax,4[bp]
36508 A608           D1E0                       shl	ax,*1
36509 A60A           D1E0                       shl	ax,*1
36510                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36511 A60C           89C3                       mov	bx,ax
36512 A60E           8B46         FC            mov	ax,-4[bp]
36513 A611           89D9                       mov	cx,bx
36514 A613           D3E8                       shr	ax,cl
36515 A615           8946         FC            mov	-4[bp],ax
36516                                           !BCC_EOS
36517                                           ! 5170   bootdev &= 0xf;
36518                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
36519 A618           8A46         FC            mov	al,-4[bp]
36520 A61B           24                     0F  and	al,*$F
36521 A61D           30E4                       xor	ah,ah
36522 A61F           8946         FC            mov	-4[bp],ax
36523                                           !BCC_EOS
36524                                           ! 5171   bootfirst = read_word(0x9ff0, 0x0084);
36525                                           ! Debug: list int = const $84 (used reg = )
36526 A622           B8                   0084  mov	ax,#$84
36527 A625           50                         push	ax
36528                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36529 A626           B8                   9FF0  mov	ax,#$9FF0
36530 A629           50                         push	ax
36531                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36532 A62A           E8         5FDE            call	_read_word
36533 A62D           83C4                   04  add	sp,*4
36534                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
36535 A630           8946         F2            mov	-$E[bp],ax
36536                                           !BCC_EOS
36537                                           ! 5172   if (bootfirst != 0xFFFF) {
36538                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
36539 A633           8B46         F2            mov	ax,-$E[bp]
36540 A636           3D                   FFFF  cmp	ax,#$FFFF
36541 A639           74           2C            je  	.73C
36542                       0000A63B            .73D:
36543                                           ! 5173     bootdev = bootfirst;
36544                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
36545 A63B           8B46         F2            mov	ax,-$E[bp]
36546 A63E           8946         FC            mov	-4[bp],ax
36547                                           !BCC_EOS
36548                                           ! 5174     write_word(0x9ff0, 0x0084, 0xFFFF);
36549                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36550 A641           B8                   FFFF  mov	ax,#$FFFF
36551 A644           50                         push	ax
36552                                           ! Debug: list int = const $84 (used reg = )
36553 A645           B8                   0084  mov	ax,#$84
36554 A648           50                         push	ax
36555                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36556 A649           B8                   9FF0  mov	ax,#$9FF0
36557 A64C           50                         push	ax
36558                                           ! Debug: func () void = write_word+0 (used reg = )
36559 A64D           E8         5FE6            call	_write_word
36560 A650           83C4                   06  add	sp,*6
36561                                           !BCC_EOS
36562                                           ! 5175     write_word(0x9ff0, 0x0082, 0xFFFF);
36563                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36564 A653           B8                   FFFF  mov	ax,#$FFFF
36565 A656           50                         push	ax
36566                                           ! Debug: list int = const $82 (used reg = )
36567 A657           B8                   0082  mov	ax,#$82
36568 A65A           50                         push	ax
36569                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
36570 A65B           B8                   9FF0  mov	ax,#$9FF0
36571 A65E           50                         push	ax
36572                                           ! Debug: func () void = write_word+0 (used reg = )
36573 A65F           E8         5FD4            call	_write_word
36574 A662           83C4                   06  add	sp,*6
36575                                           !BCC_EOS
36576                                           ! 5176   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
36577 A665           EB           15            jmp .73E
36578                       0000A667            .73C:
36579                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
36580 A667           8B46         FC            mov	ax,-4[bp]
36581 A66A           85C0                       test	ax,ax
36582 A66C           75           0E            jne 	.73F
36583                       0000A66E            .740:
36584                                           ! Debug: list * char = .741+0 (used reg = )
36585 A66E           BB                   CCF1  mov	bx,#.741
36586 A671           53                         push	bx
36587                                           ! Debug: list int = const 7 (used reg = )
36588 A672           B8                   0007  mov	ax,*7
36589 A675           50                         push	ax
36590                                           ! Debug: func () void = bios_printf+0 (used reg = )
36591 A676           E8         632E            call	_bios_printf
36592 A679           83C4                   04  add	sp,*4
36593                                           !BCC_EOS
36594                                           ! 5177   bootdev -= 1;
36595                       0000A67C            .73F:
36596                       0000A67C            .73E:
36597                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
36598 A67C           8B46         FC            mov	ax,-4[bp]
36599 A67F           48                         dec	ax
36600 A680           8946         FC            mov	-4[bp],ax
36601                                           !BCC_EOS
36602                                           ! 5178   if (get_boot_vector(bootdev, &e) == 0) {
36603                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
36604 A683           8D5E         E2            lea	bx,-$1E[bp]
36605 A686           53                         push	bx
36606                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
36607 A687           FF76         FC            push	-4[bp]
36608                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
36609 A68A           E8         6D8E            call	_get_boot_vector
36610 A68D           83C4                   04  add	sp,*4
36611                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
36612 A690           84C0                       test	al,al
36613 A692           75           15            jne 	.742
36614                       0000A694            .743:
36615                                           ! 5179     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
36616                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
36617 A694           FF76         FC            push	-4[bp]
36618                                           ! Debug: list * char = .744+0 (used reg = )
36619 A697           BB                   CCD5  mov	bx,#.744
36620 A69A           53                         push	bx
36621                                           ! Debug: list int = const 4 (used reg = )
36622 A69B           B8                   0004  mov	ax,*4
36623 A69E           50                         push	ax
36624                                           ! Debug: func () void = bios_printf+0 (used reg = )
36625 A69F           E8         6305            call	_bios_printf
36626 A6A2           83C4                   06  add	sp,*6
36627                                           !BCC_EOS
36628                                           ! 5180     return;
36629 A6A5           89EC                       mov	sp,bp
36630 A6A7           5D                         pop	bp
36631 A6A8           C3                         ret
36632                                           !BCC_EOS
36633                                           ! 5181   }
36634                                           ! 5182   print_boot_device(&e);
36635                       0000A6A9            .742:
36636                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
36637 A6A9           8D5E         E2            lea	bx,-$1E[bp]
36638 A6AC           53                         push	bx
36639                                           ! Debug: func () void = print_boot_device+0 (used reg = )
36640 A6AD           E8         6FB1            call	_print_boot_device
36641 A6B0           44                         inc	sp
36642 A6B1           44                         inc	sp
36643                                           !BCC_EOS
36644                                           ! 5183   switch(e.type) {
36645 A6B2           8B46         E2            mov	ax,-$1E[bp]
36646 A6B5           E9         0119            br 	.747
36647                                           ! 5184   case 0x01:
36648                                           ! 5185   case 0x02:
36649                       0000A6B8            .748:
36650                                           ! 5186     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
36651                       0000A6B8            .749:
36652                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
36653 A6B8           8B46         E2            mov	ax,-$1E[bp]
36654 A6BB           3D                   0002  cmp	ax,*2
36655 A6BE           75           04            jne 	.74A
36656                       0000A6C0            .74B:
36657 A6C0           B0                     80  mov	al,#$80
36658 A6C2           EB           02            jmp .74C
36659                       0000A6C4            .74A:
36660 A6C4           30C0                       xor	al,al
36661                       0000A6C6            .74C:
36662                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36663 A6C6           8846         FB            mov	-5[bp],al
36664                                           !BCC_EOS
36665                                           ! 5187     bootseg = 0x07c0;
36666                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36667 A6C9           B8                   07C0  mov	ax,#$7C0
36668 A6CC           8946         F8            mov	-8[bp],ax
36669                                           !BCC_EOS
36670                                           ! 5188     status = 0;
36671                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36672 A6CF           31C0                       xor	ax,ax
36673 A6D1           8946         F4            mov	-$C[bp],ax
36674                                           !BCC_EOS
36675                                           ! 5189 #asm
36676                                           !BCC_EOS
36677                                           !BCC_ASM
36678                       00000014            _int19_function.bootip	set	$14
36679                       FFFFFFF6            .int19_function.bootip	set	-$A
36680                       00000022            _int19_function.seq_nr	set	$22
36681                       00000004            .int19_function.seq_nr	set	4
36682                       00000018            _int19_function.bootchk	set	$18
36683                       FFFFFFFA            .int19_function.bootchk	set	-6
36684                       00000016            _int19_function.bootseg	set	$16
36685                       FFFFFFF8            .int19_function.bootseg	set	-8
36686                       0000001C            _int19_function.ebda_seg	set	$1C
36687                       FFFFFFFE            .int19_function.ebda_seg	set	-2
36688                       00000012            _int19_function.status	set	$12
36689                       FFFFFFF4            .int19_function.status	set	-$C
36690                       00000010            _int19_function.bootfirst	set	$10
36691                       FFFFFFF2            .int19_function.bootfirst	set	-$E
36692                       00000019            _int19_function.bootdrv	set	$19
36693                       FFFFFFFB            .int19_function.bootdrv	set	-5
36694                       0000001A            _int19_function.bootdev	set	$1A
36695                       FFFFFFFC            .int19_function.bootdev	set	-4
36696                       00000000            _int19_function.e	set	0
36697                       FFFFFFE2            .int19_function.e	set	-$1E
36698 A6D4           55                             push bp
36699 A6D5           89E5                           mov bp, sp
36700 A6D7           50                             push ax
36701 A6D8           53                             push bx
36702 A6D9           51                             push cx
36703 A6DA           52                             push dx
36704 A6DB           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
36705 A6DE           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
36706 A6E1           8EC0                           mov es, ax ;; segment
36707 A6E3           31DB                           xor bx, bx ;; offset
36708 A6E5           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
36709 A6E7           B0                     01      mov al, #0x01 ;; read 1 sector
36710 A6E9           B5                     00      mov ch, #0x00 ;; track 0
36711 A6EB           B1                     01      mov cl, #0x01 ;; sector 1
36712 A6ED           B6                     00      mov dh, #0x00 ;; head 0
36713 A6EF           CD                     13      int #0x13 ;; read sector
36714 A6F1           73           06                jnc int19_load_done
36715 A6F3           B8                   0001      mov ax, #0x0001
36716 A6F6           8946         14                mov _int19_function.status + 2[bp], ax
36717                       0000A6F9            int19_load_done:
36718 A6F9           5A                             pop dx
36719 A6FA           59                             pop cx
36720 A6FB           5B                             pop bx
36721 A6FC           58                             pop ax
36722 A6FD           5D                             pop bp
36723                                           ! 5215 endasm
36724                                           !BCC_ENDASM
36725                                           !BCC_EOS
36726                                           ! 5216     if (status != 0) {
36727                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36728 A6FE           8B46         F4            mov	ax,-$C[bp]
36729 A701           85C0                       test	ax,ax
36730 A703           74           11            je  	.74D
36731                       0000A705            .74E:
36732                                           ! 5217       print_boot_failure(e.type, 1);
36733                                           ! Debug: list int = const 1 (used reg = )
36734 A705           B8                   0001  mov	ax,*1
36735 A708           50                         push	ax
36736                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36737 A709           FF76         E2            push	-$1E[bp]
36738                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36739 A70C           E8         7035            call	_print_boot_failure
36740 A70F           83C4                   04  add	sp,*4
36741                                           !BCC_EOS
36742                                           ! 5218       return;
36743 A712           89EC                       mov	sp,bp
36744 A714           5D                         pop	bp
36745 A715           C3                         ret
36746                                           !BCC_EOS
36747                                           ! 5219     }
36748                                           ! 5220     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
36749                       0000A716            .74D:
36750                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
36751 A716           8B46         E2            mov	ax,-$1E[bp]
36752 A719           3D                   0001  cmp	ax,*1
36753 A71C           75           0F            jne 	.750
36754                       0000A71E            .751:
36755                                           ! Debug: list int = const $38 (used reg = )
36756 A71E           B8                   0038  mov	ax,*$38
36757 A721           50                         push	ax
36758                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36759 A722           E8         5E62            call	_inb_cmos
36760 A725           44                         inc	sp
36761 A726           44                         inc	sp
36762                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36763 A727           24                     01  and	al,*1
36764 A729           84C0                       test	al,al
36765 A72B           75           22            jne 	.74F
36766                       0000A72D            .750:
36767                                           ! 5221       if (read_word(bootseg,0x1fe) != 0xaa55) {
36768                                           ! Debug: list int = const $1FE (used reg = )
36769 A72D           B8                   01FE  mov	ax,#$1FE
36770 A730           50                         push	ax
36771                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36772 A731           FF76         F8            push	-8[bp]
36773                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36774 A734           E8         5ED4            call	_read_word
36775 A737           83C4                   04  add	sp,*4
36776                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
36777 A73A           3D                   AA55  cmp	ax,#$AA55
36778 A73D           74           10            je  	.752
36779                       0000A73F            .753:
36780                                           ! 5222         print_boot_failure(e.type, 0);
36781                                           ! Debug: list int = const 0 (used reg = )
36782 A73F           31C0                       xor	ax,ax
36783 A741           50                         push	ax
36784                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36785 A742           FF76         E2            push	-$1E[bp]
36786                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36787 A745           E8         6FFC            call	_print_boot_failure
36788 A748           83C4                   04  add	sp,*4
36789                                           !BCC_EOS
36790                                           ! 5223         return;
36791 A74B           89EC                       mov	sp,bp
36792 A74D           5D                         pop	bp
36793 A74E           C3                         ret
36794                                           !BCC_EOS
36795                                           ! 5224       }
36796                                           ! 5225     }
36797                       0000A74F            .752:
36798                                           ! 5226     bootip = (bootseg & 0x0fff) << 4;
36799                       0000A74F            .74F:
36800                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36801 A74F           8B46         F8            mov	ax,-8[bp]
36802 A752           25                   0FFF  and	ax,#$FFF
36803                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36804 A755           B1                     04  mov	cl,*4
36805 A757           D3E0                       shl	ax,cl
36806                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36807 A759           8946         F6            mov	-$A[bp],ax
36808                                           !BCC_EOS
36809                                           ! 5227     bootseg &= 0xf000;
36810                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36811 A75C           8B46         F8            mov	ax,-8[bp]
36812 A75F           25                   F000  and	ax,#$F000
36813 A762           8946         F8            mov	-8[bp],ax
36814                                           !BCC_EOS
36815                                           ! 5228   break;
36816 A765           E9         0085            br 	.745
36817                                           !BCC_EOS
36818                                           ! 5229   case 0x03:
36819                                           ! 5230     status = cdrom_boot();
36820                       0000A768            .754:
36821                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
36822 A768           E8         97D0            call	_cdrom_boot
36823                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
36824 A76B           8946         F4            mov	-$C[bp],ax
36825                                           !BCC_EOS
36826                                           ! 5231     if ( (status & 0x00ff) !=0 ) {
36827                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
36828 A76E           8A46         F4            mov	al,-$C[bp]
36829                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36830 A771           84C0                       test	al,al
36831 A773           74           19            je  	.755
36832                       0000A775            .756:
36833                                           ! 5232       print_cdro
36834                                           ! 5232 mboot_failure(status);
36835                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
36836 A775           FF76         F4            push	-$C[bp]
36837                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
36838 A778           E8         702F            call	_print_cdromboot_failure
36839 A77B           44                         inc	sp
36840 A77C           44                         inc	sp
36841                                           !BCC_EOS
36842                                           ! 5233       print_boot_failure(e.type, 1);
36843                                           ! Debug: list int = const 1 (used reg = )
36844 A77D           B8                   0001  mov	ax,*1
36845 A780           50                         push	ax
36846                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36847 A781           FF76         E2            push	-$1E[bp]
36848                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36849 A784           E8         6FBD            call	_print_boot_failure
36850 A787           83C4                   04  add	sp,*4
36851                                           !BCC_EOS
36852                                           ! 5234       return;
36853 A78A           89EC                       mov	sp,bp
36854 A78C           5D                         pop	bp
36855 A78D           C3                         ret
36856                                           !BCC_EOS
36857                                           ! 5235     }
36858                                           ! 5236     bootdrv = (Bit8u)(status>>8);
36859                       0000A78E            .755:
36860                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
36861 A78E           8B46         F4            mov	ax,-$C[bp]
36862 A791           88E0                       mov	al,ah
36863 A793           30E4                       xor	ah,ah
36864                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
36865                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36866 A795           8846         FB            mov	-5[bp],al
36867                                           !BCC_EOS
36868                                           ! 5237     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
36869                                           ! Debug: list * unsigned short = const $266 (used reg = )
36870 A798           B8                   0266  mov	ax,#$266
36871 A79B           50                         push	ax
36872                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36873 A79C           FF76         FE            push	-2[bp]
36874                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36875 A79F           E8         5E69            call	_read_word
36876 A7A2           83C4                   04  add	sp,*4
36877                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36878 A7A5           8946         F8            mov	-8[bp],ax
36879                                           !BCC_EOS
36880                                           ! 5238     bootip = 0;
36881                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
36882 A7A8           31C0                       xor	ax,ax
36883 A7AA           8946         F6            mov	-$A[bp],ax
36884                                           !BCC_EOS
36885                                           ! 5239     break;
36886 A7AD           EB           3E            jmp .745
36887                                           !BCC_EOS
36888                                           ! 5240   case 0x80:
36889                                           ! 5241     bootseg = e.vector >> 16;
36890                       0000A7AF            .757:
36891                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
36892 A7AF           8B46         E6            mov	ax,-$1A[bp]
36893 A7B2           8B5E         E8            mov	bx,-$18[bp]
36894 A7B5           93                         xchg	bx,ax
36895 A7B6           31DB                       xor	bx,bx
36896                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36897 A7B8           8946         F8            mov	-8[bp],ax
36898                                           !BCC_EOS
36899                                           ! 5242     bootip = e.vector & 0xffff;
36900                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
36901                                           ! Debug: expression subtree swapping
36902 A7BB           B8                   FFFF  mov	ax,#$FFFF
36903 A7BE           31DB                       xor	bx,bx
36904 A7C0           8D7E         E6            lea	di,-$1A[bp]
36905 A7C3           E8         58F5            call	landul
36906                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36907 A7C6           8946         F6            mov	-$A[bp],ax
36908                                           !BCC_EOS
36909                                           ! 5243     break;
36910 A7C9           EB           22            jmp .745
36911                                           !BCC_EOS
36912                                           ! 5244   default: return;
36913                       0000A7CB            .758:
36914 A7CB           89EC                       mov	sp,bp
36915 A7CD           5D                         pop	bp
36916 A7CE           C3                         ret
36917                                           !BCC_EOS
36918                                           ! 5245   }
36919                                           ! 5246   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
36920 A7CF           EB           1C            jmp .745
36921                       0000A7D1            .747:
36922 A7D1           2D                   0001  sub	ax,*1
36923 A7D4         0F84         FEE0            beq 	.748
36924 A7D8           2D                   0001  sub	ax,*1
36925 A7DB         0F84         FED9            beq 	.749
36926 A7DF           2D                   0001  sub	ax,*1
36927 A7E2         0F84         FF82            beq 	.754
36928 A7E6           2D                   007D  sub	ax,*$7D
36929 A7E9           74           C4            je 	.757
36930 A7EB           EB           DE            jmp	.758
36931                       0000A7ED            .745:
36932                       FFFFFFE0            ..FFDB	=	-$20
36933                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
36934 A7ED           FF76         F6            push	-$A[bp]
36935                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36936 A7F0           FF76         F8            push	-8[bp]
36937                                           ! Debug: list * char = .759+0 (used reg = )
36938 A7F3           BB                   CCC1  mov	bx,#.759
36939 A7F6           53                         push	bx
36940                                           ! Debug: list int = const 4 (used reg = )
36941 A7F7           B8                   0004  mov	ax,*4
36942 A7FA           50                         push	ax
36943                                           ! Debug: func () void = bios_printf+0 (used reg = )
36944 A7FB           E8         61A9            call	_bios_printf
36945 A7FE           83C4                   08  add	sp,*8
36946                                           !BCC_EOS
36947                                           ! 5247 #asm
36948                                           !BCC_EOS
36949                                           !BCC_ASM
36950                       00000014            _int19_function.bootip	set	$14
36951                       FFFFFFF6            .int19_function.bootip	set	-$A
36952                       00000022            _int19_function.seq_nr	set	$22
36953                       00000004            .int19_function.seq_nr	set	4
36954                       00000018            _int19_function.bootchk	set	$18
36955                       FFFFFFFA            .int19_function.bootchk	set	-6
36956                       00000016            _int19_function.bootseg	set	$16
36957                       FFFFFFF8            .int19_function.bootseg	set	-8
36958                       0000001C            _int19_function.ebda_seg	set	$1C
36959                       FFFFFFFE            .int19_function.ebda_seg	set	-2
36960                       00000012            _int19_function.status	set	$12
36961                       FFFFFFF4            .int19_function.status	set	-$C
36962                       00000010            _int19_function.bootfirst	set	$10
36963                       FFFFFFF2            .int19_function.bootfirst	set	-$E
36964                       00000019            _int19_function.bootdrv	set	$19
36965                       FFFFFFFB            .int19_function.bootdrv	set	-5
36966                       0000001A            _int19_function.bootdev	set	$1A
36967                       FFFFFFFC            .int19_function.bootdev	set	-4
36968                       00000000            _int19_function.e	set	0
36969                       FFFFFFE2            .int19_function.e	set	-$1E
36970 A801           89E5                           mov bp, sp
36971 A803           0E                             push cs
36972 A804           68                   ADBD      push #int18_handler
36973                                               ;; Build an iret stack frame that will take us to the boot vector.
36974                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
36975 A807           9C                             pushf
36976 A808           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
36977 A80B           50                             push ax
36978 A80C           8B46         14                mov ax, _int19_function.bootip + 0[bp]
36979 A80F           50                             push ax
36980                                               ;; Set the magic number in ax and the boot drive in dl.
36981 A810           B8                   AA55      mov ax, #0xaa55
36982 A813           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
36983                                               ;; Zero some of the other registers.
36984 A816           31DB                           xor bx, bx
36985 A818           8EDB                           mov ds, bx
36986 A81A           8EC3                           mov es, bx
36987 A81C           89DD                           mov bp, bx
36988                                               ;; Go!
36989 A81E           CF                             iret
36990                                           ! 5268 endasm
36991                                           !BCC_ENDASM
36992                                           !BCC_EOS
36993                                           ! 5269 }
36994 A81F           89EC                       mov	sp,bp
36995 A821           5D                         pop	bp
36996 A822           C3                         ret
36997                                           ! 5270   void
36998                                           ! Register BX used in function int19_function
36999                                           ! 5271 int1a_function(regs, ds, iret_addr)
37000                                           ! 5272   pusha_regs_t regs;
37001                                           export	_int1a_function
37002                       0000A823            _int1a_function:
37003                                           !BCC_EOS
37004                                           ! 5273   Bit16u ds;
37005                                           !BCC_EOS
37006                                           ! 5274   iret_addr_t iret_addr;
37007                                           !BCC_EOS
37008                                           ! 5275 {
37009                                           ! 5276   Bit8u val8;
37010                                           !BCC_EOS
37011                                           ! 5277   ;
37012 A823           55                         push	bp
37013 A824           89E5                       mov	bp,sp
37014 A826           4C                         dec	sp
37015 A827           4C                         dec	sp
37016                                           !BCC_EOS
37017                                           ! 5278 #asm
37018                                           !BCC_EOS
37019                                           !BCC_ASM
37020                       00000016            _int1a_function.ds	set	$16
37021                       00000014            .int1a_function.ds	set	$14
37022                       00000001            _int1a_function.val8	set	1
37023                       FFFFFFFF            .int1a_function.val8	set	-1
37024                       00000018            _int1a_function.iret_addr	set	$18
37025                       00000016            .int1a_function.iret_addr	set	$16
37026                       00000006            _int1a_function.regs	set	6
37027                       00000004            .int1a_function.regs	set	4
37028 A828           FB                           sti
37029                                           ! 5280 endasm
37030                                           !BCC_ENDASM
37031                                           !BCC_EOS
37032                                           ! 5281   switch (regs.u.r8.ah) {
37033 A829           8A46         13            mov	al,$13[bp]
37034 A82C           E9         036F            br 	.75C
37035                                           ! 5282     case 0:
37036                                           ! 5283 #asm
37037                       0000A82F            .75D:
37038                                           !BCC_EOS
37039                                           !BCC_ASM
37040                       00000016            _int1a_function.ds	set	$16
37041                       00000014            .int1a_function.ds	set	$14
37042                       00000001            _int1a_function.val8	set	1
37043                       FFFFFFFF            .int1a_function.val8	set	-1
37044                       00000018            _int1a_function.iret_addr	set	$18
37045                       00000016            .int1a_function.iret_addr	set	$16
37046                       00000006            _int1a_function.regs	set	6
37047                       00000004            .int1a_function.regs	set	4
37048 A82F           FA                               cli
37049                                           ! 5285 endasm
37050                                           !BCC_ENDASM
37051                                           !BCC_EOS
37052                                           ! 5286       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
37053                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
37054 A830           A1         046E            mov	ax,[$46E]
37055 A833           8946         10            mov	$10[bp],ax
37056                                           !BCC_EOS
37057                                           ! 5287       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
37058                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
37059 A836           A1         046C            mov	ax,[$46C]
37060 A839           8946         0E            mov	$E[bp],ax
37061                                           !BCC_EOS
37062                                           ! 5288       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
37063                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
37064 A83C           A0         0470            mov	al,[$470]
37065 A83F           8846         12            mov	$12[bp],al
37066                                           !BCC_EOS
37067                                           ! 5289       ((bios_data_t *) 0)->midnight_flag = 0;
37068                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
37069 A842           30C0                       xor	al,al
37070 A844           A2         0470            mov	[$470],al
37071                                           !BCC_EOS
37072                                           ! 5290 #asm
37073                                           !BCC_EOS
37074                                           !BCC_ASM
37075                       00000016            _int1a_function.ds	set	$16
37076                       00000014            .int1a_function.ds	set	$14
37077                       00000001            _int1a_function.val8	set	1
37078                       FFFFFFFF            .int1a_function.val8	set	-1
37079                       00000018            _int1a_function.iret_addr	set	$18
37080                       00000016            .int1a_function.iret_addr	set	$16
37081                       00000006            _int1a_function.regs	set	6
37082                       00000004            .int1a_function.regs	set	4
37083 A847           FB                               sti
37084                                           ! 5292 endasm
37085                                           !BCC_ENDASM
37086                                           !BCC_EOS
37087                                           ! 5293       iret_addr.flags.u.r8.flagsl &= 0xfe;
37088                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37089 A848           8A46         1A            mov	al,$1A[bp]
37090 A84B           24                     FE  and	al,#$FE
37091 A84D           8846         1A            mov	$1A[bp],al
37092                                           !BCC_EOS
37093                                           ! 5294       break;
37094 A850           E9         0376            br 	.75A
37095                                           !BCC_EOS
37096                                           ! 5295     case 1:
37097                                           ! 5296 #asm
37098                       0000A853            .75E:
37099                                           !BCC_EOS
37100                                           !BCC_ASM
37101                       00000016            _int1a_function.ds	set	$16
37102                       00000014            .int1a_function.ds	set	$14
37103                       00000001            _int1a_function.val8	set	1
37104                       FFFFFFFF            .int1a_function.val8	set	-1
37105                       00000018            _int1a_function.iret_addr	set	$18
37106                       00000016            .int1a_function.iret_addr	set	$16
37107                       00000006            _int1a_function.regs	set	6
37108                       00000004            .int1a_function.regs	set	4
37109 A853           FA                               cli
37110                                           ! 5298 endasm
37111                                           !BCC_ENDASM
37112                                           !BCC_EOS
37113                                           ! 5299       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
37114                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
37115 A854           8B46         10            mov	ax,$10[bp]
37116 A857           A3         046E            mov	[$46E],ax
37117                                           !BCC_EOS
37118                                           ! 5300       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
37119                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
37120 A85A           8B46         0E            mov	ax,$E[bp]
37121 A85D           A3         046C            mov	[$46C],ax
37122                                           !BCC_EOS
37123                                           ! 5301       ((bios_data_t *) 0)->midnight_flag = 0;
37124                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
37125 A860           30C0                       xor	al,al
37126 A862           A2         0470            mov	[$470],al
37127                                           !BCC_EOS
37128                                           ! 5302 #asm
37129                                           !BCC_EOS
37130                                           !BCC_ASM
37131                       00000016            _int1a_function.ds	set	$16
37132                       00000014            .int1a_function.ds	set	$14
37133                       00000001            _int1a_function.val8	set	1
37134                       FFFFFFFF            .int1a_function.val8	set	-1
37135                       00000018            _int1a_function.iret_addr	set	$18
37136                       00000016            .int1a_function.iret_addr	set	$16
37137                       00000006            _int1a_function.regs	set	6
37138                       00000004            .int1a_function.regs	set	4
37139 A865           FB                               sti
37140                                           ! 5304 endasm
37141                                           !BCC_ENDASM
37142                                           !BCC_EOS
37143                                           ! 5305       regs.u.r8.ah = 0;
37144                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37145 A866           30C0                       xor	al,al
37146 A868           8846         13            mov	$13[bp],al
37147                                           !BCC_EOS
37148                                           ! 5306       iret_addr.flags.u.r8.flagsl &= 0xfe;
37149                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37150 A86B           8A46         1A            mov	al,$1A[bp]
37151 A86E           24                     FE  and	al,#$FE
37152 A870           8846         1A            mov	$1A[bp],al
37153                                           !BCC_EOS
37154                                           ! 5307       break;
37155 A873           E9         0353            br 	.75A
37156                                           !BCC_EOS
37157                                           ! 5308     case 2:
37158                                           ! 5309       if (rtc_updating()) {
37159                       0000A876            .75F:
37160                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37161 A876           E8         5D4B            call	_rtc_updating
37162 A879           85C0                       test	ax,ax
37163 A87B           74           0B            je  	.760
37164                       0000A87D            .761:
37165                                           ! 5310         iret_addr.flags.u.r8.flagsl |= 0x01;
37166                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37167 A87D           8A46         1A            mov	al,$1A[bp]
37168 A880           0C                     01  or	al,*1
37169 A882           8846         1A            mov	$1A[bp],al
37170                                           !BCC_EOS
37171                                           ! 5311         break;
37172 A885           E9         0341            br 	.75A
37173                                           !BCC_EOS
37174                                           ! 5312       }
37175                                           ! 5313       regs.u.r8.dh = inb_cmos(0x00);
37176                       0000A888            .760:
37177                                           ! Debug: list int = const 0 (used reg = )
37178 A888           31C0                       xor	ax,ax
37179 A88A           50                         push	ax
37180                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37181 A88B           E8         5CF9            call	_inb_cmos
37182 A88E           44                         inc	sp
37183 A88F           44                         inc	sp
37184                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37185 A890           8846         0F            mov	$F[bp],al
37186                                           !BCC_EOS
37187                                           ! 5314       regs.u.r8.cl = inb_cmos(0x02);
37188                                           ! Debug: list int = const 2 (used reg = )
37189 A893           B8                   0002  mov	ax,*2
37190 A896           50                         push	ax
37191                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37192 A897           E8         5CED            call	_inb_cmos
37193 A89A           44                         inc	sp
37194 A89B           44                         inc	sp
37195                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37196 A89C           8846         10            mov	$10[bp],al
37197                                           !BCC_EOS
37198                                           ! 5315       regs.u.r8.ch = inb_cmos(0x04);
37199                                           ! Debug: list int = const 4 (used reg = )
37200 A89F           B8                   0004  mov	ax,*4
37201 A8A2           50                         push	ax
37202                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37203 A8A3           E8         5CE1            call	_inb_cmos
37204 A8A6           44                         inc	sp
37205 A8A7           44                         inc	sp
37206                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37207 A8A8           8846         11            mov	$11[bp],al
37208                                           !BCC_EOS
37209                                           ! 5316       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
37210                                           ! Debug: list int = const $B (used reg = )
37211 A8AB           B8                   000B  mov	ax,*$B
37212 A8AE           50                         push	ax
37213                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37214 A8AF           E8         5CD5            call	_inb_cmos
37215 A8B2           44                         inc	sp
37216 A8B3           44                         inc	sp
37217                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
37218 A8B4           24                     01  and	al,*1
37219                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37220 A8B6           8846         0E            mov	$E[bp],al
37221                                           !BCC_EOS
37222                                           ! 5317       regs.u.r8.ah = 0;
37223                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37224 A8B9           30C0                       xor	al,al
37225 A8BB           8846         13            mov	$13[bp],al
37226                                           !BCC_EOS
37227                                           ! 5318       reg
37228                                           ! 5318 s.u.r8.al = regs.u.r8.ch;
37229                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37230 A8BE           8A46         11            mov	al,$11[bp]
37231 A8C1           8846         12            mov	$12[bp],al
37232                                           !BCC_EOS
37233                                           ! 5319       iret_addr.flags.u.r8.flagsl &= 0xfe;
37234                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37235 A8C4           8A46         1A            mov	al,$1A[bp]
37236 A8C7           24                     FE  and	al,#$FE
37237 A8C9           8846         1A            mov	$1A[bp],al
37238                                           !BCC_EOS
37239                                           ! 5320       break;
37240 A8CC           E9         02FA            br 	.75A
37241                                           !BCC_EOS
37242                                           ! 5321     case 3:
37243                                           ! 5322       if (rtc_updating()) {
37244                       0000A8CF            .762:
37245                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37246 A8CF           E8         5CF2            call	_rtc_updating
37247 A8D2           85C0                       test	ax,ax
37248 A8D4           74           03            je  	.763
37249                       0000A8D6            .764:
37250                                           ! 5323         init_rtc();
37251                                           ! Debug: func () void = init_rtc+0 (used reg = )
37252 A8D6           E8         5CBA            call	_init_rtc
37253                                           !BCC_EOS
37254                                           ! 5324       }
37255                                           ! 5325       outb_cmos(0x00, regs.u.r8.dh);
37256                       0000A8D9            .763:
37257                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37258 A8D9           8A46         0F            mov	al,$F[bp]
37259 A8DC           30E4                       xor	ah,ah
37260 A8DE           50                         push	ax
37261                                           ! Debug: list int = const 0 (used reg = )
37262 A8DF           31C0                       xor	ax,ax
37263 A8E1           50                         push	ax
37264                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37265 A8E2           E8         5C93            call	_outb_cmos
37266 A8E5           83C4                   04  add	sp,*4
37267                                           !BCC_EOS
37268                                           ! 5326       outb_cmos(0x02, regs.u.r8.cl);
37269                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37270 A8E8           8A46         10            mov	al,$10[bp]
37271 A8EB           30E4                       xor	ah,ah
37272 A8ED           50                         push	ax
37273                                           ! Debug: list int = const 2 (used reg = )
37274 A8EE           B8                   0002  mov	ax,*2
37275 A8F1           50                         push	ax
37276                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37277 A8F2           E8         5C83            call	_outb_cmos
37278 A8F5           83C4                   04  add	sp,*4
37279                                           !BCC_EOS
37280                                           ! 5327       outb_cmos(0x04, regs.u.r8.ch);
37281                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37282 A8F8           8A46         11            mov	al,$11[bp]
37283 A8FB           30E4                       xor	ah,ah
37284 A8FD           50                         push	ax
37285                                           ! Debug: list int = const 4 (used reg = )
37286 A8FE           B8                   0004  mov	ax,*4
37287 A901           50                         push	ax
37288                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37289 A902           E8         5C73            call	_outb_cmos
37290 A905           83C4                   04  add	sp,*4
37291                                           !BCC_EOS
37292                                           ! 5328       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
37293                                           ! Debug: expression subtree swapping
37294                                           ! Debug: list int = const $B (used reg = )
37295 A908           B8                   000B  mov	ax,*$B
37296 A90B           50                         push	ax
37297                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37298 A90C           E8         5C78            call	_inb_cmos
37299 A90F           44                         inc	sp
37300 A910           44                         inc	sp
37301                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
37302 A911           24                     60  and	al,*$60
37303                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
37304 A913           0C                     02  or	al,*2
37305 A915           50                         push	ax
37306                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
37307 A916           8A46         0E            mov	al,$E[bp]
37308 A919           24                     01  and	al,*1
37309                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
37310 A91B           0A46         FC            or	al,0+..FFDA[bp]
37311 A91E           44                         inc	sp
37312 A91F           44                         inc	sp
37313                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37314 A920           8846         FF            mov	-1[bp],al
37315                                           !BCC_EOS
37316                                           ! 5329       outb_cmos(0x0b, val8);
37317                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37318 A923           8A46         FF            mov	al,-1[bp]
37319 A926           30E4                       xor	ah,ah
37320 A928           50                         push	ax
37321                                           ! Debug: list int = const $B (used reg = )
37322 A929           B8                   000B  mov	ax,*$B
37323 A92C           50                         push	ax
37324                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37325 A92D           E8         5C48            call	_outb_cmos
37326 A930           83C4                   04  add	sp,*4
37327                                           !BCC_EOS
37328                                           ! 5330       regs.u.r8.ah = 0;
37329                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37330 A933           30C0                       xor	al,al
37331 A935           8846         13            mov	$13[bp],al
37332                                           !BCC_EOS
37333                                           ! 5331       regs.u.r8.al = val8;
37334                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37335 A938           8A46         FF            mov	al,-1[bp]
37336 A93B           8846         12            mov	$12[bp],al
37337                                           !BCC_EOS
37338                                           ! 5332       iret_addr.flags.u.r8.flagsl &= 0xfe;
37339                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37340 A93E           8A46         1A            mov	al,$1A[bp]
37341 A941           24                     FE  and	al,#$FE
37342 A943           8846         1A            mov	$1A[bp],al
37343                                           !BCC_EOS
37344                                           ! 5333       break;
37345 A946           E9         0280            br 	.75A
37346                                           !BCC_EOS
37347                                           ! 5334     case 4:
37348                                           ! 5335       regs.u.r8.ah = 0;
37349                       0000A949            .765:
37350                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37351 A949           30C0                       xor	al,al
37352 A94B           8846         13            mov	$13[bp],al
37353                                           !BCC_EOS
37354                                           ! 5336       if (rtc_updating()) {
37355                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37356 A94E           E8         5C73            call	_rtc_updating
37357 A951           85C0                       test	ax,ax
37358 A953           74           0B            je  	.766
37359                       0000A955            .767:
37360                                           ! 5337         iret_addr.flags.u.r8.flagsl |= 0x01;
37361                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37362 A955           8A46         1A            mov	al,$1A[bp]
37363 A958           0C                     01  or	al,*1
37364 A95A           8846         1A            mov	$1A[bp],al
37365                                           !BCC_EOS
37366                                           ! 5338         break;
37367 A95D           E9         0269            br 	.75A
37368                                           !BCC_EOS
37369                                           ! 5339       }
37370                                           ! 5340       regs.u.r8.cl = inb_cmos(0x09);
37371                       0000A960            .766:
37372                                           ! Debug: list int = const 9 (used reg = )
37373 A960           B8                   0009  mov	ax,*9
37374 A963           50                         push	ax
37375                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37376 A964           E8         5C20            call	_inb_cmos
37377 A967           44                         inc	sp
37378 A968           44                         inc	sp
37379                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37380 A969           8846         10            mov	$10[bp],al
37381                                           !BCC_EOS
37382                                           ! 5341       regs.u.r8.dh = inb_cmos(0x08);
37383                                           ! Debug: list int = const 8 (used reg = )
37384 A96C           B8                   0008  mov	ax,*8
37385 A96F           50                         push	ax
37386                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37387 A970           E8         5C14            call	_inb_cmos
37388 A973           44                         inc	sp
37389 A974           44                         inc	sp
37390                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37391 A975           8846         0F            mov	$F[bp],al
37392                                           !BCC_EOS
37393                                           ! 5342       regs.u.r8.dl = inb_cmos(0x07);
37394                                           ! Debug: list int = const 7 (used reg = )
37395 A978           B8                   0007  mov	ax,*7
37396 A97B           50                         push	ax
37397                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37398 A97C           E8         5C08            call	_inb_cmos
37399 A97F           44                         inc	sp
37400 A980           44                         inc	sp
37401                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37402 A981           8846         0E            mov	$E[bp],al
37403                                           !BCC_EOS
37404                                           ! 5343       regs.u.r8.ch = inb_cmos(0x32);
37405                                           ! Debug: list int = const $32 (used reg = )
37406 A984           B8                   0032  mov	ax,*$32
37407 A987           50                         push	ax
37408                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37409 A988           E8         5BFC            call	_inb_cmos
37410 A98B           44                         inc	sp
37411 A98C           44                         inc	sp
37412                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37413 A98D           8846         11            mov	$11[bp],al
37414                                           !BCC_EOS
37415                                           ! 5344       regs.u.r8.al = regs.u.r8.ch;
37416                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37417 A990           8A46         11            mov	al,$11[bp]
37418 A993           8846         12            mov	$12[bp],al
37419                                           !BCC_EOS
37420                                           ! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
37421                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37422 A996           8A46         1A            mov	al,$1A[bp]
37423 A999           24                     FE  and	al,#$FE
37424 A99B           8846         1A            mov	$1A[bp],al
37425                                           !BCC_EOS
37426                                           ! 5346       break;
37427 A99E           E9         0228            br 	.75A
37428                                           !BCC_EOS
37429                                           ! 5347     case 5:
37430                                           ! 5348       if (rtc_updating()) {
37431                       0000A9A1            .768:
37432                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37433 A9A1           E8         5C20            call	_rtc_updating
37434 A9A4           85C0                       test	ax,ax
37435 A9A6           74           0E            je  	.769
37436                       0000A9A8            .76A:
37437                                           ! 5349         init_rtc();
37438                                           ! Debug: func () void = init_rtc+0 (used reg = )
37439 A9A8           E8         5BE8            call	_init_rtc
37440                                           !BCC_EOS
37441                                           ! 5350         iret_addr.flags.u.r8.flagsl |= 0x01;
37442                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37443 A9AB           8A46         1A            mov	al,$1A[bp]
37444 A9AE           0C                     01  or	al,*1
37445 A9B0           8846         1A            mov	$1A[bp],al
37446                                           !BCC_EOS
37447                                           ! 5351         break;
37448 A9B3           E9         0213            br 	.75A
37449                                           !BCC_EOS
37450                                           ! 5352         }
37451                                           ! 5353       outb_cmos(0x09, regs.u.r8.cl);
37452                       0000A9B6            .769:
37453                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37454 A9B6           8A46         10            mov	al,$10[bp]
37455 A9B9           30E4                       xor	ah,ah
37456 A9BB           50                         push	ax
37457                                           ! Debug: list int = const 9 (used reg = )
37458 A9BC           B8                   0009  mov	ax,*9
37459 A9BF           50                         push	ax
37460                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37461 A9C0           E8         5BB5            call	_outb_cmos
37462 A9C3           83C4                   04  add	sp,*4
37463                                           !BCC_EOS
37464                                           ! 5354       outb_cmos(0x08, regs.u.r8.dh);
37465                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37466 A9C6           8A46         0F            mov	al,$F[bp]
37467 A9C9           30E4                       xor	ah,ah
37468 A9CB           50                         push	ax
37469                                           ! Debug: list int = const 8 (used reg = )
37470 A9CC           B8                   0008  mov	ax,*8
37471 A9CF           50                         push	ax
37472                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37473 A9D0           E8         5BA5            call	_outb_cmos
37474 A9D3           83C4                   04  add	sp,*4
37475                                           !BCC_EOS
37476                                           ! 5355       outb_cmos(0x07, regs.u.r8.dl);
37477                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
37478 A9D6           8A46         0E            mov	al,$E[bp]
37479 A9D9           30E4                       xor	ah,ah
37480 A9DB           50                         push	ax
37481                                           ! Debug: list int = const 7 (used reg = )
37482 A9DC           B8                   0007  mov	ax,*7
37483 A9DF           50                         push	ax
37484                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37485 A9E0           E8         5B95            call	_outb_cmos
37486 A9E3           83C4                   04  add	sp,*4
37487                                           !BCC_EOS
37488                                           ! 5356       outb_cmos(0x32, regs.u.r8.ch);
37489                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37490 A9E6           8A46         11            mov	al,$11[bp]
37491 A9E9           30E4                       xor	ah,ah
37492 A9EB           50                         push	ax
37493                                           ! Debug: list int = const $32 (used reg = )
37494 A9EC           B8                   0032  mov	ax,*$32
37495 A9EF           50                         push	ax
37496                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37497 A9F0           E8         5B85            call	_outb_cmos
37498 A9F3           83C4                   04  add	sp,*4
37499                                           !BCC_EOS
37500                                           ! 5357       val8 = inb_cmos(0x0b) & 0x7f;
37501                                           ! Debug: list int = const $B (used reg = )
37502 A9F6           B8                   000B  mov	ax,*$B
37503 A9F9           50                         push	ax
37504                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37505 A9FA           E8         5B8A            call	_inb_cmos
37506 A9FD           44                         inc	sp
37507 A9FE           44                         inc	sp
37508                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
37509 A9FF           24                     7F  and	al,*$7F
37510                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37511 AA01           8846         FF            mov	-1[bp],al
37512                                           !BCC_EOS
37513                                           ! 5358       outb_cmos(0x0b, val8);
37514                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37515 AA04           8A46         FF            mov	al,-1[bp]
37516 AA07           30E4                       xor	ah,ah
37517 AA09           50                         push	ax
37518                                           ! Debug: list int = const $B (used reg = )
37519 AA0A           B8                   000B  mov	ax,*$B
37520 AA0D           50                         push	ax
37521                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37522 AA0E           E8         5B67            call	_outb_cmos
37523 AA11           83C4                   04  add	sp,*4
37524                                           !BCC_EOS
37525                                           ! 5359       regs.u.r8.ah = 0;
37526                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37527 AA14           30C0                       xor	al,al
37528 AA16           8846         13            mov	$13[bp],al
37529                                           !BCC_EOS
37530                                           ! 5360       regs.u.r8.al = val8;
37531                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37532 AA19           8A46         FF            mov	al,-1[bp]
37533 AA1C           8846         12            mov	$12[bp],al
37534                                           !BCC_EOS
37535                                           ! 5361       iret_addr.flags.u.r8.flagsl &= 0xfe;
37536                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37537 AA1F           8A46         1A            mov	al,$1A[bp]
37538 AA22           24                     FE  and	al,#$FE
37539 AA24           8846         1A            mov	$1A[bp],al
37540                                           !BCC_EOS
37541                                           ! 5362       break;
37542 AA27           E9         019F            br 	.75A
37543                                           !BCC_EOS
37544                                           ! 5363     case 6:
37545                                           ! 5364       val8 = inb_cmos(0x0b);
37546                       0000AA2A            .76B:
37547                                           ! Debug: list int = const $B (used reg = )
37548 AA2A           B8                   000B  mov	ax,*$B
37549 AA2D           50                         push	ax
37550                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37551 AA2E           E8         5B56            call	_inb_cmos
37552 AA31           44                         inc	sp
37553 AA32           44                         inc	sp
37554                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37555 AA33           8846         FF            mov	-1[bp],al
37556                                           !BCC_EOS
37557                                           ! 5365       regs.u.r16.ax = 0;
37558                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
37559 AA36           31C0                       xor	ax,ax
37560 AA38           8946         12            mov	$12[bp],ax
37561                                           !BCC_EOS
37562                                           ! 5366       if (val8 & 0x20) {
37563                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
37564 AA3B           8A46         FF            mov	al,-1[bp]
37565 AA3E           24                     20  and	al,*$20
37566 AA40           84C0                       test	al,al
37567 AA42           74           0B            je  	.76C
37568                       0000AA44            .76D:
37569                                           ! 5367         iret_addr.flags.u.r8.flagsl |= 0x01;
37570                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37571 AA44           8A46         1A            mov	al,$1A[bp]
37572 AA47           0C                     01  or	al,*1
37573 AA49           8846         1A            mov	$1A[bp],al
37574                                           !BCC_EOS
37575                                           ! 5368         break;
37576 AA4C           E9         017A            br 	.75A
37577                                           !BCC_EOS
37578                                           ! 5369       }
37579                                           ! 5370       if (rtc_updating()) {
37580                       0000AA4F            .76C:
37581                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37582 AA4F           E8         5B72            call	_rtc_updating
37583 AA52           85C0                       test	ax,ax
37584 AA54           74           03            je  	.76E
37585                       0000AA56            .76F:
37586                                           ! 5371         init_rtc();
37587                                           ! Debug: func () void = init_rtc+0 (used reg = )
37588 AA56           E8         5B3A            call	_init_rtc
37589                                           !BCC_EOS
37590                                           ! 5372       }
37591                                           ! 5373       outb_cmos(0x01, regs.u.r8.dh);
37592                       0000AA59            .76E:
37593                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37594 AA59           8A46         0F            mov	al,$F[bp]
37595 AA5C           30E4                       xor	ah,ah
37596 AA5E           50                         push	ax
37597                                           ! Debug: list int = const 1 (used reg = )
37598 AA5F           B8                   0001  mov	ax,*1
37599 AA62           50                         push	ax
37600                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37601 AA63           E8         5B12            call	_outb_cmos
37602 AA66           83C4                   04  add	sp,*4
37603                                           !BCC_EOS
37604                                           ! 5374       outb_cmos(0x03, regs.u.r8.cl);
37605                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37606 AA69           8A46         10            mov	al,$10[bp]
37607 AA6C           30E4                       xor	ah,ah
37608 AA6E           50                         push	ax
37609                                           ! Debug: list int = const 3 (used reg = )
37610 AA6F           B8                   0003  mov	ax,*3
37611 AA72           50                         push	ax
37612                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37613 AA73           E8         5B02            call	_outb_cmos
37614 AA76           83C4                   04  add	sp,*4
37615                                           !BCC_EOS
37616                                           ! 5375       outb_cmos(0x05, regs.u.r8.ch);
37617                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37618 AA79           8A46         11            mov	al,$11[bp]
37619 AA7C           30E4                       xor	ah,ah
37620 AA7E           50                         push	ax
37621                                           ! Debug: list int = const 5 (used reg = )
37622 AA7F           B8                   0005  mov	ax,*5
37623 AA82           50                         push	ax
37624                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37625 AA83           E8         5AF2            call	_outb_cmos
37626 AA86           83C4                   04  add	sp,*4
37627                                           !BCC_EOS
37628                                           ! 5376       outb(0xa1, inb(0xa1) & 0xfe);
37629                                           ! Debug: list int = const $A1 (used reg = )
37630 AA89           B8                   00A1  mov	ax,#$A1
37631 AA8C           50                         push	ax
37632                                           ! Debug: func () unsigned char = inb+0 (used reg = )
37633 AA8D           E8         5AB2            call	_inb
37634 AA90           44                         inc	sp
37635 AA91           44                         inc	sp
37636                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
37637 AA92           24                     FE  and	al,#$FE
37638                                           ! Debug: list unsigned char = al+0 (used reg = )
37639 AA94           30E4                       xor	ah,ah
37640 AA96           50                         push	ax
37641                                           ! Debug: list int = const $A1 (used reg = )
37642 AA97           B8                   00A1  mov	ax,#$A1
37643 AA9A           50                         push	ax
37644                                           ! Debug: func () void = outb+0 (used reg = )
37645 AA9B           E8         5ABA            call	_outb
37646 AA9E           83C4                   04  add	sp,*4
37647                                           !BCC_EOS
37648                                           ! 5377       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
37649                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
37650 AAA1           8A46         FF            mov	al,-1[bp]
37651 AAA4           24                     7F  and	al,*$7F
37652                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
37653 AAA6           0C                     20  or	al,*$20
37654                                           ! Debug: list unsigned char = al+0 (used reg = )
37655 AAA8           30E4                       xor	ah,ah
37656 AAAA           50                         push	ax
37657                                           ! Debug: list int = const $B (used reg = )
37658 AAAB           B8                   000B  mov	ax,*$B
37659 AAAE           50                         push	ax
37660                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37661 AAAF           E8         5AC6            call	_outb_cmos
37662 AAB2           83C4                   04  add	sp,*4
37663                                           !BCC_EOS
37664                                           ! 5378       iret_addr.flags.u.r8.flagsl &= 0xfe;
37665                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37666 AAB5           8A46         1A            mov	al,$1A[bp]
37667 AAB8           24                     FE  and	al,#$FE
37668 AABA           8846         1A            mov	$1A[bp],al
37669                                           !BCC_EOS
37670                                           ! 5379       break;
37671 AABD           E9         0109            br 	.75A
37672                                           !BCC_EOS
37673                                           ! 5380     case 7:
37674                                           ! 5381       val8 = inb_cmos(0x0b);
37675                       0000AAC0            .770:
37676                                           ! Debug: list int = const $B (used reg = )
37677 AAC0           B8                   000B  mov	ax,*$B
37678 AAC3           50                         push	ax
37679                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37680 AAC4           E8         5AC0            call	_inb_cmos
37681 AAC7           44                         inc	sp
37682 AAC8           44                         inc	sp
37683                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37684 AAC9           8846         FF            mov	-1[bp],al
37685                                           !BCC_EOS
37686                                           ! 5382       outb_cmos(0x0b, val8 & 0x57);
37687                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
37688 AACC           8A46         FF            mov	al,-1[bp]
37689 AACF           24                     57  and	al,*$57
37690                                           ! Debug: list unsigned char = al+0 (used reg = )
37691 AAD1           30E4                       xor	ah,ah
37692 AAD3           50                         push	ax
37693                                           ! Debug: list int = const $B (used reg = )
37694 AAD4           B8                   000B  mov	ax,*$B
37695 AAD7           50                         push	ax
37696                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37697 AAD8           E8         5A9D            call	_outb_cmos
37698 AADB           83C4                   04  add	sp,*4
37699                                           !BCC_EOS
37700                                           ! 5383       regs.u.r8.ah = 0;
37701                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37702 AADE           30C0                       xor	al,al
37703 AAE0           8846         13            mov	$13[bp],al
37704                                           !BCC_EOS
37705                                           ! 5384       regs.u.r8.al = val8;
37706                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37707 AAE3           8A46         FF            mov	al,-1[bp]
37708 AAE6           8846         12            mov	$12[bp],al
37709                                           !BCC_EOS
37710                                           ! 5385       iret_addr.flags.u.r8.flagsl &= 0xfe;
37711                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37712 AAE9           8A46         1A            mov	al,$1A[bp]
37713 AAEC           24                     FE  and	al,#$FE
37714 AAEE           8846         1A            mov	$1A[bp],al
37715                                           !BCC_EOS
37716                                           ! 5386       break;
37717 AAF1           E9         00D5            br 	.75A
37718                                           !BCC_EOS
37719                                           ! 5387     case 0xb1:
37720                                           ! 5388       if (regs.u.r8.bl == 0xff) {
37721                       0000AAF4            .771:
37722                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
37723 AAF4           8A46         0C            mov	al,$C[bp]
37724 AAF7           3C                     FF  cmp	al,#$FF
37725 AAF9           75           11            jne 	.772
37726                       0000AAFB            .773:
37727                                           ! 5389         bios_printf(4, "PCI BIOS: PCI not present\n");
37728                                           ! Debug: list * char = .774+0 (used reg = )
37729 AAFB           BB                   CCA6  mov	bx,#.774
37730 AAFE           53                         push	bx
37731                                           ! Debug: list int = const 4 (used reg = )
37732 AAFF           B8                   0004  mov	ax,*4
37733 AB02           50                         push	ax
37734                                           ! Debug: func () void = bios_printf+0 (used reg = )
37735 AB03           E8         5EA1            call	_bios_printf
37736 AB06           83C4                   04  add	sp,*4
37737                                           !BCC_EOS
37738                                           ! 5390       } el
37739                                           ! 5390 se if (regs.u.r8.bl == 0x81) {
37740 AB09           E9         0078            br 	.775
37741                       0000AB0C            .772:
37742                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
37743 AB0C           8A46         0C            mov	al,$C[bp]
37744 AB0F           3C                     81  cmp	al,#$81
37745 AB11           75           16            jne 	.776
37746                       0000AB13            .777:
37747                                           ! 5391         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
37748                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
37749 AB13           8A46         12            mov	al,$12[bp]
37750 AB16           30E4                       xor	ah,ah
37751 AB18           50                         push	ax
37752                                           ! Debug: list * char = .778+0 (used reg = )
37753 AB19           BB                   CC80  mov	bx,#.778
37754 AB1C           53                         push	bx
37755                                           ! Debug: list int = const 4 (used reg = )
37756 AB1D           B8                   0004  mov	ax,*4
37757 AB20           50                         push	ax
37758                                           ! Debug: func () void = bios_printf+0 (used reg = )
37759 AB21           E8         5E83            call	_bios_printf
37760 AB24           83C4                   06  add	sp,*6
37761                                           !BCC_EOS
37762                                           ! 5392       } else if (regs.u.r8.bl == 0x83) {
37763 AB27           EB           5B            jmp .779
37764                       0000AB29            .776:
37765                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
37766 AB29           8A46         0C            mov	al,$C[bp]
37767 AB2C           3C                     83  cmp	al,#$83
37768 AB2E           75           13            jne 	.77A
37769                       0000AB30            .77B:
37770                                           ! 5393         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
37771                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
37772 AB30           FF76         0E            push	$E[bp]
37773                                           ! Debug: list * char = .77C+0 (used reg = )
37774 AB33           BB                   CC68  mov	bx,#.77C
37775 AB36           53                         push	bx
37776                                           ! Debug: list int = const 4 (used reg = )
37777 AB37           B8                   0004  mov	ax,*4
37778 AB3A           50                         push	ax
37779                                           ! Debug: func () void = bios_printf+0 (used reg = )
37780 AB3B           E8         5E69            call	_bios_printf
37781 AB3E           83C4                   06  add	sp,*6
37782                                           !BCC_EOS
37783                                           ! 5394       } else if (regs.u.r8.bl == 0x86) {
37784 AB41           EB           41            jmp .77D
37785                       0000AB43            .77A:
37786                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
37787 AB43           8A46         0C            mov	al,$C[bp]
37788 AB46           3C                     86  cmp	al,#$86
37789 AB48           75           3A            jne 	.77E
37790                       0000AB4A            .77F:
37791                                           ! 5395         if (regs.u.r8.al == 0x02) {
37792                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
37793 AB4A           8A46         12            mov	al,$12[bp]
37794 AB4D           3C                     02  cmp	al,*2
37795 AB4F           75           19            jne 	.780
37796                       0000AB51            .781:
37797                                           ! 5396           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
37798                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37799 AB51           FF76         06            push	6[bp]
37800                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
37801 AB54           FF76         10            push	$10[bp]
37802                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
37803 AB57           FF76         0E            push	$E[bp]
37804                                           ! Debug: list * char = .782+0 (used reg = )
37805 AB5A           BB                   CC3C  mov	bx,#.782
37806 AB5D           53                         push	bx
37807                                           ! Debug: list int = const 4 (used reg = )
37808 AB5E           B8                   0004  mov	ax,*4
37809 AB61           50                         push	ax
37810                                           ! Debug: func () void = bios_printf+0 (used reg = )
37811 AB62           E8         5E42            call	_bios_printf
37812 AB65           83C4                   0A  add	sp,*$A
37813                                           !BCC_EOS
37814                                           ! 5397         } else {
37815 AB68           EB           1A            jmp .783
37816                       0000AB6A            .780:
37817                                           ! 5398           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
37818                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37819 AB6A           FF76         06            push	6[bp]
37820                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
37821 AB6D           FF76         0E            push	$E[bp]
37822                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
37823 AB70           8A46         10            mov	al,$10[bp]
37824 AB73           30E4                       xor	ah,ah
37825 AB75           50                         push	ax
37826                                           ! Debug: list * char = .784+0 (used reg = )
37827 AB76           BB                   CC00  mov	bx,#.784
37828 AB79           53                         push	bx
37829                                           ! Debug: list int = const 4 (used reg = )
37830 AB7A           B8                   0004  mov	ax,*4
37831 AB7D           50                         push	ax
37832                                           ! Debug: func () void = bios_printf+0 (used reg = )
37833 AB7E           E8         5E26            call	_bios_printf
37834 AB81           83C4                   0A  add	sp,*$A
37835                                           !BCC_EOS
37836                                           ! 5399         }
37837                                           ! 5400       }
37838                       0000AB84            .783:
37839                                           ! 5401       regs.u.r8.ah = regs.u.r8.bl;
37840                       0000AB84            .77E:
37841                       0000AB84            .77D:
37842                       0000AB84            .779:
37843                       0000AB84            .775:
37844                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
37845 AB84           8A46         0C            mov	al,$C[bp]
37846 AB87           8846         13            mov	$13[bp],al
37847                                           !BCC_EOS
37848                                           ! 5402       iret_addr.flags.u.r8.flagsl |= 0x01;
37849                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37850 AB8A           8A46         1A            mov	al,$1A[bp]
37851 AB8D           0C                     01  or	al,*1
37852 AB8F           8846         1A            mov	$1A[bp],al
37853                                           !BCC_EOS
37854                                           ! 5403       break;
37855 AB92           EB           35            jmp .75A
37856                                           !BCC_EOS
37857                                           ! 5404     default:
37858                                           ! 5405       iret_addr.flags.u.r8.flagsl |= 0x01;
37859                       0000AB94            .785:
37860                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37861 AB94           8A46         1A            mov	al,$1A[bp]
37862 AB97           0C                     01  or	al,*1
37863 AB99           8846         1A            mov	$1A[bp],al
37864                                           !BCC_EOS
37865                                           ! 5406   }
37866                                           ! 5407 }
37867 AB9C           EB           2B            jmp .75A
37868                       0000AB9E            .75C:
37869 AB9E           2C                     00  sub	al,*0
37870 ABA0           72           F2            jb 	.785
37871 ABA2           3C                     07  cmp	al,*7
37872 ABA4           77           1B            ja  	.786
37873 ABA6           30E4                       xor	ah,ah
37874 ABA8           D1E0                       shl	ax,*1
37875 ABAA           89C3                       mov	bx,ax
37876 ABAC           2E                         seg	cs
37877 ABAD           FFA7       ABB1            br	.787[bx]
37878                       0000ABB1            .787:
37879 ABB1                      A82F            .word	.75D
37880 ABB3                      A853            .word	.75E
37881 ABB5                      A876            .word	.75F
37882 ABB7                      A8CF            .word	.762
37883 ABB9                      A949            .word	.765
37884 ABBB                      A9A1            .word	.768
37885 ABBD                      AA2A            .word	.76B
37886 ABBF                      AAC0            .word	.770
37887                       0000ABC1            .786:
37888 ABC1           2C                     B1  sub	al,#$B1
37889 ABC3         0F84         FF2D            beq 	.771
37890 ABC7           EB           CB            jmp	.785
37891                       0000ABC9            .75A:
37892                       FFFFFFFC            ..FFDA	=	-4
37893 ABC9           89EC                       mov	sp,bp
37894 ABCB           5D                         pop	bp
37895 ABCC           C3                         ret
37896                                           ! 5408   void
37897                                           ! Register BX used in function int1a_function
37898                                           ! 5409 int70_function(regs, ds, iret_addr)
37899                                           ! 5410   pusha_regs_t regs;
37900                                           export	_int70_function
37901                       0000ABCD            _int70_function:
37902                                           !BCC_EOS
37903                                           ! 5411   Bit16u ds;
37904                                           !BCC_EOS
37905                                           ! 5412   iret_addr_t iret_addr;
37906                                           !BCC_EOS
37907                                           ! 5413 {
37908                                           ! 5414   Bit8u registerB = 0, registerC = 0;
37909 ABCD           55                         push	bp
37910 ABCE           89E5                       mov	bp,sp
37911 ABD0           4C                         dec	sp
37912                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
37913 ABD1           30C0                       xor	al,al
37914 ABD3           8846         FF            mov	-1[bp],al
37915 ABD6           4C                         dec	sp
37916                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
37917 ABD7           30C0                       xor	al,al
37918 ABD9           8846         FE            mov	-2[bp],al
37919                                           !BCC_EOS
37920                                           ! 5415   registerB = inb_cmos( 0xB );
37921                                           ! Debug: list int = const $B (used reg = )
37922 ABDC           B8                   000B  mov	ax,*$B
37923 ABDF           50                         push	ax
37924                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37925 ABE0           E8         59A4            call	_inb_cmos
37926 ABE3           44                         inc	sp
37927 ABE4           44                         inc	sp
37928                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
37929 ABE5           8846         FF            mov	-1[bp],al
37930                                           !BCC_EOS
37931                                           ! 5416   registerC = inb_cmos( 0xC );
37932                                           ! Debug: list int = const $C (used reg = )
37933 ABE8           B8                   000C  mov	ax,*$C
37934 ABEB           50                         push	ax
37935                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37936 ABEC           E8         5998            call	_inb_cmos
37937 ABEF           44                         inc	sp
37938 ABF0           44                         inc	sp
37939                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
37940 ABF1           8846         FE            mov	-2[bp],al
37941                                           !BCC_EOS
37942                                           ! 5417   if( ( registerB & 0x60 ) != 0 ) {
37943                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
37944 ABF4           8A46         FF            mov	al,-1[bp]
37945 ABF7           24                     60  and	al,*$60
37946                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37947 ABF9           84C0                       test	al,al
37948 ABFB         0F84         00EF            beq 	.788
37949                       0000ABFF            .789:
37950                                           ! 5418     if( ( registerC & 0x20 ) != 0 ) {
37951                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
37952 ABFF           8A46         FE            mov	al,-2[bp]
37953 AC02           24                     20  and	al,*$20
37954                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37955 AC04           84C0                       test	al,al
37956 AC06           74           04            je  	.78A
37957                       0000AC08            .78B:
37958                                           ! 5419 #asm
37959                                           !BCC_EOS
37960                                           !BCC_ASM
37961                       00000000            _int70_function.registerC	set	0
37962                       FFFFFFFE            .int70_function.registerC	set	-2
37963                       00000016            _int70_function.ds	set	$16
37964                       00000014            .int70_function.ds	set	$14
37965                       00000001            _int70_function.registerB	set	1
37966                       FFFFFFFF            .int70_function.registerB	set	-1
37967                       00000018            _int70_function.iret_addr	set	$18
37968                       00000016            .int70_function.iret_addr	set	$16
37969                       00000006            _int70_function.regs	set	6
37970                       00000004            .int70_function.regs	set	4
37971 AC08           FB                               sti
37972 AC09           CD                     4A        int #0x4a
37973 AC0B           FA                               cli
37974                                           ! 5423 endasm
37975                                           !BCC_ENDASM
37976                                           !BCC_EOS
37977                                           ! 5424     }
37978                                           ! 5425     if( ( registerC & 0x40 ) != 0 ) {
37979                       0000AC0C            .78A:
37980                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
37981 AC0C           8A46         FE            mov	al,-2[bp]
37982 AC0F           24                     40  and	al,*$40
37983                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37984 AC11           84C0                       test	al,al
37985 AC13         0F84         00D7            beq 	.78C
37986                       0000AC17            .78D:
37987                                           ! 5426       if( read_byte( 0x40, 0xA0 ) != 0 ) {
37988                                           ! Debug: list int = const $A0 (used reg = )
37989 AC17           B8                   00A0  mov	ax,#$A0
37990 AC1A           50                         push	ax
37991                                           ! Debug: list int = const $40 (used reg = )
37992 AC1B           B8                   0040  mov	ax,*$40
37993 AC1E           50                         push	ax
37994                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37995 AC1F           E8         59D6            call	_read_byte
37996 AC22           83C4                   04  add	sp,*4
37997                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37998 AC25           84C0                       test	al,al
37999 AC27         0F84         00C3            beq 	.78E
38000                       0000AC2B            .78F:
38001                                           ! 5427         Bit32u time, toggle;
38002                                           !BCC_EOS
38003                                           ! 5428         time = read_dword( 0x40, 0x9C );
38004 AC2B           83C4                   F8  add	sp,*-8
38005                                           ! Debug: list int = const $9C (used reg = )
38006 AC2E           B8                   009C  mov	ax,#$9C
38007 AC31           50                         push	ax
38008                                           ! Debug: list int = const $40 (used reg = )
38009 AC32           B8                   0040  mov	ax,*$40
38010 AC35           50                         push	ax
38011                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
38012 AC36           E8         544A            call	_read_dword
38013 AC39           89D3                       mov	bx,dx
38014 AC3B           83C4                   04  add	sp,*4
38015                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
38016 AC3E           8946         FA            mov	-6[bp],ax
38017 AC41           895E         FC            mov	-4[bp],bx
38018                                           !BCC_EOS
38019                                           ! 5429         if( time < 0x3D1 ) {
38020                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
38021 AC44           B8                   03D1  mov	ax,#$3D1
38022 AC47           31DB                       xor	bx,bx
38023 AC49           8D7E         FA            lea	di,-6[bp]
38024 AC4C           E8         547C            call	lcmpul
38025 AC4F           76           6A            jbe 	.790
38026                       0000AC51            .791:
38027                                           ! 5430           Bit16u segment, offset;
38028                                           !BCC_EOS
38029                                           ! 5431           segment = read_word( 0x40, 0x98 );
38030 AC51           83C4                   FC  add	sp,*-4
38031                                           ! Debug: list int = const $98 (used reg = )
38032 AC54           B8                   0098  mov	ax,#$98
38033 AC57           50                         push	ax
38034                                           ! Debug: list int = const $40 (used reg = )
38035 AC58           B8                   0040  mov	ax,*$40
38036 AC5B           50                         push	ax
38037                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
38038 AC5C           E8         59AC            call	_read_word
38039 AC5F           83C4                   04  add	sp,*4
38040                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
38041 AC62           8946         F4            mov	-$C[bp],ax
38042                                           !BCC_EOS
38043                                           ! 5432           offset = read_word( 0x40, 0x9A );
38044                                           ! Debug: list int = const $9A (used reg = )
38045 AC65           B8                   009A  mov	ax,#$9A
38046 AC68           50                         push	ax
38047                                           ! Debug: list int = const $40 (used reg = )
38048 AC69           B8                   0040  mov	ax,*$40
38049 AC6C           50                         push	ax
38050                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
38051 AC6D           E8         599B            call	_read_word
38052 AC70           83C4                   04  add	sp,*4
38053                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
38054 AC73           8946         F2            mov	-$E[bp],ax
38055                                           !BCC_EOS
38056                                           ! 5433           write_byte( 0x40, 0xA0, 0 );
38057                                           ! Debug: list int = const 0 (used reg = )
38058 AC76           31C0                       xor	ax,ax
38059 AC78           50                         push	ax
38060                                           ! Debug: list int = const $A0 (used reg = )
38061 AC79           B8                   00A0  mov	ax,#$A0
38062 AC7C           50                         push	ax
38063                                           ! Debug: list int = const $40 (used reg = )
38064 AC7D           B8                   0040  mov	ax,*$40
38065 AC80           50                         push	ax
38066                                           ! Debug: func () void = write_byte+0 (used reg = )
38067 AC81           E8         599A            call	_write_byte
38068 AC84           83C4                   06  add	sp,*6
38069                                           !BCC_EOS
38070                                           ! 5434           outb_cmos( 0xB, registerB & 0x37 );
38071                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
38072 AC87           8A46         FF            mov	al,-1[bp]
38073 AC8A           24                     37  and	al,*$37
38074                                           ! Debug: list unsigned char = al+0 (used reg = )
38075 AC8C           30E4                       xor	ah,ah
38076 AC8E           50                         push	ax
38077                                           ! Debug: list int = const $B (used reg = )
38078 AC8F           B8                   000B  mov	ax,*$B
38079 AC92           50                         push	ax
38080                                           ! Debug: func () void = outb_cmos+0 (used reg = )
38081 AC93           E8         58E2            call	_outb_cmos
38082 AC96           83C4                   04  add	sp,*4
38083                                           !BCC_EOS
38084                                           ! 5435           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
38085                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
38086 AC99           FF76         F2            push	-$E[bp]
38087                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
38088 AC9C           FF76         F4            push	-$C[bp]
38089                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
38090 AC9F           E8         5956            call	_read_byte
38091 ACA2           83C4                   04  add	sp,*4
38092                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
38093 ACA5           0C                     80  or	al,#$80
38094                                           ! Debug: list unsigned char = al+0 (used reg = )
38095 ACA7           30E4                       xor	ah,ah
38096 ACA9           50                         push	ax
38097                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
38098 ACAA           FF76         F2            push	-$E[bp]
38099                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
38100 ACAD           FF76         F4            push	-$C[bp]
38101                                           ! Debug: func () void = write_byte+0 (used reg = )
38102 ACB0           E8         596B            call	_write_byte
38103 ACB3           83C4                   06  add	sp,*6
38104                                           !BCC_EOS
38105                                           ! 5436         } else {
38106 ACB6           83C4                   04  add	sp,*4
38107 ACB9           EB           30            jmp .792
38108                       0000ACBB            .790:
38109                                           ! 5437           time -= 0x3D1;
38110                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
38111 ACBB           B8                   03D1  mov	ax,#$3D1
38112 ACBE           31DB                       xor	bx,bx
38113 ACC0           53                         push	bx
38114 ACC1           50                         push	ax
38115 ACC2           8B46         FA            mov	ax,-6[bp]
38116 ACC5           8B5E         FC            mov	bx,-4[bp]
38117 ACC8           8D7E         F2            lea	di,-$E[bp]
38118 ACCB           E8         5413            call	lsubul
38119 ACCE           8946         FA            mov	-6[bp],ax
38120 ACD1           895E         FC            mov	-4[bp],bx
38121 ACD4           83C4                   04  add	sp,*4
38122                                           !BCC_EOS
38123                                           ! 5438           write_dword( 0x40, 0x9C, time );
38124                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
38125 ACD7           FF76         FC            push	-4[bp]
38126 ACDA           FF76         FA            push	-6[bp]
38127                                           ! Debug: list int = const $9C (used reg = )
38128 ACDD           B8                   009C  mov	ax,#$9C
38129 ACE0           50                         push	ax
38130                                           ! Debug: list int = const $40 (used reg = )
38131 ACE1           B8                   0040  mov	ax,*$40
38132 ACE4           50                         push	ax
38133                                           ! Debug: func () void = write_dword+0 (used reg = )
38134 ACE5           E8         53B3            call	_write_dword
38135 ACE8           83C4                   08  add	sp,*8
38136                                           !BCC_EOS
38137                                           ! 5439         }
38138                                           ! 5440       }
38139                       0000ACEB            .792:
38140 ACEB           83C4                   08  add	sp,*8
38141                                           ! 5441     }
38142                       0000ACEE            .78E:
38143                                           ! 5442   }
38144                       0000ACEE            .78C:
38145                                           ! 5443 #asm
38146                       0000ACEE            .788:
38147                                           !BCC_EOS
38148                                           !BCC_ASM
38149                       00000000            _int70_function.registerC	set	0
38150                       FFFFFFFE            .int70_function.registerC	set	-2
38151                       00000016            _int70_function.ds	set	$16
38152                       00000014            .int70_function.ds	set	$14
38153                       00000001            _int70_function.registerB	set	1
38154                       FFFFFFFF            .int70_function.registerB	set	-1
38155                       00000018            _int70_function.iret_addr	set	$18
38156                       00000016            .int70_function.iret_addr	set	$16
38157                       00000006            _int70_function.regs	set	6
38158                       00000004            .int70_function.regs	set	4
38159 ACEE           E8         03FD              call eoi_both_pics
38160                                           ! 5445 endasm
38161                                           !BCC_ENDASM
38162                                           !BCC_EOS
38163                                           ! 5446 }
38164 ACF1           89EC                       mov	sp,bp
38165 ACF3           5D                         pop	bp
38166 ACF4           C3                         ret
38167                                           ! 5447 #asm
38168                                           !BCC_ASM
38169                       00000012            _int70_function.ds	set	$12
38170                       00000014            _int70_function.iret_addr	set	$14
38171                       00000002            _int70_function.regs	set	2
38172                                           ;------------------------------------------
38173                                           ;- INT74h : PS/2 mouse hardware interrupt -
38174                                           ;------------------------------------------
38175                       0000ACF5            int74_handler:
38176 ACF5           FB                           sti
38177 ACF6           60                           pusha
38178 ACF7           1E                           push ds ;; save DS
38179 ACF8           6A                     00    push #0x00 ;; placeholder for status
38180 ACFA           6A                     00    push #0x00 ;; placeholder for X
38181 ACFC           6A                     00    push #0x00 ;; placeholder for Y
38182 ACFE           6A                     00    push #0x00 ;; placeholder for Z
38183 AD00           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
38184 AD02           E8         BD38              call _int74_function
38185 AD05           59                           pop cx ;; remove make_far_call from stack
38186 AD06           E3           0C              jcxz int74_done
38187                                             ;; make far call to EBDA:0022
38188 AD08           6A                     00    push #0x00
38189 AD0A           1F                           pop ds
38190 AD0B           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
38191 AD0F           1F                           pop ds
38192 AD10           FF1E       0022              call far ptr[0x22]
38193                       0000AD14            int74_done:
38194 AD14           FA                           cli
38195 AD15           E8         03D6              call eoi_both_pics
38196 AD18           83C4                   08    add sp, #8 ;; pop status, x, y, z
38197 AD1B           1F                           pop ds ;; restore DS
38198 AD1C           61                           popa
38199 AD1D           CF                           iret
38200                                           ;; This will perform an IRET, but will retain value of current CF
38201                                           ;; by altering flags on stack. Better than RETF #02.
38202                       0000AD1E            iret_modify_cf:
38203 AD1E           72           09              jc carry_set
38204 AD20           55                           push bp
38205 AD21           89E5                         mov bp, sp
38206 AD23           8066         06        FE    and BYTE [bp + 0x06], #0xfe
38207 AD27           5D                           pop bp
38208 AD28           CF                           iret
38209                       0000AD29            carry_set:
38210 AD29           55                           push bp
38211 AD2A           89E5                         mov bp, sp
38212 AD2C           804E         06        01    or BYTE [bp + 0x06], #0x01
38213 AD30           5D                           pop bp
38214 AD31           CF                           iret
38215                                           ;----------------------
38216                                           ;- INT13h (relocated) -
38217                                           ;----------------------
38218                                           ;
38219                                           ; int13_relocated is a little bit messed up since I played with it
38220                                           ; I have to rewrite it:
38221                                           ; - call a function that detect which function to call
38222                                           ; - make all called C function get the same parameters list
38223                                           ;
38224                       0000AD32            int13_relocated:
38225                                             ;; check for an eltorito function
38226 AD32           80FC                   4A    cmp ah,#0x4a
38227 AD35           72           10              jb int13_not_eltorito
38228 AD37           80FC                   4D    cmp ah,#0x4d
38229 AD3A           77           0B              ja int13_not_eltorito
38230 AD3C           60                           pusha
38231 AD3D           06                           push es
38232 AD3E           1E                           push ds
38233 AD3F           16                           push ss
38234 AD40           1F                           pop ds
38235 AD41           68                   ADB9    push #int13_out
38236 AD44           E9         D92F              jmp _int13_eltorito ;; ELDX not used
38237                       0000AD47            int13_not_eltorito:
38238 AD47           50                           push ax
38239 AD48           53                           push bx
38240 AD49           51                           push cx
38241 AD4A           52                           push dx
38242                                             ;; check if emulation active
38243 AD4B           E8         9181              call _cdemu_isactive
38244 AD4E           3C                     00    cmp al,#0x00
38245 AD50           74           2B              je int13_cdemu_inactive
38246                                             ;; check if access to the emulated drive
38247 AD52           E8         91A1              call _cdemu_emulated_drive
38248 AD55           5A                           pop dx
38249 AD56           52                           push dx
38250 AD57           38D0                         cmp al,dl ;; int13 on emulated drive
38251 AD59           75           0F              jne int13_nocdemu
38252 AD5B           5A                           pop dx
38253 AD5C           59                           pop cx
38254 AD5D           5B                           pop bx
38255 AD5E           58                           pop ax
38256 AD5F           60                           pusha
38257 AD60           06                           push es
38258 AD61           1E                           push ds
38259 AD62           16                           push ss
38260 AD63           1F                           pop ds
38261 AD64           68                   ADB9    push #int13_out
38262 AD67           E9         DB5C              jmp _int13_cdemu ;; ELDX not used
38263                       0000AD6A            int13_nocdemu:
38264 AD6A           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
38265 AD6D           38D0                         cmp al,dl ;; al is 0x00 or 0x80
38266 AD6F           75           0C              jne int13_cdemu_inactive ;; inactive for device class
38267 AD71           5A                           pop dx
38268 AD72           59                           pop cx
38269 AD73           5B                           pop bx
38270 AD74           58                           pop ax
38271 AD75           50                           push ax
38272 AD76           51                           push cx
38273 AD77           52                           push dx
38274 AD78           53                           push bx
38275 AD79           FECA                         dec dl ;; real drive is dl - 1
38276 AD7B           EB           08              jmp int13_legacy
38277                       0000AD7D            int13_cdemu_inactive:
38278 AD7D           5A                           pop dx
38279 AD7E           59                           pop cx
38280 AD7F           5B                           pop bx
38281 AD80           58                           pop ax
38282                       0000AD81            int13_noeltorito:
38283 AD81           50                           push ax
38284 AD82           51                           push cx
38285 AD83           52                           push dx
38286 AD84           53                           push bx
38287                       0000AD85            int13_legacy:
38288 AD85           52                           push dx ;; push eltorito value of dx instead of sp
38289 AD86           55                           push bp
38290 AD87           56                           push si
38291 AD88           57                           push di
38292 AD89           06                           push es
38293 AD8A           1E                           push ds
38294 AD8B           16                           push ss
38295 AD8C           1F                           pop ds
38296                                             ;; now the 16-bit registers can be restored with:
38297                                             ;; pop ds; pop es; popa; iret
38298                                             ;; arguments passed to functions should be
38299                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
38300 AD8D           F6C2                   80    test dl, #0x80
38301 AD90           75           06              jnz int13_notfloppy
38302 AD92           68                   ADB9    push #int13_out
38303 AD95           E9         E591              jmp _int13_diskette_function
38304                       0000AD98            int13_notfloppy:
38305 AD98           80FA                   E0    cmp dl, #0xE0
38306 AD9B           72           0F              jb int13_notcdrom
38307 AD9D     66    C1EB                   10    shr ebx, #16
38308 ADA1           53                           push bx
38309 ADA2           E8         CDA2              call _int13_cdrom
38310 ADA5           5B                           pop bx
38311 ADA6     66    C1E3                   10    shl ebx, #16
38312 ADAA           EB           0D              jmp int13_out
38313                       0000ADAC            int13_notcdrom:
38314                       0000ADAC            int13_disk:
38315                                             ;; int13_harddisk modifies high word of EAX
38316 ADAC     66    C1E8                   10    shr eax, #16
38317 ADB0           50                           push ax
38318 ADB1           E8         BDA4              call _int13_harddisk
38319 ADB4           58                           pop ax
38320 ADB5     66    C1E0                   10    shl eax, #16
38321                       0000ADB9            int13_out:
38322 ADB9           1F                           pop ds
38323 ADBA           07                           pop es
38324 ADBB           61                           popa
38325 ADBC           CF                           iret
38326                                           ;----------
38327                                           ;- INT18h -
38328                                           ;----------
38329                       0000ADBD            int18_handler: ;; Boot Failure recovery: try the next device.
38330                                             ;; Reset SP and SS
38331 ADBD           B8                   FFFE    mov ax, #0xfffe
38332 ADC0           89C4                         mov sp, ax
38333 ADC2           31C0                         xor ax, ax
38334 ADC4           8ED0                         mov ss, ax
38335                                             ;; Get the boot sequence number out of the IPL memory
38336 ADC6           BB                   9FF0    mov bx, #0x9ff0
38337 ADC9           8EDB                         mov ds, bx ;; Set segment
38338 ADCB           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
38339 ADCF           43                           inc bx ;; ++
38340 ADD0           891E       0082              mov 0x0082, bx ;; Write it back
38341 ADD4           8ED8                         mov ds, ax ;; and reset the segment to zero.
38342                                             ;; Carry on in the INT 19h handler, using the new sequence number
38343 ADD6           53                           push bx
38344 ADD7           EB           17              jmp int19_next_boot
38345                                           ;----------
38346                                           ;- INT19h -
38347                                           ;----------
38348                       0000ADD9            int19_relocated: ;; Boot function, relocated
38349                                             ;; int19 was beginning to be really complex, so now it
38350                                             ;; just calls a C function that does the work
38351 ADD9           55                           push bp
38352 ADDA           89E5                         mov bp, sp
38353                                             ;; Reset SS and SP
38354 ADDC           B8                   FFFE    mov ax, #0xfffe
38355 ADDF           89C4                         mov sp, ax
38356 ADE1           31C0                         xor ax, ax
38357 ADE3           8ED0                         mov ss, ax
38358                                             ;; Start from the first boot device (0, in AX)
38359 ADE5           BB                   9FF0    mov bx, #0x9ff0
38360 ADE8           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
38361 ADEA           A3         0082              mov 0x0082, ax ;; Save the sequence number
38362 ADED           8ED8                         mov ds, ax ;; and reset the segment.
38363 ADEF           50                           push ax
38364                       0000ADF0            int19_next_boot:
38365                                             ;; Call the C code for the next boot device
38366 ADF0           E8         F7D4              call _int19_function
38367                                             ;; Boot failed: invoke the boot recovery function
38368 ADF3           CD                     18    int #0x18
38369                                           ;----------
38370                                           ;- INT1Ch -
38371                                           ;----------
38372                       0000ADF5            int1c_handler: ;; User Timer Tick
38373 ADF5           CF                           iret
38374                                           ;----------------------
38375                                           ;- POST: Floppy Drive -
38376                                           ;----------------------
38377                       0000ADF6            floppy_drive_post:
38378 ADF6           31C0                         xor ax, ax
38379 ADF8           8ED8                         mov ds, ax
38380 ADFA           B0                     00    mov al, #0x00
38381 ADFC           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
38382 ADFF           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
38383 AE02           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
38384 AE05           A2         0441              mov 0x0441, al ;; diskette controller status return code
38385 AE08           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
38386 AE0B           A2         0443              mov 0x0443, al ;; diskette controller status register 1
38387 AE0E           A2         0444              mov 0x0444, al ;; diskette controller status register 2
38388 AE11           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
38389 AE14           A2         0446              mov 0x0446, al ;; diskette controller head number
38390 AE17           A2         0447              mov 0x0447, al ;; diskette controller sector number
38391 AE1A           A2         0448              mov 0x0448, al ;; diskette controller bytes written
38392 AE1D           A2         048B              mov 0x048b, al ;; diskette configuration data
38393                                             ;; -----------------------------------------------------------------
38394                                             ;; (048F) diskette controller information
38395                                             ;;
38396 AE20           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
38397 AE22           E6                     70    out 0x70, AL
38398 AE24           E4                     71    in AL, 0x71
38399 AE26           88C4                         mov ah, al ;; save byte to AH
38400                       0000AE28            look_drive0:
38401 AE28           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
38402 AE2B           74           04              jz f0_missing ;; jump if no drive0
38403 AE2D           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
38404 AE2F           EB           02              jmp look_drive1
38405                       0000AE31            f0_missing:
38406 AE31           B3                     00    mov bl, #0x00 ;; no drive0
38407                       0000AE33            look_drive1:
38408 AE33           88E0                         mov al, ah ;; restore from AH
38409 AE35           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
38410 AE37           74           03              jz f1_missing ;; jump if no drive1
38411 AE39           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
38412                       0000AE3C            f1_missing:
38413                                                              ;; leave high bits in BL zerod
38414 AE3C           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
38415                                             ;; -----------------------------------------------------------------
38416 AE40           B0                     00    mov al, #0x00
38417 AE42           A2         0490              mov 0x0490, al ;; diskette 0 media state
38418 AE45           A2         0491              mov 0x0491, al ;; diskette 1 media state
38419                                                              ;; diskette 0,1 operational starting state
38420                                                              ;; drive type has not been determined,
38421                                                              ;; has no changed detection line
38422 AE48           A2         0492              mov 0x0492, al
38423 AE4B           A2         0493              mov 0x0493, al
38424 AE4E           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
38425 AE51           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
38426 AE54           B0                     02    mov al, #0x02
38427 AE56           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
38428                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   AE58           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   AE5B           A3         0078              mov 0x1E*4, ax
 +a   AE5E           B8                   F000    mov ax,  #0xF000
 +a   AE61           A3         007A              mov 0x1E*4+2, ax
38429                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   AE64           B8                   EC59    mov ax,  #int13_diskette
 +a   AE67           A3         0100              mov 0x40*4, ax
 +a   AE6A           B8                   F000    mov ax,  #0xF000
 +a   AE6D           A3         0102              mov 0x40*4+2, ax
38430                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   AE70           B8                   EF57    mov ax,  #int0e_handler
 +a   AE73           A3         0038              mov 0x0E*4, ax
 +a   AE76           B8                   F000    mov ax,  #0xF000
 +a   AE79           A3         003A              mov 0x0E*4+2, ax
38431 AE7C           C3                           ret
38432                                           ;--------------------
38433                                           ;- POST: HARD DRIVE -
38434                                           ;--------------------
38435                                           ; relocated here because the primary POST area isnt big enough.
38436                       0000AE7D            hard_drive_post:
38437 AE7D           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
38438 AE7F           BA                   03F6    mov dx, #0x03f6
38439 AE82           EE                           out dx, al
38440 AE83           31C0                         xor ax, ax
38441 AE85           8ED8                         mov ds, ax
38442 AE87           A2         0474              mov 0x0474, al
38443 AE8A           A2         0477              mov 0x0477, al
38444 AE8D           A2         048C              mov 0x048c, al
38445 AE90           A2         048D              mov 0x048d, al
38446 AE93           A2         048E              mov 0x048e, al
38447 AE96           B0                     01    mov al, #0x01
38448 AE98           A2         0475              mov 0x0475, al
38449 AE9B           B0                     C0    mov al, #0xc0
38450 AE9D           A2         0476              mov 0x0476, al
38451                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   AEA0           B8                   E3FE    mov ax,  #int13_handler
 +a   AEA3           A3         004C              mov 0x13*4, ax
 +a   AEA6           B8                   F000    mov ax,  #0xF000
 +a   AEA9           A3         004E              mov 0x13*4+2, ax
38452                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   AEAC           B8                   B17D    mov ax,  #int76_handler
 +a   AEAF           A3         01D8              mov 0x76*4, ax
 +a   AEB2           B8                   F000    mov ax,  #0xF000
 +a   AEB5           A3         01DA              mov 0x76*4+2, ax
38453                                             ;; INT 41h: hard disk 0 configuration pointer
38454                                             ;; INT 46h: hard disk 1 configuration pointer
38455                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   AEB8           B8                   003D    mov ax,  #0x003D
 +a   AEBB           A3         0104              mov 0x41*4, ax
 +a   AEBE           B8                   9FC0    mov ax,  #0x9FC0
 +a   AEC1           A3         0106              mov 0x41*4+2, ax
38456                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   AEC4           B8                   004D    mov ax,  #0x004D
 +a   AEC7           A3         0118              mov 0x46*4, ax
 +a   AECA           B8                   9FC0    mov ax,  #0x9FC0
 +a   AECD           A3         011A              mov 0x46*4+2, ax
38457                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
38458 AED0           B0                     12    mov al, #0x12
38459 AED2           E6                     70    out #0x70, al
38460 AED4           E4                     71    in al, #0x71
38461 AED6           24                     F0    and al, #0xf0
38462 AED8           3C                     F0    cmp al, #0xf0
38463 AEDA           74           03              je post_d0_extended
38464 AEDC           E9         00D4              jmp check_for_hd1
38465                       0000AEDF            post_d0_extended:
38466 AEDF           B0                     19    mov al, #0x19
38467 AEE1           E6                     70    out #0x70, al
38468 AEE3           E4                     71    in al, #0x71
38469 AEE5           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38470 AEE7           74           07              je post_d0_type47
38471                                             HALT(8886)
 +a   AEE9           BA                   0400    mov dx,#0x400
 +a   AEEC           B8                   22B6    mov ax,#8886
 +a   AEEF           EF                           out dx,ax
38472                       0000AEF0            post_d0_type47:
38473                                             ;; CMOS purpose param table offset
38474                                             ;; 1b cylinders low 0
38475                                             ;; 1c cylinders high 1
38476                                             ;; 1d heads 2
38477                                             ;; 1e write pre-comp low 5
38478                                             ;; 1f write pre-comp high 6
38479                                             ;; 20 retries/bad map/heads>8 8
38480                                             ;; 21 landing zone low C
38481                                             ;; 22 landing zone high D
38482                                             ;; 23 sectors/track E
38483 AEF0           B8                   9FC0    mov ax, #0x9FC0
38484 AEF3           8ED8                         mov ds, ax
38485                                             ;;; Filling EBDA table for hard disk 0.
38486 AEF5           B0                     1F    mov al, #0x1f
38487 AEF7           E6                     70    out #0x70, al
38488 AEF9           E4                     71    in al, #0x71
38489 AEFB           88C4                         mov ah, al
38490 AEFD           B0                     1E    mov al, #0x1e
38491 AEFF           E6                     70    out #0x70, al
38492 AF01           E4                     71    in al, #0x71
38493 AF03           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
38494 AF06           B0                     20    mov al, #0x20
38495 AF08           E6                     70    out #0x70, al
38496 AF0A           E4                     71    in al, #0x71
38497 AF0C           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
38498 AF0F           B0                     22    mov al, #0x22
38499 AF11           E6                     70    out #0x70, al
38500 AF13           E4                     71    in al, #0x71
38501 AF15           88C4                         mov ah, al
38502 AF17           B0                     21    mov al, #0x21
38503 AF19           E6                     70    out #0x70, al
38504 AF1B           E4                     71    in al, #0x71
38505 AF1D           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
38506 AF20           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
38507 AF22           E6                     70    out #0x70, al
38508 AF24           E4                     71    in al, #0x71 ;; high byte
38509 AF26           88C4                         mov ah, al
38510 AF28           B0                     1B    mov al, #0x1b
38511 AF2A           E6                     70    out #0x70, al
38512 AF2C           E4                     71    in al, #0x71 ;; low byte
38513 AF2E           89C3                         mov bx, ax ;; BX = cylinders
38514 AF30           B0                     1D    mov al, #0x1d
38515 AF32           E6                     70    out #0x70, al
38516 AF34           E4                     71    in al, #0x71
38517 AF36           88C1                         mov cl, al ;; CL = heads
38518 AF38           B0                     23    mov al, #0x23
38519 AF3A           E6                     70    out #0x70, al
38520 AF3C           E4                     71    in al, #0x71
38521 AF3E           88C2                         mov dl, al ;; DL = sectors
38522 AF40           81FB                 0400    cmp bx, #1024
38523 AF44           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38524                       0000AF46            hd0_post_physical_chs:
38525                                             ;; no logical CHS mapping used, just physical CHS
38526                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38527 AF46           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38528 AF4A           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38529 AF4E           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
38530 AF52           EB           5F              jmp check_for_hd1
38531                       0000AF54            hd0_post_logical_chs:
38532                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38533 AF54           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
38534 AF58           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
38535 AF5C           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
38536 AF60           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
38537 AF64           B0                     A0    mov al, #0xa0
38538 AF66           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
38539 AF69           81FB                 0800    cmp bx, #2048
38540 AF6D           77           06              jnbe hd0_post_above_2048
38541                                             ;; 1024 < c <= 2048 cylinders
38542 AF6F           D1EB                         shr bx, #0x01
38543 AF71           D0E1                         shl cl, #0x01
38544 AF73           EB           22              jmp hd0_post_store_logical
38545                       0000AF75            hd0_post_above_2048:
38546 AF75           81FB                 1000    cmp bx, #4096
38547 AF79           77           08              jnbe hd0_post_above_4096
38548                                             ;; 2048 < c <= 4096 cylinders
38549 AF7B           C1EB                   02    shr bx, #0x02
38550 AF7E           C0E1                   02    shl cl, #0x02
38551 AF81           EB           14              jmp hd0_post_store_logical
38552                       0000AF83            hd0_post_above_4096:
38553 AF83           81FB                 2000    cmp bx, #8192
38554 AF87           77           08              jnbe hd0_post_above_8192
38555                                             ;; 4096 < c <= 8192 cylinders
38556 AF89           C1EB                   03    shr bx, #0x03
38557 AF8C           C0E1                   03    shl cl, #0x03
38558 AF8F           EB           06              jmp hd0_post_store_logical
38559                       0000AF91            hd0_post_above_8192:
38560                                             ;; 8192 < c <= 16384 cylinders
38561 AF91           C1EB                   04    shr bx, #0x04
38562 AF94           C0E1                   04    shl cl, #0x04
38563                       0000AF97            hd0_post_store_logical:
38564 AF97           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38565 AF9B           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38566                                             ;; checksum
38567 AF9F           B1                     0F    mov cl, #0x0f ;; repeat count
38568 AFA1           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
38569 AFA4           B0                     00    mov al, #0x00 ;; sum
38570                       0000AFA6            hd0_post_checksum_loop:
38571 AFA6           0204                         add al, [si]
38572 AFA8           46                           inc si
38573 AFA9           FEC9                         dec cl
38574 AFAB           75           F9              jnz hd0_post_checksum_loop
38575 AFAD           F6D0                         not al ;; now take 2s complement
38576 AFAF           FEC0                         inc al
38577 AFB1           8804                         mov [si], al
38578                                           ;;; Done filling EBDA table for hard disk 0.
38579                       0000AFB3            check_for_hd1:
38580                                             ;; is there really a second hard disk? if not, return now
38581 AFB3           B0                     12    mov al, #0x12
38582 AFB5           E6                     70    out #0x70, al
38583 AFB7           E4                     71    in al, #0x71
38584 AFB9           24                     0F    and al, #0x0f
38585 AFBB           75           01              jnz post_d1_exists
38586 AFBD           C3                           ret
38587                       0000AFBE            post_d1_exists:
38588                                             ;; check that the hd type is really 0x0f.
38589 AFBE           3C                     0F    cmp al, #0x0f
38590 AFC0           74           07              jz post_d1_extended
38591                                             HALT(9023)
 +a   AFC2           BA                   0400    mov dx,#0x400
 +a   AFC5           B8                   233F    mov ax,#9023
 +a   AFC8           EF                           out dx,ax
38592                       0000AFC9            post_d1_extended:
38593                                             ;; check that the extended type is 47 - user definable
38594 AFC9           B0                     1A    mov al, #0x1a
38595 AFCB           E6                     70    out #0x70, al
38596 AFCD           E4                     71    in al, #0x71
38597 AFCF           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38598 AFD1           74           07              je post_d1_type47
38599                                             HALT(9031)
 +a   AFD3           BA                   0400    mov dx,#0x400
 +a   AFD6           B8                   2347    mov ax,#9031
 +a   AFD9           EF                           out dx,ax
38600                       0000AFDA            post_d1_type47:
38601                                             ;; Table for disk1.
38602                                             ;; CMOS purpose param table offset
38603                                             ;; 0x24 cylinders low 0
38604                                             ;; 0x25 cylinders high 1
38605                                             ;; 0x26 heads 2
38606                                             ;; 0x27 write pre-comp low 5
38607                                             ;; 0x28 write pre-comp high 6
38608                                             ;; 0x29 heads>8 8
38609                                             ;; 0x2a landing zone low C
38610                                             ;; 0x2b landing zone high D
38611                                             ;; 0x2c sectors/track E
38612                                           ;;; Fill EBDA table for hard disk 1.
38613 AFDA           B8                   9FC0    mov ax, #0x9FC0
38614 AFDD           8ED8                         mov ds, ax
38615 AFDF           B0                     28    mov al, #0x28
38616 AFE1           E6                     70    out #0x70, al
38617 AFE3           E4                     71    in al, #0x71
38618 AFE5           88C4                         mov ah, al
38619 AFE7           B0                     27    mov al, #0x27
38620 AFE9           E6                     70    out #0x70, al
38621 AFEB           E4                     71    in al, #0x71
38622 AFED           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
38623 AFF0           B0                     29    mov al, #0x29
38624 AFF2           E6                     70    out #0x70, al
38625 AFF4           E4                     71    in al, #0x71
38626 AFF6           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
38627 AFF9           B0                     2B    mov al, #0x2b
38628 AFFB           E6                     70    out #0x70, al
38629 AFFD           E4                     71    in al, #0x71
38630 AFFF           88C4                         mov ah, al
38631 B001           B0                     2A    mov al, #0x2a
38632 B003           E6                     70    out #0x70, al
38633 B005           E4                     71    in al, #0x71
38634 B007           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
38635 B00A           B0                     25    mov al, #0x25 ;; get cylinders word in AX
38636 B00C           E6                     70    out #0x70, al
38637 B00E           E4                     71    in al, #0x71 ;; high byte
38638 B010           88C4                         mov ah, al
38639 B012           B0                     24    mov al, #0x24
38640 B014           E6                     70    out #0x70, al
38641 B016           E4                     71    in al, #0x71 ;; low byte
38642 B018           89C3                         mov bx, ax ;; BX = cylinders
38643 B01A           B0                     26    mov al, #0x26
38644 B01C           E6                     70    out #0x70, al
38645 B01E           E4                     71    in al, #0x71
38646 B020           88C1                         mov cl, al ;; CL = heads
38647 B022           B0                     2C    mov al, #0x2c
38648 B024           E6                     70    out #0x70, al
38649 B026           E4                     71    in al, #0x71
38650 B028           88C2                         mov dl, al ;; DL = sectors
38651 B02A           81FB                 0400    cmp bx, #1024
38652 B02E           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38653                       0000B030            hd1_post_physical_chs:
38654                                             ;; no logical CHS mapping used, just physical CHS
38655                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38656 B030           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38657 B034           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38658 B038           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
38659 B03C           C3                           ret
38660                       0000B03D            hd1_post_logical_chs:
38661                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38662 B03D           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
38663 B041           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
38664 B045           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
38665 B049           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
38666 B04D           B0                     A0    mov al, #0xa0
38667 B04F           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
38668 B052           81FB                 0800    cmp bx, #2048
38669 B056           77           06              jnbe hd1_post_above_2048
38670                                             ;; 1024 < c <= 2048 cylinders
38671 B058           D1EB                         shr bx, #0x01
38672 B05A           D0E1                         shl cl, #0x01
38673 B05C           EB           22              jmp hd1_post_store_logical
38674                       0000B05E            hd1_post_above_2048:
38675 B05E           81FB                 1000    cmp bx, #4096
38676 B062           77           08              jnbe hd1_post_above_4096
38677                                             ;; 2048 < c <= 4096 cylinders
38678 B064           C1EB                   02    shr bx, #0x02
38679 B067           C0E1                   02    shl cl, #0x02
38680 B06A           EB           14              jmp hd1_post_store_logical
38681                       0000B06C            hd1_post_above_4096:
38682 B06C           81FB                 2000    cmp bx, #8192
38683 B070           77           08              jnbe hd1_post_above_8192
38684                                             ;; 4096 < c <= 8192 cylinders
38685 B072           C1EB                   03    shr bx, #0x03
38686 B075           C0E1                   03    shl cl, #0x03
38687 B078           EB           06              jmp hd1_post_store_logical
38688                       0000B07A            hd1_post_above_8192:
38689                                             ;; 8192 < c <= 16384 cylinders
38690 B07A           C1EB                   04    shr bx, #0x04
38691 B07D           C0E1                   04    shl cl, #0x04
38692                       0000B080            hd1_post_store_logical:
38693 B080           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38694 B084           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38695                                             ;; checksum
38696 B088           B1                     0F    mov cl, #0x0f ;; repeat count
38697 B08A           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
38698 B08D           B0                     00    mov al, #0x00 ;; sum
38699                       0000B08F            hd1_post_checksum_loop:
38700 B08F           0204                         add al, [si]
38701 B091           46                           inc si
38702 B092           FEC9                         dec cl
38703 B094           75           F9              jnz hd1_post_checksum_loop
38704 B096           F6D0                         not al ;; now take 2s complement
38705 B098           FEC0                         inc al
38706 B09A           8804                         mov [si], al
38707                                           ;;; Done filling EBDA table for hard disk 1.
38708 B09C           C3                           ret
38709                                           ;--------------------
38710                                           ;- POST: EBDA segment
38711                                           ;--------------------
38712                                           ; relocated here because the primary POST area isnt big enough.
38713                       0000B09D            ebda_post:
38714 B09D           B8                   9FC0    mov ax, #0x9FC0
38715 B0A0           8ED8                         mov ds, ax
38716 B0A2           C606       0000        01    mov byte ptr [0x0], #1
38717 B0A7           31C0                         xor ax, ax ; mov EBDA seg into 40E
38718 B0A9           8ED8                         mov ds, ax
38719 B0AB           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
38720 B0B1           C3                           ret;;
38721                                           ;--------------------
38722                                           ;- POST: EOI + jmp via [0x40:67)
38723                                           ;--------------------
38724                                           ; relocated here because the primary POST area isnt big enough.
38725                       0000B0B2            eoi_jmp_post:
38726 B0B2           B0                     20    mov al, #0x20
38727 B0B4           E6                     A0    out #0xA0, al ;; slave PIC EOI
38728 B0B6           B0                     20    mov al, #0x20
38729 B0B8           E6                     20    out #0x20, al ;; master PIC EOI
38730                       0000B0BA            jmp_post_0x467:
38731 B0BA           31C0                         xor ax, ax
38732 B0BC           8ED8                         mov ds, ax
38733 B0BE           FF2E       0467              jmp far ptr [0x467]
38734                       0000B0C2            iret_post_0x467:
38735 B0C2           31C0                         xor ax, ax
38736 B0C4           8ED8                         mov ds, ax
38737 B0C6           8B26       0467              mov sp, [0x467]
38738 B0CA           8E16       0469              mov ss, [0x469]
38739 B0CE           CF                           iret
38740                       0000B0CF            retf_post_0x467:
38741 B0CF           31C0                         xor ax, ax
38742 B0D1           8ED8                         mov ds, ax
38743 B0D3           8B26       0467              mov sp, [0x467]
38744 B0D7           8E16       0469              mov ss, [0x469]
38745 B0DB           CB                           retf
38746                       0000B0DC            s3_post:
38747 B0DC           BC                   0FFE    mov sp, #0xffe
38748 B0DF           E8         678D              call _s3_resume
38749 B0E2           B3                     00    mov bl, #0x00
38750 B0E4           21C0                         and ax, ax
38751 B0E6   7503    E9         2FB8              jz normal_post
38752 B0EB           E8         617B              call _s3_resume_panic
38753                                           ;--------------------
38754                       0000B0EE            eoi_both_pics:
38755 B0EE           B0                     20    mov al, #0x20
38756 B0F0           E6                     A0    out #0xA0, al ;; slave PIC EOI
38757                       0000B0F2            eoi_master_pic:
38758 B0F2           B0                     20    mov al, #0x20
38759 B0F4           E6                     20    out #0x20, al ;; master PIC EOI
38760 B0F6           C3                           ret
38761                                           ;--------------------
38762                       0000B0F7            BcdToBin:
38763                                             ;; in: AL in BCD format
38764                                             ;; out: AL in binary format, AH will always be 0
38765                                             ;; trashes BX
38766 B0F7           88C3                         mov bl, al
38767 B0F9           80E3                   0F    and bl, #0x0f ;; bl has low digit
38768 B0FC           C0E8                   04    shr al, #4 ;; al has high digit
38769 B0FF           B7                     0A    mov bh, #10
38770 B101           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
38771 B103           00D8                         add al, bl ;; then add low digit
38772 B105           C3                           ret
38773                                           ;--------------------
38774                       0000B106            timer_tick_post:
38775                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
38776                                             ;; Timer Ticks Roller Flag (0x470:byte)
38777                                             ;; The Timer Ticks Count needs to be set according to
38778                                             ;; the current CMOS time, as if ticks have been occurring
38779                                             ;; at 18.2hz since midnight up to this point. Calculating
38780                                             ;; this is a little complicated. Here are the factors I gather
38781                                             ;; regarding this. 14,318,180 hz was the original clock speed,
38782                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
38783                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
38784                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
38785                                             ;; the timer. With a maximum 16bit timer count, this is again
38786                                             ;; divided down by 65536 to 18.2hz.
38787                                             ;;
38788                                             ;; 14,318,180 Hz clock
38789                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
38790                                             ;; /4 = 1,193,181 Hz fed to timer
38791                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
38792                                             ;; 1 second = 18.20650736 ticks
38793                                             ;; 1 minute = 1092.390442 ticks
38794                                             ;; 1 hour = 65543.42651 ticks
38795                                             ;;
38796                                             ;; Given the values in the CMOS clock, one could calculate
38797                                             ;; the number of ticks by the following:
38798                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
38799                                             ;; (BcdToBin(minutes) * 1092.3904)
38800                                             ;; (BcdToBin(hours) * 65543.427)
38801                                             ;; To get a little more accuracy, since Im using integer
38802                                             ;; arithmatic, I use:
38803                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
38804                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
38805                                             ;; (BcdToBin(hours) * 65543427) / 1000
38806                                             ;; assuming DS=0000
38807                                             ;; get CMOS seconds
38808 B106     66    31C0                         xor eax, eax ;; clear EAX
38809 B109           B0                     00    mov al, #0x00
38810 B10B           E6                     70    out #0x70, al
38811 B10D           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
38812 B10F           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
38813 B112     66    BA               0115CF2B    mov edx, #18206507
38814 B118     66    F7E2                         mul eax, edx
38815 B11B     66    BB               000F4240    mov ebx, #1000000
38816 B121     66    31D2                         xor edx, edx
38817 B124     66    F7F3                         div eax, ebx
38818 B127     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
38819                                             ;; get CMOS minutes
38820 B12A     66    31C0                         xor eax, eax ;; clear EAX
38821 B12D           B0                     02    mov al, #0x02
38822 B12F           E6                     70    out #0x70, al
38823 B131           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
38824 B133           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
38825 B136     66    BA               00A6AF80    mov edx, #10923904
38826 B13C     66    F7E2                         mul eax, edx
38827 B13F     66    BB               00002710    mov ebx, #10000
38828 B145     66    31D2                         xor edx, edx
38829 B148     66    F7F3                         div eax, ebx
38830 B14B     66    01C1                         add ecx, eax ;; add to total ticks
38831                                             ;; get CMOS hours
38832 B14E     66    31C0                         xor eax, eax ;; clear EAX
38833 B151           B0                     04    mov al, #0x04
38834 B153           E6                     70    out #0x70, al
38835 B155           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
38836 B157           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
38837 B15A     66    BA               03E81D03    mov edx, #65543427
38838 B160     66    F7E2                         mul eax, edx
38839 B163     66    BB               000003E8    mov ebx, #1000
38840 B169     66    31D2                         xor edx, edx
38841 B16C     66    F7F3                         div eax, ebx
38842 B16F     66    01C1                         add ecx, eax ;; add to total ticks
38843 B172     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
38844 B177           30C0                         xor al, al
38845 B179           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
38846 B17C           C3                           ret
38847                                           ;--------------------
38848                       0000B17D            int76_handler:
38849                                             ;; record completion in BIOS task complete flag
38850 B17D           50                           push ax
38851 B17E           1E                           push ds
38852 B17F           B8                   0040    mov ax, #0x0040
38853 B182           8ED8                         mov ds, ax
38854 B184           C706       008E      00FF    mov 0x008E, #0xff
38855 B18A           E8         FF61              call eoi_both_pics
38856 B18D           1F                           pop ds
38857 B18E           58                           pop ax
38858 B18F           CF                           iret
38859                                           ;--------------------
38860                                           use32 386
38861                       0000B190            apm32_out_str:
38862 B190           50                           push eax
38863 B191           53                           push ebx
38864 B192           89C3                         mov ebx, eax
38865                       0000B194            apm32_out_str1:
38866 B194           2E                           SEG CS
38867 B195   67      8A07                         mov al, byte ptr [bx]
38868 B198           3C                     00    cmp al, #0
38869 B19A           74           04              je apm32_out_str2
38870 B19C           EE                           outb dx, al
38871 B19D           43                           inc ebx
38872 B19E           EB           F4              jmp apm32_out_str1
38873                       0000B1A0            apm32_out_str2:
38874 B1A0           5B                           pop ebx
38875 B1A1           58                           pop eax
38876 B1A2           C3                           ret
38877                       0000B1A3            apm32_07_poweroff_str:
38878 B1A3                        53              .ascii "Shutdown"
38879 B1AB                        00              db 0
38880                       0000B1AC            apm32_07_suspend_str:
38881 B1AC                        53              .ascii "Suspend"
38882 B1B3                        00              db 0
38883                       0000B1B4            apm32_07_standby_str:
38884 B1B4                        53              .ascii "Standby"
38885 B1BB                        00              db 0
38886                       0000B1BC            _apm32_entry:
38887 B1BC     66    9C                           pushf
38888                                           ;-----------------
38889                                           ; APM interface disconnect
38890                       0000B1BE            apm32_04:
38891 B1BE           3C                     04    cmp al, #0x04
38892 B1C0           75           05              jne apm32_05
38893 B1C2           E9     000000A1              jmp apm32_ok
38894                                           ;-----------------
38895                                           ; APM cpu idle
38896                       0000B1C7            apm32_05:
38897 B1C7           3C                     05    cmp al, #0x05
38898 B1C9           75           07              jne apm32_07
38899 B1CB           FB                           sti
38900 B1CC           F4                           hlt
38901 B1CD           E9     00000096              jmp apm32_ok
38902                                           ;-----------------
38903                                           ; APM Set Power State
38904                       0000B1D2            apm32_07:
38905 B1D2           3C                     07    cmp al, #0x07
38906 B1D4           75           52              jne apm32_08
38907 B1D6     66    83FB                   01    cmp bx, #1
38908 B1DA   7405    E9     00000087              jne apm32_ok
38909 B1E1     66    83F9                   03    cmp cx, #3
38910 B1E5           74           0E              je apm32_07_poweroff
38911 B1E7     66    83F9                   02    cmp cx, #2
38912 B1EB           74           19              je apm32_07_suspend
38913 B1ED     66    83F9                   01    cmp cx, #1
38914 B1F1           74           24              je apm32_07_standby
38915 B1F3           75           73              jne apm32_ok
38916                       0000B1F5            apm32_07_poweroff:
38917 B1F5           FA                           cli
38918 B1F6     66    BA                   8900    mov dx, #0x8900
38919 B1FA     66    B8                   B1A3    mov ax, #apm32_07_poweroff_str
38920 B1FE           E8     FFFFFF8D              call apm32_out_str
38921                       0000B203            apm32_07_1:
38922 B203           F4                           hlt
38923 B204           EB           FD              jmp apm32_07_1
38924                       0000B206            apm32_07_suspend:
38925 B206           52                           push edx
38926 B207     66    BA                   8900    mov dx, #0x8900
38927 B20B     66    B8                   B1AC    mov ax, #apm32_07_suspend_str
38928 B20F           E8     FFFFFF7C              call apm32_out_str
38929 B214           5A                           pop edx
38930 B215           EB           51              jmp apm32_ok
38931                       0000B217            apm32_07_standby:
38932 B217           52                           push edx
38933 B218     66    BA                   8900    mov dx, #0x8900
38934 B21C     66    B8                   B1B4    mov ax, #apm32_07_standby_str
38935 B220           E8     FFFFFF6B              call apm32_out_str
38936 B225           5A                           pop edx
38937 B226           EB           40              jmp apm32_ok
38938                                           ;-----------------
38939                                           ; APM Enable / Disable
38940                       0000B228            apm32_08:
38941 B228           3C                     08    cmp al, #0x08
38942 B22A           75           02              jne apm32_0a
38943 B22C           EB           3A              jmp apm32_ok
38944                                           ;-----------------
38945                                           ; Get Power Status
38946                       0000B22E            apm32_0a:
38947 B22E           3C                     0A    cmp al, #0x0a
38948 B230           75           12              jne apm32_0b
38949 B232           B7                     01    mov bh, #0x01
38950 B234           B3                     FF    mov bl, #0xff
38951 B236           B5                     80    mov ch, #0x80
38952 B238           B1                     FF    mov cl, #0xff
38953 B23A     66    BA                   FFFF    mov dx, #0xffff
38954 B23E     66    BE                   0000    mov si, #0
38955 B242           EB           24              jmp apm32_ok
38956                                           ;-----------------
38957                                           ; Get PM Event
38958                       0000B244            apm32_0b:
38959 B244           3C                     0B    cmp al, #0x0b
38960 B246           75           04              jne apm32_0e
38961 B248           B4                     80    mov ah, #0x80
38962 B24A           EB           20              jmp apm32_error
38963                                           ;-----------------
38964                                           ; APM Driver Version
38965                       0000B24C            apm32_0e:
38966 B24C           3C                     0E    cmp al, #0x0e
38967 B24E           75           06              jne apm32_0f
38968 B250           B4                     01    mov ah, #1
38969 B252           B0                     02    mov al, #2
38970 B254           EB           12              jmp apm32_ok
38971                                           ;-----------------
38972                                           ; APM Engage / Disengage
38973                       0000B256            apm32_0f:
38974 B256           3C                     0F    cmp al, #0x0f
38975 B258           75           02              jne apm32_10
38976 B25A           EB           0C              jmp apm32_ok
38977                                           ;-----------------
38978                                           ; APM Get Capabilities
38979                       0000B25C            apm32_10:
38980 B25C           3C                     10    cmp al, #0x10
38981 B25E           75           0C              jne apm32_unimplemented
38982 B260           B3                     00    mov bl, #0
38983 B262     66    B9                   0000    mov cx, #0
38984 B266           EB           00              jmp apm32_ok
38985                                           ;-----------------
38986                       0000B268            apm32_ok:
38987 B268     66    9D                           popf
38988 B26A           F8                           clc
38989 B26B           CB                           retf
38990                       0000B26C            apm32_unimplemented:
38991                       0000B26C            apm32_error:
38992 B26C     66    9D                           popf
38993 B26E           F9                           stc
38994 B26F           CB                           retf
38995                                           use16 386
38996                       0000B270            apm16_out_str:
38997 B270     66    50                           push eax
38998 B272     66    53                           push ebx
38999 B274     66    89C3                         mov ebx, eax
39000                       0000B277            apm16_out_str1:
39001 B277           2E                           SEG CS
39002 B278           8A07                         mov al, byte ptr [bx]
39003 B27A           3C                     00    cmp al, #0
39004 B27C           74           05              je apm16_out_str2
39005 B27E           EE                           outb dx, al
39006 B27F     66    43                           inc ebx
39007 B281           EB           F4              jmp apm16_out_str1
39008                       0000B283            apm16_out_str2:
39009 B283     66    5B                           pop ebx
39010 B285     66    58                           pop eax
39011 B287           C3                           ret
39012                       0000B288            apm16_07_poweroff_str:
39013 B288                        53              .ascii "Shutdown"
39014 B290                        00              db 0
39015                       0000B291            apm16_07_suspend_str:
39016 B291                        53              .ascii "Suspend"
39017 B298                        00              db 0
39018                       0000B299            apm16_07_standby_str:
39019 B299                        53              .ascii "Standby"
39020 B2A0                        00              db 0
39021                       0000B2A1            _apm16_entry:
39022 B2A1           9C                           pushf
39023                                           ;-----------------
39024                                           ; APM interface disconnect
39025                       0000B2A2            apm16_04:
39026 B2A2           3C                     04    cmp al, #0x04
39027 B2A4           75           03              jne apm16_05
39028 B2A6           E9         008B              jmp apm16_ok
39029                                           ;-----------------
39030                                           ; APM cpu idle
39031                       0000B2A9            apm16_05:
39032 B2A9           3C                     05    cmp al, #0x05
39033 B2AB           75           05              jne apm16_07
39034 B2AD           FB                           sti
39035 B2AE           F4                           hlt
39036 B2AF           E9         0082              jmp apm16_ok
39037                                           ;-----------------
39038                                           ; APM Set Power State
39039                       0000B2B2            apm16_07:
39040 B2B2           3C                     07    cmp al, #0x07
39041 B2B4           75           41              jne apm16_08
39042 B2B6           83FB                   01    cmp bx, #1
39043 B2B9           75           79              jne apm16_ok
39044 B2BB           83F9                   03    cmp cx, #3
39045 B2BE           74           0C              je apm16_07_poweroff
39046 B2C0           83F9                   02    cmp cx, #2
39047 B2C3           74           14              je apm16_07_suspend
39048 B2C5           83F9                   01    cmp cx, #1
39049 B2C8           74           1E              je apm16_07_standby
39050 B2CA           75           68              jne apm16_ok
39051                       0000B2CC            apm16_07_poweroff:
39052 B2CC           FA                           cli
39053 B2CD           BA                   8900    mov dx, #0x8900
39054 B2D0           B8                   B288    mov ax, #apm16_07_poweroff_str
39055 B2D3           E8         FF9A              call apm16_out_str
39056                       0000B2D6            apm16_07_1:
39057 B2D6           F4                           hlt
39058 B2D7           EB           FD              jmp apm16_07_1
39059                       0000B2D9            apm16_07_suspend:
39060 B2D9     66    52                           push edx
39061 B2DB           BA                   8900    mov dx, #0x8900
39062 B2DE           B8                   B291    mov ax, #apm16_07_suspend_str
39063 B2E1           E8         FF8C              call apm16_out_str
39064 B2E4     66    5A                           pop edx
39065 B2E6           EB           4C              jmp apm16_ok
39066                       0000B2E8            apm16_07_standby:
39067 B2E8     66    52                           push edx
39068 B2EA           BA                   8900    mov dx, #0x8900
39069 B2ED           B8                   B299    mov ax, #apm16_07_standby_str
39070 B2F0           E8         FF7D              call apm16_out_str
39071 B2F3     66    5A                           pop edx
39072 B2F5           EB           3D              jmp apm16_ok
39073                                           ;-----------------
39074                                           ; APM Enable / Disable
39075                       0000B2F7            apm16_08:
39076 B2F7           3C                     08    cmp al, #0x08
39077 B2F9           75           02              jne apm16_0a
39078 B2FB           EB           37              jmp apm16_ok
39079                                           ;-----------------
39080                                           ; Get Power Status
39081                       0000B2FD            apm16_0a:
39082 B2FD           3C                     0A    cmp al, #0x0a
39083 B2FF           75           10              jne apm16_0b
39084 B301           B7                     01    mov bh, #0x01
39085 B303           B3                     FF    mov bl, #0xff
39086 B305           B5                     80    mov ch, #0x80
39087 B307           B1                     FF    mov cl, #0xff
39088 B309           BA                   FFFF    mov dx, #0xffff
39089 B30C           BE                   0000    mov si, #0
39090 B30F           EB           23              jmp apm16_ok
39091                                           ;-----------------
39092                                           ; Get PM Event
39093                       0000B311            apm16_0b:
39094 B311           3C                     0B    cmp al, #0x0b
39095 B313           75           04              jne apm16_0e
39096 B315           B4                     80    mov ah, #0x80
39097 B317           EB           1E              jmp apm16_error
39098                                           ;-----------------
39099                                           ; APM Driver Version
39100                       0000B319            apm16_0e:
39101 B319           3C                     0E    cmp al, #0x0e
39102 B31B           75           06              jne apm16_0f
39103 B31D           B4                     01    mov ah, #1
39104 B31F           B0                     02    mov al, #2
39105 B321           EB           11              jmp apm16_ok
39106                                           ;-----------------
39107                                           ; APM Engage / Disengage
39108                       0000B323            apm16_0f:
39109 B323           3C                     0F    cmp al, #0x0f
39110 B325           75           02              jne apm16_10
39111 B327           EB           0B              jmp apm16_ok
39112                                           ;-----------------
39113                                           ; APM Get Capabilities
39114                       0000B329            apm16_10:
39115 B329           3C                     10    cmp al, #0x10
39116 B32B           75           0A              jne apm16_unimplemented
39117 B32D           B3                     00    mov bl, #0
39118 B32F           B9                   0000    mov cx, #0
39119 B332           EB           00              jmp apm16_ok
39120                                           ;-----------------
39121                       0000B334            apm16_ok:
39122 B334           9D                           popf
39123 B335           F8                           clc
39124 B336           CB                           retf
39125                       0000B337            apm16_unimplemented:
39126                       0000B337            apm16_error:
39127 B337           9D                           popf
39128 B338           F9                           stc
39129 B339           CB                           retf
39130                       0000B33A            apmreal_out_str:
39131 B33A     66    50                           push eax
39132 B33C     66    53                           push ebx
39133 B33E     66    89C3                         mov ebx, eax
39134                       0000B341            apmreal_out_str1:
39135 B341           2E                           SEG CS
39136 B342           8A07                         mov al, byte ptr [bx]
39137 B344           3C                     00    cmp al, #0
39138 B346           74           05              je apmreal_out_str2
39139 B348           EE                           outb dx, al
39140 B349     66    43                           inc ebx
39141 B34B           EB           F4              jmp apmreal_out_str1
39142                       0000B34D            apmreal_out_str2:
39143 B34D     66    5B                           pop ebx
39144 B34F     66    58                           pop eax
39145 B351           C3                           ret
39146                       0000B352            apmreal_07_poweroff_str:
39147 B352                        53              .ascii "Shutdown"
39148 B35A                        00              db 0
39149                       0000B35B            apmreal_07_suspend_str:
39150 B35B                        53              .ascii "Suspend"
39151 B362                        00              db 0
39152                       0000B363            apmreal_07_standby_str:
39153 B363                        53              .ascii "Standby"
39154 B36A                        00              db 0
39155 B36B           9C                           pushf
39156                       0000B36C            _apmreal_entry:
39157                                           ;-----------------
39158                                           ; APM installation check
39159                       0000B36C            apmreal_00:
39160 B36C           3C                     00    cmp al, #0x00
39161 B36E           75           0E              jne apmreal_01
39162 B370           B4                     01    mov ah, #1
39163 B372           B0                     02    mov al, #2
39164 B374           B7                     50    mov bh, #0x50
39165 B376           B3                     4D    mov bl, #0x4d
39166 B378           B9                   0003    mov cx, #0x3
39167 B37B           E9         00CE              jmp apmreal_ok
39168                                           ;-----------------
39169                                           ; APM real mode interface connect
39170                       0000B37E            apmreal_01:
39171 B37E           3C                     01    cmp al, #0x01
39172 B380           75           03              jne apmreal_02
39173 B382           E9         00C7              jmp apmreal_ok
39174                                           ;-----------------
39175                                           ; APM 16 bit protected mode interface connect
39176                       0000B385            apmreal_02:
39177 B385           3C                     02    cmp al, #0x02
39178 B387           75           12              jne apmreal_03
39179 B389           BB                   B2A1    mov bx, #_apm16_entry
39180 B38C           B8                   F000    mov ax, #0xf000
39181 B38F           BE                   FFF0    mov si, #0xfff0
39182 B392           B9                   F000    mov cx, #0xf000
39183 B395           BF                   FFF0    mov di, #0xfff0
39184 B398           E9         00B1              jmp apmreal_ok
39185                                           ;-----------------
39186                                           ; APM 32 bit protected mode interface connect
39187                       0000B39B            apmreal_03:
39188 B39B           3C                     03    cmp al, #0x03
39189 B39D           75           1B              jne apmreal_04
39190 B39F           B8                   F000    mov ax, #0xf000
39191 B3A2     66    BB               0000B1BC    mov ebx, #_apm32_entry
39192 B3A8           B9                   F000    mov cx, #0xf000
39193 B3AB     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
39194 B3B1           BA                   F000    mov dx, #0xf000
39195 B3B4           BF                   FFF0    mov di, #0xfff0
39196 B3B7           E9         0092              jmp apmreal_ok
39197                                           ;-----------------
39198                                           ; APM interface disconnect
39199                       0000B3BA            apmreal_04:
39200 B3BA           3C                     04    cmp al, #0x04
39201 B3BC           75           03              jne apmreal_05
39202 B3BE           E9         008B              jmp apmreal_ok
39203                                           ;-----------------
39204                                           ; APM cpu idle
39205                       0000B3C1            apmreal_05:
39206 B3C1           3C                     05    cmp al, #0x05
39207 B3C3           75           05              jne apmreal_07
39208 B3C5           FB                           sti
39209 B3C6           F4                           hlt
39210 B3C7           E9         0082              jmp apmreal_ok
39211                                           ;-----------------
39212                                           ; APM Set Power State
39213                       0000B3CA            apmreal_07:
39214 B3CA           3C                     07    cmp al, #0x07
39215 B3CC           75           41              jne apmreal_08
39216 B3CE           83FB                   01    cmp bx, #1
39217 B3D1           75           79              jne apmreal_ok
39218 B3D3           83F9                   03    cmp cx, #3
39219 B3D6           74           0C              je apmreal_07_poweroff
39220 B3D8           83F9                   02    cmp cx, #2
39221 B3DB           74           14              je apmreal_07_suspend
39222 B3DD           83F9                   01    cmp cx, #1
39223 B3E0           74           1E              je apmreal_07_standby
39224 B3E2           75           68              jne apmreal_ok
39225                       0000B3E4            apmreal_07_poweroff:
39226 B3E4           FA                           cli
39227 B3E5           BA                   8900    mov dx, #0x8900
39228 B3E8           B8                   B352    mov ax, #apmreal_07_poweroff_str
39229 B3EB           E8         FF4C              call apmreal_out_str
39230                       0000B3EE            apmreal_07_1:
39231 B3EE           F4                           hlt
39232 B3EF           EB           FD              jmp apmreal_07_1
39233                       0000B3F1            apmreal_07_suspend:
39234 B3F1     66    52                           push edx
39235 B3F3           BA                   8900    mov dx, #0x8900
39236 B3F6           B8                   B35B    mov ax, #apmreal_07_suspend_str
39237 B3F9           E8         FF3E              call apmreal_out_str
39238 B3FC     66    5A                           pop edx
39239 B3FE           EB           4C              jmp apmreal_ok
39240                       0000B400            apmreal_07_standby:
39241 B400     66    52                           push edx
39242 B402           BA                   8900    mov dx, #0x8900
39243 B405           B8                   B363    mov ax, #apmreal_07_standby_str
39244 B408           E8         FF2F              call apmreal_out_str
39245 B40B     66    5A                           pop edx
39246 B40D           EB           3D              jmp apmreal_ok
39247                                           ;-----------------
39248                                           ; APM Enable / Disable
39249                       0000B40F            apmreal_08:
39250 B40F           3C                     08    cmp al, #0x08
39251 B411           75           02              jne apmreal_0a
39252 B413           EB           37              jmp apmreal_ok
39253                                           ;-----------------
39254                                           ; Get Power Status
39255                       0000B415            apmreal_0a:
39256 B415           3C                     0A    cmp al, #0x0a
39257 B417           75           10              jne apmreal_0b
39258 B419           B7                     01    mov bh, #0x01
39259 B41B           B3                     FF    mov bl, #0xff
39260 B41D           B5                     80    mov ch, #0x80
39261 B41F           B1                     FF    mov cl, #0xff
39262 B421           BA                   FFFF    mov dx, #0xffff
39263 B424           BE                   0000    mov si, #0
39264 B427           EB           23              jmp apmreal_ok
39265                                           ;-----------------
39266                                           ; Get PM Event
39267                       0000B429            apmreal_0b:
39268 B429           3C                     0B    cmp al, #0x0b
39269 B42B           75           04              jne apmreal_0e
39270 B42D           B4                     80    mov ah, #0x80
39271 B42F           EB           20              jmp apmreal_error
39272                                           ;-----------------
39273                                           ; APM Driver Version
39274                       0000B431            apmreal_0e:
39275 B431           3C                     0E    cmp al, #0x0e
39276 B433           75           06              jne apmreal_0f
39277 B435           B4                     01    mov ah, #1
39278 B437           B0                     02    mov al, #2
39279 B439           EB           11              jmp apmreal_ok
39280                                           ;-----------------
39281                                           ; APM Engage / Disengage
39282                       0000B43B            apmreal_0f:
39283 B43B           3C                     0F    cmp al, #0x0f
39284 B43D           75           02              jne apmreal_10
39285 B43F           EB           0B              jmp apmreal_ok
39286                                           ;-----------------
39287                                           ; APM Get Capabilities
39288                       0000B441            apmreal_10:
39289 B441           3C                     10    cmp al, #0x10
39290 B443           75           0C              jne apmreal_unimplemented
39291 B445           B3                     00    mov bl, #0
39292 B447           B9                   0000    mov cx, #0
39293 B44A           EB           00              jmp apmreal_ok
39294                                           ;-----------------
39295                       0000B44C            apmreal_ok:
39296 B44C           9D                           popf
39297 B44D           F8                           clc
39298 B44E           E9         F8CD              jmp iret_modify_cf
39299                       0000B451            apmreal_unimplemented:
39300                       0000B451            apmreal_error:
39301 B451           9D                           popf
39302 B452           F9                           stc
39303 B453           E9         F8C8              jmp iret_modify_cf
39304                                           ;--------------------
39305                                           use32 386
39306 B456                  00000010            .align 16
39307                       0000B460            bios32_structure:
39308 B460                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
39309 B464                      B470              dw bios32_entry_point, 0xf ;; 32 bit physical address
39310 B468                        00              db 0 ;; revision level
39311                                             ;; length in paragraphs and checksum stored in a word to prevent errors
39312 B469                      A901              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
39313 B46B                        00              db 0,0,0,0,0 ;; reserved
39314 B470                  00000010            .align 16
39315                       0000B470            bios32_entry_point:
39316 B470           9C                           pushfd
39317 B471           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
39318 B476           75           29              jne unknown_service
39319 B478           B8               80000000    mov eax, #0x80000000
39320 B47D     66    BA                   0CF8    mov dx, #0x0cf8
39321 B481           EF                           out dx, eax
39322 B482     66    BA                   0CFC    mov dx, #0x0cfc
39323 B486           ED                           in eax, dx
39324 B487           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39325 B48C           75           13              jne unknown_service
39326 B48E           BB               000F0000    mov ebx, #0x000f0000
39327 B493           B9               00000000    mov ecx, #0
39328 B498           BA               0000B4B0    mov edx, #pcibios_protected
39329 B49D           30C0                         xor al, al
39330 B49F           EB           02              jmp bios32_end
39331                       0000B4A1            unknown_service:
39332 B4A1           B0                     80    mov al, #0x80
39333                       0000B4A3            bios32_end:
39334 B4A3           9D                           popfd
39335 B4A4           CB                           retf
39336 B4A5                  00000010            .align 16
39337                       0000B4B0            pcibios_protected:
39338 B4B0           9C                           pushfd
39339 B4B1           FA                           cli
39340 B4B2           56                           push esi
39341 B4B3           57                           push edi
39342 B4B4           3C                     01    cmp al, #0x01 ;; installation check
39343 B4B6           75           14              jne pci_pro_f02
39344 B4B8     66    BB                   0210    mov bx, #0x0210
39345 B4BC     66    B9                   0000    mov cx, #0
39346 B4C0           BA               20494350    mov edx, #0x20494350 ;; "PCI "
39347 B4C5           B0                     01    mov al, #0x01
39348 B4C7           E9     0000011B              jmp pci_pro_ok
39349                       0000B4CC            pci_pro_f02: ;; find pci device
39350 B4CC           3C                     02    cmp al, #0x02
39351 B4CE           75           38              jne pci_pro_f03
39352 B4D0           C1E1                   10    shl ecx, #16
39353 B4D3     66    89D1                         mov cx, dx
39354 B4D6     66    31DB                         xor bx, bx
39355 B4D9     66    BF                   0000    mov di, #0x00
39356                       0000B4DD            pci_pro_devloop:
39357 B4DD           E8     0000010C              call pci_pro_select_reg
39358 B4E2     66    BA                   0CFC    mov dx, #0x0cfc
39359 B4E6           ED                           in eax, dx
39360 B4E7           39C8                         cmp eax, ecx
39361 B4E9           75           0D              jne pci_pro_nextdev
39362 B4EB     66    83FE                   00    cmp si, #0
39363 B4EF   7505    E9     000000F1              je pci_pro_ok
39364 B4F6     66    4E                           dec si
39365                       0000B4F8            pci_pro_nextdev:
39366 B4F8     66    43                           inc bx
39367 B4FA     66    81FB                 0100    cmp bx, #0x0100
39368 B4FF           75           DC              jne pci_pro_devloop
39369 B501           B4                     86    mov ah, #0x86
39370 B503           E9     000000DA              jmp pci_pro_fail
39371                       0000B508            pci_pro_f03: ;; find class code
39372 B508           3C                     03    cmp al, #0x03
39373 B50A           75           35              jne pci_pro_f08
39374 B50C     66    31DB                         xor bx, bx
39375 B50F     66    BF                   0008    mov di, #0x08
39376                       0000B513            pci_pro_devloop2:
39377 B513           E8     000000D6              call pci_pro_select_reg
39378 B518     66    BA                   0CFC    mov dx, #0x0cfc
39379 B51C           ED                           in eax, dx
39380 B51D           C1E8                   08    shr eax, #8
39381 B520           39C8                         cmp eax, ecx
39382 B522           75           0D              jne pci_pro_nextdev2
39383 B524     66    83FE                   00    cmp si, #0
39384 B528   7505    E9     000000B8              je pci_pro_ok
39385 B52F     66    4E                           dec si
39386                       0000B531            pci_pro_nextdev2:
39387 B531     66    43                           inc bx
39388 B533     66    81FB                 0100    cmp bx, #0x0100
39389 B538           75           D9              jne pci_pro_devloop2
39390 B53A           B4                     86    mov ah, #0x86
39391 B53C           E9     000000A1              jmp pci_pro_fail
39392                       0000B541            pci_pro_f08: ;; read configuration byte
39393 B541           3C                     08    cmp al, #0x08
39394 B543           75           1B              jne pci_pro_f09
39395 B545           E8     000000A4              call pci_pro_select_reg
39396 B54A           52                           push edx
39397 B54B     66    89FA                         mov dx, di
39398 B54E     66    83E2                   03    and dx, #0x03
39399 B552     66    81C2                 0CFC    add dx, #0x0cfc
39400 B557           EC                           in al, dx
39401 B558           5A                           pop edx
39402 B559           88C1                         mov cl, al
39403 B55B           E9     00000087              jmp pci_pro_ok
39404                       0000B560            pci_pro_f09: ;; read configuration word
39405 B560           3C                     09    cmp al, #0x09
39406 B562           75           1A              jne pci_pro_f0a
39407 B564           E8     00000085              call pci_pro_select_reg
39408 B569           52                           push edx
39409 B56A     66    89FA                         mov dx, di
39410 B56D     66    83E2                   02    and dx, #0x02
39411 B571     66    81C2                 0CFC    add dx, #0x0cfc
39412 B576     66    ED                           in ax, dx
39413 B578           5A                           pop edx
39414 B579     66    89C1                         mov cx, ax
39415 B57C           EB           69              jmp pci_pro_ok
39416                       0000B57E            pci_pro_f0a: ;; read configuration dword
39417 B57E           3C                     0A    cmp al, #0x0a
39418 B580           75           10              jne pci_pro_f0b
39419 B582           E8     00000067              call pci_pro_select_reg
39420 B587           52                           push edx
39421 B588     66    BA                   0CFC    mov dx, #0x0cfc
39422 B58C           ED                           in eax, dx
39423 B58D           5A                           pop edx
39424 B58E           89C1                         mov ecx, eax
39425 B590           EB           55              jmp pci_pro_ok
39426                       0000B592            pci_pro_f0b: ;; write configuration byte
39427 B592           3C                     0B    cmp al, #0x0b
39428 B594           75           18              jne pci_pro_f0c
39429 B596           E8     00000053              call pci_pro_select_reg
39430 B59B           52                           push edx
39431 B59C     66    89FA                         mov dx, di
39432 B59F     66    83E2                   03    and dx, #0x03
39433 B5A3     66    81C2                 0CFC    add dx, #0x0cfc
39434 B5A8           88C8                         mov al, cl
39435 B5AA           EE                           out dx, al
39436 B5AB           5A                           pop edx
39437 B5AC           EB           39              jmp pci_pro_ok
39438                       0000B5AE            pci_pro_f0c: ;; write configuration word
39439 B5AE           3C                     0C    cmp al, #0x0c
39440 B5B0           75           1A              jne pci_pro_f0d
39441 B5B2           E8     00000037              call pci_pro_select_reg
39442 B5B7           52                           push edx
39443 B5B8     66    89FA                         mov dx, di
39444 B5BB     66    83E2                   02    and dx, #0x02
39445 B5BF     66    81C2                 0CFC    add dx, #0x0cfc
39446 B5C4     66    89C8                         mov ax, cx
39447 B5C7     66    EF                           out dx, ax
39448 B5C9           5A                           pop edx
39449 B5CA           EB           1B              jmp pci_pro_ok
39450                       0000B5CC            pci_pro_f0d: ;; write configuration dword
39451 B5CC           3C                     0D    cmp al, #0x0d
39452 B5CE           75           10              jne pci_pro_unknown
39453 B5D0           E8     00000019              call pci_pro_select_reg
39454 B5D5           52                           push edx
39455 B5D6     66    BA                   0CFC    mov dx, #0x0cfc
39456 B5DA           89C8                         mov eax, ecx
39457 B5DC           EF                           out dx, eax
39458 B5DD           5A                           pop edx
39459 B5DE           EB           07              jmp pci_pro_ok
39460                       0000B5E0            pci_pro_unknown:
39461 B5E0           B4                     81    mov ah, #0x81
39462                       0000B5E2            pci_pro_fail:
39463 B5E2           5F                           pop edi
39464 B5E3           5E                           pop esi
39465 B5E4           9D                           popfd
39466 B5E5           F9                           stc
39467 B5E6           CB                           retf
39468                       0000B5E7            pci_pro_ok:
39469 B5E7           30E4                         xor ah, ah
39470 B5E9           5F                           pop edi
39471 B5EA           5E                           pop esi
39472 B5EB           9D                           popfd
39473 B5EC           F8                           clc
39474 B5ED           CB                           retf
39475                       0000B5EE            pci_pro_select_reg:
39476 B5EE           52                           push edx
39477 B5EF           B8               00800000    mov eax, #0x800000
39478 B5F4     66    89D8                         mov ax, bx
39479 B5F7           C1E0                   08    shl eax, #8
39480 B5FA     66    81E7                 00FF    and di, #0xff
39481 B5FF     66    09F8                         or ax, di
39482 B602           24                     FC    and al, #0xfc
39483 B604     66    BA                   0CF8    mov dx, #0x0cf8
39484 B608           EF                           out dx, eax
39485 B609           5A                           pop edx
39486 B60A           C3                           ret
39487                                           use16 386
39488                       0000B60B            pcibios_real:
39489 B60B     66    50                           push eax
39490 B60D           52                           push dx
39491 B60E     66    B8               80000000    mov eax, #0x80000000
39492 B614           BA                   0CF8    mov dx, #0x0cf8
39493 B617     66    EF                           out dx, eax
39494 B619           BA                   0CFC    mov dx, #0x0cfc
39495 B61C     66    ED                           in eax, dx
39496 B61E     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39497 B624           74           07              je pci_present
39498 B626           5A                           pop dx
39499 B627     66    58                           pop eax
39500 B629           B4                     FF    mov ah, #0xff
39501 B62B           F9                           stc
39502 B62C           C3                           ret
39503                       0000B62D            pci_present:
39504 B62D           5A                           pop dx
39505 B62E     66    58                           pop eax
39506 B630           3C                     01    cmp al, #0x01 ;; installation check
39507 B632           75           1A              jne pci_real_f02
39508 B634           B8                   0001    mov ax, #0x0001
39509 B637           BB                   0210    mov bx, #0x0210
39510 B63A           B9                   0000    mov cx, #0
39511 B63D     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
39512 B643     66    BF               000F0000    mov edi, #0xf0000
39513 B649           BF                   B4B0    mov di, #pcibios_protected
39514 B64C           F8                           clc
39515 B64D           C3                           ret
39516                       0000B64E            pci_real_f02: ;; find pci device
39517 B64E     66    56                           push esi
39518 B650     66    57                           push edi
39519 B652           3C                     02    cmp al, #0x02
39520 B654           75           34              jne pci_real_f03
39521 B656     66    C1E1                   10    shl ecx, #16
39522 B65A           89D1                         mov cx, dx
39523 B65C           31DB                         xor bx, bx
39524 B65E           BF                   0000    mov di, #0x00
39525                       0000B661            pci_real_devloop:
39526 B661           E8         012F              call pci_real_select_reg
39527 B664           BA                   0CFC    mov dx, #0x0cfc
39528 B667     66    ED                           in eax, dx
39529 B669     66    39C8                         cmp eax, ecx
39530 B66C           75           09              jne pci_real_nextdev
39531 B66E           83FE                   00    cmp si, #0
39532 B671   7503    E9         0115              je pci_real_ok
39533 B676           4E                           dec si
39534                       0000B677            pci_real_nextdev:
39535 B677           43                           inc bx
39536 B678           81FB                 0100    cmp bx, #0x0100
39537 B67C           75           E3              jne pci_real_devloop
39538 B67E           89CA                         mov dx, cx
39539 B680     66    C1E9                   10    shr ecx, #16
39540 B684           B8                   8602    mov ax, #0x8602
39541 B687           E9         00FB              jmp pci_real_fail
39542                       0000B68A            pci_real_f03: ;; find class code
39543 B68A           3C                     03    cmp al, #0x03
39544 B68C           75           32              jne pci_real_f08
39545 B68E           31DB                         xor bx, bx
39546 B690           BF                   0008    mov di, #0x08
39547                       0000B693            pci_real_devloop2:
39548 B693           E8         00FD              call pci_real_select_reg
39549 B696           BA                   0CFC    mov dx, #0x0cfc
39550 B699     66    ED                           in eax, dx
39551 B69B     66    C1E8                   08    shr eax, #8
39552 B69F     66    39C8                         cmp eax, ecx
39553 B6A2           75           09              jne pci_real_nextdev2
39554 B6A4           83FE                   00    cmp si, #0
39555 B6A7   7503    E9         00DF              je pci_real_ok
39556 B6AC           4E                           dec si
39557                       0000B6AD            pci_real_nextdev2:
39558 B6AD           43                           inc bx
39559 B6AE           81FB                 0100    cmp bx, #0x0100
39560 B6B2           75           DF              jne pci_real_devloop2
39561 B6B4           89CA                         mov dx, cx
39562 B6B6     66    C1E9                   10    shr ecx, #16
39563 B6BA           B8                   8603    mov ax, #0x8603
39564 B6BD           E9         00C5              jmp pci_real_fail
39565                       0000B6C0            pci_real_f08: ;; read configuration byte
39566 B6C0           3C                     08    cmp al, #0x08
39567 B6C2           75           14              jne pci_real_f09
39568 B6C4           E8         00CC              call pci_real_select_reg
39569 B6C7           52                           push dx
39570 B6C8           89FA                         mov dx, di
39571 B6CA           83E2                   03    and dx, #0x03
39572 B6CD           81C2                 0CFC    add dx, #0x0cfc
39573 B6D1           EC                           in al, dx
39574 B6D2           5A                           pop dx
39575 B6D3           88C1                         mov cl, al
39576 B6D5           E9         00B3              jmp pci_real_ok
39577                       0000B6D8            pci_real_f09: ;; read configuration word
39578 B6D8           3C                     09    cmp al, #0x09
39579 B6DA           75           14              jne pci_real_f0a
39580 B6DC           E8         00B4              call pci_real_select_reg
39581 B6DF           52                           push dx
39582 B6E0           89FA                         mov dx, di
39583 B6E2           83E2                   02    and dx, #0x02
39584 B6E5           81C2                 0CFC    add dx, #0x0cfc
39585 B6E9           ED                           in ax, dx
39586 B6EA           5A                           pop dx
39587 B6EB           89C1                         mov cx, ax
39588 B6ED           E9         009B              jmp pci_real_ok
39589                       0000B6F0            pci_real_f0a: ;; read configuration dword
39590 B6F0           3C                     0A    cmp al, #0x0a
39591 B6F2           75           10              jne pci_real_f0b
39592 B6F4           E8         009C              call pci_real_select_reg
39593 B6F7           52                           push dx
39594 B6F8           BA                   0CFC    mov dx, #0x0cfc
39595 B6FB     66    ED                           in eax, dx
39596 B6FD           5A                           pop dx
39597 B6FE     66    89C1                         mov ecx, eax
39598 B701           E9         0087              jmp pci_real_ok
39599                       0000B704            pci_real_f0b: ;; write configuration byte
39600 B704           3C                     0B    cmp al, #0x0b
39601 B706           75           13              jne pci_real_f0c
39602 B708           E8         0088              call pci_real_select_reg
39603 B70B           52                           push dx
39604 B70C           89FA                         mov dx, di
39605 B70E           83E2                   03    and dx, #0x03
39606 B711           81C2                 0CFC    add dx, #0x0cfc
39607 B715           88C8                         mov al, cl
39608 B717           EE                           out dx, al
39609 B718           5A                           pop dx
39610 B719           EB           70              jmp pci_real_ok
39611                       0000B71B            pci_real_f0c: ;; write configuration word
39612 B71B           3C                     0C    cmp al, #0x0c
39613 B71D           75           13              jne pci_real_f0d
39614 B71F           E8         0071              call pci_real_select_reg
39615 B722           52                           push dx
39616 B723           89FA                         mov dx, di
39617 B725           83E2                   02    and dx, #0x02
39618 B728           81C2                 0CFC    add dx, #0x0cfc
39619 B72C           89C8                         mov ax, cx
39620 B72E           EF                           out dx, ax
39621 B72F           5A                           pop dx
39622 B730           EB           59              jmp pci_real_ok
39623                       0000B732            pci_real_f0d: ;; write configuration dword
39624 B732           3C                     0D    cmp al, #0x0d
39625 B734           75           0F              jne pci_real_f0e
39626 B736           E8         005A              call pci_real_select_reg
39627 B739           52                           push dx
39628 B73A           BA                   0CFC    mov dx, #0x0cfc
39629 B73D     66    89C8                         mov eax, ecx
39630 B740     66    EF                           out dx, eax
39631 B742           5A                           pop dx
39632 B743           EB           46              jmp pci_real_ok
39633                       0000B745            pci_real_f0e: ;; get irq routing options
39634 B745           3C                     0E    cmp al, #0x0e
39635 B747           75           3A              jne pci_real_unknown
39636 B749           26                           SEG ES
39637 B74A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39638 B74D           72           2B              jb pci_real_too_small
39639 B74F           26                           SEG ES
39640 B750           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39641 B754           9C                           pushf
39642 B755           1E                           push ds
39643 B756           06                           push es
39644 B757           51                           push cx
39645 B758           56                           push si
39646 B759           57                           push di
39647 B75A           FC                           cld
39648 B75B           BE                   B7D0    mov si, #pci_routing_table_structure_start
39649 B75E           0E                           push cs
39650 B75F           1F                           pop ds
39651 B760           26                           SEG ES
39652 B761           8B4D         02              mov cx, [di+2]
39653 B764           26                           SEG ES
39654 B765           8E45         04              mov es, [di+4]
39655 B768           89CF                         mov di, cx
39656 B76A           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
39657 B76D           F3                           rep
39658 B76E           A4                               movsb
39659 B76F           5F                           pop di
39660 B770           5E                           pop si
39661 B771           59                           pop cx
39662 B772           07                           pop es
39663 B773           1F                           pop ds
39664 B774           9D                           popf
39665 B775           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
39666 B778           EB           11              jmp pci_real_ok
39667                       0000B77A            pci_real_too_small:
39668 B77A           26                           SEG ES
39669 B77B           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39670 B77F           B4                     89    mov ah, #0x89
39671 B781           EB           02              jmp pci_real_fail
39672                       0000B783            pci_real_unknown:
39673 B783           B4                     81    mov ah, #0x81
39674                       0000B785            pci_real_fail:
39675 B785     66    5F                           pop edi
39676 B787     66    5E                           pop esi
39677 B789           F9                           stc
39678 B78A           C3                           ret
39679                       0000B78B            pci_real_ok:
39680 B78B           30E4                         xor ah, ah
39681 B78D     66    5F                           pop edi
39682 B78F     66    5E                           pop esi
39683 B791           F8                           clc
39684 B792           C3                           ret
39685                       0000B793            pci_real_select_reg:
39686 B793           52                           push dx
39687 B794     66    B8               00800000    mov eax, #0x800000
39688 B79A           89D8                         mov ax, bx
39689 B79C     66    C1E0                   08    shl eax, #8
39690 B7A0           81E7                 00FF    and di, #0xff
39691 B7A4           09F8                         or ax, di
39692 B7A6           24                     FC    and al, #0xfc
39693 B7A8           BA                   0CF8    mov dx, #0x0cf8
39694 B7AB     66    EF                           out dx, eax
39695 B7AD           5A                           pop dx
39696 B7AE           C3                           ret
39697 B7AF                  00000010            .align 16
39698                       0000B7B0            pci_routing_table_structure:
39699 B7B0                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39700 B7B4                        00              db 0, 1 ;; version
39701 B7B6                      0080              dw 32 + (6 * 16) ;; table size
39702 B7B8                        00              db 0 ;; PCI interrupt router bus
39703 B7B9                        08              db 0x08 ;; PCI interrupt router DevFunc
39704 B7BA                      0000              dw 0x0000 ;; PCI exclusive IRQs
39705 B7BC                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39706 B7BE                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39707 B7C0                      0000              dw 0,0 ;; Miniport data
39708 B7C4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39709 B7CF                        37              db 0x37 ;; checksum
39710                       0000B7D0            pci_routing_table_structure_start:
39711                                             ;; first slot entry PCI-to-ISA (embedded)
39712 B7D0                        00              db 0 ;; pci bus number
39713 B7D1                        08              db 0x08 ;; pci device number (bit 7-3)
39714 B7D2                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
39715 B7D3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39716 B7D5                        61              db 0x61 ;; link value INTB#
39717 B7D6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39718 B7D8                        62              db 0x62 ;; link value INTC#
39719 B7D9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39720 B7DB                        63              db 0x63 ;; link value INTD#
39721 B7DC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39722 B7DE                        00              db 0 ;; physical slot (0 = embedded)
39723 B7DF                        00              db 0 ;; reserved
39724                                             ;; second slot entry: 1st PCI slot
39725 B7E0                        00              db 0 ;; pci bus number
39726 B7E1                        10              db 0x10 ;; pci device number (bit 7-3)
39727 B7E2                        61              db 0x61 ;; link value INTA#
39728 B7E3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39729 B7E5                        62              db 0x62 ;; link value INTB#
39730 B7E6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39731 B7E8                        63              db 0x63 ;; link value INTC#
39732 B7E9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39733 B7EB                        60              db 0x60 ;; link value INTD#
39734 B7EC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39735 B7EE                        01              db 1 ;; physical slot (0 = embedded)
39736 B7EF                        00              db 0 ;; reserved
39737                                             ;; third slot entry: 2nd PCI slot
39738 B7F0                        00              db 0 ;; pci bus number
39739 B7F1                        18              db 0x18 ;; pci device number (bit 7-3)
39740 B7F2                        62              db 0x62 ;; link value INTA#
39741 B7F3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39742 B7F5                        63              db 0x63 ;; link value INTB#
39743 B7F6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39744 B7F8                        60              db 0x60 ;; link value INTC#
39745 B7F9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39746 B7FB                        61              db 0x61 ;; link value INTD#
39747 B7FC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39748 B7FE                        02              db 2 ;; physical slot (0 = embedded)
39749 B7FF                        00              db 0 ;; reserved
39750                                             ;; 4th slot entry: 3rd PCI slot
39751 B800                        00              db 0 ;; pci bus number
39752 B801                        20              db 0x20 ;; pci device number (bit 7-3)
39753 B802                        63              db 0x63 ;; link value INTA#
39754 B803                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39755 B805                        60              db 0x60 ;; link value INTB#
39756 B806                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39757 B808                        61              db 0x61 ;; link value INTC#
39758 B809                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39759 B80B                        62              db 0x62 ;; link value INTD#
39760 B80C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39761 B80E                        03              db 3 ;; physical slot (0 = embedded)
39762 B80F                        00              db 0 ;; reserved
39763                                             ;; 5th slot entry: 4rd PCI slot
39764 B810                        00              db 0 ;; pci bus number
39765 B811                        28              db 0x28 ;; pci device number (bit 7-3)
39766 B812                        60              db 0x60 ;; link value INTA#
39767 B813                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39768 B815                        61              db 0x61 ;; link value INTB#
39769 B816                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39770 B818                        62              db 0x62 ;; link value INTC#
39771 B819                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39772 B81B                        63              db 0x63 ;; link value INTD#
39773 B81C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39774 B81E                        04              db 4 ;; physical slot (0 = embedded)
39775 B81F                        00              db 0 ;; reserved
39776                                             ;; 6th slot entry: 5rd PCI slot
39777 B820                        00              db 0 ;; pci bus number
39778 B821                        30              db 0x30 ;; pci device number (bit 7-3)
39779 B822                        61              db 0x61 ;; link value INTA#
39780 B823                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
39781 B825                        62              db 0x62 ;; link value INTB#
39782 B826                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
39783 B828                        63              db 0x63 ;; link value INTC#
39784 B829                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
39785 B82B                        60              db 0x60 ;; link value INTD#
39786 B82C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
39787 B82E                        05              db 5 ;; physical slot (0 = embedded)
39788 B82F                        00              db 0 ;; reserved
39789                       0000B830            pci_routing_table_structure_end:
39790                       0000B830            pci_irq_list:
39791 B830                        0B              db 11, 10, 9, 5;
39792                       0000B834            pcibios_init_sel_reg:
39793 B834     66    50                           push eax
39794 B836     66    B8               00800000    mov eax, #0x800000
39795 B83C           89D8                         mov ax, bx
39796 B83E     66    C1E0                   08    shl eax, #8
39797 B842           80E2                   FC    and dl, #0xfc
39798 B845           08D0                         or al, dl
39799 B847           BA                   0CF8    mov dx, #0x0cf8
39800 B84A     66    EF                           out dx, eax
39801 B84C     66    58                           pop eax
39802 B84E           C3                           ret
39803                       0000B84F            pcibios_init_iomem_bases:
39804 B84F           55                           push bp
39805 B850           89E5                         mov bp, sp
39806 B852     66    B8               C0000000    mov eax, #0xc0000000 ;; base for memory init
39807 B858     66    50                           push eax
39808 B85A           B8                   C000    mov ax, #0xc000 ;; base for i/o init
39809 B85D           50                           push ax
39810 B85E           B8                   0010    mov ax, #0x0010 ;; start at base address #0
39811 B861           50                           push ax
39812 B862           BB                   0008    mov bx, #0x0008
39813                       0000B865            pci_init_io_loop1:
39814 B865           B2                     00    mov dl, #0x00
39815 B867           E8         FFCA              call pcibios_init_sel_reg
39816 B86A           BA                   0CFC    mov dx, #0x0cfc
39817 B86D           ED                           in ax, dx
39818 B86E           3D                   FFFF    cmp ax, #0xffff
39819 B871   7503    E9         0088              jz next_pci_dev
39820 B876           B2                     04    mov dl, #0x04 ;; disable i/o and memory space access
39821 B878           E8         FFB9              call pcibios_init_sel_reg
39822 B87B           BA                   0CFC    mov dx, #0x0cfc
39823 B87E           EC                           in al, dx
39824 B87F           24                     FC    and al, #0xfc
39825 B881           EE                           out dx, al
39826                       0000B882            pci_init_io_loop2:
39827 B882           8A56         F8              mov dl, [bp-8]
39828 B885           E8         FFAC              call pcibios_init_sel_reg
39829 B888           BA                   0CFC    mov dx, #0x0cfc
39830 B88B     66    ED                           in eax, dx
39831 B88D           A8                     01    test al, #0x01
39832 B88F           75           34              jnz init_io_base
39833 B891     66    89C1                         mov ecx, eax
39834 B894     66    B8               FFFFFFFF    mov eax, #0xffffffff
39835 B89A     66    EF                           out dx, eax
39836 B89C     66    ED                           in eax, dx
39837 B89E     66    39C8                         cmp eax, ecx
39838 B8A1           74           41              je next_pci_base
39839 B8A3     66    83F0                   FF    xor eax, #0xffffffff
39840 B8A7     66    89C1                         mov ecx, eax
39841 B8AA     66    8B46         FC              mov eax, [bp-4]
39842 B8AE     66    EF                           out dx, eax
39843 B8B0     66    01C8                         add eax, ecx ;; calculate next free mem base
39844 B8B3     66    05               01000000    add eax, #0x01000000
39845 B8B9     66    25               FF000000    and eax, #0xff000000
39846 B8BF     66    8946         FC              mov [bp-4], eax
39847 B8C3           EB           1F              jmp next_pci_base
39848                       0000B8C5            init_io_base:
39849 B8C5           89C1                         mov cx, ax
39850 B8C7           B8                   FFFF    mov ax, #0xffff
39851 B8CA           EF                           out dx, ax
39852 B8CB           ED                           in ax, dx
39853 B8CC           39C8                         cmp ax, cx
39854 B8CE           74           14              je next_pci_base
39855 B8D0           35                   FFFE    xor ax, #0xfffe
39856 B8D3           89C1                         mov cx, ax
39857 B8D5           8B46         FA              mov ax, [bp-6]
39858 B8D8           EF                           out dx, ax
39859 B8D9           01C8                         add ax, cx ;; calculate next free i/o base
39860 B8DB           05                   0100    add ax, #0x0100
39861 B8DE           25                   FF00    and ax, #0xff00
39862 B8E1           8946         FA              mov [bp-6], ax
39863                       0000B8E4            next_pci_base:
39864 B8E4           8A46         F8              mov al, [bp-8]
39865 B8E7           04                     04    add al, #0x04
39866 B8E9           3C                     28    cmp al, #0x28
39867 B8EB           74           05              je enable_iomem_space
39868 B8ED           8846         F8              mov byte ptr[bp-8], al
39869 B8F0           EB           90              jmp pci_init_io_loop2
39870                       0000B8F2            enable_iomem_space:
39871 B8F2           B2                     04    mov dl, #0x04 ;; enable i/o and memory space access if available
39872 B8F4           E8         FF3D              call pcibios_init_sel_reg
39873 B8F7           BA                   0CFC    mov dx, #0x0cfc
39874 B8FA           EC                           in al, dx
39875 B8FB           0C                     07    or al, #0x07
39876 B8FD           EE                           out dx, al
39877                       0000B8FE            next_pci_dev:
39878 B8FE           C646         F8        10    mov byte ptr[bp-8], #0x10
39879 B902           43                           inc bx
39880 B903           81FB                 0100    cmp bx, #0x0100
39881 B907   7403    E9         FF59              jne pci_init_io_loop1
39882 B90C           89EC                         mov sp, bp
39883 B90E           5D                           pop bp
39884 B90F           C3                           ret
39885                       0000B910            pcibios_init_set_elcr:
39886 B910           50                           push ax
39887 B911           51                           push cx
39888 B912           BA                   04D0    mov dx, #0x04d0
39889 B915           A8                     08    test al, #0x08
39890 B917           74           03              jz is_master_pic
39891 B919           42                           inc dx
39892 B91A           24                     07    and al, #0x07
39893                       0000B91C            is_master_pic:
39894 B91C           88C1                         mov cl, al
39895 B91E           B3                     01    mov bl, #0x01
39896 B920           D2E3                         shl bl, cl
39897 B922           EC                           in al, dx
39898 B923           08D8                         or al, bl
39899 B925           EE                           out dx, al
39900 B926           59                           pop cx
39901 B927           58                           pop ax
39902 B928           C3                           ret
39903                       0000B929            pcibios_init_irqs:
39904 B929           1E                           push ds
39905 B92A           55                           push bp
39906 B92B           B8                   F000    mov ax, #0xf000
39907 B92E           8ED8                         mov ds, ax
39908 B930           BA                   04D0    mov dx, #0x04d0 ;; reset ELCR1 + ELCR2
39909 B933           B0                     00    mov al, #0x00
39910 B935           EE                           out dx, al
39911 B936           42                           inc dx
39912 B937           EE                           out dx, al
39913 B938           BE                   B7B0    mov si, #pci_routing_table_structure
39914 B93B           8A7C         08              mov bh, [si+8]
39915 B93E           8A5C         09              mov bl, [si+9]
39916 B941           B2                     00    mov dl, #0x00
39917 B943           E8         FEEE              call pcibios_init_sel_reg
39918 B946           BA                   0CFC    mov dx, #0x0cfc
39919 B949           ED                           in ax, dx
39920 B94A           3B44         0C              cmp ax, [si+12] ;; check irq router
39921 B94D   7403    E9         00A6              jne pci_init_end
39922 B952           8A54         22              mov dl, [si+34]
39923 B955           E8         FEDC              call pcibios_init_sel_reg
39924 B958           53                           push bx ;; save irq router bus + devfunc
39925 B959           BA                   0CFC    mov dx, #0x0cfc
39926 B95C           B8                   8080    mov ax, #0x8080
39927 B95F           EF                           out dx, ax ;; reset PIRQ route control
39928 B960           83C2                   02    add dx, #2
39929 B963           EF                           out dx, ax
39930 B964           8B44         06              mov ax, [si+6]
39931 B967           2D                   0020    sub ax, #0x20
39932 B96A           C1E8                   04    shr ax, #4
39933 B96D           89C1                         mov cx, ax
39934 B96F           83C6                   20    add si, #0x20 ;; set pointer to 1st entry
39935 B972           89E5                         mov bp, sp
39936 B974           B8                   B830    mov ax, #pci_irq_list
39937 B977           50                           push ax
39938 B978           31C0                         xor ax, ax
39939 B97A           50                           push ax
39940                       0000B97B            pci_init_irq_loop1:
39941 B97B           8A3C                         mov bh, [si]
39942 B97D           8A5C         01              mov bl, [si+1]
39943                       0000B980            pci_init_irq_loop2:
39944 B980           B2                     00    mov dl, #0x00
39945 B982           E8         FEAF              call pcibios_init_sel_reg
39946 B985           BA                   0CFC    mov dx, #0x0cfc
39947 B988           ED                           in ax, dx
39948 B989           3D                   FFFF    cmp ax, #0xffff
39949 B98C           75           07              jnz pci_test_int_pin
39950 B98E           F6C3                   07    test bl, #0x07
39951 B991           74           59              jz next_pir_entry
39952 B993           EB           4D              jmp next_pci_func
39953                       0000B995            pci_test_int_pin:
39954 B995           B2                     3C    mov dl, #0x3c
39955 B997           E8         FE9A              call pcibios_init_sel_reg
39956 B99A           BA                   0CFD    mov dx, #0x0cfd
39957 B99D           EC                           in al, dx
39958 B99E           24                     07    and al, #0x07
39959 B9A0           74           40              jz next_pci_func
39960 B9A2           FEC8                         dec al ;; determine pirq reg
39961 B9A4           B2                     03    mov dl, #0x03
39962 B9A6           F6E2                         mul al, dl
39963 B9A8           04                     02    add al, #0x02
39964 B9AA           30E4                         xor ah, ah
39965 B9AC           89C3                         mov bx, ax
39966 B9AE           8A           00              mov al, [si+bx]
39967 B9B0           88C2                         mov dl, al
39968 B9B2           8B5E         00              mov bx, [bp]
39969 B9B5           E8         FE7C              call pcibios_init_sel_reg
39970 B9B8           BA                   0CFC    mov dx, #0x0cfc
39971 B9BB           24                     03    and al, #0x03
39972 B9BD           00C2                         add dl, al
39973 B9BF           EC                           in al, dx
39974 B9C0           3C                     80    cmp al, #0x80
39975 B9C2           72           0D              jb pirq_found
39976 B9C4           8B5E         FE              mov bx, [bp-2] ;; pci irq list pointer
39977 B9C7           8A07                         mov al, [bx]
39978 B9C9           EE                           out dx, al
39979 B9CA           43                           inc bx
39980 B9CB           895E         FE              mov [bp-2], bx
39981 B9CE           E8         FF3F              call pcibios_init_set_elcr
39982                       0000B9D1            pirq_found:
39983 B9D1           8A3C                         mov bh, [si]
39984 B9D3           8A5C         01              mov bl, [si+1]
39985 B9D6           025E         FD              add bl, [bp-3] ;; pci function number
39986 B9D9           B2                     3C    mov dl, #0x3c
39987 B9DB           E8         FE56              call pcibios_init_sel_reg
39988 B9DE           BA                   0CFC    mov dx, #0x0cfc
39989 B9E1           EE                           out dx, al
39990                       0000B9E2            next_pci_func:
39991 B9E2           FE46         FD              inc byte ptr[bp-3]
39992 B9E5           FEC3                         inc bl
39993 B9E7           F6C3                   07    test bl, #0x07
39994 B9EA           75           94              jnz pci_init_irq_loop2
39995                       0000B9EC            next_pir_entry:
39996 B9EC           83C6                   10    add si, #0x10
39997 B9EF           C646         FD        00    mov byte ptr[bp-3], #0x00
39998 B9F3           E2           86              loop pci_init_irq_loop1
39999 B9F5           89EC                         mov sp, bp
40000 B9F7           5B                           pop bx
40001                       0000B9F8            pci_init_end:
40002 B9F8           5D                           pop bp
40003 B9F9           1F                           pop ds
40004 B9FA           C3                           ret
40005                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
40006                       0000B9FB            detect_parport:
40007 B9FB           52                           push dx
40008 B9FC           83C2                   02    add dx, #2
40009 B9FF           EC                           in al, dx
40010 BA00           24                     DF    and al, #0xdf ; clear input mode
40011 BA02           EE                           out dx, al
40012 BA03           5A                           pop dx
40013 BA04           B0                     AA    mov al, #0xaa
40014 BA06           EE                           out dx, al
40015 BA07           EC                           in al, dx
40016 BA08           3C                     AA    cmp al, #0xaa
40017 BA0A           75           0D              jne no_parport
40018 BA0C           53                           push bx
40019 BA0D           D1E3                         shl bx, #1
40020 BA0F           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
40021 BA13           5B                           pop bx
40022 BA14           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
40023 BA18           43                           inc bx
40024                       0000BA19            no_parport:
40025 BA19           C3                           ret
40026                                           ; serial port detection: base address in DX, index in BX, timeout in CL
40027                       0000BA1A            detect_serial:
40028 BA1A           52                           push dx
40029 BA1B           42                           inc dx
40030 BA1C           B0                     02    mov al, #0x02
40031 BA1E           EE                           out dx, al
40032 BA1F           EC                           in al, dx
40033 BA20           3C                     02    cmp al, #0x02
40034 BA22           75           19              jne no_serial
40035 BA24           42                           inc dx
40036 BA25           EC                           in al, dx
40037 BA26           3C                     02    cmp al, #0x02
40038 BA28           75           13              jne no_serial
40039 BA2A           4A                           dec dx
40040 BA2B           30C0                         xor al, al
40041 BA2D           EE                           out dx, al
40042 BA2E           5A                           pop dx
40043 BA2F           53                           push bx
40044 BA30           D1E3                         shl bx, #1
40045 BA32           8997       0400              mov [bx+0x400], dx ; Serial I/O address
40046 BA36           5B                           pop bx
40047 BA37           888F       047C              mov [bx+0x47c], cl ; Serial timeout
40048 BA3B           43                           inc bx
40049 BA3C           C3                           ret
40050                       0000BA3D            no_serial:
40051 BA3D           5A                           pop dx
40052 BA3E           C3                           ret
40053                       0000BA3F            rom_checksum:
40054 BA3F           60                           pusha
40055 BA40           1E                           push ds
40056 BA41           31C0                         xor ax, ax
40057 BA43           31DB                         xor bx, bx
40058 BA45           31C9                         xor cx, cx
40059 BA47           31D2                         xor dx, dx
40060 BA49           8A2E       0002              mov ch, [2]
40061 BA4D           D1E1                         shl cx, #1
40062 BA4F           73           03              jnc checksum_loop
40063 BA51           87CA                         xchg dx, cx
40064 BA53           49                           dec cx
40065                       0000BA54            checksum_loop:
40066 BA54           0207                         add al, [bx]
40067 BA56           43                           inc bx
40068 BA57           E2           FB              loop checksum_loop
40069 BA59           85D2                         test dx, dx
40070 BA5B           74           11              je checksum_out
40071 BA5D           0207                         add al, [bx]
40072 BA5F           89D1                         mov cx, dx
40073 BA61           8CDA                         mov dx, ds
40074 BA63           80C6                   10    add dh, #0x10
40075 BA66           8EDA                         mov ds, dx
40076 BA68           31D2                         xor dx, dx
40077 BA6A           31DB                         xor bx, bx
40078 BA6C           EB           E6              jmp checksum_loop
40079                       0000BA6E            checksum_out:
40080 BA6E           24                     FF    and al, #0xff
40081 BA70           1F                           pop ds
40082 BA71           61                           popa
40083 BA72           C3                           ret
40084                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
40085                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
40086 BA73                  00000010            .align 16
40087 BA80                        00              db 0
40088                       0000BA81            pnp_string:
40089 BA81                        24              .ascii "$PnP"
40090                       0000BA85            rom_scan:
40091                                             ;; Scan for existence of valid expansion ROMS.
40092                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
40093                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
40094                                             ;; System ROM: only 0xE0000
40095                                             ;;
40096                                             ;; Header:
40097                                             ;; Offset Value
40098                                             ;; 0 0x55
40099                                             ;; 1 0xAA
40100                                             ;; 2 ROM length in 512-byte blocks
40101                                             ;; 3 ROM initialization entry point (FAR CALL)
40102                       0000BA85            rom_scan_loop:
40103 BA85           50                           push ax ;; Save AX
40104 BA86           8ED9                         mov ds, cx
40105 BA88           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
40106 BA8B           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
40107 BA91   7403    E9         009E              jne rom_scan_increment
40108 BA96           E8         FFA6              call rom_checksum
40109 BA99   7403    E9         0096              jnz rom_scan_increment
40110 BA9E           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
40111                                             ;; We want our increment in 512-byte quantities, rounded to
40112                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
40113 BAA1           A8                     03    test al, #0x03
40114 BAA3           74           04              jz block_count_rounded
40115 BAA5           24                     FC    and al, #0xfc ;; needs rounding up
40116 BAA7           04                     04    add al, #0x04
40117                       0000BAA9            block_count_rounded:
40118 BAA9           31DB                         xor bx, bx ;; Restore DS back to 0000:
40119 BAAB           8EDB                         mov ds, bx
40120 BAAD           50                           push ax ;; Save AX
40121 BAAE           57                           push di ;; Save DI
40122                                             ;; Push addr of ROM entry point
40123 BAAF           51                           push cx ;; Push seg
40124 BAB0           6A                     03    push #0x0003 ;; Push offset
40125                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40126                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
40127 BAB2           B8                   F000    mov ax, #0xf000
40128 BAB5           8EC0                         mov es, ax
40129 BAB7           8D3E       BA81              lea di, pnp_string
40130 BABB           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
40131 BABD                        FF              db 0xff ;; call_far ss:[bp+0]
40132 BABE                        5E              db 0x5e
40133 BABF                        00              db 0
40134 BAC0           FA                           cli ;; In case expansion ROM BIOS turns IF on
40135 BAC1           83C4                   02    add sp, #2 ;; Pop offset value
40136 BAC4           59                           pop cx ;; Pop seg value (restore CX)
40137                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
40138                                             ;; to init all the ROMs and then go back and build an IPL table of
40139                                             ;; all the bootable devices, but we can get away with one pass.
40140 BAC5           8ED9                         mov ds, cx ;; ROM base
40141 BAC7           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
40142 BACB           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
40143 BACD           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
40144 BAD0           75           60              jne no_bev
40145 BAD2           8B47         02              mov ax, 2[bx]
40146 BAD5           3D                   506E    cmp ax, #0x506e
40147 BAD8           75           58              jne no_bev
40148 BADA           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
40149 BADD           3D                   0000    cmp ax, #0x0000
40150 BAE0           74           17              je no_bcv
40151                                             ;; Option ROM has BCV. Run it now.
40152 BAE2           51                           push cx ;; Push seg
40153 BAE3           50                           push ax ;; Push offset
40154                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40155 BAE4           BB                   F000    mov bx, #0xf000
40156 BAE7           8EC3                         mov es, bx
40157 BAE9           8D3E       BA81              lea di, pnp_string
40158 BAED           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
40159 BAEF                        FF              db 0xff ;; call_far ss:[bp+0]
40160 BAF0                        5E              db 0x5e
40161 BAF1                        00              db 0
40162 BAF2           FA                           cli ;; In case expansion ROM BIOS turns IF on
40163 BAF3           83C4                   02    add sp, #2 ;; Pop offset value
40164 BAF6           59                           pop cx ;; Pop seg value (restore CX)
40165 BAF7           EB           39              jmp no_bev
40166                       0000BAF9            no_bcv:
40167 BAF9           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
40168 BAFC           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
40169 BAFF           74           31              je no_bev
40170                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
40171 BB01           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
40172 BB04           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
40173 BB07           8EDB                         mov ds, bx
40174 BB09           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
40175 BB0D           83FB                   08    cmp bx, #8
40176 BB10           74           20              je no_bev ;; Get out if the table is full
40177 BB12           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
40178 BB15           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
40179 BB19           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
40180 BB1C           8947         04              mov 4[bx], ax ;; and the offset
40181 BB1F           83FF                   00    cmp di, #0x0000
40182 BB22           74           06              je no_prod_str
40183 BB24           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
40184 BB27           897F         08              mov 8[bx], di ;; and the offset
40185                       0000BB2A            no_prod_str:
40186 BB2A           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
40187 BB2D           43                           inc bx ;; We have one more entry now
40188 BB2E           891E       0080              mov 0x0080, bx ;; Remember that.
40189                       0000BB32            no_bev:
40190 BB32           5F                           pop di ;; Restore DI
40191 BB33           58                           pop ax ;; Restore AX
40192                       0000BB34            rom_scan_increment:
40193 BB34           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
40194                                                           ;; because the segment selector is shifted left 4 bits.
40195 BB37           01C1                         add cx, ax
40196 BB39           58                           pop ax ;; Restore AX
40197 BB3A           39C1                         cmp cx, ax
40198 BB3C   7703    E9         FF44              jbe rom_scan_loop
40199 BB41           31C0                         xor ax, ax ;; Restore DS back to 0000:
40200 BB43           8ED8                         mov ds, ax
40201 BB45           C3                           ret
40202                       0000BB46            post_init_pic:
40203 BB46           B0                     11    mov al, #0x11 ; send initialisation commands
40204 BB48           E6                     20    out 0x20, al
40205 BB4A           E6                     A0    out 0xa0, al
40206 BB4C           B0                     08    mov al, #0x08
40207 BB4E           E6                     21    out 0x21, al
40208 BB50           B0                     70    mov al, #0x70
40209 BB52           E6                     A1    out 0xa1, al
40210 BB54           B0                     04    mov al, #0x04
40211 BB56           E6                     21    out 0x21, al
40212 BB58           B0                     02    mov al, #0x02
40213 BB5A           E6                     A1    out 0xa1, al
40214 BB5C           B0                     01    mov al, #0x01
40215 BB5E           E6                     21    out 0x21, al
40216 BB60           E6                     A1    out 0xa1, al
40217 BB62           B0                     B8    mov al, #0xb8
40218 BB64           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
40219 BB66           B0                     8F    mov al, #0x8f
40220 BB68           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
40221 BB6A           C3                           ret
40222                                           ;; the following area can be used to write dynamically generated tables
40223 BB6B                  00000010              .align 16
40224                       0000BB70            bios_table_area_start:
40225 BB70                  AAFB4442              dd 0xaafb4442
40226 BB74                  00001088              dd bios_table_area_end - bios_table_area_start - 8;
40227                                           ;--------
40228                                           ;- POST -
40229                                           ;--------
40230 E05B                                      .org 0xe05b ; POST Entry Point
40231                       0000E05B            post:
40232 E05B           31C0                         xor ax, ax
40233                                             ;; first reset the DMA controllers
40234 E05D           E6                     0D    out 0x0d,al
40235 E05F           E6                     DA    out 0xda,al
40236                                             ;; then initialize the DMA controllers
40237 E061           B0                     C0    mov al, #0xC0
40238 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
40239 E065           B0                     00    mov al, #0x00
40240 E067           E6                     D4    out 0xD4, al ; unmask channel 4
40241                                             ;; Examine CMOS shutdown status.
40242 E069           B0                     0F    mov AL, #0x0f
40243 E06B           E6                     70    out 0x70, AL
40244 E06D           E4                     71    in AL, 0x71
40245                                             ;; backup status
40246 E06F           88C3                         mov bl, al
40247                                             ;; Reset CMOS shutdown status.
40248 E071           B0                     0F    mov AL, #0x0f
40249 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
40250 E075           B0                     00    mov AL, #0x00
40251 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
40252                                             ;; Examine CMOS shutdown status.
40253 E079           88D8                         mov al, bl
40254                                             ;; 0x00, 0x09, 0x0D+ = normal startup
40255 E07B           3C                     00    cmp AL, #0x00
40256 E07D           74           24              jz normal_post
40257 E07F           3C                     0D    cmp AL, #0x0d
40258 E081           73           20              jae normal_post
40259                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
40260 E083           3C                     05    cmp al, #0x05
40261 E085   7503    E9         D028              je eoi_jmp_post
40262                                             ;; 0x0A = jmp via [0x40:0x67] jump
40263 E08A           3C                     0A    cmp al, #0x0a
40264 E08C   7503    E9         D029              je jmp_post_0x467
40265                                             ;; 0x0B = iret via [0x40:0x67]
40266 E091           3C                     0B    cmp al, #0x0b
40267 E093   7503    E9         D02A              je iret_post_0x467
40268                                             ;; 0x0C = retf via [0x40:0x67]
40269 E098           3C                     0C    cmp al, #0x0c
40270 E09A   7503    E9         D030              je retf_post_0x467
40271                                             ;; Examine CMOS shutdown status.
40272                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
40273 E09F           53                           push bx
40274 E0A0           E8         31AE              call _shutdown_status_panic
40275                       0000E0A3            normal_post:
40276                                             ; case 0: normal startup
40277 E0A3           FA                           cli
40278 E0A4           B8                   FFFE    mov ax, #0xfffe
40279 E0A7           89C4                         mov sp, ax
40280 E0A9           31C0                         xor ax, ax
40281 E0AB           8ED8                         mov ds, ax
40282 E0AD           8ED0                         mov ss, ax
40283                                             ;; Save shutdown status
40284 E0AF           881E       04B0              mov 0x04b0, bl
40285 E0B3           80FB                   FE    cmp bl, #0xfe
40286 E0B6   7503    E9         D021              jz s3_post
40287                                             ;; zero out BIOS data area (40:00..40:ff)
40288 E0BB           8EC0                         mov es, ax
40289 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
40290 E0C0           BF                   0400    mov di, #0x0400
40291 E0C3           FC                           cld
40292 E0C4           F3                           rep
40293 E0C5           AB                             stosw
40294 E0C6           E8         371A              call _log_bios_start
40295                                             ;; set all interrupts to default handler
40296 E0C9           31DB                         xor bx, bx ;; offset index
40297 E0CB           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
40298 E0CE           B8                   FF53    mov ax, #dummy_iret_handler
40299 E0D1           BA                   F000    mov dx, #0xF000
40300                       0000E0D4            post_default_ints:
40301 E0D4           8907                         mov [bx], ax
40302 E0D6           83C3                   02    add bx, #2
40303 E0D9           8917                         mov [bx], dx
40304 E0DB           83C3                   02    add bx, #2
40305 E0DE           E2           F4              loop post_default_ints
40306                                             ;; set vector 0x79 to zero
40307                                             ;; this is used by 'gardian angel' protection system
40308                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E0           B8                   0000    mov ax,  #0
 +a   E0E3           A3         01E4              mov 0x79*4, ax
 +a   E0E6           B8                   0000    mov ax,  #0
 +a   E0E9           A3         01E6              mov 0x79*4+2, ax
40309                                             ;; base memory in K 40:13 (word)
40310 E0EC           B8                   027F    mov ax, #(640 - 1)
40311 E0EF           A3         0413              mov 0x0413, ax
40312                                             ;; Manufacturing Test 40:12
40313                                             ;; zerod out above
40314                                             ;; Warm Boot Flag 0040:0072
40315                                             ;; value of 1234h = skip memory checks
40316                                             ;; zerod out above
40317                                             ;; Printer Services vector
40318                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F2           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F5           A3         005C              mov 0x17*4, ax
 +a   E0F8           B8                   F000    mov ax,  #0xF000
 +a   E0FB           A3         005E              mov 0x17*4+2, ax
40319                                             ;; Bootstrap failure vector
40320                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E0FE           B8                   ADBD    mov ax,  #int18_handler
 +a   E101           A3         0060              mov 0x18*4, ax
 +a   E104           B8                   F000    mov ax,  #0xF000
 +a   E107           A3         0062              mov 0x18*4+2, ax
40321                                             ;; Bootstrap Loader vector
40322                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10A           B8                   E6F2    mov ax,  #int19_handler
 +a   E10D           A3         0064              mov 0x19*4, ax
 +a   E110           B8                   F000    mov ax,  #0xF000
 +a   E113           A3         0066              mov 0x19*4+2, ax
40323                                             ;; User Timer Tick vector
40324                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E116           B8                   ADF5    mov ax,  #int1c_handler
 +a   E119           A3         0070              mov 0x1c*4, ax
 +a   E11C           B8                   F000    mov ax,  #0xF000
 +a   E11F           A3         0072              mov 0x1c*4+2, ax
40325                                             ;; Memory Size Check vector
40326                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E122           B8                   F841    mov ax,  #int12_handler
 +a   E125           A3         0048              mov 0x12*4, ax
 +a   E128           B8                   F000    mov ax,  #0xF000
 +a   E12B           A3         004A              mov 0x12*4+2, ax
40327                                             ;; Equipment Configuration Check vector
40328                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E12E           B8                   F84D    mov ax,  #int11_handler
 +a   E131           A3         0044              mov 0x11*4, ax
 +a   E134           B8                   F000    mov ax,  #0xF000
 +a   E137           A3         0046              mov 0x11*4+2, ax
40329                                             ;; System Services
40330                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13A           B8                   F859    mov ax,  #int15_handler
 +a   E13D           A3         0054              mov 0x15*4, ax
 +a   E140           B8                   F000    mov ax,  #0xF000
 +a   E143           A3         0056              mov 0x15*4+2, ax
40331                                             ;; EBDA setup
40332 E146           E8         CF54              call ebda_post
40333                                             ;; PIT setup
40334                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E149           B8                   FEA5    mov ax,  #int08_handler
 +a   E14C           A3         0020              mov 0x08*4, ax
 +a   E14F           B8                   F000    mov ax,  #0xF000
 +a   E152           A3         0022              mov 0x08*4+2, ax
40335                                             ;; int 1C already points at dummy_iret_handler (above)
40336 E155           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
40337 E157           E6                     43    out 0x43, al
40338 E159           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
40339 E15B           E6                     40    out 0x40, al
40340 E15D           E6                     40    out 0x40, al
40341                                             ;; Keyboard
40342                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E15F           B8                   E987    mov ax,  #int09_handler
 +a   E162           A3         0024              mov 0x09*4, ax
 +a   E165           B8                   F000    mov ax,  #0xF000
 +a   E168           A3         0026              mov 0x09*4+2, ax
40343                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E16B           B8                   E82E    mov ax,  #int16_handler
 +a   E16E           A3         0058              mov 0x16*4, ax
 +a   E171           B8                   F000    mov ax,  #0xF000
 +a   E174           A3         005A              mov 0x16*4+2, ax
40344 E177           31C0                         xor ax, ax
40345 E179           8ED8                         mov ds, ax
40346 E17B           A2         0417              mov 0x0417, al
40347 E17E           A2         0418              mov 0x0418, al
40348 E181           A2         0419              mov 0x0419, al
40349 E184           A2         0471              mov 0x0471, al
40350 E187           A2         0497              mov 0x0497, al
40351 E18A           B0                     10    mov al, #0x10
40352 E18C           A2         0496              mov 0x0496, al
40353 E18F           BB                   001E    mov bx, #0x001E
40354 E192           891E       041A              mov 0x041A, bx
40355 E196           891E       041C              mov 0x041C, bx
40356 E19A           BB                   001E    mov bx, #0x001E
40357 E19D           891E       0480              mov 0x0480, bx
40358 E1A1           BB                   003E    mov bx, #0x003E
40359 E1A4           891E       0482              mov 0x0482, bx
40360 E1A8           E8         2BCD              call _keyboard_init
40361                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
40362 E1AB           A1         0410              mov ax, 0x0410
40363 E1AE           B0                     14    mov al, #0x14
40364 E1B0           E6                     70    out 0x70, al
40365 E1B2           E4                     71    in al, 0x71
40366 E1B4           A3         0410              mov 0x0410, ax
40367                                             ;; Parallel setup
40368                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1B7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BA           A3         003C              mov 0x0F*4, ax
 +a   E1BD           B8                   F000    mov ax,  #0xF000
 +a   E1C0           A3         003E              mov 0x0F*4+2, ax
40369 E1C3           31C0                         xor ax, ax
40370 E1C5           8ED8                         mov ds, ax
40371 E1C7           31DB                         xor bx, bx
40372 E1C9           B1                     14    mov cl, #0x14 ; timeout value
40373 E1CB           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
40374 E1CE           E8         D82A              call detect_parport
40375 E1D1           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
40376 E1D4           E8         D824              call detect_parport
40377 E1D7           C1E3                   0E    shl bx, #0x0e
40378 E1DA           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
40379 E1DD           25                   3FFF    and ax, #0x3fff
40380 E1E0           09D8                         or ax, bx ; set number of parallel ports
40381 E1E2           A3         0410              mov 0x410, ax
40382                                             ;; Serial setup
40383                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1E5           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1E8           A3         0030              mov 0x0C*4, ax
 +a   E1EB           B8                   F000    mov ax,  #0xF000
 +a   E1EE           A3         0032              mov 0x0C*4+2, ax
40384                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F1           B8                   E739    mov ax,  #int14_handler
 +a   E1F4           A3         0050              mov 0x14*4, ax
 +a   E1F7           B8                   F000    mov ax,  #0xF000
 +a   E1FA           A3         0052              mov 0x14*4+2, ax
40385 E1FD           31DB                         xor bx, bx
40386 E1FF           B1                     0A    mov cl, #0x0a ; timeout value
40387 E201           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
40388 E204           E8         D813              call detect_serial
40389 E207           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
40390 E20A           E8         D80D              call detect_serial
40391 E20D           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
40392 E210           E8         D807              call detect_serial
40393 E213           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
40394 E216           E8         D801              call detect_serial
40395 E219           C1E3                   09    shl bx, #0x09
40396 E21C           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
40397 E21F           25                   F1FF    and ax, #0xf1ff
40398 E222           09D8                         or ax, bx ; set number of serial port
40399 E224           A3         0410              mov 0x410, ax
40400                                             ;; CMOS RTC
40401                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E227           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22A           A3         0068              mov 0x1A*4, ax
 +a   E22D           B8                   F000    mov ax,  #0xF000
 +a   E230           A3         006A              mov 0x1A*4+2, ax
40402                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E233           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E236           A3         0128              mov 0x4A*4, ax
 +a   E239           B8                   F000    mov ax,  #0xF000
 +a   E23C           A3         012A              mov 0x4A*4+2, ax
40403                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E23F           B8                   FE93    mov ax,  #int70_handler
 +a   E242           A3         01C0              mov 0x70*4, ax
 +a   E245           B8                   F000    mov ax,  #0xF000
 +a   E248           A3         01C2              mov 0x70*4+2, ax
40404                                             ;; BIOS DATA AREA 0x4CE ???
40405 E24B           E8         CEB8              call timer_tick_post
40406                                             ;; PS/2 mouse setup
40407                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E24E           B8                   ACF5    mov ax,  #int74_handler
 +a   E251           A3         01D0              mov 0x74*4, ax
 +a   E254           B8                   F000    mov ax,  #0xF000
 +a   E257           A3         01D2              mov 0x74*4+2, ax
40408                                             ;; IRQ13 (FPU exception) setup
40409                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25A           B8                   E2C7    mov ax,  #int75_handler
 +a   E25D           A3         01D4              mov 0x75*4, ax
 +a   E260           B8                   F000    mov ax,  #0xF000
 +a   E263           A3         01D6              mov 0x75*4+2, ax
40410                                             ;; Video setup
40411                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E266           B8                   F065    mov ax,  #int10_handler
 +a   E269           A3         0040              mov 0x10*4, ax
 +a   E26C           B8                   F000    mov ax,  #0xF000
 +a   E26F           A3         0042              mov 0x10*4+2, ax
40412                                             ;; PIC
40413 E272           E8         D8D1              call post_init_pic
40414 E275           B9                   C000    mov cx, #0xc000 ;; init vga bios
40415 E278           B8                   C780    mov ax, #0xc780
40416 E27B           E8         D807              call rom_scan
40417 E27E           E8         2FFA              call _print_bios_banner
40418 E281           E8         D5CB              call pcibios_init_iomem_bases
40419 E284           E8         D6A2              call pcibios_init_irqs
40420                                             ;;
40421                                             ;; Floppy setup
40422                                             ;;
40423 E287           E8         CB6C              call floppy_drive_post
40424                                             ;;
40425                                             ;; Hard Drive setup
40426                                             ;;
40427 E28A           E8         CBF0              call hard_drive_post
40428                                             ;;
40429                                             ;; ATA/ATAPI driver setup
40430                                             ;;
40431 E28D           E8         36BA              call _ata_init
40432 E290           E8         3B09              call _ata_detect
40433                                             ;;
40434                                             ;;
40435                                             ;; eltorito floppy/harddisk emulation from cd
40436                                             ;;
40437 E293           E8         5C0F              call _cdemu_init
40438                                             ;;
40439 E296           E8         303B              call _init_boot_vectors
40440 E299           B9                   C800    mov cx, #0xc800 ;; init option roms
40441 E29C           B8                   E000    mov ax, #0xe000
40442 E29F           E8         D7E3              call rom_scan
40443 E2A2           E8         31C3              call _interactive_bootkey
40444 E2A5           FB                           sti ;; enable interrupts
40445 E2A6           CD                     19    int #0x19
40446 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
40447                       0000E2C3            nmi:
40448                                             ;; FIXME the NMI handler should not panic
40449                                             ;; but iret when called from int75 (fpu exception)
40450 E2C3           E8         34F9              call _nmi_handler_msg
40451 E2C6           CF                           iret
40452                       0000E2C7            int75_handler:
40453 E2C7           E6                     F0    out 0xf0, al
40454 E2C9           E8         CE22              call eoi_both_pics
40455 E2CC           CD                     02    int 2
40456 E2CE           CF                           iret
40457                                           ;-------------------------------------------
40458                                           ;- INT 13h Fixed Disk Services Entry Point -
40459                                           ;-------------------------------------------
40460 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
40461                       0000E3FE            int13_handler:
40462 E3FE           E9         C931              jmp int13_relocated
40463 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
40464                                           ;----------
40465                                           ;- INT19h -
40466                                           ;----------
40467 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
40468                       0000E6F2            int19_handler:
40469 E6F2           E9         C6E4              jmp int19_relocated
40470                                           ;-------------------------------------------
40471                                           ;- System BIOS Configuration Data Table
40472                                           ;-------------------------------------------
40473 E6F5                                      .org 0xe6f5
40474 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
40475 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
40476 E6F7                        FC            db 0xFC
40477 E6F8                        00            db 0x00
40478 E6F9                        01            db 1
40479                                           ; Feature byte 1
40480                                           ; b7: 1=DMA channel 3 used by hard disk
40481                                           ; b6: 1=2 interrupt controllers present
40482                                           ; b5: 1=RTC present
40483                                           ; b4: 1=BIOS calls int 15h/4Fh every key
40484                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
40485                                           ; b2: 1=extended BIOS data area used
40486                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
40487                                           ; b0: 1=Dual bus (MicroChannel + ISA)
40488 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
40489                                           ; Feature byte 2
40490                                           ; b7: 1=32-bit DMA supported
40491                                           ; b6: 1=int16h, function 9 supported
40492                                           ; b5: 1=int15h/C6h (get POS data) supported
40493                                           ; b4: 1=int15h/C7h (get mem map info) supported
40494                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
40495                                           ; b2: 1=non-8042 kb controller
40496                                           ; b1: 1=data streaming supported
40497                                           ; b0: reserved
40498 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
40499                                           ; Feature byte 3
40500                                           ; b7: not used
40501                                           ; b6: reserved
40502                                           ; b5: reserved
40503                                           ; b4: POST supports ROM-to-RAM enable/disable
40504                                           ; b3: SCSI on system board
40505                                           ; b2: info panel installed
40506                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
40507                                           ; b0: SCSI supported in IML
40508 E6FC                        00            db 0x00
40509                                           ; Feature byte 4
40510                                           ; b7: IBM private
40511                                           ; b6: EEPROM present
40512                                           ; b5-3: ABIOS presence (011 = not supported)
40513                                           ; b2: private
40514                                           ; b1: memory split above 16Mb supported
40515                                           ; b0: POSTEXT directly supported by POST
40516 E6FD                        00            db 0x00
40517                                           ; Feature byte 5 (IBM)
40518                                           ; b1: enhanced mouse
40519                                           ; b0: flash EPROM
40520 E6FE                        00            db 0x00
40521 E729                                      .org 0xe729 ; Baud Rate Generator Table
40522                                           ;----------
40523                                           ;- INT14h -
40524                                           ;----------
40525 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
40526                       0000E739            int14_handler:
40527 E739           1E                           push ds
40528 E73A           60                           pusha
40529 E73B           31C0                         xor ax, ax
40530 E73D           8ED8                         mov ds, ax
40531 E73F           E8         5F79              call _int14_function
40532 E742           61                           popa
40533 E743           1F                           pop ds
40534 E744           CF                           iret
40535                                           ;----------------------------------------
40536                                           ;- INT 16h Keyboard Service Entry Point -
40537                                           ;----------------------------------------
40538 E82E                                      .org 0xe82e
40539                       0000E82E            int16_handler:
40540 E82E           FB                           sti
40541 E82F           1E                           push ds
40542 E830           9C                           pushf
40543 E831           60                           pusha
40544 E832           80FC                   00    cmp ah, #0x00
40545 E835           74           24              je int16_F00
40546 E837           80FC                   10    cmp ah, #0x10
40547 E83A           74           1F              je int16_F00
40548 E83C           BB                   F000    mov bx, #0xf000
40549 E83F           8EDB                         mov ds, bx
40550 E841           E8         7367              call _int16_function
40551 E844           61                           popa
40552 E845           9D                           popf
40553 E846           1F                           pop ds
40554 E847           74           09              jz int16_zero_set
40555                       0000E849            int16_zero_clear:
40556 E849           55                           push bp
40557 E84A           89E5                         mov bp, sp
40558 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
40559 E850           5D                           pop bp
40560 E851           CF                           iret
40561                       0000E852            int16_zero_set:
40562 E852           55                           push bp
40563 E853           89E5                         mov bp, sp
40564 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
40565 E859           5D                           pop bp
40566 E85A           CF                           iret
40567                       0000E85B            int16_F00:
40568 E85B           BB                   0040    mov bx, #0x0040
40569 E85E           8EDB                         mov ds, bx
40570                       0000E860            int16_wait_for_key:
40571 E860           FA                           cli
40572 E861           8B1E       001A              mov bx, 0x001a
40573 E865           3B1E       001C              cmp bx, 0x001c
40574 E869           75           04              jne int16_key_found
40575 E86B           FB                           sti
40576 E86C           90                           nop
40577 E86D           EB           F1              jmp int16_wait_for_key
40578                       0000E86F            int16_key_found:
40579 E86F           BB                   F000    mov bx, #0xf000
40580 E872           8EDB                         mov ds, bx
40581 E874           E8         7334              call _int16_function
40582 E877           61                           popa
40583 E878           9D                           popf
40584 E879           1F                           pop ds
40585 E87A           CF                           iret
40586                                           ;-------------------------------------------------
40587                                           ;- INT09h : Keyboard Hardware Service Entry Point -
40588                                           ;-------------------------------------------------
40589 E987                                      .org 0xe987
40590                       0000E987            int09_handler:
40591 E987           FA                           cli
40592 E988           50                           push ax
40593 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
40594 E98B           E6                     64    out #0x64, al
40595 E98D           B0                     0B    mov al, #0x0B
40596 E98F           E6                     20    out #0x20, al
40597 E991           E4                     20    in al, #0x20
40598 E993           24                     02    and al, #0x02
40599 E995           74           3E              jz int09_finish
40600 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
40601 E999           FB                           sti
40602 E99A           1E                           push ds
40603 E99B           60                           pusha
40604 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
40605 E99E           F9                           stc
40606 E99F           CD                     15    int #0x15
40607 E9A1           73           2C              jnc int09_done
40608                                             ;; check for extended key
40609 E9A3           3C                     E0    cmp al, #0xe0
40610 E9A5           75           0E              jne int09_check_pause
40611 E9A7           31C0                         xor ax, ax
40612 E9A9           8ED8                         mov ds, ax
40613 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
40614 E9AE           0C                     02    or al, #0x02
40615 E9B0           A2         0496              mov BYTE [0x496], al
40616 E9B3           EB           1A              jmp int09_done
40617                       0000E9B5            int09_check_pause: ;; check for pause key
40618 E9B5           3C                     E1    cmp al, #0xe1
40619 E9B7           75           0E              jne int09_process_key
40620 E9B9           31C0                         xor ax, ax
40621 E9BB           8ED8                         mov ds, ax
40622 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
40623 E9C0           0C                     01    or al, #0x01
40624 E9C2           A2         0496              mov BYTE [0x496], al
40625 E9C5           EB           08              jmp int09_done
40626                       0000E9C7            int09_process_key:
40627 E9C7           BB                   F000    mov bx, #0xf000
40628 E9CA           8EDB                         mov ds, bx
40629 E9CC           E8         7949              call _int09_function
40630                       0000E9CF            int09_done:
40631 E9CF           61                           popa
40632 E9D0           1F                           pop ds
40633 E9D1           FA                           cli
40634 E9D2           E8         C71D              call eoi_master_pic
40635                       0000E9D5            int09_finish:
40636 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
40637 E9D7           E6                     64    out #0x64, al
40638 E9D9           58                           pop ax
40639 E9DA           CF                           iret
40640                                           ;----------------------------------------
40641                                           ;- INT 13h Diskette Service Entry Point -
40642                                           ;----------------------------------------
40643 EC59                                      .org 0xec59
40644                       0000EC59            int13_diskette:
40645 EC59           E9         C125              jmp int13_noeltorito
40646                                           ;---------------------------------------------
40647                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
40648                                           ;---------------------------------------------
40649 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
40650                       0000EF57            int0e_handler:
40651 EF57           50                           push ax
40652 EF58           52                           push dx
40653 EF59           BA                   03F4    mov dx, #0x03f4
40654 EF5C           EC                           in al, dx
40655 EF5D           24                     C0    and al, #0xc0
40656 EF5F           3C                     C0    cmp al, #0xc0
40657 EF61           74           1E              je int0e_normal
40658 EF63           BA                   03F5    mov dx, #0x03f5
40659 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
40660 EF68           EE                           out dx, al
40661                       0000EF69            int0e_loop1:
40662 EF69           BA                   03F4    mov dx, #0x03f4
40663 EF6C           EC                           in al, dx
40664 EF6D           24                     C0    and al, #0xc0
40665 EF6F           3C                     C0    cmp al, #0xc0
40666 EF71           75           F6              jne int0e_loop1
40667                       0000EF73            int0e_loop2:
40668 EF73           BA                   03F5    mov dx, #0x03f5
40669 EF76           EC                           in al, dx
40670 EF77           BA                   03F4    mov dx, #0x03f4
40671 EF7A           EC                           in al, dx
40672 EF7B           24                     C0    and al, #0xc0
40673 EF7D           3C                     C0    cmp al, #0xc0
40674 EF7F           74           F2              je int0e_loop2
40675                       0000EF81            int0e_normal:
40676 EF81           1E                           push ds
40677 EF82           31C0                         xor ax, ax ;; segment 0000
40678 EF84           8ED8                         mov ds, ax
40679 EF86           E8         C169              call eoi_master_pic
40680 EF89           A0         043E              mov al, 0x043e
40681 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
40682 EF8E           A2         043E              mov 0x043e, al
40683 EF91           1F                           pop ds
40684 EF92           5A                           pop dx
40685 EF93           58                           pop ax
40686 EF94           CF                           iret
40687 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
40688                       0000EFC7            diskette_param_table:
40689                                           ;; Since no provisions are made for multiple drive types, most
40690                                           ;; values in this table are ignored. I set parameters for 1.44M
40691                                           ;; floppy here
40692 EFC7                        AF            db 0xAF
40693 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
40694 EFC9                        25            db 0x25
40695 EFCA                        02            db 0x02
40696 EFCB                        12            db 18
40697 EFCC                        1B            db 0x1B
40698 EFCD                        FF            db 0xFF
40699 EFCE                        6C            db 0x6C
40700 EFCF                        F6            db 0xF6
40701 EFD0                        0F            db 0x0F
40702 EFD1                        08            db 0x08
40703                                           ;----------------------------------------
40704                                           ;- INT17h : Printer Service Entry Point -
40705                                           ;----------------------------------------
40706 EFD2                                      .org 0xefd2
40707                       0000EFD2            int17_handler:
40708 EFD2           1E                           push ds
40709 EFD3           60                           pusha
40710 EFD4           31C0                         xor ax, ax
40711 EFD6           8ED8                         mov ds, ax
40712 EFD8           E8         B4B4              call _int17_function
40713 EFDB           61                           popa
40714 EFDC           1F                           pop ds
40715 EFDD           CF                           iret
40716                       0000EFDE            diskette_param_table2:
40717                                           ;; New diskette parameter table adding 3 parameters from IBM
40718                                           ;; Since no provisions are made for multiple drive types, most
40719                                           ;; values in this table are ignored. I set parameters for 1.44M
40720                                           ;; floppy here
40721 EFDE                        AF            db 0xAF
40722 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
40723 EFE0                        25            db 0x25
40724 EFE1                        02            db 0x02
40725 EFE2                        12            db 18
40726 EFE3                        1B            db 0x1B
40727 EFE4                        FF            db 0xFF
40728 EFE5                        6C            db 0x6C
40729 EFE6                        F6            db 0xF6
40730 EFE7                        0F            db 0x0F
40731 EFE8                        08            db 0x08
40732 EFE9                        4F            db 79 ;; maximum track
40733 EFEA                        00            db 0 ;; data transfer rate
40734 EFEB                        04            db 4 ;; drive type in cmos
40735 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
40736                                             HALT(11136)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2B80    mov ax,#11136
 +a   F04B           EF                           out dx,ax
40737 F04C           CF                           iret
40738                                           ;----------
40739                                           ;- INT10h -
40740                                           ;----------
40741 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
40742                       0000F065            int10_handler:
40743                                             ;; dont do anything, since the VGA BIOS handles int10h requests
40744 F065           CF                           iret
40745 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
40746                                           ;----------
40747                                           ;- INT12h -
40748                                           ;----------
40749 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
40750                                           ; ??? different for Pentium (machine check)?
40751                       0000F841            int12_handler:
40752 F841           1E                           push ds
40753 F842           B8                   0040    mov ax, #0x0040
40754 F845           8ED8                         mov ds, ax
40755 F847           A1         0013              mov ax, 0x0013
40756 F84A           1F                           pop ds
40757 F84B           CF                           iret
40758                                           ;----------
40759                                           ;- INT11h -
40760                                           ;----------
40761 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
40762                       0000F84D            int11_handler:
40763 F84D           1E                           push ds
40764 F84E           B8                   0040    mov ax, #0x0040
40765 F851           8ED8                         mov ds, ax
40766 F853           A1         0010              mov ax, 0x0010
40767 F856           1F                           pop ds
40768 F857           CF                           iret
40769                                           ;----------
40770                                           ;- INT15h -
40771                                           ;----------
40772 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
40773                       0000F859            int15_handler:
40774 F859           9C                           pushf
40775 F85A           80FC                   53    cmp ah, #0x53
40776 F85D           74           1C              je apm_call
40777 F85F           1E                           push ds
40778 F860           06                           push es
40779 F861           80FC                   86    cmp ah, #0x86
40780 F864           74           1D              je int15_handler32
40781 F866           80FC                   E8    cmp ah, #0xE8
40782 F869           74           18              je int15_handler32
40783 F86B           60                           pusha
40784 F86C           80FC                   C2    cmp ah, #0xC2
40785 F86F           74           0D              je int15_handler_mouse
40786 F871           E8         50AF              call _int15_function
40787                       0000F874            int15_handler_mouse_ret:
40788 F874           61                           popa
40789                       0000F875            int15_handler32_ret:
40790 F875           07                           pop es
40791 F876           1F                           pop ds
40792 F877           9D                           popf
40793 F878           E9         B4A3              jmp iret_modify_cf
40794                       0000F87B            apm_call:
40795 F87B           E9         BAEE              jmp _apmreal_entry
40796                       0000F87E            int15_handler_mouse:
40797 F87E           E8         56C4              call _int15_function_mouse
40798 F881           EB           F1              jmp int15_handler_mouse_ret
40799                       0000F883            int15_handler32:
40800 F883     66    60                           pushad
40801 F885           E8         5E2A              call _int15_function32
40802 F888     66    61                           popad
40803 F88A           EB           E9              jmp int15_handler32_ret
40804                                           ;; Protected mode IDT descriptor
40805                                           ;;
40806                                           ;; I just make the limit 0, so the machine will shutdown
40807                                           ;; if an exception occurs during protected mode memory
40808                                           ;; transfers.
40809                                           ;;
40810                                           ;; Set base to f0000 to correspond to beginning of BIOS,
40811                                           ;; in case I actually define an IDT later
40812                                           ;; Set limit to 0
40813                       0000F88C            pmode_IDT_info:
40814 F88C                      0000            dw 0x0000 ;; limit 15:00
40815 F88E                      0000            dw 0x0000 ;; base 15:00
40816 F890                        0F            db 0x0f ;; base 23:16
40817                                           ;; Real mode IDT descriptor
40818                                           ;;
40819                                           ;; Set to typical real-mode values.
40820                                           ;; base = 000000
40821                                           ;; limit = 03ff
40822                       0000F891            rmode_IDT_info:
40823 F891                      03FF            dw 0x03ff ;; limit 15:00
40824 F893                      0000            dw 0x0000 ;; base 15:00
40825 F895                        00            db 0x00 ;; base 23:16
40826                                           ;----------
40827                                           ;- INT1Ah -
40828                                           ;----------
40829 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40830                       0000FE6E            int1a_handler:
40831 FE6E           80FC                   B1    cmp ah, #0xb1
40832 FE71           75           14              jne int1a_normal
40833 FE73           E8         B795              call pcibios_real
40834 FE76           72           03              jc pcibios_error
40835 FE78           CA                   0002    retf 2
40836                       0000FE7B            pcibios_error:
40837 FE7B           88E3                         mov bl, ah
40838 FE7D           B4                     B1    mov ah, #0xb1
40839 FE7F           1E                           push ds
40840 FE80           60                           pusha
40841 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40842 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40843 FE85           EB           06              jmp int1a_callfunction
40844                       0000FE87            int1a_normal:
40845 FE87           1E                           push ds
40846 FE88           60                           pusha
40847 FE89           31C0                         xor ax, ax
40848 FE8B           8ED8                         mov ds, ax
40849                       0000FE8D            int1a_callfunction:
40850 FE8D           E8         A993              call _int1a_function
40851 FE90           61                           popa
40852 FE91           1F                           pop ds
40853 FE92           CF                           iret
40854                                           ;;
40855                                           ;; int70h: IRQ8 - CMOS RTC
40856                                           ;;
40857                       0000FE93            int70_handler:
40858 FE93           1E                           push ds
40859 FE94     66    60                           pushad
40860 FE96           31C0                         xor ax, ax
40861 FE98           8ED8                         mov ds, ax
40862 FE9A           E8         AD30              call _int70_function
40863 FE9D     66    61                           popad
40864 FE9F           1F                           pop ds
40865 FEA0           CF                           iret
40866                                           ;---------
40867                                           ;- INT08 -
40868                                           ;---------
40869 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40870                       0000FEA5            int08_handler:
40871 FEA5           FB                           sti
40872 FEA6     66    50                           push eax
40873 FEA8           1E                           push ds
40874 FEA9           31C0                         xor ax, ax
40875 FEAB           8ED8                         mov ds, ax
40876                                             ;; time to turn off drive(s)?
40877 FEAD           A0         0440              mov al,0x0440
40878 FEB0           08C0                         or al,al
40879 FEB2           74           10              jz int08_floppy_off
40880 FEB4           FEC8                         dec al
40881 FEB6           A2         0440              mov 0x0440,al
40882 FEB9           75           09              jnz int08_floppy_off
40883                                             ;; turn motor(s) off
40884 FEBB           52                           push dx
40885 FEBC           BA                   03F2    mov dx,#0x03f2
40886 FEBF           EC                           in al,dx
40887 FEC0           24                     CF    and al,#0xcf
40888 FEC2           EE                           out dx,al
40889 FEC3           5A                           pop dx
40890                       0000FEC4            int08_floppy_off:
40891 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
40892 FEC8     66    40                           inc eax
40893                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
40894 FECA     66    3D               001800B0    cmp eax, #0x001800B0
40895 FED0           72           07              jb int08_store_ticks
40896                                             ;; there has been a midnight rollover at this point
40897 FED2     66    31C0                         xor eax, eax ;; zero out counter
40898 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
40899                       0000FED9            int08_store_ticks:
40900 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
40901                                             ;; chain to user timer tick INT #0x1c
40902 FEDD           CD                     1C    int #0x1c
40903 FEDF           FA                           cli
40904 FEE0           E8         B20F              call eoi_master_pic
40905 FEE3           1F                           pop ds
40906 FEE4     66    58                           pop eax
40907 FEE6           CF                           iret
40908 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
40909 FF00                                      .org 0xff00
40910 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
40911                                           ;------------------------------------------------
40912                                           ;- IRET Instruction for Dummy Interrupt Handler -
40913                                           ;------------------------------------------------
40914 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
40915                       0000FF53            dummy_iret_handler:
40916 FF53           CF                           iret
40917 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
40918                                             HALT(11355)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2C5B    mov ax,#11355
 +a   FF5A           EF                           out dx,ax
40919 FF5B           CF                           iret
40920 FFF0                                      .org 0xfff0 ; Power-up Entry Point
40921 FFF0           EA         E05B      F000    jmp 0xf000:post
40922 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
40923 FFF5                        31            .ascii "10/11/09"
40924 FFFE                                      .org 0xfffe ; System Model ID
40925 FFFE                        FC            db 0xFC
40926 FFFF                        00            db 0x00 ; filler
40927 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
40928                                           ! 8204 endasm
40929                                           !BCC_ENDASM
40930                                           ! 8205 static Bit8u vgafont8[128*8]=
40931                                           ! Register BX used in function int70_function
40932                                           ! 8206 {
40933                                           
40934                       0000FA6E            _vgafont8:
40935                                           ! 8207  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40936 FA6E                        00            .byte	0
40937 FA6F                        00            .byte	0
40938 FA70                        00            .byte	0
40939 FA71                        00            .byte	0
40940 FA72                        00            .byte	0
40941 FA73                        00            .byte	0
40942 FA74                        00            .byte	0
40943 FA75                        00            .byte	0
40944                                           ! 8208  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
40945 FA76                        7E            .byte	$7E
40946 FA77                        81            .byte	$81
40947 FA78                        A5            .byte	$A5
40948 FA79                        81            .byte	$81
40949 FA7A                        BD            .byte	$BD
40950 FA7B                        99            .byte	$99
40951 FA7C                        81            .byte	$81
40952 FA7D                        7E            .byte	$7E
40953                                           ! 8209  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
40954 FA7E                        7E            .byte	$7E
40955 FA7F                        FF            .byte	$FF
40956 FA80                        DB            .byte	$DB
40957 FA81                        FF            .byte	$FF
40958 FA82                        C3            .byte	$C3
40959 FA83                        E7            .byte	$E7
40960 FA84                        FF            .byte	$FF
40961 FA85                        7E            .byte	$7E
40962                                           ! 8210  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40963 FA86                        6C            .byte	$6C
40964 FA87                        FE            .byte	$FE
40965 FA88                        FE            .byte	$FE
40966 FA89                        FE            .byte	$FE
40967 FA8A                        7C            .byte	$7C
40968 FA8B                        38            .byte	$38
40969 FA8C                        10            .byte	$10
40970 FA8D                        00            .byte	0
40971                                           ! 8211  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40972 FA8E                        10            .byte	$10
40973 FA8F                        38            .byte	$38
40974 FA90                        7C            .byte	$7C
40975 FA91                        FE            .byte	$FE
40976 FA92                        7C            .byte	$7C
40977 FA93                        38            .byte	$38
40978 FA94                        10            .byte	$10
40979 FA95                        00            .byte	0
40980                                           ! 8212  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
40981 FA96                        38            .byte	$38
40982 FA97                        7C            .byte	$7C
40983 FA98                        38            .byte	$38
40984 FA99                        FE            .byte	$FE
40985 FA9A                        FE            .byte	$FE
40986 FA9B                        7C            .byte	$7C
40987 FA9C                        38            .byte	$38
40988 FA9D                        7C            .byte	$7C
40989                                           ! 8213  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
40990 FA9E                        10            .byte	$10
40991 FA9F                        10            .byte	$10
40992 FAA0                        38            .byte	$38
40993 FAA1                        7C            .byte	$7C
40994 FAA2                        FE            .byte	$FE
40995 FAA3                        7C            .byte	$7C
40996 FAA4                        38            .byte	$38
40997 FAA5                        7C            .byte	$7C
40998                                           ! 8214  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
40999 FAA6                        00            .byte	0
41000 FAA7                        00            .byte	0
41001 FAA8                        18            .byte	$18
41002 FAA9                        3C            .byte	$3C
41003 FAAA                        3C            .byte	$3C
41004 FAAB                        18            .byte	$18
41005 FAAC                        00            .byte	0
41006 FAAD                        00            .byte	0
41007                                           ! 8215  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
41008 FAAE                        FF            .byte	$FF
41009 FAAF                        FF            .byte	$FF
41010 FAB0                        E7            .byte	$E7
41011 FAB1                        C3            .byte	$C3
41012 FAB2                        C3            .byte	$C3
41013 FAB3                        E7            .byte	$E7
41014 FAB4                        FF            .byte	$FF
41015 FAB5                        FF            .byte	$FF
41016                                           ! 8216  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
41017 FAB6                        00            .byte	0
41018 FAB7                        3C            .byte	$3C
41019 FAB8                        66            .byte	$66
41020 FAB9                        42            .byte	$42
41021 FABA                        42            .byte	$42
41022 FABB                        66            .byte	$66
41023 FABC                        3C            .byte	$3C
41024 FABD                        00            .byte	0
41025                                           ! 8217  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
41026 FABE                        FF            .byte	$FF
41027 FABF                        C3            .byte	$C3
41028 FAC0                        99            .byte	$99
41029 FAC1                        BD            .byte	$BD
41030 FAC2                        BD            .byte	$BD
41031 FAC3                        99            .byte	$99
41032 FAC4                        C3            .byte	$C3
41033 FAC5                        FF            .byte	$FF
41034                                           ! 8218  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
41035 FAC6                        0F            .byte	$F
41036 FAC7                        07            .byte	7
41037 FAC8                        0F            .byte	$F
41038 FAC9                        7D            .byte	$7D
41039 FACA                        CC            .byte	$CC
41040 FACB                        CC            .byte	$CC
41041 FACC                        CC            .byte	$CC
41042 FACD                        78            .byte	$78
41043                                           ! 8219  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
41044 FACE                        3C            .byte	$3C
41045 FACF                        66            .byte	$66
41046 FAD0                        66            .byte	$66
41047 FAD1                        66            .byte	$66
41048 FAD2                        3C            .byte	$3C
41049 FAD3                        18            .byte	$18
41050 FAD4                        7E            .byte	$7E
41051 FAD5                        18            .byte	$18
41052                                           ! 8220  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
41053 FAD6                        3F            .byte	$3F
41054 FAD7                        33            .byte	$33
41055 FAD8                        3F            .byte	$3F
41056 FAD9                        30            .byte	$30
41057 FADA                        30            .byte	$30
41058 FADB                        70            .byte	$70
41059 FADC                        F0            .byte	$F0
41060 FADD                        E0            .byte	$E0
41061                                           ! 8221  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
41062 FADE                        7F            .byte	$7F
41063 FADF                        63            .byte	$63
41064 FAE0                        7F            .byte	$7F
41065 FAE1                        63            .byte	$63
41066 FAE2                        63            .byte	$63
41067 FAE3                        67            .byte	$67
41068 FAE4                        E6            .byte	$E6
41069                                           ! 8221 
41070 FAE5                        C0            .byte	$C0
41071                                           ! 8222  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
41072 FAE6                        99            .byte	$99
41073 FAE7                        5A            .byte	$5A
41074 FAE8                        3C            .byte	$3C
41075 FAE9                        E7            .byte	$E7
41076 FAEA                        E7            .byte	$E7
41077 FAEB                        3C            .byte	$3C
41078 FAEC                        5A            .byte	$5A
41079 FAED                        99            .byte	$99
41080                                           ! 8223  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
41081 FAEE                        80            .byte	$80
41082 FAEF                        E0            .byte	$E0
41083 FAF0                        F8            .byte	$F8
41084 FAF1                        FE            .byte	$FE
41085 FAF2                        F8            .byte	$F8
41086 FAF3                        E0            .byte	$E0
41087 FAF4                        80            .byte	$80
41088 FAF5                        00            .byte	0
41089                                           ! 8224  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
41090 FAF6                        02            .byte	2
41091 FAF7                        0E            .byte	$E
41092 FAF8                        3E            .byte	$3E
41093 FAF9                        FE            .byte	$FE
41094 FAFA                        3E            .byte	$3E
41095 FAFB                        0E            .byte	$E
41096 FAFC                        02            .byte	2
41097 FAFD                        00            .byte	0
41098                                           ! 8225  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
41099 FAFE                        18            .byte	$18
41100 FAFF                        3C            .byte	$3C
41101 FB00                        7E            .byte	$7E
41102 FB01                        18            .byte	$18
41103 FB02                        18            .byte	$18
41104 FB03                        7E            .byte	$7E
41105 FB04                        3C            .byte	$3C
41106 FB05                        18            .byte	$18
41107                                           ! 8226  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
41108 FB06                        66            .byte	$66
41109 FB07                        66            .byte	$66
41110 FB08                        66            .byte	$66
41111 FB09                        66            .byte	$66
41112 FB0A                        66            .byte	$66
41113 FB0B                        00            .byte	0
41114 FB0C                        66            .byte	$66
41115 FB0D                        00            .byte	0
41116                                           ! 8227  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
41117 FB0E                        7F            .byte	$7F
41118 FB0F                        DB            .byte	$DB
41119 FB10                        DB            .byte	$DB
41120 FB11                        7B            .byte	$7B
41121 FB12                        1B            .byte	$1B
41122 FB13                        1B            .byte	$1B
41123 FB14                        1B            .byte	$1B
41124 FB15                        00            .byte	0
41125                                           ! 8228  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
41126 FB16                        3E            .byte	$3E
41127 FB17                        63            .byte	$63
41128 FB18                        38            .byte	$38
41129 FB19                        6C            .byte	$6C
41130 FB1A                        6C            .byte	$6C
41131 FB1B                        38            .byte	$38
41132 FB1C                        CC            .byte	$CC
41133 FB1D                        78            .byte	$78
41134                                           ! 8229  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
41135 FB1E                        00            .byte	0
41136 FB1F                        00            .byte	0
41137 FB20                        00            .byte	0
41138 FB21                        00            .byte	0
41139 FB22                        7E            .byte	$7E
41140 FB23                        7E            .byte	$7E
41141 FB24                        7E            .byte	$7E
41142 FB25                        00            .byte	0
41143                                           ! 8230  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
41144 FB26                        18            .byte	$18
41145 FB27                        3C            .byte	$3C
41146 FB28                        7E            .byte	$7E
41147 FB29                        18            .byte	$18
41148 FB2A                        7E            .byte	$7E
41149 FB2B                        3C            .byte	$3C
41150 FB2C                        18            .byte	$18
41151 FB2D                        FF            .byte	$FF
41152                                           ! 8231  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
41153 FB2E                        18            .byte	$18
41154 FB2F                        3C            .byte	$3C
41155 FB30                        7E            .byte	$7E
41156 FB31                        18            .byte	$18
41157 FB32                        18            .byte	$18
41158 FB33                        18            .byte	$18
41159 FB34                        18            .byte	$18
41160 FB35                        00            .byte	0
41161                                           ! 8232  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
41162 FB36                        18            .byte	$18
41163 FB37                        18            .byte	$18
41164 FB38                        18            .byte	$18
41165 FB39                        18            .byte	$18
41166 FB3A                        7E            .byte	$7E
41167 FB3B                        3C            .byte	$3C
41168 FB3C                        18            .byte	$18
41169 FB3D                        00            .byte	0
41170                                           ! 8233  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
41171 FB3E                        00            .byte	0
41172 FB3F                        18            .byte	$18
41173 FB40                        0C            .byte	$C
41174 FB41                        FE            .byte	$FE
41175 FB42                        0C            .byte	$C
41176 FB43                        18            .byte	$18
41177 FB44                        00            .byte	0
41178 FB45                        00            .byte	0
41179                                           ! 8234  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
41180 FB46                        00            .byte	0
41181 FB47                        30            .byte	$30
41182 FB48                        60            .byte	$60
41183 FB49                        FE            .byte	$FE
41184 FB4A                        60            .byte	$60
41185 FB4B                        30            .byte	$30
41186 FB4C                        00            .byte	0
41187 FB4D                        00            .byte	0
41188                                           ! 8235  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
41189 FB4E                        00            .byte	0
41190 FB4F                        00            .byte	0
41191 FB50                        C0            .byte	$C0
41192 FB51                        C0            .byte	$C0
41193 FB52                        C0            .byte	$C0
41194 FB53                        FE            .byte	$FE
41195 FB54                        00            .byte	0
41196 FB55                        00            .byte	0
41197                                           ! 8236  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
41198 FB56                        00            .byte	0
41199 FB57                        24            .byte	$24
41200 FB58                        66            .byte	$66
41201 FB59                        FF            .byte	$FF
41202 FB5A                        66            .byte	$66
41203 FB5B                        24            .byte	$24
41204 FB5C                        00            .byte	0
41205 FB5D                        00            .byte	0
41206                                           ! 8237  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
41207 FB5E                        00            .byte	0
41208 FB5F                        18            .byte	$18
41209 FB60                        3C            .byte	$3C
41210 FB61                        7E            .byte	$7E
41211 FB62                        FF            .byte	$FF
41212 FB63                        FF            .byte	$FF
41213 FB64                        00            .byte	0
41214 FB65                        00            .byte	0
41215                                           ! 8238  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
41216 FB66                        00            .byte	0
41217 FB67                        FF            .byte	$FF
41218 FB68                        FF            .byte	$FF
41219 FB69                        7E            .byte	$7E
41220 FB6A                        3C            .byte	$3C
41221 FB6B                        18            .byte	$18
41222 FB6C                        00            .byte	0
41223 FB6D                        00            .byte	0
41224                                           ! 8239  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41225 FB6E                        00            .byte	0
41226 FB6F                        00            .byte	0
41227 FB70                        00            .byte	0
41228 FB71                        00            .byte	0
41229 FB72                        00            .byte	0
41230 FB73                        00            .byte	0
41231 FB74                        00            .byte	0
41232 FB75                        00            .byte	0
41233                                           ! 8240  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
41234 FB76                        30            .byte	$30
41235 FB77                        78            .byte	$78
41236 FB78                        78            .byte	$78
41237 FB79                        30            .byte	$30
41238 FB7A                        30            .byte	$30
41239 FB7B                        00            .byte	0
41240 FB7C                        30            .byte	$30
41241 FB7D                        00            .byte	0
41242                                           ! 8241  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
41243 FB7E                        6C            .byte	$6C
41244 FB7F                        6C            .byte	$6C
41245 FB80                        6C            .byte	$6C
41246 FB81                        00            .byte	0
41247 FB82                        00            .byte	0
41248 FB83                        00            .byte	0
41249 FB84                        00            .byte	0
41250 FB85                        00            .byte	0
41251                                           ! 8242  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
41252 FB86                        6C            .byte	$6C
41253 FB87                        6C            .byte	$6C
41254 FB88                        FE            .byte	$FE
41255 FB89                        6C            .byte	$6C
41256 FB8A                        FE            .byte	$FE
41257 FB8B                        6C            .byte	$6C
41258 FB8C                        6C            .byte	$6C
41259 FB8D                        00            .byte	0
41260                                           ! 8243  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
41261 FB8E                        30            .byte	$30
41262 FB8F                        7C            .byte	$7C
41263 FB90                        C0            .byte	$C0
41264 FB91                        78            .byte	$78
41265 FB92                        0C            .byte	$C
41266 FB93                        F8            .byte	$F8
41267 FB94                        30            .byte	$30
41268 FB95                        00            .byte	0
41269                                           ! 8244  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
41270 FB96                        00            .byte	0
41271 FB97                        C6            .byte	$C6
41272 FB98                        CC            .byte	$CC
41273 FB99                        18            .byte	$18
41274 FB9A                        30            .byte	$30
41275 FB9B                        66            .byte	$66
41276 FB9C                        C6            .byte	$C6
41277 FB9D                        00            .byte	0
41278                                           ! 8245  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
41279 FB9E                        38            .byte	$38
41280 FB9F                        6C            .byte	$6C
41281 FBA0                        38            .byte	$38
41282 FBA1                        76            .byte	$76
41283 FBA2                        DC            .byte	$DC
41284 FBA3                        CC            .byte	$CC
41285 FBA4                        76            .byte	$76
41286 FBA5                        00            .byte	0
41287                                           ! 8246  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
41288 FBA6                        60            .byte	$60
41289 FBA7                        60            .byte	$60
41290 FBA8                        C0            .byte	$C0
41291 FBA9                        00            .byte	0
41292 FBAA                        00            .byte	0
41293 FBAB                        00            .byte	0
41294 FBAC                        00            .byte	0
41295 FBAD                        00            .byte	0
41296                                           ! 8247  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
41297 FBAE                        18            .byte	$18
41298 FBAF                        30            .byte	$30
41299 FBB0                        60            .byte	$60
41300 FBB1                        60            .byte	$60
41301 FBB2                        60            .byte	$60
41302 FBB3                        30            .byte	$30
41303 FBB4                        18            .byte	$18
41304 FBB5                        00            .byte	0
41305                                           ! 8248  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
41306 FBB6                        60            .byte	$60
41307 FBB7                        30            .byte	$30
41308 FBB8                        18            .byte	$18
41309 FBB9                        18            .byte	$18
41310 FBBA                        18            .byte	$18
41311 FBBB                        30            .byte	$30
41312 FBBC                        60            .byte	$60
41313 FBBD                        00            .byte	0
41314                                           ! 8249  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
41315 FBBE                        00            .byte	0
41316 FBBF                        66            .byte	$66
41317 FBC0                        3C            .byte	$3C
41318 FBC1                        FF            .byte	$FF
41319 FBC2                        3C            .byte	$3C
41320 FBC3                        66            .byte	$66
41321 FBC4                        00            .byte	0
41322 FBC5                        00            .byte	0
41323                                           ! 8250  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
41324 FBC6                        00            .byte	0
41325 FBC7                        30            .byte	$30
41326 FBC8                        30            .byte	$30
41327 FBC9                        FC            .byte	$FC
41328 FBCA                        30            .byte	$30
41329 FBCB                        30            .byte	$30
41330 FBCC                        00            .byte	0
41331 FBCD                        00            .byte	0
41332                                           ! 8251  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
41333 FBCE                        00            .byte	0
41334 FBCF                        00            .byte	0
41335 FBD0                        00            .byte	0
41336 FBD1                        00            .byte	0
41337 FBD2                        00            .byte	0
41338 FBD3                        30            .byte	$30
41339 FBD4                        30            .byte	$30
41340 FBD5                        60            .byte	$60
41341                                           ! 8252  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
41342 FBD6                        00            .byte	0
41343 FBD7                        00            .byte	0
41344 FBD8                        00            .byte	0
41345 FBD9                        FC            .byte	$FC
41346 FBDA                        00            .byte	0
41347 FBDB                        00            .byte	0
41348 FBDC                        00            .byte	0
41349 FBDD                        00            .byte	0
41350                                           ! 8253  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
41351 FBDE                        00            .byte	0
41352 FBDF                        00            .byte	0
41353 FBE0                        00            .byte	0
41354 FBE1                        00            .byte	0
41355 FBE2                        00            .byte	0
41356 FBE3                        30            .byte	$30
41357 FBE4                        30            .byte	$30
41358 FBE5                        00            .byte	0
41359                                           ! 8254  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
41360 FBE6                        06            .byte	6
41361 FBE7                        0C            .byte	$C
41362 FBE8                        18            .byte	$18
41363 FBE9                        30            .byte	$30
41364 FBEA                        60            .byte	$60
41365 FBEB                        C0            .byte	$C0
41366 FBEC                        80            .byte	$80
41367 FBED                        00            .byte	0
41368                                           ! 8255  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
41369 FBEE                        7C            .byte	$7C
41370 FBEF                        C6            .byte	$C6
41371 FBF0                        CE            .byte	$CE
41372 FBF1                        DE            .byte	$DE
41373 FBF2                        F6            .byte	$F6
41374 FBF3                        E6            .byte	$E6
41375 FBF4                        7C            .byte	$7C
41376 FBF5                        00            .byte	0
41377                                           ! 8256  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
41378 FBF6                        30            .byte	$30
41379 FBF7                        70            .byte	$70
41380 FBF8                        30            .byte	$30
41381 FBF9                        30            .byte	$30
41382 FBFA                        30            .byte	$30
41383 FBFB                        30            .byte	$30
41384 FBFC                        FC            .byte	$FC
41385 FBFD                        00            .byte	0
41386                                           ! 8257  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
41387 FBFE                        78            .byte	$78
41388 FBFF                        CC            .byte	$CC
41389 FC00                        0C            .byte	$C
41390 FC01                        38            .byte	$38
41391 FC02                        60            .byte	$60
41392 FC03                        CC            .byte	$CC
41393 FC04                        FC            .byte	$FC
41394 FC05                        00            .byte	0
41395                                           ! 8258  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
41396 FC06                        78            .byte	$78
41397 FC07                        CC            .byte	$CC
41398 FC08                        0C            .byte	$C
41399 FC09                        38            .byte	$38
41400 FC0A                        0C            .byte	$C
41401 FC0B                        CC            .byte	$CC
41402 FC0C                        78            .byte	$78
41403 FC0D                        00            .byte	0
41404                                           ! 8259  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
41405 FC0E                        1C            .byte	$1C
41406 FC0F                        3C            .byte	$3C
41407 FC10                        6C            .byte	$6C
41408 FC11                        CC            .byte	$CC
41409 FC12                        FE            .byte	$FE
41410 FC13                        0C            .byte	$C
41411 FC14                        1E            .byte	$1E
41412 FC15                        00            .byte	0
41413                                           ! 8260  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
41414 FC16                        FC            .byte	$FC
41415 FC17                        C0            .byte	$C0
41416 FC18                        F8            .byte	$F8
41417 FC19                        0C            .byte	$C
41418 FC1A                        0C            .byte	$C
41419 FC1B                        CC            .byte	$CC
41420 FC1C                        78            .byte	$78
41421 FC1D                        00            .byte	0
41422                                           ! 8261  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
41423 FC1E                        38            .byte	$38
41424 FC1F                        60            .byte	$60
41425 FC20                        C0            .byte	$C0
41426 FC21                        F8            .byte	$F8
41427 FC22                        CC            .byte	$CC
41428 FC23                        CC            .byte	$CC
41429 FC24                        78            .byte	$78
41430 FC25                        00            .byte	0
41431                                           ! 8262  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
41432 FC26                        FC            .byte	$FC
41433 FC27                        CC            .byte	$CC
41434 FC28                        0C            .byte	$C
41435 FC29                        18            .byte	$18
41436 FC2A                        30            .byte	$30
41437 FC2B                        30            .byte	$30
41438 FC2C                        30            .byte	$30
41439 FC2D                        00            .byte	0
41440                                           ! 8263  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0
41441 FC2E                        78            .byte	$78
41442 FC2F                        CC            .byte	$CC
41443 FC30                        CC            .byte	$CC
41444 FC31                        78            .byte	$78
41445 FC32                        CC            .byte	$CC
41446 FC33                        CC            .byte	$CC
41447                                           ! 8263 x78, 0x00,
41448 FC34                        78            .byte	$78
41449 FC35                        00            .byte	0
41450                                           ! 8264  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
41451 FC36                        78            .byte	$78
41452 FC37                        CC            .byte	$CC
41453 FC38                        CC            .byte	$CC
41454 FC39                        7C            .byte	$7C
41455 FC3A                        0C            .byte	$C
41456 FC3B                        18            .byte	$18
41457 FC3C                        70            .byte	$70
41458 FC3D                        00            .byte	0
41459                                           ! 8265  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
41460 FC3E                        00            .byte	0
41461 FC3F                        30            .byte	$30
41462 FC40                        30            .byte	$30
41463 FC41                        00            .byte	0
41464 FC42                        00            .byte	0
41465 FC43                        30            .byte	$30
41466 FC44                        30            .byte	$30
41467 FC45                        00            .byte	0
41468                                           ! 8266  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
41469 FC46                        00            .byte	0
41470 FC47                        30            .byte	$30
41471 FC48                        30            .byte	$30
41472 FC49                        00            .byte	0
41473 FC4A                        00            .byte	0
41474 FC4B                        30            .byte	$30
41475 FC4C                        30            .byte	$30
41476 FC4D                        60            .byte	$60
41477                                           ! 8267  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
41478 FC4E                        18            .byte	$18
41479 FC4F                        30            .byte	$30
41480 FC50                        60            .byte	$60
41481 FC51                        C0            .byte	$C0
41482 FC52                        60            .byte	$60
41483 FC53                        30            .byte	$30
41484 FC54                        18            .byte	$18
41485 FC55                        00            .byte	0
41486                                           ! 8268  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
41487 FC56                        00            .byte	0
41488 FC57                        00            .byte	0
41489 FC58                        FC            .byte	$FC
41490 FC59                        00            .byte	0
41491 FC5A                        00            .byte	0
41492 FC5B                        FC            .byte	$FC
41493 FC5C                        00            .byte	0
41494 FC5D                        00            .byte	0
41495                                           ! 8269  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
41496 FC5E                        60            .byte	$60
41497 FC5F                        30            .byte	$30
41498 FC60                        18            .byte	$18
41499 FC61                        0C            .byte	$C
41500 FC62                        18            .byte	$18
41501 FC63                        30            .byte	$30
41502 FC64                        60            .byte	$60
41503 FC65                        00            .byte	0
41504                                           ! 8270  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
41505 FC66                        78            .byte	$78
41506 FC67                        CC            .byte	$CC
41507 FC68                        0C            .byte	$C
41508 FC69                        18            .byte	$18
41509 FC6A                        30            .byte	$30
41510 FC6B                        00            .byte	0
41511 FC6C                        30            .byte	$30
41512 FC6D                        00            .byte	0
41513                                           ! 8271  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
41514 FC6E                        7C            .byte	$7C
41515 FC6F                        C6            .byte	$C6
41516 FC70                        DE            .byte	$DE
41517 FC71                        DE            .byte	$DE
41518 FC72                        DE            .byte	$DE
41519 FC73                        C0            .byte	$C0
41520 FC74                        78            .byte	$78
41521 FC75                        00            .byte	0
41522                                           ! 8272  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
41523 FC76                        30            .byte	$30
41524 FC77                        78            .byte	$78
41525 FC78                        CC            .byte	$CC
41526 FC79                        CC            .byte	$CC
41527 FC7A                        FC            .byte	$FC
41528 FC7B                        CC            .byte	$CC
41529 FC7C                        CC            .byte	$CC
41530 FC7D                        00            .byte	0
41531                                           ! 8273  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
41532 FC7E                        FC            .byte	$FC
41533 FC7F                        66            .byte	$66
41534 FC80                        66            .byte	$66
41535 FC81                        7C            .byte	$7C
41536 FC82                        66            .byte	$66
41537 FC83                        66            .byte	$66
41538 FC84                        FC            .byte	$FC
41539 FC85                        00            .byte	0
41540                                           ! 8274  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
41541 FC86                        3C            .byte	$3C
41542 FC87                        66            .byte	$66
41543 FC88                        C0            .byte	$C0
41544 FC89                        C0            .byte	$C0
41545 FC8A                        C0            .byte	$C0
41546 FC8B                        66            .byte	$66
41547 FC8C                        3C            .byte	$3C
41548 FC8D                        00            .byte	0
41549                                           ! 8275  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
41550 FC8E                        F8            .byte	$F8
41551 FC8F                        6C            .byte	$6C
41552 FC90                        66            .byte	$66
41553 FC91                        66            .byte	$66
41554 FC92                        66            .byte	$66
41555 FC93                        6C            .byte	$6C
41556 FC94                        F8            .byte	$F8
41557 FC95                        00            .byte	0
41558                                           ! 8276  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
41559 FC96                        FE            .byte	$FE
41560 FC97                        62            .byte	$62
41561 FC98                        68            .byte	$68
41562 FC99                        78            .byte	$78
41563 FC9A                        68            .byte	$68
41564 FC9B                        62            .byte	$62
41565 FC9C                        FE            .byte	$FE
41566 FC9D                        00            .byte	0
41567                                           ! 8277  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
41568 FC9E                        FE            .byte	$FE
41569 FC9F                        62            .byte	$62
41570 FCA0                        68            .byte	$68
41571 FCA1                        78            .byte	$78
41572 FCA2                        68            .byte	$68
41573 FCA3                        60            .byte	$60
41574 FCA4                        F0            .byte	$F0
41575 FCA5                        00            .byte	0
41576                                           ! 8278  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
41577 FCA6                        3C            .byte	$3C
41578 FCA7                        66            .byte	$66
41579 FCA8                        C0            .byte	$C0
41580 FCA9                        C0            .byte	$C0
41581 FCAA                        CE            .byte	$CE
41582 FCAB                        66            .byte	$66
41583 FCAC                        3E            .byte	$3E
41584 FCAD                        00            .byte	0
41585                                           ! 8279  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
41586 FCAE                        CC            .byte	$CC
41587 FCAF                        CC            .byte	$CC
41588 FCB0                        CC            .byte	$CC
41589 FCB1                        FC            .byte	$FC
41590 FCB2                        CC            .byte	$CC
41591 FCB3                        CC            .byte	$CC
41592 FCB4                        CC            .byte	$CC
41593 FCB5                        00            .byte	0
41594                                           ! 8280  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41595 FCB6                        78            .byte	$78
41596 FCB7                        30            .byte	$30
41597 FCB8                        30            .byte	$30
41598 FCB9                        30            .byte	$30
41599 FCBA                        30            .byte	$30
41600 FCBB                        30            .byte	$30
41601 FCBC                        78            .byte	$78
41602 FCBD                        00            .byte	0
41603                                           ! 8281  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
41604 FCBE                        1E            .byte	$1E
41605 FCBF                        0C            .byte	$C
41606 FCC0                        0C            .byte	$C
41607 FCC1                        0C            .byte	$C
41608 FCC2                        CC            .byte	$CC
41609 FCC3                        CC            .byte	$CC
41610 FCC4                        78            .byte	$78
41611 FCC5                        00            .byte	0
41612                                           ! 8282  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
41613 FCC6                        E6            .byte	$E6
41614 FCC7                        66            .byte	$66
41615 FCC8                        6C            .byte	$6C
41616 FCC9                        78            .byte	$78
41617 FCCA                        6C            .byte	$6C
41618 FCCB                        66            .byte	$66
41619 FCCC                        E6            .byte	$E6
41620 FCCD                        00            .byte	0
41621                                           ! 8283  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
41622 FCCE                        F0            .byte	$F0
41623 FCCF                        60            .byte	$60
41624 FCD0                        60            .byte	$60
41625 FCD1                        60            .byte	$60
41626 FCD2                        62            .byte	$62
41627 FCD3                        66            .byte	$66
41628 FCD4                        FE            .byte	$FE
41629 FCD5                        00            .byte	0
41630                                           ! 8284  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
41631 FCD6                        C6            .byte	$C6
41632 FCD7                        EE            .byte	$EE
41633 FCD8                        FE            .byte	$FE
41634 FCD9                        FE            .byte	$FE
41635 FCDA                        D6            .byte	$D6
41636 FCDB                        C6            .byte	$C6
41637 FCDC                        C6            .byte	$C6
41638 FCDD                        00            .byte	0
41639                                           ! 8285  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
41640 FCDE                        C6            .byte	$C6
41641 FCDF                        E6            .byte	$E6
41642 FCE0                        F6            .byte	$F6
41643 FCE1                        DE            .byte	$DE
41644 FCE2                        CE            .byte	$CE
41645 FCE3                        C6            .byte	$C6
41646 FCE4                        C6            .byte	$C6
41647 FCE5                        00            .byte	0
41648                                           ! 8286  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
41649 FCE6                        38            .byte	$38
41650 FCE7                        6C            .byte	$6C
41651 FCE8                        C6            .byte	$C6
41652 FCE9                        C6            .byte	$C6
41653 FCEA                        C6            .byte	$C6
41654 FCEB                        6C            .byte	$6C
41655 FCEC                        38            .byte	$38
41656 FCED                        00            .byte	0
41657                                           ! 8287  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
41658 FCEE                        FC            .byte	$FC
41659 FCEF                        66            .byte	$66
41660 FCF0                        66            .byte	$66
41661 FCF1                        7C            .byte	$7C
41662 FCF2                        60            .byte	$60
41663 FCF3                        60            .byte	$60
41664 FCF4                        F0            .byte	$F0
41665 FCF5                        00            .byte	0
41666                                           ! 8288  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
41667 FCF6                        78            .byte	$78
41668 FCF7                        CC            .byte	$CC
41669 FCF8                        CC            .byte	$CC
41670 FCF9                        CC            .byte	$CC
41671 FCFA                        DC            .byte	$DC
41672 FCFB                        78            .byte	$78
41673 FCFC                        1C            .byte	$1C
41674 FCFD                        00            .byte	0
41675                                           ! 8289  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
41676 FCFE                        FC            .byte	$FC
41677 FCFF                        66            .byte	$66
41678 FD00                        66            .byte	$66
41679 FD01                        7C            .byte	$7C
41680 FD02                        6C            .byte	$6C
41681 FD03                        66            .byte	$66
41682 FD04                        E6            .byte	$E6
41683 FD05                        00            .byte	0
41684                                           ! 8290  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
41685 FD06                        78            .byte	$78
41686 FD07                        CC            .byte	$CC
41687 FD08                        E0            .byte	$E0
41688 FD09                        70            .byte	$70
41689 FD0A                        1C            .byte	$1C
41690 FD0B                        CC            .byte	$CC
41691 FD0C                        78            .byte	$78
41692 FD0D                        00            .byte	0
41693                                           ! 8291  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41694 FD0E                        FC            .byte	$FC
41695 FD0F                        B4            .byte	$B4
41696 FD10                        30            .byte	$30
41697 FD11                        30            .byte	$30
41698 FD12                        30            .byte	$30
41699 FD13                        30            .byte	$30
41700 FD14                        78            .byte	$78
41701 FD15                        00            .byte	0
41702                                           ! 8292  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
41703 FD16                        CC            .byte	$CC
41704 FD17                        CC            .byte	$CC
41705 FD18                        CC            .byte	$CC
41706 FD19                        CC            .byte	$CC
41707 FD1A                        CC            .byte	$CC
41708 FD1B                        CC            .byte	$CC
41709 FD1C                        FC            .byte	$FC
41710 FD1D                        00            .byte	0
41711                                           ! 8293  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41712 FD1E                        CC            .byte	$CC
41713 FD1F                        CC            .byte	$CC
41714 FD20                        CC            .byte	$CC
41715 FD21                        CC            .byte	$CC
41716 FD22                        CC            .byte	$CC
41717 FD23                        78            .byte	$78
41718 FD24                        30            .byte	$30
41719 FD25                        00            .byte	0
41720                                           ! 8294  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
41721 FD26                        C6            .byte	$C6
41722 FD27                        C6            .byte	$C6
41723 FD28                        C6            .byte	$C6
41724 FD29                        D6            .byte	$D6
41725 FD2A                        FE            .byte	$FE
41726 FD2B                        EE            .byte	$EE
41727 FD2C                        C6            .byte	$C6
41728 FD2D                        00            .byte	0
41729                                           ! 8295  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
41730 FD2E                        C6            .byte	$C6
41731 FD2F                        C6            .byte	$C6
41732 FD30                        6C            .byte	$6C
41733 FD31                        38            .byte	$38
41734 FD32                        38            .byte	$38
41735 FD33                        6C            .byte	$6C
41736 FD34                        C6            .byte	$C6
41737 FD35                        00            .byte	0
41738                                           ! 8296  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
41739 FD36                        CC            .byte	$CC
41740 FD37                        CC            .byte	$CC
41741 FD38                        CC            .byte	$CC
41742 FD39                        78            .byte	$78
41743 FD3A                        30            .byte	$30
41744 FD3B                        30            .byte	$30
41745 FD3C                        78            .byte	$78
41746 FD3D                        00            .byte	0
41747                                           ! 8297  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
41748 FD3E                        FE            .byte	$FE
41749 FD3F                        C6            .byte	$C6
41750 FD40                        8C            .byte	$8C
41751 FD41                        18            .byte	$18
41752 FD42                        32            .byte	$32
41753 FD43                        66            .byte	$66
41754 FD44                        FE            .byte	$FE
41755 FD45                        00            .byte	0
41756                                           ! 8298  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
41757 FD46                        78            .byte	$78
41758 FD47                        60            .byte	$60
41759 FD48                        60            .byte	$60
41760 FD49                        60            .byte	$60
41761 FD4A                        60            .byte	$60
41762 FD4B                        60            .byte	$60
41763 FD4C                        78            .byte	$78
41764 FD4D                        00            .byte	0
41765                                           ! 8299  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
41766 FD4E                        C0            .byte	$C0
41767 FD4F                        60            .byte	$60
41768 FD50                        30            .byte	$30
41769 FD51                        18            .byte	$18
41770 FD52                        0C            .byte	$C
41771 FD53                        06            .byte	6
41772 FD54                        02            .byte	2
41773 FD55                        00            .byte	0
41774                                           ! 8300  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
41775 FD56                        78            .byte	$78
41776 FD57                        18            .byte	$18
41777 FD58                        18            .byte	$18
41778 FD59                        18            .byte	$18
41779 FD5A                        18            .byte	$18
41780 FD5B                        18            .byte	$18
41781 FD5C                        78            .byte	$78
41782 FD5D                        00            .byte	0
41783                                           ! 8301  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
41784 FD5E                        10            .byte	$10
41785 FD5F                        38            .byte	$38
41786 FD60                        6C            .byte	$6C
41787 FD61                        C6            .byte	$C6
41788 FD62                        00            .byte	0
41789 FD63                        00            .byte	0
41790 FD64                        00            .byte	0
41791 FD65                        00            .byte	0
41792                                           ! 8302  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
41793 FD66                        00            .byte	0
41794 FD67                        00            .byte	0
41795 FD68                        00            .byte	0
41796 FD69                        00            .byte	0
41797 FD6A                        00            .byte	0
41798 FD6B                        00            .byte	0
41799 FD6C                        00            .byte	0
41800 FD6D                        FF            .byte	$FF
41801                                           ! 8303  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
41802 FD6E                        30            .byte	$30
41803 FD6F                        30            .byte	$30
41804 FD70                        18            .byte	$18
41805 FD71                        00            .byte	0
41806 FD72                        00            .byte	0
41807 FD73                        00            .byte	0
41808 FD74                        00            .byte	0
41809 FD75                        00            .byte	0
41810                                           ! 8304  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
41811 FD76                        00            .byte	0
41812 FD77                        00            .byte	0
41813 FD78                        78            .byte	$78
41814 FD79                        0C            .byte	$C
41815 FD7A                        7C            .byte	$7C
41816 FD7B                        CC            .byte	$CC
41817 FD7C                        76            .byte	$76
41818 FD7D                        00            .byte	0
41819                                           ! 8305  0xe0, 0x60, 0x60, 0x7c, 0x6
41820 FD7E                        E0            .byte	$E0
41821 FD7F                        60            .byte	$60
41822 FD80                        60            .byte	$60
41823 FD81                        7C            .byte	$7C
41824                                           ! 8305 6, 0x66, 0xdc, 0x00,
41825 FD82                        66            .byte	$66
41826 FD83                        66            .byte	$66
41827 FD84                        DC            .byte	$DC
41828 FD85                        00            .byte	0
41829                                           ! 8306  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41830 FD86                        00            .byte	0
41831 FD87                        00            .byte	0
41832 FD88                        78            .byte	$78
41833 FD89                        CC            .byte	$CC
41834 FD8A                        C0            .byte	$C0
41835 FD8B                        CC            .byte	$CC
41836 FD8C                        78            .byte	$78
41837 FD8D                        00            .byte	0
41838                                           ! 8307  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
41839 FD8E                        1C            .byte	$1C
41840 FD8F                        0C            .byte	$C
41841 FD90                        0C            .byte	$C
41842 FD91                        7C            .byte	$7C
41843 FD92                        CC            .byte	$CC
41844 FD93                        CC            .byte	$CC
41845 FD94                        76            .byte	$76
41846 FD95                        00            .byte	0
41847                                           ! 8308  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41848 FD96                        00            .byte	0
41849 FD97                        00            .byte	0
41850 FD98                        78            .byte	$78
41851 FD99                        CC            .byte	$CC
41852 FD9A                        FC            .byte	$FC
41853 FD9B                        C0            .byte	$C0
41854 FD9C                        78            .byte	$78
41855 FD9D                        00            .byte	0
41856                                           ! 8309  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41857 FD9E                        38            .byte	$38
41858 FD9F                        6C            .byte	$6C
41859 FDA0                        60            .byte	$60
41860 FDA1                        F0            .byte	$F0
41861 FDA2                        60            .byte	$60
41862 FDA3                        60            .byte	$60
41863 FDA4                        F0            .byte	$F0
41864 FDA5                        00            .byte	0
41865                                           ! 8310  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41866 FDA6                        00            .byte	0
41867 FDA7                        00            .byte	0
41868 FDA8                        76            .byte	$76
41869 FDA9                        CC            .byte	$CC
41870 FDAA                        CC            .byte	$CC
41871 FDAB                        7C            .byte	$7C
41872 FDAC                        0C            .byte	$C
41873 FDAD                        F8            .byte	$F8
41874                                           ! 8311  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
41875 FDAE                        E0            .byte	$E0
41876 FDAF                        60            .byte	$60
41877 FDB0                        6C            .byte	$6C
41878 FDB1                        76            .byte	$76
41879 FDB2                        66            .byte	$66
41880 FDB3                        66            .byte	$66
41881 FDB4                        E6            .byte	$E6
41882 FDB5                        00            .byte	0
41883                                           ! 8312  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
41884 FDB6                        30            .byte	$30
41885 FDB7                        00            .byte	0
41886 FDB8                        70            .byte	$70
41887 FDB9                        30            .byte	$30
41888 FDBA                        30            .byte	$30
41889 FDBB                        30            .byte	$30
41890 FDBC                        78            .byte	$78
41891 FDBD                        00            .byte	0
41892                                           ! 8313  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
41893 FDBE                        0C            .byte	$C
41894 FDBF                        00            .byte	0
41895 FDC0                        0C            .byte	$C
41896 FDC1                        0C            .byte	$C
41897 FDC2                        0C            .byte	$C
41898 FDC3                        CC            .byte	$CC
41899 FDC4                        CC            .byte	$CC
41900 FDC5                        78            .byte	$78
41901                                           ! 8314  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
41902 FDC6                        E0            .byte	$E0
41903 FDC7                        60            .byte	$60
41904 FDC8                        66            .byte	$66
41905 FDC9                        6C            .byte	$6C
41906 FDCA                        78            .byte	$78
41907 FDCB                        6C            .byte	$6C
41908 FDCC                        E6            .byte	$E6
41909 FDCD                        00            .byte	0
41910                                           ! 8315  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41911 FDCE                        70            .byte	$70
41912 FDCF                        30            .byte	$30
41913 FDD0                        30            .byte	$30
41914 FDD1                        30            .byte	$30
41915 FDD2                        30            .byte	$30
41916 FDD3                        30            .byte	$30
41917 FDD4                        78            .byte	$78
41918 FDD5                        00            .byte	0
41919                                           ! 8316  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
41920 FDD6                        00            .byte	0
41921 FDD7                        00            .byte	0
41922 FDD8                        CC            .byte	$CC
41923 FDD9                        FE            .byte	$FE
41924 FDDA                        FE            .byte	$FE
41925 FDDB                        D6            .byte	$D6
41926 FDDC                        C6            .byte	$C6
41927 FDDD                        00            .byte	0
41928                                           ! 8317  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
41929 FDDE                        00            .byte	0
41930 FDDF                        00            .byte	0
41931 FDE0                        F8            .byte	$F8
41932 FDE1                        CC            .byte	$CC
41933 FDE2                        CC            .byte	$CC
41934 FDE3                        CC            .byte	$CC
41935 FDE4                        CC            .byte	$CC
41936 FDE5                        00            .byte	0
41937                                           ! 8318  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
41938 FDE6                        00            .byte	0
41939 FDE7                        00            .byte	0
41940 FDE8                        78            .byte	$78
41941 FDE9                        CC            .byte	$CC
41942 FDEA                        CC            .byte	$CC
41943 FDEB                        CC            .byte	$CC
41944 FDEC                        78            .byte	$78
41945 FDED                        00            .byte	0
41946                                           ! 8319  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
41947 FDEE                        00            .byte	0
41948 FDEF                        00            .byte	0
41949 FDF0                        DC            .byte	$DC
41950 FDF1                        66            .byte	$66
41951 FDF2                        66            .byte	$66
41952 FDF3                        7C            .byte	$7C
41953 FDF4                        60            .byte	$60
41954 FDF5                        F0            .byte	$F0
41955                                           ! 8320  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
41956 FDF6                        00            .byte	0
41957 FDF7                        00            .byte	0
41958 FDF8                        76            .byte	$76
41959 FDF9                        CC            .byte	$CC
41960 FDFA                        CC            .byte	$CC
41961 FDFB                        7C            .byte	$7C
41962 FDFC                        0C            .byte	$C
41963 FDFD                        1E            .byte	$1E
41964                                           ! 8321  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
41965 FDFE                        00            .byte	0
41966 FDFF                        00            .byte	0
41967 FE00                        DC            .byte	$DC
41968 FE01                        76            .byte	$76
41969 FE02                        66            .byte	$66
41970 FE03                        60            .byte	$60
41971 FE04                        F0            .byte	$F0
41972 FE05                        00            .byte	0
41973                                           ! 8322  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
41974 FE06                        00            .byte	0
41975 FE07                        00            .byte	0
41976 FE08                        7C            .byte	$7C
41977 FE09                        C0            .byte	$C0
41978 FE0A                        78            .byte	$78
41979 FE0B                        0C            .byte	$C
41980 FE0C                        F8            .byte	$F8
41981 FE0D                        00            .byte	0
41982                                           ! 8323  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
41983 FE0E                        10            .byte	$10
41984 FE0F                        30            .byte	$30
41985 FE10                        7C            .byte	$7C
41986 FE11                        30            .byte	$30
41987 FE12                        30            .byte	$30
41988 FE13                        34            .byte	$34
41989 FE14                        18            .byte	$18
41990 FE15                        00            .byte	0
41991                                           ! 8324  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
41992 FE16                        00            .byte	0
41993 FE17                        00            .byte	0
41994 FE18                        CC            .byte	$CC
41995 FE19                        CC            .byte	$CC
41996 FE1A                        CC            .byte	$CC
41997 FE1B                        CC            .byte	$CC
41998 FE1C                        76            .byte	$76
41999 FE1D                        00            .byte	0
42000                                           ! 8325  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
42001 FE1E                        00            .byte	0
42002 FE1F                        00            .byte	0
42003 FE20                        CC            .byte	$CC
42004 FE21                        CC            .byte	$CC
42005 FE22                        CC            .byte	$CC
42006 FE23                        78            .byte	$78
42007 FE24                        30            .byte	$30
42008 FE25                        00            .byte	0
42009                                           ! 8326  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
42010 FE26                        00            .byte	0
42011 FE27                        00            .byte	0
42012 FE28                        C6            .byte	$C6
42013 FE29                        D6            .byte	$D6
42014 FE2A                        FE            .byte	$FE
42015 FE2B                        FE            .byte	$FE
42016 FE2C                        6C            .byte	$6C
42017 FE2D                        00            .byte	0
42018                                           ! 8327  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
42019 FE2E                        00            .byte	0
42020 FE2F                        00            .byte	0
42021 FE30                        C6            .byte	$C6
42022 FE31                        6C            .byte	$6C
42023 FE32                        38            .byte	$38
42024 FE33                        6C            .byte	$6C
42025 FE34                        C6            .byte	$C6
42026 FE35                        00            .byte	0
42027                                           ! 8328  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
42028 FE36                        00            .byte	0
42029 FE37                        00            .byte	0
42030 FE38                        CC            .byte	$CC
42031 FE39                        CC            .byte	$CC
42032 FE3A                        CC            .byte	$CC
42033 FE3B                        7C            .byte	$7C
42034 FE3C                        0C            .byte	$C
42035 FE3D                        F8            .byte	$F8
42036                                           ! 8329  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
42037 FE3E                        00            .byte	0
42038 FE3F                        00            .byte	0
42039 FE40                        FC            .byte	$FC
42040 FE41                        98            .byte	$98
42041 FE42                        30            .byte	$30
42042 FE43                        64            .byte	$64
42043 FE44                        FC            .byte	$FC
42044 FE45                        00            .byte	0
42045                                           ! 8330  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
42046 FE46                        1C            .byte	$1C
42047 FE47                        30            .byte	$30
42048 FE48                        30            .byte	$30
42049 FE49                        E0            .byte	$E0
42050 FE4A                        30            .byte	$30
42051 FE4B                        30            .byte	$30
42052 FE4C                        1C            .byte	$1C
42053 FE4D                        00            .byte	0
42054                                           ! 8331  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
42055 FE4E                        18            .byte	$18
42056 FE4F                        18            .byte	$18
42057 FE50                        18            .byte	$18
42058 FE51                        00            .byte	0
42059 FE52                        18            .byte	$18
42060 FE53                        18            .byte	$18
42061 FE54                        18            .byte	$18
42062 FE55                        00            .byte	0
42063                                           ! 8332  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
42064 FE56                        E0            .byte	$E0
42065 FE57                        30            .byte	$30
42066 FE58                        30            .byte	$30
42067 FE59                        1C            .byte	$1C
42068 FE5A                        30            .byte	$30
42069 FE5B                        30            .byte	$30
42070 FE5C                        E0            .byte	$E0
42071 FE5D                        00            .byte	0
42072                                           ! 8333  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
42073 FE5E                        76            .byte	$76
42074 FE5F                        DC            .byte	$DC
42075 FE60                        00            .byte	0
42076 FE61                        00            .byte	0
42077 FE62                        00            .byte	0
42078 FE63                        00            .byte	0
42079 FE64                        00            .byte	0
42080 FE65                        00            .byte	0
42081                                           ! 8334  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
42082 FE66                        00            .byte	0
42083 FE67                        10            .byte	$10
42084 FE68                        38            .byte	$38
42085 FE69                        6C            .byte	$6C
42086 FE6A                        C6            .byte	$C6
42087 FE6B                        C6            .byte	$C6
42088 FE6C                        FE            .byte	$FE
42089 FE6D                        00            .byte	0
42090                                           ! 8335 };
42091                                           !BCC_EOS
42092                                           ! 8336 #asm
42093                                           !BCC_ASM
42094 CC00                                      .org 0xcc00
42095                       0000CC00            bios_table_area_end:
42096                                           ! 8339 endasm
42097                                           !BCC_ENDASM
42098                                           ! 8340 
42099                       0000CC00            .784:
42100                       0000CC00            .793:
42101 CC00                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
42102 CC28                        20            .ascii	" found at index %d"
42103 CC3A                        0A            .byte	$A
42104 CC3B                        00            .byte	0
42105                       0000CC3C            .782:
42106                       0000CC3C            .794:
42107 CC3C                        50            .ascii	"PCI device %04x:%04x not found at index "
42108 CC64                        25            .ascii	"%d"
42109 CC66                        0A            .byte	$A
42110 CC67                        00            .byte	0
42111                       0000CC68            .77C:
42112                       0000CC68            .795:
42113 CC68                        62            .ascii	"bad PCI vendor ID %04x"
42114 CC7E                        0A            .byte	$A
42115 CC7F                        00            .byte	0
42116                       0000CC80            .778:
42117                       0000CC80            .796:
42118 CC80                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
42119 CCA4                        0A            .byte	$A
42120 CCA5                        00            .byte	0
42121                       0000CCA6            .774:
42122                       0000CCA6            .797:
42123 CCA6                        50            .ascii	"PCI BIOS: PCI not present"
42124 CCBF                        0A            .byte	$A
42125 CCC0                        00            .byte	0
42126                       0000CCC1            .759:
42127                       0000CCC1            .798:
42128 CCC1                        42            .ascii	"Booting from %x:%x"
42129 CCD3                        0A            .byte	$A
42130 CCD4                        00            .byte	0
42131                       0000CCD5            .744:
42132                       0000CCD5            .799:
42133 CCD5                        49            .ascii	"Invalid boot device (0x%x)"
42134 CCEF                        0A            .byte	$A
42135 CCF0                        00            .byte	0
42136                       0000CCF1            .741:
42137                       0000CCF1            .79A:
42138 CCF1                        4E            .ascii	"No bootable device."
42139 CD04                        0A            .byte	$A
42140 CD05                        00            .byte	0
42141                       0000CD06            .72B:
42142                       0000CD06            .79B:
42143 CD06                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
42144 CD2B                        0A            .byte	$A
42145 CD2C                        00            .byte	0
42146                       0000CD2D            .726:
42147                       0000CD2D            .79C:
42148 CD2D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
42149 CD50                        0A            .byte	$A
42150 CD51                        00            .byte	0
42151                       0000CD52            .714:
42152                       0000CD52            .79D:
42153 CD52                        66            .ascii	"floppy: int13: bad floppy type"
42154 CD70                        0A            .byte	$A
42155 CD71                        00            .byte	0
42156                       0000CD72            .6FC:
42157                       0000CD72            .79E:
42158 CD72                        69            .ascii	"int13_diskette_function: write error"
42159 CD96                        0A            .byte	$A
42160 CD97                        00            .byte	0
42161                       0000CD98            .6F6:
42162                       0000CD98            .79F:
42163 CD98                        69            .ascii	"int13_diskette: ctrl not ready"
42164 CDB6                        0A            .byte	$A
42165 CDB7                        00            .byte	0
42166                       0000CDB8            .6DB:
42167                       0000CDB8            .7A0:
42168 CDB8                        69            .ascii	"int13_diskette_function: read error"
42169 CDDB                        0A            .byte	$A
42170 CDDC                        00            .byte	0
42171                       0000CDDD            .6D5:
42172                       0000CDDD            .7A1:
42173 CDDD                        69            .ascii	"int13_diskette: ctrl not ready"
42174 CDFB                        0A            .byte	$A
42175 CDFC                        00            .byte	0
42176                       0000CDFD            .6C3:
42177                       0000CDFD            .7A2:
42178 CDFD                        69            .ascii	"int13_diskette: ctrl not ready"
42179 CE1B                        0A            .byte	$A
42180 CE1C                        00            .byte	0
42181                       0000CE1D            .6AE:
42182                       0000CE1D            .7A3:
42183 CE1D                        69            .ascii	"int13_diskette: read/write/verify: param"
42184 CE45                        65            .ascii	"eter out of range"
42185 CE56                        0A            .byte	$A
42186 CE57                        00            .byte	0
42187                       0000CE58            .64C:
42188                       0000CE58            .7A4:
42189 CE58                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
42190 CE80                        2C            .ascii	", returns fail"
42191 CE8E                        0A            .byte	$A
42192 CE8F                        00            .byte	0
42193                       0000CE90            .634:
42194                       0000CE90            .7A5:
42195 CE90                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
42196 CEB8                        0A            .byte	$A
42197 CEB9                        00            .byte	0
42198                       0000CEBA            .616:
42199                       0000CEBA            .7A6:
42200 CEBA                        69            .ascii	"int13_cdemu: function %02x, emulation no"
42201 CEE2                        74            .ascii	"t active for DL= %02x"
42202 CEF7                        0A            .byte	$A
42203 CEF8                        00            .byte	0
42204                       0000CEF9            .612:
42205                       0000CEF9            .7A7:
42206 CEF9                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
42207 CF1C                        0A            .byte	$A
42208 CF1D                        00            .byte	0
42209                       0000CF1E            .60D:
42210                       0000CF1E            .7A8:
42211 CF1E                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
42212 CF46                        20            .ascii	" report"
42213 CF4D                        0A            .byte	$A
42214 CF4E                        00            .byte	0
42215                       0000CF4F            .602:
42216                       0000CF4F            .7A9:
42217 CF4F                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
42218 CF6F                        0A            .byte	$A
42219 CF70                        00            .byte	0
42220                       0000CF71            .5BB:
42221                       0000CF71            .7AA:
42222 CF71                        69            .ascii	"int13_cdrom: function %02x, status %02x "
42223 CF99                        21            .ascii	"!"
42224 CF9A                        0A            .byte	$A
42225 CF9B                        00            .byte	0
42226                       0000CF9C            .5B5:
42227                       0000CF9C            .7AB:
42228 CF9C                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
42229 CFC4                        62            .ascii	"bits lba"
42230 CFCC                        0A            .byte	$A
42231 CFCD                        00            .byte	0
42232                       0000CFCE            .59B:
42233                       0000CFCE            .7AC:
42234 CFCE                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
42235 CFF6                        69            .ascii	"ice for ELDL=%02x"
42236 D007                        0A            .byte	$A
42237 D008                        00            .byte	0
42238                       0000D009            .598:
42239                       0000D009            .7AD:
42240 D009                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
42241 D031                        72            .ascii	"range %02x"
42242 D03B                        0A            .byte	$A
42243 D03C                        00            .byte	0
42244                       0000D03D            .590:
42245                       0000D03D            .7AE:
42246 D03D                        69            .ascii	"int13_harddisk: function %02xh unsupport"
42247 D065                        65            .ascii	"ed, returns fail"
42248 D075                        0A            .byte	$A
42249 D076                        00            .byte	0
42250                       0000D077            .58A:
42251                       0000D077            .7AF:
42252 D077                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
42253 D09F                        6E            .ascii	"nted, returns success"
42254 D0B4                        0A            .byte	$A
42255 D0B5                        00            .byte	0
42256                       0000D0B6            .549:
42257                       0000D0B6            .7B0:
42258 D0B6                        69            .ascii	"int13_harddisk: function %02x, error %02"
42259 D0DE                        78            .ascii	"x !"
42260 D0E1                        0A            .byte	$A
42261 D0E2                        00            .byte	0
42262                       0000D0E3            .540:
42263                       0000D0E3            .7B1:
42264 D0E3                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42265 D10B                        66            .ascii	"f range"
42266 D112                        0A            .byte	$A
42267 D113                        00            .byte	0
42268                       0000D114            .53C:
42269                       0000D114            .7B2:
42270 D114                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42271 D13C                        66            .ascii	"f range"
42272 D143                        0A            .byte	$A
42273 D144                        00            .byte	0
42274                       0000D145            .52E:
42275                       0000D145            .7B3:
42276 D145                        66            .ascii	"format disk track called"
42277 D15D                        0A            .byte	$A
42278 D15E                        00            .byte	0
42279                       0000D15F            .52C:
42280                       0000D15F            .7B4:
42281 D15F                        69            .ascii	"int13_harddisk: function %02x, error %02"
42282 D187                        78            .ascii	"x !"
42283 D18A                        0A            .byte	$A
42284 D18B                        00            .byte	0
42285                       0000D18C            .521:
42286                       0000D18C            .7B5:
42287 D18C                        69            .ascii	"int13_harddisk: function %02x, parameter"
42288 D1B4                        73            .ascii	"s out of range %04x/%04x/%04x!"
42289 D1D2                        0A            .byte	$A
42290 D1D3                        00            .byte	0
42291                       0000D1D4            .51C:
42292                       0000D1D4            .7B6:
42293 D1D4                        69            .ascii	"int13_harddisk: function %02x, parameter"
42294 D1FC                        20            .ascii	" out of range!"
42295 D20A                        0A            .byte	$A
42296 D20B                        00            .byte	0
42297                       0000D20C            .50C:
42298                       0000D20C            .7B7:
42299 D20C                        69            .ascii	"int13_harddisk: function %02x, unmapped "
42300 D234                        64            .ascii	"device for ELDL=%02x"
42301 D248                        0A            .byte	$A
42302 D249                        00            .byte	0
42303                       0000D24A            .509:
42304                       0000D24A            .7B8:
42305 D24A                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
42306 D272                        6F            .ascii	"of range %02x"
42307 D27F                        0A            .byte	$A
42308 D280                        00            .byte	0
42309                       0000D281            .4F6:
42310                       0000D281            .7B9:
42311 D281                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
42312 D2A9                        6F            .ascii	"ode are zero?"
42313 D2B6                        0A            .byte	$A
42314 D2B7                        00            .byte	0
42315                       0000D2B8            .4DE:
42316                       0000D2B8            .7BA:
42317 D2B8                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
42318 D2E0                        72            .ascii	"read: 0x%02x!"
42319 D2ED                        0A            .byte	$A
42320 D2EE                        00            .byte	0
42321                       0000D2EF            .4B3:
42322                       0000D2EF            .7BB:
42323 D2EF                        4B            .ascii	"KBD: int09 handler: AL=0"
42324 D307                        0A            .byte	$A
42325 D308                        00            .byte	0
42326                       0000D309            .4B0:
42327                       0000D309            .7BC:
42328 D309                        73            .ascii	"setkbdcomm"
42329 D313                        00            .byte	0
42330                       0000D314            .4A9:
42331                       0000D314            .7BD:
42332 D314                        73            .ascii	"sendmouse"
42333 D31D                        00            .byte	0
42334                       0000D31E            .4A6:
42335                       0000D31E            .7BE:
42336 D31E                        65            .ascii	"enabmouse"
42337 D327                        00            .byte	0
42338                       0000D328            .49F:
42339                       0000D328            .7BF:
42340 D328                        65            .ascii	"enabmouse"
42341 D331                        00            .byte	0
42342                       0000D332            .49C:
42343                       0000D332            .7C0:
42344 D332                        69            .ascii	"inhibmouse"
42345 D33C                        00            .byte	0
42346                       0000D33D            .495:
42347                       0000D33D            .7C1:
42348 D33D                        69            .ascii	"inhibmouse"
42349 D347                        00            .byte	0
42350                       0000D348            .488:
42351                       0000D348            .7C2:
42352 D348                        4B            .ascii	"KBD: unsupported int 16h function %02x"
42353 D36E                        0A            .byte	$A
42354 D36F                        00            .byte	0
42355                       0000D370            .477:
42356                       0000D370            .7C3:
42357 D370                        4B            .ascii	"KBD: int16h: out of keyboard input"
42358 D392                        0A            .byte	$A
42359 D393                        00            .byte	0
42360                       0000D394            .449:
42361                       0000D394            .7C4:
42362 D394                        4B            .ascii	"KBD: int16h: out of keyboard input"
42363 D3B6                        0A            .byte	$A
42364 D3B7                        00            .byte	0
42365                       0000D3B8            .436:
42366                       0000D3B8            .7C5:
42367 D3B8                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42368 D3E0                        74            .ascii	"t yet supported!"
42369 D3F0                        0A            .byte	$A
42370 D3F1                        00            .byte	0
42371                       0000D3F2            .40F:
42372                       0000D3F2            .7C6:
42373 D3F2                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42374 D41A                        74            .ascii	"t yet supported!"
42375 D42A                        0A            .byte	$A
42376 D42B                        00            .byte	0
42377                       0000D42C            .403:
42378                       0000D42C            .7C7:
42379 D42C                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
42380 D444                        0A            .byte	$A
42381 D445                        00            .byte	0
42382                       0000D446            .3ED:
42383                       0000D446            .7C8:
42384 D446                        4D            .ascii	"Mouse status returned %02x (should be ac"
42385 D46E                        6B            .ascii	"k)"
42386 D470                        0A            .byte	$A
42387 D471                        00            .byte	0
42388                       0000D472            .3DD:
42389                       0000D472            .7C9:
42390 D472                        4D            .ascii	"Mouse status returned %02x (should be ac"
42391 D49A                        6B            .ascii	"k)"
42392 D49C                        0A            .byte	$A
42393 D49D                        00            .byte	0
42394                       0000D49E            .3DA:
42395                       0000D49E            .7CA:
42396 D49E                        4D            .ascii	"Mouse status returned %02x (should be ac"
42397 D4C6                        6B            .ascii	"k)"
42398 D4C8                        0A            .byte	$A
42399 D4C9                        00            .byte	0
42400                       0000D4CA            .3B8:
42401                       0000D4CA            .7CB:
42402 D4CA                        4D            .ascii	"Mouse reset returned %02x (should be ack"
42403 D4F2                        29            .ascii	")"
42404 D4F3                        0A            .byte	$A
42405 D4F4                        00            .byte	0
42406                       0000D4F5            .38F:
42407                       0000D4F5            .7CC:
42408 D4F5                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42409 D51D                        74            .ascii	"t yet supported!"
42410 D52D                        0A            .byte	$A
42411 D52E                        00            .byte	0
42412                       0000D52F            .38D:
42413                       0000D52F            .7CD:
42414 D52F                        45            .ascii	"EISA BIOS not present"
42415 D544                        0A            .byte	$A
42416 D545                        00            .byte	0
42417                       0000D546            .389:
42418                       0000D546            .7CE:
42419 D546                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
42420 D56E                        72            .ascii	"rted!"
42421 D573                        0A            .byte	$A
42422 D574                        00            .byte	0
42423                       0000D575            .371:
42424                       0000D575            .7CF:
42425 D575                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
42426 D59D                        20            .ascii	" control not supported"
42427 D5B3                        0A            .byte	$A
42428 D5B4                        00            .byte	0
42429                       0000D5B5            .30B:
42430                       0000D5B5            .7D0:
42431 D5B5                        61            .ascii	"ata_is_ready returned %d"
42432 D5CD                        0A            .byte	$A
42433 D5CE                        00            .byte	0
42434                       0000D5CF            .2F5:
42435                       0000D5CF            .7D1:
42436 D5CF                        25            .ascii	"%dMB medium detected"
42437 D5E3                        0A            .byte	$A
42438 D5E4                        00            .byte	0
42439                       0000D5E5            .2F0:
42440                       0000D5E5            .7D2:
42441 D5E5                        55            .ascii	"Unsupported sector size %u"
42442 D5FF                        0A            .byte	$A
42443 D600                        00            .byte	0
42444                       0000D601            .2EB:
42445                       0000D601            .7D3:
42446 D601                        57            .ascii	"Waiting for device to detect medium... "
42447 D628                        00            .byte	0
42448                       0000D629            .2DD:
42449                       0000D629            .7D4:
42450 D629                        6E            .ascii	"not implemented for non-ATAPI device"
42451 D64D                        0A            .byte	$A
42452 D64E                        00            .byte	0
42453                       0000D64F            .2A3:
42454                       0000D64F            .7D5:
42455 D64F                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
42456 D677                        65            .ascii	"et"
42457 D679                        0A            .byte	$A
42458 D67A                        00            .byte	0
42459                       0000D67B            .253:
42460                       0000D67B            .7D6:
42461 D67B                        0A            .byte	$A
42462 D67C                        00            .byte	0
42463                       0000D67D            .24E:
42464                       0000D67D            .7D7:
42465 D67D                        6D            .ascii	"master"
42466 D683                        00            .byte	0
42467                       0000D684            .24D:
42468                       0000D684            .7D8:
42469 D684                        20            .ascii	" slave"
42470 D68A                        00            .byte	0
42471                       0000D68B            .24C:
42472                       0000D68B            .7D9:
42473 D68B                        61            .ascii	"ata%d %s: Unknown device"
42474 D6A3                        0A            .byte	$A
42475 D6A4                        00            .byte	0
42476                       0000D6A5            .24A:
42477                       0000D6A5            .7DA:
42478 D6A5                        20            .ascii	" ATAPI-%d Device"
42479 D6B5                        0A            .byte	$A
42480 D6B6                        00            .byte	0
42481                       0000D6B7            .248:
42482                       0000D6B7            .7DB:
42483 D6B7                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
42484 D6CF                        0A            .byte	$A
42485 D6D0                        00            .byte	0
42486                       0000D6D1            .244:
42487                       0000D6D1            .7DC:
42488 D6D1                        25            .ascii	"%c"
42489 D6D3                        00            .byte	0
42490                       0000D6D4            .23D:
42491                       0000D6D4            .7DD:
42492 D6D4                        6D            .ascii	"master"
42493 D6DA                        00            .byte	0
42494                       0000D6DB            .23C:
42495                       0000D6DB            .7DE:
42496 D6DB                        20            .ascii	" slave"
42497 D6E1                        00            .byte	0
42498                       0000D6E2            .23B:
42499                       0000D6E2            .7DF:
42500 D6E2                        61            .ascii	"ata%d %s: "
42501 D6EC                        00            .byte	0
42502                       0000D6ED            .239:
42503                       0000D6ED            .7E0:
42504 D6ED                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
42505 D70B                        0A            .byte	$A
42506 D70C                        00            .byte	0
42507                       0000D70D            .237:
42508                       0000D70D            .7E1:
42509 D70D                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
42510 D72B                        0A            .byte	$A
42511 D72C                        00            .byte	0
42512                       0000D72D            .233:
42513                       0000D72D            .7E2:
42514 D72D                        25            .ascii	"%c"
42515 D72F                        00            .byte	0
42516                       0000D730            .22C:
42517                       0000D730            .7E3:
42518 D730                        6D            .ascii	"master"
42519 D736                        00            .byte	0
42520                       0000D737            .22B:
42521                       0000D737            .7E4:
42522 D737                        20            .ascii	" slave"
42523 D73D                        00            .byte	0
42524                       0000D73E            .22A:
42525                       0000D73E            .7E5:
42526 D73E                        61            .ascii	"ata%d %s: "
42527 D748                        00            .byte	0
42528                       0000D749            .1FF:
42529                       0000D749            .7E6:
42530 D749                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
42531 D771                        65            .ascii	"e"
42532 D772                        0A            .byte	$A
42533 D773                        00            .byte	0
42534                       0000D774            .1FA:
42535                       0000D774            .7E7:
42536 D774                        20            .ascii	" LCHS=%d/%d/%d"
42537 D782                        0A            .byte	$A
42538 D783                        00            .byte	0
42539                       0000D784            .1DA:
42540                       0000D784            .7E8:
42541 D784                        72            .ascii	"r-echs"
42542 D78A                        00            .byte	0
42543                       0000D78B            .1D8:
42544                       0000D78B            .7E9:
42545 D78B                        6C            .ascii	"large"
42546 D790                        00            .byte	0
42547                       0000D791            .1D6:
42548                       0000D791            .7EA:
42549 D791                        6C            .ascii	"lba"
42550 D794                        00            .byte	0
42551                       0000D795            .1D4:
42552                       0000D795            .7EB:
42553 D795                        6E            .ascii	"none"
42554 D799                        00            .byte	0
42555                       0000D79A            .1CA:
42556                       0000D79A            .7EC:
42557 D79A                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
42558 D7BE                        00            .byte	0
42559                       0000D7BF            .1C0:
42560                       0000D7BF            .7ED:
42561 D7BF                        61            .ascii	"ata-detect: Failed to detect ATA device"
42562 D7E6                        0A            .byte	$A
42563 D7E7                        00            .byte	0
42564                       0000D7E8            .19F:
42565                       0000D7E8            .7EE:
42566 D7E8                        49            .ascii	"IDE time out"
42567 D7F4                        0A            .byte	$A
42568 D7F5                        00            .byte	0
42569                       0000D7F6            .163:
42570                       0000D7F6            .7EF:
42571 D7F6                        53            .ascii	"S3 resume jump to %x:%x"
42572 D80D                        0A            .byte	$A
42573 D80E                        00            .byte	0
42574                       0000D80F            .15F:
42575                       0000D80F            .7F0:
42576 D80F                        53            .ascii	"S3 resume called %x 0x%lx"
42577 D828                        0A            .byte	$A
42578 D829                        00            .byte	0
42579                       0000D82A            .159:
42580                       0000D82A            .7F1:
42581 D82A                        25            .ascii	"%s"
42582 D82C                        0A            .byte	$A
42583 D82D                        00            .byte	0
42584                       0000D82E            .158:
42585                       0000D82E            .7F2:
42586 D82E                        49            .ascii	"INT18: BOOT FAILURE"
42587 D841                        0A            .byte	$A
42588 D842                        00            .byte	0
42589                       0000D843            .157:
42590                       0000D843            .7F3:
42591 D843                        4E            .ascii	"NMI Handler called"
42592 D855                        0A            .byte	$A
42593 D856                        00            .byte	0
42594                       0000D857            .156:
42595                       0000D857            .7F4:
42596 D857                        43            .ascii	"CDROM boot failure code : %04x"
42597 D875                        0A            .byte	$A
42598 D876                        00            .byte	0
42599                       0000D877            .155:
42600                       0000D877            .7F5:
42601 D877                        0A            .byte	$A,$A
42602 D879                        00            .byte	0
42603                       0000D87A            .154:
42604                       0000D87A            .7F6:
42605 D87A                        3A            .ascii	": could not read the boot disk"
42606 D898                        00            .byte	0
42607                       0000D899            .152:
42608                       0000D899            .7F7:
42609 D899                        3A            .ascii	": not a bootable disk"
42610 D8AE                        00            .byte	0
42611                       0000D8AF            .14D:
42612                       0000D8AF            .7F8:
42613 D8AF                        42            .ascii	"Boot failed"
42614 D8BA                        00            .byte	0
42615                       0000D8BB            .14C:
42616                       0000D8BB            .7F9:
42617 D8BB                        42            .ascii	"Bad drive type"
42618 D8C9                        0A            .byte	$A
42619 D8CA                        00            .byte	0
42620                       0000D8CB            .148:
42621                       0000D8CB            .7FA:
42622 D8CB                        2E            .ascii	"..."
42623 D8CE                        0A            .byte	$A
42624 D8CF                        00            .byte	0
42625                       0000D8D0            .147:
42626                       0000D8D0            .7FB:
42627 D8D0                        20            .ascii	" [%S]"
42628 D8D5                        00            .byte	0
42629                       0000D8D6            .143:
42630                       0000D8D6            .7FC:
42631 D8D6                        42            .ascii	"Booting from %s"
42632 D8E5                        00            .byte	0
42633                       0000D8E6            .142:
42634                       0000D8E6            .7FD:
42635 D8E6                        42            .ascii	"Bad drive type"
42636 D8F4                        0A            .byte	$A
42637 D8F5                        00            .byte	0
42638                       0000D8F6            .13C:
42639                       0000D8F6            .7FE:
42640 D8F6                        0A            .byte	$A
42641 D8F7                        00            .byte	0
42642                       0000D8F8            .130:
42643                       0000D8F8            .7FF:
42644 D8F8                        0A            .byte	$A
42645 D8F9                        00            .byte	0
42646                       0000D8FA            .12F:
42647                       0000D8FA            .800:
42648 D8FA                        20            .ascii	" [%S]"
42649 D8FF                        00            .byte	0
42650                       0000D900            .12C:
42651                       0000D900            .801:
42652 D900                        25            .ascii	"%s"
42653 D902                        00            .byte	0
42654                       0000D903            .12A:
42655                       0000D903            .802:
42656 D903                        25            .ascii	"%s"
42657 D905                        0A            .byte	$A
42658 D906                        00            .byte	0
42659                       0000D907            .123:
42660                       0000D907            .803:
42661 D907                        25            .ascii	"%d. "
42662 D90B                        00            .byte	0
42663                       0000D90C            .11E:
42664                       0000D90C            .804:
42665 D90C                        53            .ascii	"Select boot device:"
42666 D91F                        0A            .byte	$A,$A
42667 D921                        00            .byte	0
42668                       0000D922            .115:
42669                       0000D922            .805:
42670 D922                        50            .ascii	"Press F12 for boot menu."
42671 D93A                        0A            .byte	$A,$A
42672 D93C                        00            .byte	0
42673                       0000D93D            .109:
42674                       0000D93D            .806:
42675 D93D                        61            .ascii	"apmbios pcibios eltorito "
42676 D956                        0A            .byte	$A,$A
42677 D958                        00            .byte	0
42678                       0000D959            .108:
42679                       0000D959            .807:
42680 D959                        31            .ascii	"10/11/09"
42681 D961                        00            .byte	0
42682                       0000D962            .107:
42683                       0000D962            .808:
42684 D962                        42            .ascii	"Bochs BIOS - build: %s"
42685 D978                        0A            .byte	$A
42686 D979                        25            .ascii	"%s"
42687 D97B                        0A            .byte	$A
42688 D97C                        4F            .ascii	"Options: "
42689 D985                        00            .byte	0
42690                       0000D986            .106:
42691                       0000D986            .809:
42692 D986                        52            .ascii	"Returned from s3_resume."
42693 D99E                        0A            .byte	$A
42694 D99F                        00            .byte	0
42695                       0000D9A0            .105:
42696                       0000D9A0            .80A:
42697 D9A0                        55            .ascii	"Unimplemented shutdown status: %02x"
42698 D9C3                        0A            .byte	$A
42699 D9C4                        00            .byte	0
42700                       0000D9C5            .104:
42701                       0000D9C5            .80B:
42702 D9C5                        4B            .ascii	"Keyboard error:%u"
42703 D9D6                        0A            .byte	$A
42704 D9D7                        00            .byte	0
42705                       0000D9D8            .8D:
42706                       0000D9D8            .80C:
42707 D9D8                        62            .ascii	"bios_printf: unknown format"
42708 D9F3                        0A            .byte	$A
42709 D9F4                        00            .byte	0
42710                       0000D9F5            .41:
42711                       0000D9F5            .80D:
42712 D9F5                        46            .ascii	"FATAL: "
42713 D9FC                        00            .byte	0
42714 D9FD                                      .bss
42715                                           
42716                                           ! 0 errors detected

Symbols:
..FFDA                      0 FFFC A   ..FFDB                      0 FFE0 A   
..FFDC                      0 FFE0 A   ..FFDD                      0 FFCA A   
..FFDE                      0 FFCA A   ..FFDF                      0 FFCA A   
..FFE0                      0 FFCA A   ..FFE1                      0 FFCA A   
..FFE2                      0 FFCA A   ..FFE3                      0 FFFC A   
..FFE4                      0 FFFC A   ..FFE5                      0 FFFC A   
..FFE6                      0 FFDE A   ..FFE7                      0 FFDE A   
..FFE8                      0 FFDE A   ..FFE9                      0 FFDE A   
..FFEA                      0 FFD2 A   ..FFEB                      0 FFDE A   
..FFEC                      0 FFD8 A   ..FFED                      0 FFD8 A   
..FFEE                      0 FFD8 A   ..FFEF                      0 FFD8 A   
..FFF0                      0 FFCA A   ..FFF1                      0 FFD8 A   
..FFF2                      0 FFF8 A   ..FFF3                      0 FFF4 A   
..FFF4                      0 FFF0 A   ..FFF5                      0 FFF0 A   
..FFF6                      0 FFF0 A   ..FFF7                      0 FFEA A   
..FFF8                      0 FFF6 A   ..FFF9                      0 F7E2 A   
..FFFA                      0 FFD4 A   ..FFFB                      0 FDBA A   
..FFFC                      0 FDBA A   ..FFFD                      0 FDD8 A   
..FFFE                      0 FDD8 A   ..FFFF                      0 FFC4 A   
.1                          0 0194 A   .10                         0 06EB A   
.100                        0 1214 A   .101                        0 120B A   
.102                        0 122A A   .103                        0 1221 A   
.104                        0 D9C5 A   .105                        0 D9A0 A   
.106                        0 D986 A   .107                        0 D962 A   
.108                        0 D959 A   .109                        0 D93D A   
.10A                        0 12A2 A   .10B                        0 12AC A   
.10C                        0 12B6 A   .10D                        0 12C0 A   
.10E                        0 12CA A   .10F                        0 1446 A   
.11                         0 06D5 A   .110                        0 1440 A   
.111                        0 1487 A   .112                        0 1480 A   
.113                        0 147D A   .114                        0 1487 A   
.115                        0 D922 A   .116                        0 165D A   
.117                        0 14AC A   .118                        0 165D A   
.119                        0 14BB A   .11A                        0 14C7 A   
.11B                        0 14C0 A   .11C                        0 14BD A   
.11D                        0 14C7 A   .11E                        0 D90C A   
.11F                        0 15F6 A   .12                         0 0719 A   
.120                        0 15E3 A   .121                        0 15EA A   
.122                        0 14EE A   .123                        0 D907 A   
.124                        0 15E3 A   .126                        0 15C7 A   
.127                        0 1528 A   .128                        0 1528 A   
.129                        0 1528 A   .12A                        0 D903 A   
.12B                        0 154B A   .12C                        0 D900 A   
.12D                        0 15B5 A   .12E                        0 1574 A   
.12F                        0 D8FA A   .13                         0 0705 A   
.130                        0 D8F8 A   .131                        0 15F6 A   
.132                        0 164F A   .133                        0 1648 A   
.134                        0 15FF A   .135                        0 161B A   
.136                        0 1613 A   .137                        0 160C A   
.138                        0 1648 A   .139                        0 1648 A   
.13A                        0 1625 A   .13B                        0 164F A   
.13C                        0 D8F6 A   .13D                        0 1683 A   
.13E                        0 167D A   .13F                        0 16A0 A   
.14                         0 06FA A   .140                        0 1692 A   
.141                        0 168A A   .142                        0 D8E6 A   
.143                        0 D8D6 A   .144                        0 1732 A   
.145                        0 16E2 A   .146                        0 16C8 A   
.147                        0 D8D0 A   .148                        0 D8CB A   
.149                        0 1763 A   .14A                        0 1756 A   
.14B                        0 174E A   .14C                        0 D8BB A   
.14D                        0 D8AF A   .14E                        0 179B A   
.14F                        0 1778 A   .15                         0 06ED A   
.150                        0 178E A   .151                        0 177F A   
.152                        0 D899 A   .153                        0 179B A   
.154                        0 D87A A   .155                        0 D877 A   
.156                        0 D857 A   .157                        0 D843 A   
.158                        0 D82E A   .159                        0 D82A A   
.15A                        0 1825 A   .15B                        0 1811 A   
.15C                        0 1837 A   .15D                        0 1844 A   
.15E                        0 1846 A   .15F                        0 D80F A   
.16                         0 0705 A   .160                        0 18CE A   
.161                        0 18C8 A   .162                        0 18BD A   
.163                        0 D7F6 A   .164                        0 19E8 A   
.165                        0 19DA A   .166                        0 19E1 A   
.167                        0 196A A   .168                        0 19E8 A   
.169                        0 1BB9 A   .16A                        0 1BA9 A   
.16B                        0 1BB0 A   .16C                        0 19F0 A   
.16D                        0 1BB9 A   .16E                        0 1C00 A   
.16F                        0 1BF2 A   .17                         0 0719 A   
.170                        0 1BF9 A   .171                        0 1BC0 A   
.172                        0 1C00 A   .173                        0 1D87 A   
.174                        0 1D84 A   .175                        0 1C55 A   
.176                        0 1C84 A   .177                        0 1C79 A   
.178                        0 1D18 A   .179                        0 1CA0 A   
.17A                        0 1C8B A   .17B                        0 1C98 A   
.17C                        0 1C94 A   .17D                        0 1C9A A   
.17E                        0 1D18 A   .17F                        0 1CC4 A   
.18                         0 070C A   .180                        0 1CA7 A   
.181                        0 1CBD A   .182                        0 1CB9 A   
.183                        0 1CB0 A   .184                        0 1CBF A   
.185                        0 1D18 A   .186                        0 1CE8 A   
.187                        0 1CCB A   .188                        0 1CE1 A   
.189                        0 1CDD A   .18A                        0 1CD4 A   
.18B                        0 1CE3 A   .18C                        0 1D18 A   
.18D                        0 1D0C A   .18E                        0 1CEF A   
.18F                        0 1D05 A   .19                         0 076E A   
.190                        0 1D01 A   .191                        0 1CF8 A   
.192                        0 1D07 A   .193                        0 1D18 A   
.194                        0 1D18 A   .195                        0 1D13 A   
.196                        0 1D25 A   .197                        0 1D1F A   
.198                        0 1D45 A   .199                        0 1D36 A   
.19A                        0 1D55 A   .19B                        0 1D4E A   
.19C                        0 1D84 A   .19D                        0 1D82 A   
.19E                        0 1D5C A   .19F                        0 D7E8 A   
.1A                         0 0758 A   .1A0                        0 2C80 A   
.1A1                        0 2C70 A   .1A2                        0 2C77 A   
.1A3                        0 1ED2 A   .1A4                        0 1F45 A   
.1A5                        0 1F41 A   .1A6                        0 1F47 A   
.1A7                        0 213B A   .1A8                        0 1FF6 A   
.1A9                        0 1FEC A   .1AA                        0 202B A   
.1AB                        0 2027 A   .1AC                        0 202D A   
.1AD                        0 213B A   .1AE                        0 2073 A   
.1AF                        0 2069 A   .1B                         0 079C A   
.1B0                        0 20D6 A   .1B1                        0 20B6 A   
.1B2                        0 20AE A   .1B3                        0 213B A   
.1B4                        0 210E A   .1B5                        0 20EE A   
.1B6                        0 20E6 A   .1B7                        0 20DE A   
.1B8                        0 213B A   .1B9                        0 213B A   
.1BA                        0 211E A   .1BB                        0 2116 A   
.1BC                        0 2709 A   .1BD                        0 2161 A   
.1BE                        0 21E3 A   .1BF                        0 21D5 A   
.1C                         0 0788 A   .1C0                        0 D7BF A   
.1C1                        0 21FC A   .1C2                        0 21F8 A   
.1C3                        0 21FE A   .1C4                        0 2219 A   
.1C5                        0 2215 A   .1C6                        0 221B A   
.1C7                        0 22B5 A   .1C8                        0 2281 A   
.1C9                        0 22DA A   .1CA                        0 D79A A   
.1CB                        0 245F A   .1CC                        0 244E A   
.1CD                        0 2457 A   .1CE                        0 2440 A   
.1CF                        0 245F A   .1D                         0 077D A   
.1D0                        0 24E2 A   .1D2                        0 24D2 A   
.1D3                        0 2490 A   .1D4                        0 D795 A   
.1D5                        0 24A0 A   .1D6                        0 D791 A   
.1D7                        0 24B0 A   .1D8                        0 D78B A   
.1D9                        0 24C0 A   .1DA                        0 D784 A   
.1DB                        0 2660 A   .1DD                        0 264A A   
.1DE                        0 24E9 A   .1DF                        0 24EC A   
.1E                         0 0770 A   .1E0                        0 2543 A   
.1E1                        0 253A A   .1E2                        0 2580 A   
.1E3                        0 2555 A   .1E4                        0 254C A   
.1E5                        0 2580 A   .1E6                        0 2567 A   
.1E7                        0 255E A   .1E8                        0 2580 A   
.1E9                        0 2579 A   .1EA                        0 2570 A   
.1EB                        0 2580 A   .1EC                        0 25A1 A   
.1ED                        0 261C A   .1EE                        0 25AA A   
.1EF                        0 25D5 A   .1F                         0 0788 A   
.1F0                        0 25CE A   .1F1                        0 261C A   
.1F2                        0 2646 A   .1F3                        0 263D A   
.1F4                        0 261E A   .1F5                        0 263D A   
.1F6                        0 263B A   .1F7                        0 2646 A   
.1F8                        0 2670 A   .1F9                        0 2669 A   
.1FA                        0 D774 A   .1FB                        0 2892 A   
.1FC                        0 2712 A   .1FD                        0 2794 A   
.1FE                        0 2786 A   .1FF                        0 D749 A   
.2                          0 05F1 A   .20                         0 079C A   
.200                        0 27C2 A   .201                        0 27BE A   
.202                        0 27C4 A   .203                        0 27DF A   
.204                        0 27DB A   .205                        0 27E1 A   
.206                        0 2AB2 A   .208                        0 2AA6 A   
.209                        0 289B A   .20A                        0 28FC A   
.20B                        0 295D A   .20C                        0 294C A   
.20D                        0 2955 A   .20E                        0 2933 A   
.20F                        0 294C A   .21                         0 078F A   
.210                        0 294A A   .211                        0 295D A   
.212                        0 29EA A   .213                        0 29D7 A   
.214                        0 29E0 A   .215                        0 2965 A   
.216                        0 29EA A   .217                        0 2A52 A   
.218                        0 2A41 A   .219                        0 2A4A A   
.21A                        0 2A04 A   .21B                        0 2A3F A   
.21C                        0 2A21 A   .21D                        0 2A41 A   
.21E                        0 2A52 A   .21F                        0 2AA2 A   
.22                         0 0809 A   .220                        0 2A5A A   
.221                        0 2AA2 A   .222                        0 2A91 A   
.223                        0 2A9A A   .224                        0 2A74 A   
.225                        0 2AA2 A   .226                        0 2C6A A   
.228                        0 2C5A A   .229                        0 2AB8 A   
.22A                        0 D73E A   .22B                        0 D737 A   
.22C                        0 D730 A   .22D                        0 2AC5 A   
.22E                        0 2AC0 A   .22F                        0 2AC8 A   
.23                         0 07F0 A   .230                        0 2B22 A   
.231                        0 2AFB A   .232                        0 2AE6 A   
.233                        0 D72D A   .234                        0 2B22 A   
.235                        0 2B4B A   .236                        0 2B30 A   
.237                        0 D70D A   .238                        0 2B77 A   
.239                        0 D6ED A   .23A                        0 2B7A A   
.23B                        0 D6E2 A   .23C                        0 D6DB A   
.23D                        0 D6D4 A   .23E                        0 2B87 A   
.23F                        0 2B82 A   .24                         0 0837 A   
.240                        0 2B8A A   .241                        0 2BE4 A   
.242                        0 2BBD A   .243                        0 2BA8 A   
.244                        0 D6D1 A   .245                        0 2BE4 A   
.246                        0 2C19 A   .247                        0 2C02 A   
.248                        0 D6B7 A   .249                        0 2C2E A   
.24A                        0 D6A5 A   .24B                        0 2C30 A   
.24C                        0 D68B A   .24D                        0 D684 A   
.24E                        0 D67D A   .24F                        0 2C3D A   
.25                         0 0823 A   .250                        0 2C38 A   
.251                        0 2C40 A   .252                        0 2C80 A   
.253                        0 D67B A   .254                        0 2E08 A   
.255                        0 2D84 A   .256                        0 2D8F A   
.257                        0 2D8B A   .258                        0 2D91 A   
.259                        0 2DF7 A   .25A                        0 2DCC A   
.25B                        0 2DC5 A   .25C                        0 2DE6 A   
.25D                        0 2DD3 A   .25E                        0 2DF7 A   
.25F                        0 2EB9 A   .26                         0 0818 A   
.260                        0 2EAD A   .261                        0 2EC1 A   
.262                        0 2F08 A   .263                        0 2F01 A   
.264                        0 3089 A   .265                        0 2F22 A   
.266                        0 3028 A   .267                        0 2F6C A   
.268                        0 2F45 A   .269                        0 2F3A A   
.26A                        0 2F2E A   .26B                        0 2F30 A   
.26D                        0 30E9 A   .26E                        0 30E5 A   
.26F                        0 30EB A   .27                         0 080B A   
.270                        0 3140 A   .271                        0 3137 A   
.272                        0 3150 A   .273                        0 3150 A   
.274                        0 3149 A   .275                        0 31F6 A   
.276                        0 31F3 A   .277                        0 3151 A   
.278                        0 31E1 A   .279                        0 31CD A   
.27A                        0 31DD A   .27B                        0 31D6 A   
.27C                        0 31F3 A   .27D                        0 31F1 A   
.27E                        0 31EA A   .27F                        0 31F6 A   
.28                         0 0823 A   .280                        0 32A2 A   
.281                        0 3296 A   .282                        0 32AA A   
.283                        0 32F1 A   .284                        0 32EA A   
.285                        0 3472 A   .286                        0 330B A   
.287                        0 3411 A   .288                        0 3355 A   
.289                        0 332E A   .28A                        0 3323 A   
.28B                        0 3317 A   .28C                        0 3319 A   
.28E                        0 34D2 A   .28F                        0 34CE A   
.29                         0 0837 A   .290                        0 34D4 A   
.291                        0 3529 A   .292                        0 3520 A   
.293                        0 3539 A   .294                        0 3539 A   
.295                        0 3532 A   .296                        0 35D0 A   
.297                        0 35CD A   .298                        0 353A A   
.299                        0 35BB A   .29A                        0 35A7 A   
.29B                        0 35B7 A   .29C                        0 35B0 A   
.29D                        0 35CD A   .29E                        0 35CB A   
.29F                        0 35C4 A   .2A                         0 082A A   
.2A0                        0 35D0 A   .2A1                        0 362C A   
.2A2                        0 3617 A   .2A3                        0 D64F A   
.2A4                        0 363C A   .2A5                        0 3635 A   
.2A6                        0 36A5 A   .2A7                        0 36A0 A   
.2A8                        0 36B1 A   .2A9                        0 36AC A   
.2AA                        0 36FD A   .2AB                        0 36F6 A   
.2AC                        0 3768 A   .2AD                        0 3764 A   
.2AE                        0 376A A   .2AF                        0 37BD A   
.2B                         0 08AA A   .2B0                        0 37B4 A   
.2B1                        0 37CD A   .2B2                        0 37CD A   
.2B3                        0 37C6 A   .2B4                        0 3824 A   
.2B5                        0 3801 A   .2B6                        0 3A9F A   
.2B7                        0 3A9C A   .2B8                        0 3A99 A   
.2B9                        0 382D A   .2BA                        0 3856 A   
.2BB                        0 3834 A   .2BC                        0 3867 A   
.2BD                        0 38A8 A   .2BE                        0 38A5 A   
.2BF                        0 389C A   .2C                         0 0897 A   
.2C0                        0 38B8 A   .2C1                        0 38B1 A   
.2C2                        0 3917 A   .2C3                        0 3901 A   
.2C4                        0 392B A   .2C5                        0 3958 A   
.2C6                        0 3938 A   .2C7                        0 3979 A   
.2C8                        0 3993 A   .2C9                        0 398E A   
.2CA                        0 39A1 A   .2CB                        0 399C A   
.2CC                        0 39AF A   .2CD                        0 39AA A   
.2CE                        0 39D6 A   .2CF                        0 39B8 A   
.2D                         0 0881 A   .2D0                        0 39D6 A   
.2D1                        0 39CF A   .2D2                        0 39C6 A   
.2D3                        0 39FD A   .2D4                        0 39DD A   
.2D5                        0 3A15 A   .2D6                        0 3A9C A   
.2D7                        0 3AAF A   .2D8                        0 3AA8 A   
.2D9                        0 3B21 A   .2DA                        0 3B1A A   
.2DB                        0 3B93 A   .2DC                        0 3B7E A   
.2DD                        0 D629 A   .2DE                        0 3C85 A   
.2DF                        0 3C75 A   .2E                         0 08AA A   
.2E0                        0 3BCA A   .2E1                        0 3BFF A   
.2E2                        0 3BF9 A   .2E3                        0 3C59 A   
.2E4                        0 3C18 A   .2E5                        0 3C26 A   
.2E6                        0 3C1F A   .2E7                        0 3C59 A   
.2E8                        0 3C3B A   .2E9                        0 3C34 A   
.2EA                        0 3C2D A   .2EB                        0 D601 A   
.2EC                        0 3C85 A   .2ED                        0 3D2C A   
.2EE                        0 3D11 A   .2EF                        0 3CF9 A   
.2F                         0 095A A   .2F0                        0 D5E5 A   
.2F1                        0 3DC9 A   .2F2                        0 3DB7 A   
.2F3                        0 3E0F A   .2F4                        0 3DEB A   
.2F5                        0 D5CF A   .2F6                        0 3E56 A   
.2F7                        0 3E50 A   .2F8                        0 3E7A A   
.2F9                        0 3E74 A   .2FA                        0 3E9E A   
.2FB                        0 3E98 A   .2FC                        0 3F1D A   
.2FD                        0 3F23 A   .2FE                        0 3F80 A   
.2FF                        0 3F6F A   .3                          0 05E6 A   
.30                         0 094C A   .300                        0 3F78 A   
.301                        0 3F5D A   .302                        0 3F6F A   
.303                        0 3F6D A   .304                        0 3F80 A   
.305                        0 3F8F A   .306                        0 3F88 A   
.307                        0 3FC1 A   .308                        0 3FAF A   
.309                        0 3FA3 A   .30A                        0 3FA5 A   
.30B                        0 D5B5 A   .30C                        0 4038 A   
.30D                        0 4031 A   .30E                        0 4047 A   
.30F                        0 4040 A   .31                         0 08D6 A   
.310                        0 4093 A   .311                        0 4081 A   
.312                        0 408A A   .313                        0 404F A   
.314                        0 4081 A   .315                        0 407A A   
.316                        0 4093 A   .317                        0 40E1 A   
.318                        0 40CF A   .319                        0 40D8 A   
.31A                        0 409B A   .31B                        0 40CF A   
.31C                        0 40C8 A   .31D                        0 40E1 A   
.31E                        0 4219 A   .31F                        0 4212 A   
.32                         0 0920 A   .320                        0 4228 A   
.321                        0 4221 A   .322                        0 4237 A   
.323                        0 4230 A   .324                        0 4246 A   
.325                        0 423F A   .326                        0 4255 A   
.327                        0 424E A   .328                        0 4264 A   
.329                        0 425D A   .32A                        0 4293 A   
.32B                        0 4280 A   .32C                        0 42BE A   
.32D                        0 42AD A   .32E                        0 429B A   
.32F                        0 42BE A   .33                         0 08FA A   
.330                        0 4311 A   .331                        0 430A A   
.332                        0 44D6 A   .333                        0 44CF A   
.334                        0 461E A   .336                        0 4606 A   
.337                        0 44E6 A   .338                        0 451C A   
.339                        0 4552 A   .33A                        0 4588 A   
.33B                        0 4681 A   .33C                        0 462F A   
.33D                        0 4663 A   .33E                        0 4640 A   
.33F                        0 4681 A   .34                         0 0940 A   
.340                        0 46A3 A   .341                        0 4692 A   
.342                        0 4917 A   .343                        0 46FC A   
.344                        0 46F3 A   .345                        0 4915 A   
.347                        0 48FD A   .348                        0 4702 A   
.349                        0 4747 A   .34A                        0 4729 A   
.34B                        0 4780 A   .34C                        0 47BE A   
.34D                        0 4810 A   .34E                        0 47F7 A   
.34F                        0 47D1 A   .35                         0 0940 A   
.350                        0 47F7 A   .351                        0 47EA A   
.352                        0 4810 A   .353                        0 4809 A   
.354                        0 4837 A   .355                        0 4817 A   
.356                        0 483C A   .357                        0 4847 A   
.358                        0 4899 A   .359                        0 4880 A   
.35A                        0 485A A   .35B                        0 4880 A   
.35C                        0 4873 A   .35D                        0 4899 A   
.35E                        0 4892 A   .35F                        0 48BC A   
.36                         0 092E A   .360                        0 48A0 A   
.361                        0 48C1 A   .362                        0 48CB A   
.363                        0 48F3 A   .364                        0 491F A   
.365                        0 4F41 A   .367                        0 4EDD A   
.368                        0 4942 A   .369                        0 49E7 A   
.36B                        0 49D1 A   .36C                        0 4948 A   
.36D                        0 4960 A   .36E                        0 4978 A   
.36F                        0 4999 A   .37                         0 095A A   
.370                        0 49AE A   .371                        0 D575 A   
.372                        0 49EA A   .373                        0 49FA A   
.374                        0 4A05 A   .375                        0 4A15 A   
.376                        0 4ADF A   .377                        0 4A1E A   
.378                        0 4AD0 A   .379                        0 4A34 A   
.37A                        0 4ADD A   .37B                        0 4B33 A   
.37C                        0 4B1F A   .37D                        0 4AE6 A   
.37E                        0 4B33 A   .37F                        0 4B36 A   
.38                         0 09A3 A   .380                        0 4B71 A   
.381                        0 4B6A A   .382                        0 4D43 A   
.383                        0 4D69 A   .384                        0 4D63 A   
.385                        0 4D74 A   .386                        0 4E49 A   
.387                        0 4E4C A   .388                        0 4E4F A   
.389                        0 D546 A   .38A                        0 4E6D A   
.38B                        0 4E89 A   .38C                        0 4E9A A   
.38D                        0 D52F A   .38E                        0 4EB8 A   
.38F                        0 D4F5 A   .39                         0 0994 A   
.390                        0 4F26 A   .391                        0 4F08 A   
.392                        0 55BE A   .394                        0 55B6 A   
.395                        0 4F64 A   .396                        0 558F A   
.398                        0 556A A   .399                        0 4F6A A   
.39A                        0 5067 A   .39C                        0 5059 A   
.39D                        0 4F70 A   .39E                        0 4FB1 A   
.39F                        0 4F86 A   .3A                         0 099B A   
.3A0                        0 4FB1 A   .3A1                        0 4FA0 A   
.3A2                        0 4F99 A   .3A3                        0 4FC6 A   
.3A4                        0 4FF0 A   .3A5                        0 4FDF A   
.3A6                        0 5034 A   .3A7                        0 5006 A   
.3A8                        0 5034 A   .3A9                        0 5020 A   
.3AA                        0 5019 A   .3AB                        0 5046 A   
.3AC                        0 506A A   .3AD                        0 506A A   
.3AE                        0 50D1 A   .3AF                        0 5073 A   
.3B                         0 0983 A   .3B0                        0 508B A   
.3B1                        0 507A A   .3B2                        0 5170 A   
.3B3                        0 50E9 A   .3B4                        0 5108 A   
.3B5                        0 50FC A   .3B6                        0 5123 A   
.3B7                        0 510F A   .3B8                        0 D4CA A   
.3B9                        0 5170 A   .3BA                        0 512A A   
.3BB                        0 5170 A   .3BC                        0 513D A   
.3BD                        0 5170 A   .3BE                        0 5150 A   
.3BF                        0 5182 A   .3C                         0 0994 A   
.3C0                        0 51E2 A   .3C2                        0 51BF A   
.3C3                        0 5187 A   .3C4                        0 518E A   
.3C5                        0 5195 A   .3C6                        0 519C A   
.3C7                        0 51A3 A   .3C8                        0 51AA A   
.3C9                        0 51B1 A   .3CA                        0 51B8 A   
.3CB                        0 51E0 A   .3CC                        0 51D2 A   
.3CD                        0 5240 A   .3CE                        0 51E9 A   
.3CF                        0 5231 A   .3D                         0 0992 A   
.3D0                        0 51FC A   .3D1                        0 523E A   
.3D2                        0 524D A   .3D3                        0 5250 A   
.3D4                        0 52EC A   .3D5                        0 525F A   
.3D6                        0 52DD A   .3D7                        0 5272 A   
.3D8                        0 5299 A   .3D9                        0 5285 A   
.3DA                        0 D49E A   .3DB                        0 52CE A   
.3DC                        0 52BA A   .3DD                        0 D472 A   
.3DE                        0 52EA A   .3DF                        0 52F9 A   
.3E                         0 09A3 A   .3E0                        0 5307 A   
.3E1                        0 534A A   .3E2                        0 531D A   
.3E3                        0 5357 A   .3E4                        0 535A A   
.3E5                        0 54CE A   .3E7                        0 54BA A   
.3E8                        0 5360 A   .3E9                        0 5410 A   
.3EA                        0 537B A   .3EB                        0 53A2 A   
.3EC                        0 538E A   .3ED                        0 D446 A   
.3EE                        0 5410 A   .3EF                        0 53A9 A   
.3F                         0 09E7 A   .3F0                        0 5410 A   
.3F1                        0 53BC A   .3F2                        0 5410 A   
.3F3                        0 53CF A   .3F4                        0 5410 A   
.3F5                        0 53E2 A   .3F6                        0 542D A   
.3F7                        0 542D A   .3F8                        0 5448 A   
.3F9                        0 543A A   .3FA                        0 5454 A   
.3FB                        0 5474 A   .3FC                        0 545B A   
.3FD                        0 546F A   .3FE                        0 5471 A   
.3FF                        0 548A A   .4                          0 05D1 A   
.40                         0 09CC A   .400                        0 547B A   
.401                        0 5497 A   .402                        0 54A4 A   
.403                        0 D42C A   .404                        0 54D1 A   
.405                        0 5531 A   .406                        0 551B A   
.407                        0 5514 A   .408                        0 552F A   
.409                        0 5524 A   .40A                        0 5539 A   
.40B                        0 555B A   .40C                        0 558D A   
.40D                        0 557D A   .40E                        0 5591 A   
.40F                        0 D3F2 A   .41                         0 D9F5 A   
.410                        0 5BA7 A   .412                        0 5B99 A   
.413                        0 56DE A   .414                        0 5724 A   
.415                        0 5B72 A   .417                        0 5B66 A   
.418                        0 572A A   .419                        0 5B04 A   
.41A                        0 5745 A   .41B                        0 57C6 A   
.41C                        0 57BA A   .41D                        0 5890 A   
.41E                        0 580D A   .41F                        0 5AE3 A   
.42                         0 0D67 A   .421                        0 5AC0 A   
.422                        0 5925 A   .423                        0 5957 A   
.424                        0 598A A   .425                        0 59BD A   
.426                        0 59EE A   .427                        0 5A30 A   
.428                        0 5A77 A   .429                        0 5A6A A   
.42A                        0 5A5F A   .42B                        0 5A81 A   
.42C                        0 5A83 A   .42D                        0 5AB6 A   
.42E                        0 5AE1 A   .42F                        0 5AD3 A   
.43                         0 0D51 A   .430                        0 5B09 A   
.431                        0 5B0B A   .432                        0 5B39 A   
.433                        0 5B33 A   .434                        0 5B5F A   
.435                        0 5B74 A   .436                        0 D3B8 A   
.437                        0 5C92 A   .438                        0 5BEF A   
.439                        0 5C1D A   .43A                        0 5C0E A   
.43B                        0 5C00 A   .43C                        0 5C1D A   
.43D                        0 5C91 A   .43E                        0 5C2A A   
.43F                        0 5C74 A   .44                         0 09EA A   
.440                        0 5C65 A   .441                        0 5C57 A   
.442                        0 5C74 A   .443                        0 5FE9 A   
.445                        0 5F9F A   .446                        0 5C9C A   
.447                        0 5CC0 A   .448                        0 5CB2 A   
.449                        0 D394 A   .44A                        0 5CD5 A   
.44B                        0 5CCE A   .44C                        0 5CC7 A   
.44D                        0 5CE1 A   .44E                        0 5CE1 A   
.44F                        0 5CDC A   .45                         0 09FF A   
.450                        0 5CF3 A   .451                        0 5D14 A   
.452                        0 5D08 A   .453                        0 5D29 A   
.454                        0 5D22 A   .455                        0 5D1B A   
.456                        0 5D35 A   .457                        0 5D35 A   
.458                        0 5D30 A   .459                        0 5D4F A   
.45A                        0 5D6E A   .45B                        0 5D92 A   
.45C                        0 5D86 A   .45D                        0 5D9C A   
.45E                        0 5D9F A   .45F                        0 5DAC A   
.46                         0 09F1 A   .460                        0 5DF3 A   
.461                        0 5DD9 A   .462                        0 5DCC A   
.463                        0 5DF3 A   .464                        0 5DE8 A   
.465                        0 5E67 A   .466                        0 5DFA A   
.467                        0 5E67 A   .468                        0 5E07 A   
.469                        0 5E67 A   .46A                        0 5E5C A   
.46B                        0 5E07 A   .46C                        0 5E36 A   
.46D                        0 5E1C A   .46E                        0 5E0F A   
.46F                        0 5E36 A   .47                         0 0D4A A   
.470                        0 5E2B A   .471                        0 5E5C A   
.472                        0 5E3D A   .473                        0 5E67 A   
.474                        0 5E70 A   .475                        0 5E94 A   
.476                        0 5E86 A   .477                        0 D370 A   
.478                        0 5EA7 A   .479                        0 5EA2 A   
.47A                        0 5E9B A   .47B                        0 5EB9 A   
.47C                        0 5EDA A   .47D                        0 5ECE A   
.47E                        0 5EED A   .47F                        0 5EE8 A   
.48                         0 0D3B A   .480                        0 5EE1 A   
.481                        0 5F07 A   .482                        0 5F66 A   
.483                        0 5F73 A   .484                        0 5F75 A   
.485                        0 5F87 A   .486                        0 5F7C A   
.487                        0 5F87 A   .488                        0 D348 A   
.489                        0 5FD8 A   .48A                        0 5FB2 A   
.48B                        0 60C4 A   .48C                        0 6041 A   
.48D                        0 60BB A   .48E                        0 6094 A   
.48F                        0 60AA A   .49                         0 0A08 A   
.490                        0 60A4 A   .491                        0 60CA A   
.492                        0 60CE A   .493                        0 6114 A   
.494                        0 6102 A   .495                        0 D33D A   
.496                        0 6133 A   .497                        0 6124 A   
.498                        0 6124 A   .499                        0 6133 A   
.49A                        0 6166 A   .49B                        0 6154 A   
.49C                        0 D332 A   .49D                        0 61C1 A   
.49E                        0 61AF A   .49F                        0 D328 A   
.4A                         0 0A37 A   .4A0                        0 61E0 A   
.4A1                        0 61D1 A   .4A2                        0 61D1 A   
.4A3                        0 61E0 A   .4A4                        0 620D A   
.4A5                        0 61FB A   .4A6                        0 D31E A   
.4A7                        0 6265 A   .4A8                        0 6253 A   
.4A9                        0 D314 A   .4AA                        0 62A0 A   
.4AB                        0 6291 A   .4AC                        0 6291 A   
.4AD                        0 62A0 A   .4AE                        0 62ED A   
.4AF                        0 62DC A   .4B                         0 0A16 A   
.4B0                        0 D309 A   .4B1                        0 633D A   
.4B2                        0 632B A   .4B3                        0 D2EF A   
.4B4                        0 6958 A   .4B6                        0 6901 A   
.4B7                        0 637B A   .4B8                        0 63B6 A   
.4B9                        0 63D5 A   .4BA                        0 63F4 A   
.4BB                        0 6413 A   .4BC                        0 6432 A   
.4BD                        0 6451 A   .4BE                        0 64B9 A   
.4BF                        0 645A A   .4C                         0 0A0F A   
.4C0                        0 649D A   .4C1                        0 647F A   
.4C2                        0 64B9 A   .4C3                        0 64BC A   
.4C4                        0 6524 A   .4C5                        0 64C5 A   
.4C6                        0 6508 A   .4C7                        0 64EA A   
.4C8                        0 6524 A   .4C9                        0 6527 A   
.4CA                        0 656A A   .4CB                        0 654C A   
.4CC                        0 6586 A   .4CD                        0 6589 A   
.4CE                        0 65CC A   .4CF                        0 65AE A   
.4D                         0 0D39 A   .4D0                        0 65E8 A   
.4D1                        0 65EB A   .4D2                        0 662C A   
.4D3                        0 65F4 A   .4D4                        0 662F A   
.4D5                        0 6654 A   .4D6                        0 6638 A   
.4D7                        0 6657 A   .4D8                        0 6692 A   
.4D9                        0 66B1 A   .4DA                        0 66BD A   
.4DB                        0 66BA A   .4DC                        0 66DC A   
.4DD                        0 66C4 A   .4DE                        0 D2B8 A   
.4DF                        0 6722 A   .4E                         0 0AD2 A   
.4E0                        0 66E5 A   .4E1                        0 68CF A   
.4E2                        0 6768 A   .4E3                        0 672B A   
.4E4                        0 68CF A   .4E5                        0 67A3 A   
.4E6                        0 677F A   .4E7                        0 6771 A   
.4E8                        0 6778 A   .4E9                        0 68CF A   
.4EA                        0 6840 A   .4EB                        0 67AE A   
.4EC                        0 6803 A   .4ED                        0 67CD A   
.4EE                        0 683D A   .4EF                        0 68CF A   
.4F                         0 0A5C A   .4F0                        0 689B A   
.4F1                        0 685F A   .4F2                        0 68CF A   
.4F3                        0 68EB A   .4F4                        0 68DD A   
.4F5                        0 68D6 A   .4F6                        0 D281 A   
.4F7                        0 6969 A   .4F8                        0 6961 A   
.4F9                        0 69EF A   .4FA                        0 69E9 A   
.4FB                        0 69FD A   .4FC                        0 69F7 A   
.4FD                        0 6A74 A   .4FE                        0 6A70 A   
.4FF                        0 6AAD A   .5                          0 05E6 A   
.50                         0 0A55 A   .500                        0 6AA9 A   
.501                        0 6B3A A   .502                        0 6AE9 A   
.503                        0 6B38 A   .504                        0 6B32 A   
.505                        0 6B41 A   .506                        0 6BB3 A   
.507                        0 6B91 A   .508                        0 6B8A A   
.509                        0 D24A A   .50A                        0 6BF7 A   
.50B                        0 6BD5 A   .50C                        0 D20C A   
.50D                        0 7AF0 A   .50F                        0 7A72 A   
.51                         0 0A69 A   .510                        0 6C01 A   
.511                        0 6C15 A   .512                        0 6C5D A   
.513                        0 6C55 A   .514                        0 6C63 A   
.515                        0 6C66 A   .516                        0 6C66 A   
.517                        0 6C66 A   .518                        0 6CDC A   
.519                        0 6CC0 A   .51A                        0 6CB9 A   
.51B                        0 6CB2 A   .51C                        0 D1D4 A   
.51D                        0 6D70 A   .51E                        0 6D4B A   
.51F                        0 6D43 A   .52                         0 0A63 A   
.520                        0 6D3B A   .521                        0 D18C A   
.522                        0 6D82 A   .523                        0 6D7C A   
.524                        0 6E3E A   .525                        0 6DCC A   
.526                        0 6DC4 A   .527                        0 6E7D A   
.528                        0 6E4A A   .529                        0 6EAE A   
.52A                        0 6EFD A   .52B                        0 6ED0 A   
.52C                        0 D15F A   .52D                        0 6F06 A   
.52E                        0 D145 A   .52F                        0 6F21 A   
.53                         0 0A78 A   .530                        0 6FFF A   
.531                        0 7037 A   .532                        0 702F A   
.533                        0 7048 A   .534                        0 704B A   
.535                        0 70FC A   .536                        0 711C A   
.537                        0 711C A   .538                        0 711C A   
.539                        0 711C A   .53A                        0 71AC A   
.53B                        0 7190 A   .53C                        0 D114 A   
.53D                        0 7228 A   .53E                        0 720C A   
.53F                        0 71E8 A   .54                         0 0A70 A   
.540                        0 D0E3 A   .541                        0 7246 A   
.542                        0 7240 A   .543                        0 7234 A   
.544                        0 7285 A   .545                        0 7252 A   
.546                        0 72B6 A   .547                        0 730C A   
.548                        0 72DF A   .549                        0 D0B6 A   
.54A                        0 7315 A   .54B                        0 7315 A   
.54C                        0 731E A   .54D                        0 7332 A   
.54E                        0 7350 A   .54F                        0 734A A   
.55                         0 0A7E A   .550                        0 753D A   
.551                        0 735A A   .552                        0 74A6 A   
.553                        0 747E A   .554                        0 742E A   
.555                        0 746F A   .556                        0 7471 A   
.558                        0 74D0 A   .559                        0 77BA A   
.55A                        0 7547 A   .55B                        0 7622 A   
.55C                        0 761E A   .55D                        0 7624 A   
.55E                        0 7640 A   .55F                        0 763C A   
.56                         0 0ACF A   .560                        0 7642 A   
.561                        0 7659 A   .562                        0 7655 A   
.563                        0 765B A   .564                        0 7674 A   
.565                        0 7670 A   .566                        0 7676 A   
.567                        0 7755 A   .568                        0 7742 A   
.569                        0 7766 A   .56A                        0 779D A   
.56B                        0 778F A   .56C                        0 7796 A   
.56D                        0 7772 A   .56E                        0 779D A   
.56F                        0 79FF A   .57                         0 0AC1 A   
.570                        0 77C4 A   .571                        0 78BD A   
.572                        0 786C A   .573                        0 78BD A   
.574                        0 7951 A   .575                        0 7913 A   
.576                        0 7951 A   .577                        0 79DF A   
.578                        0 79D1 A   .579                        0 79D8 A   
.57A                        0 79B3 A   .57B                        0 79DF A   
.57C                        0 7A08 A   .57D                        0 7A2F A   
.57F                        0 7A1D A   .58                         0 0AC8 A   
.580                        0 7A0D A   .581                        0 7A0D A   
.582                        0 7A0D A   .583                        0 7A0D A   
.584                        0 7A15 A   .585                        0 7A32 A   
.586                        0 7A32 A   .587                        0 7A32 A   
.588                        0 7A32 A   .589                        0 7A32 A   
.58A                        0 D077 A   .58B                        0 7A51 A   
.58C                        0 7A51 A   .58D                        0 7A51 A   
.58E                        0 7A51 A   .58F                        0 7A51 A   
.59                         0 0A87 A   .590                        0 D03D A   
.591                        0 7ABA A   .592                        0 7A88 A   
.593                        0 7AED A   .594                        0 7ACD A   
.595                        0 7BA1 A   .596                        0 7B7F A   
.597                        0 7B78 A   .598                        0 D009 A   
.599                        0 7BE5 A   .59A                        0 7BC3 A   
.59B                        0 CFCE A   .59C                        0 861F A   
.59E                        0 85A1 A   .59F                        0 7BEF A   
.5A                         0 0AAE A   .5A0                        0 7BEF A   
.5A1                        0 7BEF A   .5A2                        0 7BEF A   
.5A3                        0 7BEF A   .5A4                        0 7BEF A   
.5A5                        0 7BEF A   .5A6                        0 7BEF A   
.5A7                        0 7BF8 A   .5A8                        0 7BF8 A   
.5A9                        0 7BF8 A   .5AA                        0 7C0C A   
.5AB                        0 7C54 A   .5AC                        0 7C4C A   
.5AD                        0 7C5A A   .5AE                        0 7C5D A   
.5AF                        0 7C71 A   .5B                         0 0AA6 A   
.5B0                        0 7C91 A   .5B1                        0 7C91 A   
.5B2                        0 7C91 A   .5B3                        0 7D14 A   
.5B4                        0 7CF8 A   .5B5                        0 CF9C A   
.5B6                        0 7D4A A   .5B7                        0 7D44 A   
.5B8                        0 7D38 A   .5B9                        0 7E6D A   
.5BA                        0 7E40 A   .5BB                        0 CF71 A   
.5BC                        0 7E76 A   .5BD                        0 7E83 A   
.5BE                        0 7E7D A   .5BF                        0 7F8B A   
.5C                         0 0AB7 A   .5C1                        0 7F7B A   
.5C2                        0 7EA6 A   .5C3                        0 7EC8 A   
.5C4                        0 7EAD A   .5C5                        0 7EF9 A   
.5C6                        0 7F1B A   .5C7                        0 7F00 A   
.5C8                        0 7F4A A   .5C9                        0 7F46 A   
.5CA                        0 7F4C A   .5CB                        0 7F5C A   
.5CC                        0 7F67 A   .5CD                        0 7F63 A   
.5CE                        0 7F69 A   .5CF                        0 7F94 A   
.5D                         0 0ACF A   .5D0                        0 7FC9 A   
.5D1                        0 7FB8 A   .5D2                        0 7FF4 A   
.5D3                        0 7FE3 A   .5D4                        0 7FFD A   
.5D5                        0 801B A   .5D6                        0 8015 A   
.5D7                        0 80F1 A   .5D8                        0 8025 A   
.5D9                        0 82F4 A   .5DA                        0 80FB A   
.5DB                        0 81CF A   .5DC                        0 81CB A   
.5DD                        0 81D1 A   .5DE                        0 82D7 A   
.5DF                        0 82C9 A   .5E                         0 0D34 A   
.5E0                        0 82D0 A   .5E1                        0 82AC A   
.5E2                        0 82D7 A   .5E3                        0 8539 A   
.5E4                        0 82FE A   .5E5                        0 83F7 A   
.5E6                        0 83A6 A   .5E7                        0 83F7 A   
.5E8                        0 848B A   .5E9                        0 844D A   
.5EA                        0 848B A   .5EB                        0 8519 A   
.5EC                        0 850B A   .5ED                        0 8512 A   
.5EE                        0 84ED A   .5EF                        0 8519 A   
.5F                         0 0AEE A   .5F0                        0 8542 A   
.5F1                        0 8556 A   .5F2                        0 857D A   
.5F4                        0 856B A   .5F5                        0 855B A   
.5F6                        0 855B A   .5F7                        0 855B A   
.5F8                        0 855B A   .5F9                        0 8563 A   
.5FA                        0 8580 A   .5FB                        0 8580 A   
.5FC                        0 8580 A   .5FD                        0 8580 A   
.5FE                        0 8580 A   .5FF                        0 8580 A   
.6                          0 05E0 A   .60                         0 0AD9 A   
.600                        0 8580 A   .601                        0 8580 A   
.602                        0 CF4F A   .603                        0 85E9 A   
.604                        0 85B7 A   .605                        0 861C A   
.606                        0 85FC A   .607                        0 8872 A   
.609                        0 8854 A   .60A                        0 8696 A   
.60B                        0 8696 A   .60C                        0 8696 A   
.60D                        0 CF1E A   .60E                        0 86B0 A   
.60F                        0 882E A   .61                         0 0D34 A   
.610                        0 881E A   .611                        0 8835 A   
.612                        0 CEF9 A   .613                        0 8968 A   
.614                        0 8946 A   .615                        0 892D A   
.616                        0 CEBA A   .617                        0 8ECB A   
.619                        0 8E50 A   .61A                        0 8972 A   
.61B                        0 8972 A   .61C                        0 8972 A   
.61D                        0 8972 A   .61E                        0 8972 A   
.61F                        0 8972 A   .62                         0 0C84 A   
.620                        0 8972 A   .621                        0 8972 A   
.622                        0 897B A   .623                        0 897B A   
.624                        0 898F A   .625                        0 89D7 A   
.626                        0 89CF A   .627                        0 89DD A   
.628                        0 89E0 A   .629                        0 89E0 A   
.62A                        0 8A75 A   .62B                        0 8A6F A   
.62C                        0 8A93 A   .62D                        0 8A8D A   
.62E                        0 8A85 A   .62F                        0 8A7D A   
.63                         0 0AF7 A   .630                        0 8AA5 A   
.631                        0 8A9F A   .632                        0 8D1E A   
.633                        0 8CE7 A   .634                        0 CE90 A   
.635                        0 8D27 A   .636                        0 8E06 A   
.638                        0 8DFA A   .639                        0 8DD4 A   
.63A                        0 8DE0 A   .63B                        0 8DEC A   
.63C                        0 8E1C A   .63D                        0 8E30 A   
.63E                        0 8E30 A   .63F                        0 8E30 A   
.64                         0 0B9F A   .640                        0 8E30 A   
.641                        0 8E30 A   .642                        0 8E30 A   
.643                        0 8E30 A   .644                        0 8E30 A   
.645                        0 8E30 A   .646                        0 8E30 A   
.647                        0 8E30 A   .648                        0 8E30 A   
.649                        0 8E30 A   .64A                        0 8E30 A   
.64B                        0 8E30 A   .64C                        0 CE58 A   
.64D                        0 8E95 A   .64E                        0 8E63 A   
.64F                        0 8EC8 A   .65                         0 0B2C A   
.650                        0 8EA8 A   .651                        0 8F69 A   
.652                        0 8F60 A   .653                        0 8F54 A   
.654                        0 8F69 A   .655                        0 8FBC A   
.656                        0 8FB5 A   .657                        0 8FC1 A   
.658                        0 9009 A   .659                        0 9000 A   
.65A                        0 8FF4 A   .65B                        0 9009 A   
.65C                        0 9048 A   .65D                        0 9010 A   
.65E                        0 902B A   .65F                        0 9022 A   
.66                         0 0B73 A   .660                        0 9011 A   
.661                        0 902B A   .662                        0 9074 A   
.663                        0 906A A   .664                        0 9089 A   
.665                        0 9083 A   .666                        0 909D A   
.667                        0 9096 A   .668                        0 90C8 A   
.669                        0 90C2 A   .66A                        0 90E7 A   
.66B                        0 90E1 A   .66C                        0 9108 A   
.66D                        0 90FA A   .66E                        0 9110 A   
.66F                        0 912A A   .67                         0 0B36 A   
.670                        0 9117 A   .671                        0 91EB A   
.672                        0 9144 A   .673                        0 9131 A   
.674                        0 91EB A   .675                        0 915E A   
.676                        0 914B A   .677                        0 91EB A   
.678                        0 9178 A   .679                        0 9165 A   
.67A                        0 91EB A   .67B                        0 9191 A   
.67C                        0 917F A   .67D                        0 91EB A   
.67E                        0 91AA A   .67F                        0 9198 A   
.68                         0 0B9C A   .680                        0 91EB A   
.681                        0 91C3 A   .682                        0 91B1 A   
.683                        0 91EB A   .684                        0 91DC A   
.685                        0 91CA A   .686                        0 91EB A   
.687                        0 91FA A   .688                        0 91F2 A   
.689                        0 9200 A   .68A                        0 9272 A   
.68B                        0 926B A   .68C                        0 9258 A   
.68D                        0 9272 A   .68E                        0 92A8 A   
.68F                        0 9298 A   .69                         0 0C81 A   
.690                        0 92B6 A   .691                        0 9307 A   
.692                        0 92F9 A   .693                        0 930F A   
.694                        0 931E A   .695                        0 9316 A   
.696                        0 9325 A   .697                        0 A441 A   
.699                        0 A402 A   .69A                        0 933F A   
.69B                        0 936C A   .69C                        0 934C A   
.69D                        0 938D A   .69E                        0 937F A   
.69F                        0 9395 A   .6A                         0 0BD2 A   
.6A0                        0 93BC A   .6A1                        0 939C A   
.6A2                        0 93E9 A   .6A3                        0 9427 A   
.6A4                        0 941F A   .6A5                        0 942B A   
.6A6                        0 942B A   .6A7                        0 942B A   
.6A8                        0 94AC A   .6A9                        0 9474 A   
.6AA                        0 946D A   .6AB                        0 9466 A   
.6AC                        0 945F A   .6AD                        0 9458 A   
.6AE                        0 CE1D A   .6AF                        0 94E5 A   
.6B                         0 0BA6 A   .6B0                        0 94BB A   
.6B1                        0 952D A   .6B2                        0 94F4 A   
.6B3                        0 952D A   .6B4                        0 9503 A   
.6B5                        0 98EA A   .6B6                        0 9536 A   
.6B7                        0 9566 A   .6B8                        0 955F A   
.6B9                        0 95AF A   .6BA                        0 9585 A   
.6BB                        0 9756 A   .6BC                        0 974F A   
.6BD                        0 96F7 A   .6BE                        0 973C A   
.6BF                        0 970F A   .6C                         0 0C81 A   
.6C0                        0 9756 A   .6C1                        0 97AC A   
.6C2                        0 979E A   .6C3                        0 CDFD A   
.6C4                        0 98BF A   .6C5                        0 9895 A   
.6C6                        0 9CC1 A   .6C7                        0 9C99 A   
.6C8                        0 98F3 A   .6C9                        0 9923 A   
.6CA                        0 991C A   .6CB                        0 996C A   
.6CC                        0 9942 A   .6CD                        0 9B05 A   
.6CE                        0 9AFE A   .6CF                        0 9AA6 A   
.6D                         0 0C81 A   .6D0                        0 9AEB A   
.6D1                        0 9ABE A   .6D2                        0 9B05 A   
.6D3                        0 9B5B A   .6D4                        0 9B4D A   
.6D5                        0 CDDD A   .6D6                        0 9C6F A   
.6D7                        0 9C44 A   .6D8                        0 9C61 A   
.6D9                        0 9C4D A   .6DA                        0 9C6F A   
.6DB                        0 CDB8 A   .6DC                        0 9CC1 A   
.6DD                        0 9CC4 A   .6DE                        0 9D23 A   
.6DF                        0 9D07 A   .6E                         0 0BE2 A   
.6E0                        0 9D00 A   .6E1                        0 9CF9 A   
.6E2                        0 9CF2 A   .6E3                        0 9CEB A   
.6E4                        0 9D52 A   .6E5                        0 9D32 A   
.6E6                        0 9D9A A   .6E7                        0 9D61 A   
.6E8                        0 9D9A A   .6E9                        0 9D70 A   
.6EA                        0 9DCA A   .6EB                        0 9DC3 A   
.6EC                        0 9E12 A   .6ED                        0 9DE8 A   
.6EE                        0 9F6A A   .6EF                        0 9F63 A   
.6F                         0 0BD9 A   .6F0                        0 9F15 A   
.6F1                        0 9F50 A   .6F2                        0 9F2D A   
.6F3                        0 9F6A A   .6F4                        0 9FC0 A   
.6F5                        0 9FB2 A   .6F6                        0 CD98 A   
.6F7                        0 A0D4 A   .6F8                        0 A0A9 A   
.6F9                        0 A0C6 A   .6FA                        0 A0B2 A   
.6FB                        0 A0D4 A   .6FC                        0 CD72 A   
.6FD                        0 A101 A   .6FE                        0 A143 A   
.6FF                        0 A10E A   .7                          0 05F1 A   
.70                         0 0BEF A   .700                        0 A164 A   
.701                        0 A15D A   .702                        0 A174 A   
.703                        0 A16D A   .704                        0 A189 A   
.705                        0 A17B A   .706                        0 A191 A   
.707                        0 A2AE A   .709                        0 A287 A   
.70A                        0 A1CB A   .70B                        0 A1DD A   
.70C                        0 A1F1 A   .70D                        0 A205 A   
.70E                        0 A219 A   .70F                        0 A22D A   
.71                         0 0BE9 A   .710                        0 A240 A   
.711                        0 A252 A   .712                        0 A264 A   
.713                        0 A277 A   .714                        0 CD52 A   
.715                        0 A2AC A   .716                        0 A29A A   
.717                        0 A2C7 A   .718                        0 A2EA A   
.719                        0 A2D4 A   .71A                        0 A30B A   
.71B                        0 A2FD A   .71C                        0 A313 A   
.71D                        0 A32E A   .71E                        0 A322 A   
.71F                        0 A339 A   .72                         0 0BFE A   
.720                        0 A33D A   .721                        0 A36A A   
.722                        0 A34A A   .723                        0 A38A A   
.724                        0 A3AA A   .725                        0 A3CA A   
.726                        0 CD2D A   .727                        0 A427 A   
.728                        0 A415 A   .729                        0 A474 A   
.72A                        0 A467 A   .72B                        0 CD06 A   
.72C                        0 A5BB A   .72D                        0 A4C8 A   
.72E                        0 A4BF A   .72F                        0 A4B5 A   
.73                         0 0BF6 A   .730                        0 A54F A   
.731                        0 A4E9 A   .732                        0 A54F A   
.733                        0 A538 A   .734                        0 A531 A   
.735                        0 A54F A   .736                        0 A548 A   
.737                        0 A58D A   .738                        0 A556 A   
.739                        0 A5B1 A   .73A                        0 A5A9 A   
.73B                        0 A5C3 A   .73C                        0 A667 A   
.73D                        0 A63B A   .73E                        0 A67C A   
.73F                        0 A67C A   .74                         0 0C04 A   
.740                        0 A66E A   .741                        0 CCF1 A   
.742                        0 A6A9 A   .743                        0 A694 A   
.744                        0 CCD5 A   .745                        0 A7ED A   
.747                        0 A7D1 A   .748                        0 A6B8 A   
.749                        0 A6B8 A   .74A                        0 A6C4 A   
.74B                        0 A6C0 A   .74C                        0 A6C6 A   
.74D                        0 A716 A   .74E                        0 A705 A   
.74F                        0 A74F A   .75                         0 0C81 A   
.750                        0 A72D A   .751                        0 A71E A   
.752                        0 A74F A   .753                        0 A73F A   
.754                        0 A768 A   .755                        0 A78E A   
.756                        0 A775 A   .757                        0 A7AF A   
.758                        0 A7CB A   .759                        0 CCC1 A   
.75A                        0 ABC9 A   .75C                        0 AB9E A   
.75D                        0 A82F A   .75E                        0 A853 A   
.75F                        0 A876 A   .76                         0 0C73 A   
.760                        0 A888 A   .761                        0 A87D A   
.762                        0 A8CF A   .763                        0 A8D9 A   
.764                        0 A8D6 A   .765                        0 A949 A   
.766                        0 A960 A   .767                        0 A955 A   
.768                        0 A9A1 A   .769                        0 A9B6 A   
.76A                        0 A9A8 A   .76B                        0 AA2A A   
.76C                        0 AA4F A   .76D                        0 AA44 A   
.76E                        0 AA59 A   .76F                        0 AA56 A   
.77                         0 0C7A A   .770                        0 AAC0 A   
.771                        0 AAF4 A   .772                        0 AB0C A   
.773                        0 AAFB A   .774                        0 CCA6 A   
.775                        0 AB84 A   .776                        0 AB29 A   
.777                        0 AB13 A   .778                        0 CC80 A   
.779                        0 AB84 A   .77A                        0 AB43 A   
.77B                        0 AB30 A   .77C                        0 CC68 A   
.77D                        0 AB84 A   .77E                        0 AB84 A   
.77F                        0 AB4A A   .78                         0 0C0D A   
.780                        0 AB6A A   .781                        0 AB51 A   
.782                        0 CC3C A   .783                        0 AB84 A   
.784                        0 CC00 A   .785                        0 AB94 A   
.786                        0 ABC1 A   .787                        0 ABB1 A   
.788                        0 ACEE A   .789                        0 ABFF A   
.78A                        0 AC0C A   .78B                        0 AC08 A   
.78C                        0 ACEE A   .78D                        0 AC17 A   
.78E                        0 ACEE A   .78F                        0 AC2B A   
.79                         0 0C60 A   .790                        0 ACBB A   
.791                        0 AC51 A   .792                        0 ACEB A   
.793                        0 CC00 A   .794                        0 CC3C A   
.795                        0 CC68 A   .796                        0 CC80 A   
.797                        0 CCA6 A   .798                        0 CCC1 A   
.799                        0 CCD5 A   .79A                        0 CCF1 A   
.79B                        0 CD06 A   .79C                        0 CD2D A   
.79D                        0 CD52 A   .79E                        0 CD72 A   
.79F                        0 CD98 A   .7A                         0 0C58 A   
.7A0                        0 CDB8 A   .7A1                        0 CDDD A   
.7A2                        0 CDFD A   .7A3                        0 CE1D A   
.7A4                        0 CE58 A   .7A5                        0 CE90 A   
.7A6                        0 CEBA A   .7A7                        0 CEF9 A   
.7A8                        0 CF1E A   .7A9                        0 CF4F A   
.7AA                        0 CF71 A   .7AB                        0 CF9C A   
.7AC                        0 CFCE A   .7AD                        0 D009 A   
.7AE                        0 D03D A   .7AF                        0 D077 A   
.7B                         0 0C69 A   .7B0                        0 D0B6 A   
.7B1                        0 D0E3 A   .7B2                        0 D114 A   
.7B3                        0 D145 A   .7B4                        0 D15F A   
.7B5                        0 D18C A   .7B6                        0 D1D4 A   
.7B7                        0 D20C A   .7B8                        0 D24A A   
.7B9                        0 D281 A   .7BA                        0 D2B8 A   
.7BB                        0 D2EF A   .7BC                        0 D309 A   
.7BD                        0 D314 A   .7BE                        0 D31E A   
.7BF                        0 D328 A   .7C                         0 0C81 A   
.7C0                        0 D332 A   .7C1                        0 D33D A   
.7C2                        0 D348 A   .7C3                        0 D370 A   
.7C4                        0 D394 A   .7C5                        0 D3B8 A   
.7C6                        0 D3F2 A   .7C7                        0 D42C A   
.7C8                        0 D446 A   .7C9                        0 D472 A   
.7CA                        0 D49E A   .7CB                        0 D4CA A   
.7CC                        0 D4F5 A   .7CD                        0 D52F A   
.7CE                        0 D546 A   .7CF                        0 D575 A   
.7D                         0 0D34 A   .7D0                        0 D5B5 A   
.7D1                        0 D5CF A   .7D2                        0 D5E5 A   
.7D3                        0 D601 A   .7D4                        0 D629 A   
.7D5                        0 D64F A   .7D6                        0 D67B A   
.7D7                        0 D67D A   .7D8                        0 D684 A   
.7D9                        0 D68B A   .7DA                        0 D6A5 A   
.7DB                        0 D6B7 A   .7DC                        0 D6D1 A   
.7DD                        0 D6D4 A   .7DE                        0 D6DB A   
.7DF                        0 D6E2 A   .7E                         0 0CC3 A   
.7E0                        0 D6ED A   .7E1                        0 D70D A   
.7E2                        0 D72D A   .7E3                        0 D730 A   
.7E4                        0 D737 A   .7E5                        0 D73E A   
.7E6                        0 D749 A   .7E7                        0 D774 A   
.7E8                        0 D784 A   .7E9                        0 D78B A   
.7EA                        0 D791 A   .7EB                        0 D795 A   
.7EC                        0 D79A A   .7ED                        0 D7BF A   
.7EE                        0 D7E8 A   .7EF                        0 D7F6 A   
.7F                         0 0C8B A   .7F0                        0 D80F A   
.7F1                        0 D82A A   .7F2                        0 D82E A   
.7F3                        0 D843 A   .7F4                        0 D857 A   
.7F5                        0 D877 A   .7F6                        0 D87A A   
.7F7                        0 D899 A   .7F8                        0 D8AF A   
.7F9                        0 D8BB A   .7FA                        0 D8CB A   
.7FB                        0 D8D0 A   .7FC                        0 D8D6 A   
.7FD                        0 D8E6 A   .7FE                        0 D8F6 A   
.7FF                        0 D8F8 A   .8                          0 067F A   
.80                         0 0CAF A   .800                        0 D8FA A   
.801                        0 D900 A   .802                        0 D903 A   
.803                        0 D907 A   .804                        0 D90C A   
.805                        0 D922 A   .806                        0 D93D A   
.807                        0 D959 A   .808                        0 D962 A   
.809                        0 D986 A   .80A                        0 D9A0 A   
.80B                        0 D9C5 A   .80C                        0 D9D8 A   
.80D                        0 D9F5 A   .81                         0 0C95 A   
.82                         0 0CC1 A   .83                         0 0D34 A   
.84                         0 0CDC A   .85                         0 0CCA A   
.86                         0 0D34 A   .87                         0 0D11 A   
.88                         0 0CE3 A   .89                         0 0D34 A   
.8A                         0 0D26 A   .8B                         0 0D18 A   
.8C                         0 0D34 A   .8D                         0 D9D8 A   
.8E                         0 0D4A A   .8F                         0 0D67 A   
.9                          0 0670 A   .90                         0 0D74 A   
.91                         0 0D70 A   .92                         0 0DAC A   
.93                         0 0D92 A   .94                         0 0D85 A   
.95                         0 0DAC A   .96                         0 0DA1 A   
.97                         0 0DEA A   .98                         0 0DDF A   
.99                         0 0DB4 A   .9A                         0 0DDF A   
.9B                         0 0DD0 A   .9C                         0 0DEA A   
.9D                         0 0E27 A   .9E                         0 0E0D A   
.9F                         0 0E00 A   .A                          0 0697 A   
.A0                         0 0E27 A   .A1                         0 0E1C A   
.A2                         0 0E36 A   .A3                         0 0E2E A   
.A4                         0 0E66 A   .A5                         0 0E4C A   
.A6                         0 0E3E A   .A7                         0 0E66 A   
.A8                         0 0E5B A   .A9                         0 0E76 A   
.AA                         0 0E6D A   .AB                         0 0E8C A   
.AC                         0 0E83 A   .AD                         0 0ECA A   
.AE                         0 0EB0 A   .AF                         0 0EA2 A   
.B                          0 0688 A   .B0                         0 0ECA A   
.B1                         0 0EBF A   .B2                         0 0EDA A   
.B3                         0 0ED1 A   .B4                         0 0F0A A   
.B5                         0 0EF0 A   .B6                         0 0EE2 A   
.B7                         0 0F0A A   .B8                         0 0EFF A   
.B9                         0 0F1A A   .BA                         0 0F11 A   
.BB                         0 0F30 A   .BC                         0 0F27 A   
.BD                         0 0F8A A   .BE                         0 0F70 A   
.BF                         0 0F62 A   .C                          0 06BB A   
.C0                         0 0F8A A   .C1                         0 0F7F A   
.C2                         0 0F9A A   .C3                         0 0F91 A   
.C4                         0 0FCA A   .C5                         0 0FB0 A   
.C6                         0 0FA2 A   .C7                         0 0FCA A   
.C8                         0 0FBF A   .C9                         0 0FDA A   
.CA                         0 0FD1 A   .CB                         0 0FF0 A   
.CC                         0 0FE7 A   .CD                         0 1020 A   
.CE                         0 1006 A   .CF                         0 0FF8 A   
.D                          0 06A0 A   .D0                         0 1020 A   
.D1                         0 1015 A   .D2                         0 1030 A   
.D3                         0 1027 A   .D4                         0 1046 A   
.D5                         0 103D A   .D6                         0 1084 A   
.D7                         0 106A A   .D8                         0 105C A   
.D9                         0 1084 A   .DA                         0 1079 A   
.DB                         0 1094 A   .DC                         0 108B A   
.DD                         0 10C4 A   .DE                         0 10AA A   
.DF                         0 109C A   .E                          0 06B0 A   
.E0                         0 10C4 A   .E1                         0 10B9 A   
.E2                         0 10D4 A   .E3                         0 10CB A   
.E4                         0 10EA A   .E5                         0 10E1 A   
.E6                         0 1128 A   .E7                         0 110E A   
.E8                         0 1100 A   .E9                         0 1128 A   
.EA                         0 111D A   .EB                         0 1138 A   
.EC                         0 112F A   .ED                         0 1176 A   
.EE                         0 115C A   .EF                         0 114E A   
.F                          0 06A7 A   .F0                         0 1176 A   
.F1                         0 116B A   .F2                         0 1186 A   
.F3                         0 117D A   .F4                         0 11C4 A   
.F5                         0 11AA A   .F6                         0 119C A   
.F7                         0 11C4 A   .F8                         0 11B9 A   
.F9                         0 11D4 A   .FA                         0 11CB A   
.FB                         0 1204 A   .FC                         0 11EA A   
.FD                         0 11DC A   .FE                         0 1204 A   
.FF                         0 11F9 A   .FFDD                       0 8F02 A   
.FFDE                       0 8EEC A   .FFDF                       0 8ED6 A   
.FFE0                       0 8EF8 A   .FFE2                       0 8ECB A   
.FFE3                       0 889F A   .FFE4                       0 8872 A   
.FFE6                       0 8659 A   .FFE7                       0 8643 A   
.FFE8                       0 862D A   .FFE9                       0 864F A   
.FFEB                       0 8622 A   .FFEC                       0 7AFE A   
.FFED                       0 7B2A A   .FFEE                       0 7B14 A   
.FFEF                       0 7B20 A   .FFF1                       0 7AF3 A   
.FFF4                       0 5B74 A   .FFFA                       0 3C8C A   
BcdToBin                    0 B0F7 A   _apm16_entry                0 B2A1 A   
_apm32_entry                0 B1BC A   _apmreal_entry              0 B36C A   
_ata_cmd_data_in            0 2E24 A E _ata_cmd_data_out           0 320D A E 
_ata_cmd_non_data           0 2E1D A E _ata_cmd_packet             0 35E7 A E 
_ata_detect                 0 1D9C A E _ata_init                   0 194A A E 
_ata_reset                  0 2CCC A E _atapi_get_sense            0 3AC6 A E 
_atapi_is_cdrom             0 3E33 A E _atapi_is_ready             0 3B4B A E 
_await_ide                  0 1C24 A   _bios_cvs_version_string    0 0194 A   
_bios_printf                0 09A7 A E _cdemu_emulated_drive       0 3EF6 A E 
_cdemu_init                 0 3EA5 A E _cdemu_isactive             0 3ECF A E 
_cdrom_boot                 0 3F3B A E _check_for_keystroke        0 0960 A E 
_debugger_off               0 185E A E _debugger_on                0 184C A E 
_delay_ticks                0 08AE A E _delay_ticks_and_check_for+ 0 0976 A E 
_dequeue_key                0 5FED A E _determine_floppy_media     0 A48E A E 
_drivetypes                 0 12A2 A   _eltorito                   0 3F23 A   
_enable_mouse_int_and_even+ 0 619B A E _enqueue_key                0 6989 A E 
_floppy_drive_exists        0 92E1 A E _floppy_drive_recal         0 922E A E 
_floppy_media_known         0 904C A E _floppy_media_sense         0 90CF A E 
_floppy_prepare_controller  0 8F6D A E _floppy_reset_controller    0 8F1F A E 
_get_CS                     0 064E A E _get_SS                     0 0651 A E 
_get_boot_vector            0 141B A   _get_keystroke              0 096E A E 
_get_mouse_data             0 6289 A E _inb                        0 0542 A E 
_inb_cmos                   0 0587 A E _inhibit_mouse_int_and_eve+ 0 60EE A E 
_init_boot_vectors          0 12D4 A   _init_rtc                   0 0593 A E 
_int09_function             0 6318 A E _int13_cdemu                0 88C6 A E 
_int13_cdrom                0 7B47 A E _int13_diskette_function    0 9329 A E 
_int13_eltorito             0 8676 A E _int13_harddisk             0 6B58 A E 
_int14_function             0 46BB A E _int15_function             0 4923 A E 
_int15_function32           0 56B2 A E _int15_function_mouse       0 4F45 A E 
_int16_function             0 5BAB A E _int17_function             0 A48F A E 
_int18_panic_msg            0 17D1 A E _int19_function             0 A5C7 A E 
_int1a_function             0 A823 A E _int70_function             0 ABCD A E 
_int74_function             0 6A3D A E _interactive_bootkey        0 1468 A E 
_inw                        0 054D A E _isotag                     0 3F1D A   
_keyboard_init              0 0D78 A E _keyboard_panic             0 123C A E 
_log_bios_start             0 17E3 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 17BF A E _outb                       0 0558 A E 
_outb_cmos                  0 0578 A E _outw                       0 0568 A E 
_panic_msg_keyb_buffer_ful+ 0 60CE A   _print_bios_banner          0 127B A E 
_print_boot_device          0 1661 A E _print_boot_failure         0 1744 A E 
_print_cdromboot_failure    0 17AA A E _put_int                    0 06BD A E 
_put_luint                  0 07C3 A E _put_str                    0 087A A E 
_put_uint                   0 0740 A E _read_byte                  0 05F8 A E 
_read_dword                 0 0083 A E _read_word                  0 060B A E 
_rtc_updating               0 05C4 A E _s3_resume                  0 186F A E 
_s3_resume_panic            0 1269 A E _scan_to_scanascii          0 01C8 A   
_send                       0 0664 A E _send_to_mouse_ctrl         0 623F A E 
_set_diskette_current_cyl   0 A45D A E _set_diskette_ret_status    0 A445 A E 
_set_e820_range             0 55C2 A E _set_enable_a20             0 17F9 A E 
_set_kbd_command_byte       0 62CA A E _shutdown_status_panic      0 1251 A E 
_vgafont8                   0 FA6E A   _wrch                       0 0654 A E 
_write_byte                 0 061E A E _write_dword                0 009B A E 
_write_word                 0 0636 A E apm16_04                    0 B2A2 A   
apm16_05                    0 B2A9 A   apm16_07                    0 B2B2 A   
apm16_07_1                  0 B2D6 A   apm16_07_poweroff           0 B2CC A   
apm16_07_poweroff_str       0 B288 A   apm16_07_standby            0 B2E8 A   
apm16_07_standby_str        0 B299 A   apm16_07_suspend            0 B2D9 A   
apm16_07_suspend_str        0 B291 A   apm16_08                    0 B2F7 A   
apm16_0a                    0 B2FD A   apm16_0b                    0 B311 A   
apm16_0e                    0 B319 A   apm16_0f                    0 B323 A   
apm16_10                    0 B329 A   apm16_error                 0 B337 A   
apm16_ok                    0 B334 A   apm16_out_str               0 B270 A   
apm16_out_str1              0 B277 A   apm16_out_str2              0 B283 A   
apm16_unimplemented         0 B337 A   apm32_04                    0 B1BE A   
apm32_05                    0 B1C7 A   apm32_07                    0 B1D2 A   
apm32_07_1                  0 B203 A   apm32_07_poweroff           0 B1F5 A   
apm32_07_poweroff_str       0 B1A3 A   apm32_07_standby            0 B217 A   
apm32_07_standby_str        0 B1B4 A   apm32_07_suspend            0 B206 A   
apm32_07_suspend_str        0 B1AC A   apm32_08                    0 B228 A   
apm32_0a                    0 B22E A   apm32_0b                    0 B244 A   
apm32_0e                    0 B24C A   apm32_0f                    0 B256 A   
apm32_10                    0 B25C A   apm32_error                 0 B26C A   
apm32_ok                    0 B268 A   apm32_out_str               0 B190 A   
apm32_out_str1              0 B194 A   apm32_out_str2              0 B1A0 A   
apm32_unimplemented         0 B26C A   apm_call                    0 F87B A   
apmreal_00                  0 B36C A   apmreal_01                  0 B37E A   
apmreal_02                  0 B385 A   apmreal_03                  0 B39B A   
apmreal_04                  0 B3BA A   apmreal_05                  0 B3C1 A   
apmreal_07                  0 B3CA A   apmreal_07_1                0 B3EE A   
apmreal_07_poweroff         0 B3E4 A   apmreal_07_poweroff_str     0 B352 A   
apmreal_07_standby          0 B400 A   apmreal_07_standby_str      0 B363 A   
apmreal_07_suspend          0 B3F1 A   apmreal_07_suspend_str      0 B35B A   
apmreal_08                  0 B40F A   apmreal_0a                  0 B415 A   
apmreal_0b                  0 B429 A   apmreal_0e                  0 B431 A   
apmreal_0f                  0 B43B A   apmreal_10                  0 B441 A   
apmreal_error               0 B451 A   apmreal_ok                  0 B44C A   
apmreal_out_str             0 B33A A   apmreal_out_str1            0 B341 A   
apmreal_out_str2            0 B34D A   apmreal_unimplemented       0 B451 A   
ata_in_16                   0 3177 A   ata_in_32                   0 317B A   
ata_in_adjust               0 3163 A   ata_in_done                 0 317E A   
ata_in_no_adjust            0 316A A   ata_out_16                  0 3560 A   
ata_out_32                  0 3565 A   ata_out_adjust              0 354C A   
ata_out_done                0 3569 A   ata_out_no_adjust           0 3553 A   
ata_packet_after            0 3A51 A   ata_packet_done             0 3A6B A   
ata_packet_in_16            0 3A4A A   ata_packet_in_32            0 3A4E A   
ata_packet_in_after_16      0 3A5E A   ata_packet_in_after_32      0 3A63 A   
ata_packet_in_after_32_loo+ 0 3A65 A   ata_packet_in_before_16     0 3A28 A   
ata_packet_in_before_32     0 3A2D A   ata_packet_in_before_32_lo+ 0 3A2F A   
ata_packet_no_before        0 3A35 A   bios32_end                  0 B4A3 A   
bios32_entry_point          0 B470 A   bios32_structure            0 B460 A   
bios_table_area_end         0 CC00 A   bios_table_area_start       0 BB70 A   
block_count_rounded         0 BAA9 A   carry_set                   0 AD29 A   
check_for_hd1               0 AFB3 A   checksum_loop               0 BA54 A   
checksum_out                0 BA6E A   detect_parport              0 B9FB A   
detect_serial               0 BA1A A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 096D A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 B09D A   
enable_iomem_space          0 B8F2 A   eoi_both_pics               0 B0EE A   
eoi_jmp_post                0 B0B2 A   eoi_master_pic              0 B0F2 A   
f0_missing                  0 AE31 A   f1_missing                  0 AE3C A   
floppy_drive_post           0 ADF6 A   halt2_loop                  0 0D71 A   
hard_drive_post             0 AE7D A   hd0_post_above_2048         0 AF75 A   
hd0_post_above_4096         0 AF83 A   hd0_post_above_8192         0 AF91 A   
hd0_post_checksum_loop      0 AFA6 A   hd0_post_logical_chs        0 AF54 A   
hd0_post_physical_chs       0 AF46 A   hd0_post_store_logical      0 AF97 A   
hd1_post_above_2048         0 B05E A   hd1_post_above_4096         0 B06C A   
hd1_post_above_8192         0 B07A A   hd1_post_checksum_loop      0 B08F A   
hd1_post_logical_chs        0 B03D A   hd1_post_physical_chs       0 B030 A   
hd1_post_store_logical      0 B080 A   idiv_                       0 0165 A   
idiv_u                      0 0169 A   init_io_base                0 B8C5 A   
int08_floppy_off            0 FEC4 A   int08_handler               0 FEA5 A   
int08_store_ticks           0 FED9 A   int09_check_pause           0 E9B5 A   
int09_done                  0 E9CF A   int09_finish                0 E9D5 A   
int09_handler               0 E987 A   int09_process_key           0 E9C7 A   
int0e_handler               0 EF57 A   int0e_loop1                 0 EF69 A   
int0e_loop2                 0 EF73 A   int0e_normal                0 EF81 A   
int10_handler               0 F065 A   int11_handler               0 F84D A   
int12_handler               0 F841 A   int13_cdemu_inactive        0 AD7D A   
int13_cdrom_rme_end         0 7FDB A   int13_disk                  0 ADAC A   
int13_diskette              0 EC59 A   int13_handler               0 E3FE A   
int13_legacy                0 AD85 A   int13_nocdemu               0 AD6A A   
int13_noeltorito            0 AD81 A   int13_not_eltorito          0 AD47 A   
int13_notcdrom              0 ADAC A   int13_notfloppy             0 AD98 A   
int13_out                   0 ADB9 A   int13_relocated             0 AD32 A   
int14_handler               0 E739 A   int1586_tick                0 5713 A   
int1586_tick_end            0 5721 A   int15_handler               0 F859 A   
int15_handler32             0 F883 A   int15_handler32_ret         0 F875 A   
int15_handler_mouse         0 F87E A   int15_handler_mouse_ret     0 F874 A   
int16_F00                   0 E85B A   int16_handler               0 E82E A   
int16_key_found             0 E86F A   int16_wait_for_key          0 E860 A   
int16_zero_clear            0 E849 A   int16_zero_set              0 E852 A   
int17_handler               0 EFD2 A   int18_handler               0 ADBD A   
int19_handler               0 E6F2 A   int19_load_done             0 A6F9 A   
int19_next_boot             0 ADF0 A   int19_relocated             0 ADD9 A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 ADF5 A   
int70_handler               0 FE93 A   int74_done                  0 AD14 A   
int74_handler               0 ACF5 A   int75_handler               0 E2C7 A   
int76_handler               0 B17D A   iret_modify_cf              0 AD1E A   
iret_post_0x467             0 B0C2 A   is_master_pic               0 B91C A   
jmp_post_0x467              0 B0BA A   laddl                       0 00C3 A   
laddul                      0 00C3 A   landl                       0 00BB A   
landul                      0 00BB A   lcmpl                       0 00CB A   
lcmpul                      0 00CB A   ldecl                       0 0102 A   
ldecul                      0 0102 A   ldivul                      0 016E A   
lincl                       0 010F A   lincul                      0 010F A   
lmull                       0 00E9 A   lmulul                      0 00E9 A   
look_drive0                 0 AE28 A   look_drive1                 0 AE33 A   
lorl                        0 0107 A   lorul                       0 0107 A   
lsl_exit                    0 0164 A   lsl_loop                    0 0158 A   
lsll                        0 0147 A   lslul                       0 0147 A   
lsr_exit                    0 0146 A   lsr_loop                    0 013A A   
lsrul                       0 0129 A   lsubl                       0 00E1 A   
lsubul                      0 00E1 A   ltstl                       0 0114 A   
ltstul                      0 0114 A   memcpyb_end                 0 004B A   
memcpyd_end                 0 007B A   memsetb_end                 0 001E A   
next_pci_base               0 B8E4 A   next_pci_dev                0 B8FE A   
next_pci_func               0 B9E2 A   next_pir_entry              0 B9EC A   
nmi                         0 E2C3 A   no_bcv                      0 BAF9 A   
no_bev                      0 BB32 A   no_key                      0 096B A   
no_parport                  0 BA19 A   no_prod_str                 0 BB2A A   
no_serial                   0 BA3D A   normal_post                 0 E0A3 A   
pci_init_end                0 B9F8 A   pci_init_io_loop1           0 B865 A   
pci_init_io_loop2           0 B882 A   pci_init_irq_loop1          0 B97B A   
pci_init_irq_loop2          0 B980 A   pci_irq_list                0 B830 A   
pci_present                 0 B62D A   pci_pro_devloop             0 B4DD A   
pci_pro_devloop2            0 B513 A   pci_pro_f02                 0 B4CC A   
pci_pro_f03                 0 B508 A   pci_pro_f08                 0 B541 A   
pci_pro_f09                 0 B560 A   pci_pro_f0a                 0 B57E A   
pci_pro_f0b                 0 B592 A   pci_pro_f0c                 0 B5AE A   
pci_pro_f0d                 0 B5CC A   pci_pro_fail                0 B5E2 A   
pci_pro_nextdev             0 B4F8 A   pci_pro_nextdev2            0 B531 A   
pci_pro_ok                  0 B5E7 A   pci_pro_select_reg          0 B5EE A   
pci_pro_unknown             0 B5E0 A   pci_real_devloop            0 B661 A   
pci_real_devloop2           0 B693 A   pci_real_f02                0 B64E A   
pci_real_f03                0 B68A A   pci_real_f08                0 B6C0 A   
pci_real_f09                0 B6D8 A   pci_real_f0a                0 B6F0 A   
pci_real_f0b                0 B704 A   pci_real_f0c                0 B71B A   
pci_real_f0d                0 B732 A   pci_real_f0e                0 B745 A   
pci_real_fail               0 B785 A   pci_real_nextdev            0 B677 A   
pci_real_nextdev2           0 B6AD A   pci_real_ok                 0 B78B A   
pci_real_select_reg         0 B793 A   pci_real_too_small          0 B77A A   
pci_real_unknown            0 B783 A   pci_routing_table_structur+ 0 B7B0 A   
pci_routing_table_structur+ 0 B830 A   pci_routing_table_structur+ 0 B7D0 A   
pci_test_int_pin            0 B995 A   pcibios_error               0 FE7B A   
pcibios_init_iomem_bases    0 B84F A   pcibios_init_irqs           0 B929 A   
pcibios_init_sel_reg        0 B834 A   pcibios_init_set_elcr       0 B910 A   
pcibios_protected           0 B4B0 A   pcibios_real                0 B60B A   
pirq_found                  0 B9D1 A   pmode_IDT_info              0 F88C A   
pnp_string                  0 BA81 A   post                        0 E05B A   
post_d0_extended            0 AEDF A   post_d0_type47              0 AEF0 A   
post_d1_exists              0 AFBE A   post_d1_extended            0 AFC9 A   
post_d1_type47              0 AFDA A   post_default_ints           0 E0D4 A   
post_init_pic               0 BB46 A   protected_mode              0 4CEC A   
protmode_switch             0 4E25 A   real_mode                   0 4D16 A   
retf_post_0x467             0 B0CF A   rmode_IDT_info              0 F891 A   
rom_checksum                0 BA3F A   rom_scan                    0 BA85 A   
rom_scan_increment          0 BB34 A   rom_scan_loop               0 BA85 A   
s3_post                     0 B0DC A   timer_tick_post             0 B106 A   
unknown_service             0 B4A1 A   

00000 errors
00000 warnings
